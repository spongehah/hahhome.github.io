<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis安装和常见数据类型命令</title>
      <link href="/blog/Redis/"/>
      <url>/blog/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇Redis"><a href="#基础篇Redis" class="headerlink" title="基础篇Redis"></a>基础篇Redis</h1><h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><p><strong>理想课程</strong></p><p>小伙伴们理想的课程一定是能够通过讲解的方式，得到如下这些启发，我们的课程会从基础到精通，从redis小白，到redis大牛，还在等什么，这套课程一定就是你最适合你的课程~</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652882458107.png" alt="1652882458107"></p><h2 id="1-Redis简单介绍"><a href="#1-Redis简单介绍" class="headerlink" title="1.Redis简单介绍"></a>1.Redis简单介绍</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li>键值型</li><li>NoSql</li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652882668159.png" alt="1652882668159"></p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><p>对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。</p><h2 id="2-课程目录"><a href="#2-课程目录" class="headerlink" title="2.课程目录"></a>2.课程目录</h2><blockquote><ul><li>初始Redis<ul><li>认识NoSQL</li><li>认识Redis</li><li>安装Redis</li></ul></li><li>Redis常见命令<ul><li>5种常见数据结构</li><li>通用命令</li><li>不同数据结构的操作命令</li></ul></li><li>Redis的Java客户端<ul><li>Jedis客户端</li><li>SpringDataRedis客户端</li></ul></li></ul></blockquote><h2 id="3-初始Redis"><a href="#3-初始Redis" class="headerlink" title="3.初始Redis"></a>3.初始Redis</h2><h3 id="3-1-认识NoSQL"><a href="#3-1-认识NoSQL" class="headerlink" title="3.1.认识NoSQL"></a>3.1.认识NoSQL</h3><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h4 id="3-1-1-结构化与非结构化"><a href="#3-1-1-结构化与非结构化" class="headerlink" title="3.1.1.结构化与非结构化"></a>3.1.1.结构化与非结构化</h4><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="https://i.imgur.com/4tUgFo6.png"></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="https://i.imgur.com/GdqOSsj.png"></p><p>也可以是文档型：</p><p><img src="https://i.imgur.com/zBBQfcc.png"></p><p>甚至可以是图格式：</p><p><img src="https://i.imgur.com/zBnKxWf.png"></p><h4 id="3-1-2-关联和非关联"><a href="#3-1-2-关联和非关联" class="headerlink" title="3.1.2.关联和非关联"></a>3.1.2.关联和非关联</h4><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="https://i.imgur.com/tXYSl5x.png"></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h4 id="3-1-3-查询方式"><a href="#3-1-3-查询方式" class="headerlink" title="3.1.3.查询方式"></a>3.1.3.查询方式</h4><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="https://i.imgur.com/AzaHOTF.png"></p><h4 id="3-1-4-事务"><a href="#3-1-4-事务" class="headerlink" title="3.1.4.事务"></a>3.1.4.事务</h4><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="https://i.imgur.com/J1MqOJM.png"></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h4 id="3-1-5-总结"><a href="#3-1-5-总结" class="headerlink" title="3.1.5.总结"></a>3.1.5.总结</h4><p>除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="https://i.imgur.com/kZP40dQ.png"></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h3 id="3-2-认识Redis"><a href="#3-2-认识Redis" class="headerlink" title="3.2.认识Redis"></a>3.2.认识Redis</h3><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存.IO多路复用.良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群.分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h3 id="3-3-单机安装Redis"><a href="#3-3-单机安装Redis" class="headerlink" title="3.3.单机安装Redis"></a>3.3.单机安装Redis</h3><h4 id="3-3-1-安装Redis依赖"><a href="#3-3-1-安装Redis依赖" class="headerlink" title="3.3.1.安装Redis依赖"></a>3.3.1.安装Redis依赖</h4><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h4 id="3-3-2-上传安装包并解压"><a href="#3-3-2-上传安装包并解压" class="headerlink" title="3.3.2.上传安装包并解压"></a>3.3.2.上传安装包并解压</h4><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211071712536.png" alt="image-20211211071712536"></p><p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211080151539.png" alt="image-20211211080151539"></p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p>解压后：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211080339076.png" alt="image-20211211080339076"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211080603710.png" alt="image-20211211080603710"></p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h4 id="3-3-3-启动"><a href="#3-3-3-启动" class="headerlink" title="3.3.3.启动"></a>3.3.3.启动</h4><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h5 id="3-3-3-1-默认启动"><a href="#3-3-3-1-默认启动" class="headerlink" title="3.3.3.1.默认启动"></a>3.3.3.1.默认启动</h5><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211081716167.png" alt="image-20211211081716167"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h5 id="3-3-3-2-指定配置启动"><a href="#3-3-3-2-指定配置启动" class="headerlink" title="3.3.3.2.指定配置启动"></a>3.3.3.2.指定配置启动</h5><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h5 id="3-3-3-3-开机自启"><a href="#3-3-3-3-开机自启" class="headerlink" title="3.3.3.3.开机自启"></a>3.3.3.3.开机自启</h5><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h3 id="3-4-Redis客户端"><a href="#3-4-Redis客户端" class="headerlink" title="3.4.Redis客户端"></a>3.4.Redis客户端</h3><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h4 id="3-4-1-Redis命令行客户端"><a href="#3-4-1-Redis命令行客户端" class="headerlink" title="3.4.1.Redis命令行客户端"></a>3.4.1.Redis命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211110439353.png" alt="image-20211211110439353"></p><h4 id="3-4-2-图形化桌面客户端"><a href="#3-4-2-图形化桌面客户端" class="headerlink" title="3.4.2.图形化桌面客户端"></a>3.4.2.图形化桌面客户端</h4><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211111351885.png" alt="image-20211211111351885"></p><h5 id="3-4-2-1-安装"><a href="#3-4-2-1-安装" class="headerlink" title="3.4.2.1.安装"></a>3.4.2.1.安装</h5><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211214154938770.png" alt="image-20211214154938770"></p><p>解压缩后，运行安装程序即可安装：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211214155123841.png" alt="image-20211214155123841"></p><p>此处略。</p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211110935819.png" alt="image-20211211110935819"></p><p>双击即可运行：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211214155406692.png" alt="image-20211214155406692"></p><h5 id="2-2-2-2-建立连接"><a href="#2-2-2-2-建立连接" class="headerlink" title="2.2.2.2.建立连接"></a>2.2.2.2.建立连接</h5><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211214155424842.png" alt="image-20211214155424842"></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211211111614483.png" alt="image-20211211111614483"></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211214155804523.png" alt="image-20211214155804523"></p><p>点击即可建立连接了：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20211214155849495.png" alt="image-20211214155849495"></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure><h2 id="4-Redis常见命令"><a href="#4-Redis常见命令" class="headerlink" title="4.Redis常见命令"></a>4.Redis常见命令</h2><h3 id="4-1-Redis数据结构介绍"><a href="#4-1-Redis数据结构介绍" class="headerlink" title="4.1 Redis数据结构介绍"></a>4.1 Redis数据结构介绍</h3><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652887393157.png" alt="1652887393157"></p><p><strong>贴心小建议：命令不要死记，学会查询就好啦</strong></p><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652887648826.png" alt="1652887648826"></p><p>当然我们也可以通过Help命令来帮助我们去查看命令</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652887748279.png" alt="1652887748279"></p><h3 id="4-2-Redis-通用命令"><a href="#4-2-Redis-通用命令" class="headerlink" title="4.2 Redis 通用命令"></a>4.2 Redis 通用命令</h3><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652887865189.png" alt="1652887865189"></p><p>课堂代码如下</p><ul><li>KEYS</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询以a开头的key</span></span><br><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</strong></p><ul><li>DEL</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> del</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">  summary: Delete a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del name <span class="comment">#删除单个</span></span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment">#成功删除1个</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 <span class="comment">#批量添加数据</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">(<span class="built_in">integer</span>) 3   <span class="comment">#此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment">#再查询全部的key</span></span><br><span class="line">1) <span class="string">&quot;age&quot;</span><span class="comment">#只剩下一个了</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~</strong></p><ul><li>EXISTS</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> EXISTS</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">  summary: Determine <span class="keyword">if</span> a key exists</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><ul><li>EXPIRE</li></ul><p><strong>贴心小提示</strong>：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire age 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2  <span class="comment">#当这个key过期了，那么此时查询出来就是-2 </span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 10 <span class="comment">#如果没有设置过期时间</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1  <span class="comment"># ttl的返回值就是-1</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Redis命令-String命令"><a href="#4-3-Redis命令-String命令" class="headerlink" title="4.3 Redis命令-String命令"></a>4.3 Redis命令-String命令</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652890121291.png" alt="1652890121291"></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>DECR：与INCR相反，一般使用 INCRBY key -1 即可</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p><ul><li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure><ul><li>MSET和MGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><ul><li>INCR和INCRBY和DECY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>SETNX</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><ul><li>SETEX</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h3 id="4-4-Redis命令-Key的层级结构"><a href="#4-4-Redis命令-Key的层级结构" class="headerlink" title="4.4 Redis命令-Key的层级结构"></a>4.4 Redis命令-Key的层级结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652941631682.png" alt="1652941631682"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652941883537.png" alt="1652941883537"></p><h3 id="4-5-Redis命令-Hash命令"><a href="#4-5-Redis命令-Hash命令" class="headerlink" title="4.5 Redis命令-Hash命令"></a>4.5 Redis命令-Hash命令</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652941995945.png" alt="1652941995945"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/1652942027719.png" alt="1652942027719"></p><p><strong>Hash类型的常见命令</strong></p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中的所有的value</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HINCRBYFLOAT</li><li>HEXIST：是否存在某个field</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li><li>HDEL：删除某个field</li></ul><p><strong>贴心小提示</strong>：哈希结构也是我们以后实际开发中常用的命令哟</p><ul><li>HSET和HGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HMSET和HMGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HGETALL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HKEYS和HVALS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HINCRBY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>HSETNX</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-6-Redis命令-List命令"><a href="#4-6-Redis命令-List命令" class="headerlink" title="4.6 Redis命令-List命令"></a>4.6 Redis命令-List命令</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：阻塞获取，与LPOP和RPOP类似，只不过在没有元素时 等待指定时间，而不是直接返回nil</li><li>lindex：按照索引下标获得元素（从上到下） </li><li>llen：获取列表中元素的个数 </li><li>lrem key 数字N 给定值v1：删除N个值等于V1的元素</li><li>Itrim key 开始index 结束index：截取指定范围的值后再赋值给key </li><li>rpoplpush 源列表 目的列表</li><li>lset key index value</li><li>linsert key before&#x2F;after 已有值 插入的新值</li></ul><p><img src="https://www.hahhome.top/blog/Redis/../../image/.%5CRedis.assets%5C1652943604992.png" alt="1652943604992"></p><ul><li>LPUSH和RPUSH</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>LPOP和RPOP</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><ul><li>LRANGE</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-7-Redis命令-Set命令"><a href="#4-7-Redis命令-Set命令" class="headerlink" title="4.7 Redis命令-Set命令"></a>4.7 Redis命令-Set命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="https://i.imgur.com/ha8x86R.png"></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="https://i.imgur.com/L9vTv2X.png"></p><p><strong>具体命令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s1 a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">s1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><ul><li>将下列数据用Redis的Set集合来存储：</li><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD zs lisi wangwu <span class="title function_">zhaoliu</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD ls wangwu mazi <span class="title function_">ergou</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">zs</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SINTER zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SDIFF zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUNION zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;mazi&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;ergou&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER ls <span class="title function_">zhangsan</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SREM zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS zs</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-8-Redis命令-SortedSet类型"><a href="#4-8-Redis命令-SortedSet类型" class="headerlink" title="4.8 Redis命令-SortedSet类型"></a>4.8 Redis命令-SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h2 id="5-Redis的Java客户端-Jedis"><a href="#5-Redis的Java客户端-Jedis" class="headerlink" title="5.Redis的Java客户端-Jedis"></a>5.Redis的Java客户端-Jedis</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="https://i.imgur.com/9f68ivq.png"></p><p>其中Java客户端也包含很多：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20220609102817435.png" alt="image-20220609102817435"></p><p>标记为❤的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="5-1-Jedis快速入门"><a href="#5-1-Jedis快速入门" class="headerlink" title="5.1 Jedis快速入门"></a>5.1 Jedis快速入门</h3><p><strong>入门案例详细步骤</strong></p><p>案例分析：</p><p>0）创建工程：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/%5CRedis.assets%5C1652959239813.png" alt="1652959239813"></p><p>1）引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-Jedis连接池"><a href="#5-2-Jedis连接池" class="headerlink" title="5.2 Jedis连接池"></a>5.2 Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p><h4 id="5-2-1-创建Jedis的连接池"><a href="#5-2-1-创建Jedis的连接池" class="headerlink" title="5.2.1.创建Jedis的连接池"></a>5.2.1.创建Jedis的连接池</h4><p>- </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.150.101&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ul><li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>3）最后提供返回连接池中连接的方法.</p></li></ul><h4 id="5-2-2-改造原始代码"><a href="#5-2-2-改造原始代码" class="headerlink" title="5.2.2.改造原始代码"></a>5.2.2.改造原始代码</h4><p><strong>代码说明:</strong></p><p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。</p><p>，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p><p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@BeforeEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//建立连接</span></span><br><span class="line">     <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">     jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">      <span class="comment">//选择库</span></span><br><span class="line">     jedis.select(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">         jedis.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="6-Redis的Java客户端-SpringDataRedis"><a href="#6-Redis的Java客户端-SpringDataRedis" class="headerlink" title="6.Redis的Java客户端-SpringDataRedis"></a>6.Redis的Java客户端-SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/.%5CRedis.assets%5C1652976773295.png" alt="1652976773295"></p><h3 id="6-1-快速入门"><a href="#6-1-快速入门" class="headerlink" title="6.1.快速入门"></a>6.1.快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：</p><h4 id="6-1-1-导入pom坐标"><a href="#6-1-1-导入pom坐标" class="headerlink" title="6.1.1.导入pom坐标"></a>6.1.1.导入pom坐标</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-1-2-配置文件"><a href="#6-1-2-配置文件" class="headerlink" title="6.1.2 .配置文件"></a>6.1.2 .配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment">#最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment">#最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><h4 id="6-1-3-测试代码"><a href="#6-1-3-测试代码" class="headerlink" title="6.1.3.测试代码"></a>6.1.3.测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p><p>SpringDataRedis的使用步骤：</p><ul><li>引入spring-boot-starter-data-redis依赖</li><li>在application.yml配置Redis信息</li><li>注入RedisTemplate</li></ul><h3 id="6-2-数据序列化器"><a href="#6-2-数据序列化器" class="headerlink" title="6.2 .数据序列化器"></a>6.2 .数据序列化器</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20230922163151492.png" alt="image-20230922163151492"></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20230922163101317.png" alt="image-20230922163101317"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>规定好key都用普通字符串，值随意，一般都用jackson序列化工具</p></blockquote><p>引入jackson依赖（引入SpringMVC依赖时会自动引入）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/Redis.assets/image-20230922165225513.png" alt="image-20230922165225513"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="6-3-StringRedisTemplate"><a href="#6-3-StringRedisTemplate" class="headerlink" title="6.3 StringRedisTemplate"></a>6.3 StringRedisTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;鸡哥&quot;</span>,<span class="number">21</span>));</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/.%5CRedis.assets%5C1653054602930.png" alt="1653054602930"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来<strong>额外的内存开销</strong>。</p><p>为了减少内存的消耗，我们可以采用<strong>手动序列化</strong>的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们<strong>只采用String的序列化器</strong>，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/.%5CRedis.assets%5C1653054744832.png" alt="1653054744832"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：<strong>StringRedisTemplate</strong>，它的key和value的序列化方式默认就是String方式。 </p><p><img src="https://i.imgur.com/zXH6Qn6.png"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p><p><img src="https://www.hahhome.top/blog/Redis/../../image/.%5CRedis.assets%5C1653054945211.png" alt="1653054945211"></p><p>最后小总结：</p><p>RedisTemplate的两种序列化实践方案：</p><ul><li>方案一：<ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li><li>缺点：会占用内存存储对象的全类名</li></ul></li><li>方案二：<ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li><li>缺点：麻烦</li></ul></li></ul><h3 id="6-4-Hash结构操作"><a href="#6-4-Hash结构操作" class="headerlink" title="6.4 Hash结构操作"></a>6.4 Hash结构操作</h3><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p><p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(6)实战45讲笔记</title>
      <link href="/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要参考：MySQL实战45讲</p><p>次要参考：xiaolingcoding图解MySQL</p></blockquote><h1 id="01-讲基础架构：一条SQL查询语句是如何执行的"><a href="#01-讲基础架构：一条SQL查询语句是如何执行的" class="headerlink" title="01 讲基础架构：一条SQL查询语句是如何执行的"></a>01 讲基础架构：一条SQL查询语句是如何执行的</h1><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"> </p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><h3 id="连接sleep"><a href="#连接sleep" class="headerlink" title="连接sleep"></a>连接sleep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br></pre></td></tr></table></figure><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/f2da4aa3a672d48ec05df97b9f992fed.png" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数<strong>wait_timeout</strong>控制的，默认值是<strong>8小时</strong>。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>MySQL 服务支持的最大连接数由 <strong>max_connections</strong> 参数控制，比如我的 MySQL 服务默认是 <strong>151</strong> 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是<strong>尽量使用长连接</strong>。</p><p><strong>但是全部使用长连接</strong>后，你可能会发现，有些时候MySQL占用<strong>内存涨得特别快</strong>，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么<strong>解决</strong>这个问题呢？你可以考虑以下两种方案。</p><ol><li><code>定期断开长连接</code>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection来重新初始化连接资源</code>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p><strong>大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p><strong>查询缓存的命中率会非常低</strong>，并且<strong>在一个表上有更新的时候，跟这个表有关的查询缓存会失效</strong>。</p><p>除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说<strong>8.0开始彻底没有这个功能</strong>了。</p><h2 id="第三步：分析器"><a href="#第三步：分析器" class="headerlink" title="第三步：分析器"></a>第三步：分析器</h2><p>MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><ul><li>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</li></ul><p>做完了这些识别以后，就要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><ul><li><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p></li><li><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p></li></ul><h2 id="第四步：优化器"><a href="#第四步：优化器" class="headerlink" title="第四步：优化器"></a>第四步：优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p><h2 id="第五步：执行器"><a href="#第五步：执行器" class="headerlink" title="第五步：执行器"></a>第五步：执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的<strong>权限</strong>，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><p>如果<strong>有权限</strong>，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p><strong>eg：</strong></p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个<strong>rows_examined</strong>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h1 id="02-讲日志系统：一条SQL更新语句是如何执行的"><a href="#02-讲日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="02 讲日志系统：一条SQL更新语句是如何执行的"></a>02 讲日志系统：一条SQL更新语句是如何执行的</h1><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示:</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230919205345326.png" alt="image-20230919205345326"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><blockquote><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p></blockquote><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板<strong>redo log是InnoDB引擎特有的日志</strong>，而<strong>Server层也有自己的日志，称为binlog</strong>（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li><code>redo log是InnoDB引擎特有的</code>；<code>binlog是MySQL的Server层实现的</code>，所有引擎都可以使用。</li><li>redo log是<strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；binlog是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”（三种格式）。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h2 id="更新语句执行过程"><a href="#更新语句执行过程" class="headerlink" title="更新语句执行过程"></a>更新语句执行过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></p><p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h2 id="redo-log的两阶段提交"><a href="#redo-log的两阶段提交" class="headerlink" title="redo log的两阶段提交"></a>redo log的两阶段提交</h2><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol><li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li></ol><p>可以看到，<strong>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</strong>。</p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><p>即<strong>保证主库和从库的数据一致性</strong></p><blockquote><p>redo log用于保证crash-safe能力。<strong>innodb_flush_log_at_trx_commit</strong>这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p><strong>sync_binlog</strong>这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p></blockquote><h1 id="03-讲事务隔离：为什么你改了我还看不见"><a href="#03-讲事务隔离：为什么你改了我还看不见" class="headerlink" title="03 讲事务隔离：为什么你改了我还看不见"></a>03 讲事务隔离：为什么你改了我还看不见</h1><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p><strong>总结：</strong></p><p>1、务的特性：原子性、一致性、隔离性、持久性<br>2、多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读<br>3、事务隔离级别：读未提交、读提交、可重复读、串行化<br>4、不同事务隔离级别的区别：<br>读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到<br>读提交：一个事务提交之后，它所做的变更才可以被别的事务看到<br>可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的<br>串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</p><p>5、配置方法：启动参数transaction-isolation<br>6、事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。</p><p>7、回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。<br>8、什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。</p><p>9、为什么<strong>尽量不要使用长事务</strong>。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</p><p>10、事务启动方式：一、显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；二、set autocommit&#x3D;0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。<br>11、建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit&#x3D;1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。</p><p>可以在information_schema库的innodb_trx这个表中<strong>查询长事务</strong>，比如下面这个语句，用于查找持续时间超过60s的事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure><h1 id="04-讲深入浅出索引-上"><a href="#04-讲深入浅出索引-上" class="headerlink" title="04 讲深入浅出索引(上)"></a>04 讲深入浅出索引(上)</h1><p><strong>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</strong></p><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p><p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/0c62b601afda86fe5d0fe57346ace957.png" alt="img"></p><p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以<strong>哈希索引做区间查询(范围查询)的速度是很慢的</strong>。</p><p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p><p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p><h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230920194507068.png" alt="image-20230920194507068"></p><p>这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个**时间复杂度是O(log(N))**。</p><p>这个索引结构<strong>支持范围查询</strong>。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要<strong>更新数据</strong>的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，<strong>成本太高</strong>。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/04fb9d24065635a6a637c25ba9ddde68.png" alt="img"></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个**时间复杂度是O(log(N))**。</p><p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p><p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，<strong>这个查询可真够慢的</strong>。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p><p><strong>N叉树</strong>由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230920195036279.png" alt="image-20230920195036279"></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，<strong>我们在应用中应该尽量使用主键查询</strong>。</p><p>当不使用有序索引时，插入可能造成<strong>页分裂</strong>，严重影响数据库性能</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p><strong>总结：</strong></p><p>1.索引的作用：提高数据查询效率<br>2.常见索引模型：哈希表、有序数组、搜索树</p><p>3.哈希表：键 - 值(key - value)。<br>4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置<br>5.哈希冲突的处理办法：链表<br>6.哈希表适用场景：只有等值查询的场景</p><p>7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))<br>8.有序数组查询效率高，更新效率低<br>9.有序数组的适用场景：静态存储引擎。</p><p>10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子<br>11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))<br>12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树</p><p>13.InnoDB中的索引模型：B+Tree<br>14.索引类型：主键索引、非主键索引<br>主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)<br>15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)</p><p>16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。<br>17.从性能和存储空间方面考量，自增主键往往是更合理的选择</p><h1 id="05-讲深入浅出索引-下"><a href="#05-讲深入浅出索引-下" class="headerlink" title="05 讲深入浅出索引(下)"></a>05 讲深入浅出索引(下)</h1><h2 id="回表过程"><a href="#回表过程" class="headerlink" title="回表过程"></a>回表过程</h2><p>在下面这个表T中，如果我执行 <strong>select * from T where k between 3 and 5</strong>，需要执行几次树的搜索操作，会扫描多少行？</p><p>下面是这个表的初始化语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230921102234370.png" alt="image-20230921102234370"></p><p>现在，我们一起来看看这条SQL查询语句的执行流程：</p><ol><li>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</li><li>再到ID索引树查到ID&#x3D;300对应的R3；</li><li>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</li><li>再回到ID索引树查到ID&#x3D;500对应的R4；</li><li>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</li></ol><p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p><p>有没有可能经过索引优化，避免回表过程呢？</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果执行的语句是select <strong>ID</strong> from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><p>需要注意的是，在<strong>引擎内部</strong>使用覆盖索引在索引k上其实读了<strong>三个记录</strong>，R3~R5（对应的索引k上的记录项），但是对于MySQL的<strong>Server层</strong>来说，它就是找引擎拿到了<strong>两条记录</strong>，因此MySQL认为扫描行数是2。</p><h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p><strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p><strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><p>第二要<strong>考虑的原则就是空间</strong>了。比如name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p><p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p><p>然后呢？</p><p>当然是判断其他条件是否满足。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而MySQL 5.6 引入<strong>的索引下推优化</strong>（index condition pushdown)， 可以<strong>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><p>索引下推是使用联合索引时，若是后面的索引失效，就可以使用索引下推</p><p><strong>总结：</strong><br>回表：回到主键索引树搜索的过程，称为回表<br>覆盖索引：某索引已经覆盖了查询需求，称为覆盖索引，例如：select ID from T where k between 3 and 5<br>在引擎内部使用覆盖索引在索引K上其实读了三个记录，R3~R5(对应的索引k上的记录项)，但对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2</p><p>最左前缀原则：B+Tree这种索引结构，可以利用索引的”最左前缀”来定位记录<br>只要满足最左前缀，就可以利用索引来加速检索。<br>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符<br>第一原则是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p><p>索引下推：在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段值。<br>MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h1 id="06-讲全局锁和表锁：给表加个字段怎么有这么多阻碍"><a href="#06-讲全局锁和表锁：给表加个字段怎么有这么多阻碍" class="headerlink" title="06 讲全局锁和表锁：给表加个字段怎么有这么多阻碍"></a>06 讲全局锁和表锁：给表加个字段怎么有这么多阻碍</h1><p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都select出来存成文本。</p><p>但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li></ul><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？<strong>一致性读是好，但前提是引擎要支持这个隔离级别。</strong>比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。</p><p>所以，<strong>single-transaction方法只适用于所有的表使用事务引擎的库。</strong>如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。</p><p>你也许会问，<strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p><ul><li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><blockquote><p>我认为还有一个原因：修改global属性后，已有的session不会更改</p></blockquote><p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p><strong>表锁的语法是 lock tables … read&#x2F;write。</strong></p><p><strong>另一类表级的锁是MDL（metadata lock)。</strong>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230921112908550.png" alt="image-20230921112908550"></p><p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</p><p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被<strong>阻塞</strong>。</p><p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p><strong>解决方法：</strong></p><p>比较理想的机制是，<strong>在alter table语句里面设定等待时间</strong>，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p><p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT&#x2F;WAIT n这个语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>根据加锁范围：MySQL里面的锁可以分为：全局锁、表级锁、行级锁</p><p>一、全局锁：<br>对整个数据库实例加锁。<br>MySQL提供加全局读锁的方法：Flush tables with read lock(FTWRL)<br>这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会被阻塞。<br>使用场景：全库逻辑备份。<br>风险：<br>1.如果在主库备份，在备份期间不能更新，业务停摆<br>2.如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟</p><p>官方自带的逻辑备份工具mysqldump，当mysqldump使用参数–single-transaction的时候，会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>一致性读是好，但是前提是引擎要支持这个隔离级别。<br>如果要全库只读，为什么不使用set global readonly&#x3D;true的方式？<br>1.在有些系统中，readonly的值会被用来做其他逻辑，比如判断主备库。所以修改global变量的方式影响太大。<br>2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</p><p>二、表级锁<br>MySQL里面表级锁有两种，一种是表锁，一种是元数据锁(meta data lock,MDL)<br>表锁的语法是:lock tables … read&#x2F;write<br>可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。<br>对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><p>MDL：不需要显式使用，在访问一个表的时候会被自动加上。<br>MDL的作用：保证读写的正确性。<br>在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。<br>读锁之间不互斥。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。<br>MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p><h1 id="07-讲行锁功过：怎么减少行锁对性能的影响"><a href="#07-讲行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="07 讲行锁功过：怎么减少行锁对性能的影响"></a>07 讲行锁功过：怎么减少行锁对性能的影响</h1><p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<strong>InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一</strong>。</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，<font color="red">如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</font>。</p><blockquote><p>eg：</p><p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p><ol><li>从顾客A账户余额中扣除电影票价；</li><li>给影院B的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p><p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，<strong>提升了并发度</strong>。</p></blockquote><h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。这是什么原因呢？</p><p>这里，我就要说到<strong>死锁</strong>和<strong>死锁检测</strong>了。</p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230922131553223.png" alt="image-20230922131553223"></p><p>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>在InnoDB中，<strong>innodb_lock_wait_timeout的默认值是50s</strong>，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是<strong>无法接受</strong>的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现<strong>很多误伤</strong>。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且<strong>innodb_deadlock_detect</strong>的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有<strong>额外负担</strong>的。</p><p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是<strong>O(n)<strong>的操作。假设有</strong>1000</strong>个并发线程要同时更新同一行，那么死锁检测操作就是<strong>100万</strong>这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到<strong>CPU利用率很高，但是每秒却执行不了几个事务</strong>。</p><h2 id="怎么解决由热点行更新导致的性能问题？"><a href="#怎么解决由热点行更新导致的性能问题？" class="headerlink" title="怎么解决由热点行更新导致的性能问题？"></a>怎么解决由热点行更新导致的性能问题？</h2><p><font color="red">怎么解决由这种热点行更新导致的性能问题呢？</font></p><ul><li><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是<strong>业务有损</strong>的。</li><li><strong>另一个思路是控制并发度。</strong>根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。</li></ul><p>因此，这个<strong>并发控制要做在数据库服务端</strong>。如果你有<strong>中间件</strong>，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</p><p>可能你会问，<strong>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</strong></p><p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，<strong>影院的账户总额等于这10个记录的值的总和</strong>。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的<strong>1&#x2F;10</strong>，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p><p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。</p><p><strong>总结：</strong></p><p>两阶段锁：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放， 而是要等到事务结束时才释放。<br>建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>死锁：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态。</p><p>解决方案：<br>1、通过参数 innodb_lock_wait_timeout 根据实际业务场景来设置超时时间，InnoDB引擎默认值是50s。<br>2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状态）。</p><p>如何解决热点行更新导致的性能问题？<br>1、如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用<br>2、控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。<br>3、将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。</p><p><strong>innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</strong></p><h1 id="08-讲事务到底是隔离的还是不隔离的"><a href="#08-讲事务到底是隔离的还是不隔离的" class="headerlink" title="08 讲事务到底是隔离的还是不隔离的"></a>08 讲事务到底是隔离的还是不隔离的</h1><h2 id="read-view的生成以及当前读"><a href="#read-view的生成以及当前读" class="headerlink" title="read view的生成以及当前读"></a>read view的生成以及当前读</h2><p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/823acf76e53c0bdba7beab45e72e90d6.png" alt="img"></p><p>图1 事务A、B、C的执行流程</p><blockquote><p>这里，我们需要注意的是事务的启动时机。</p><p><strong>begin&#x2F;start transaction</strong> 命令并不是一个事务的起点，在执行到它们之后的<strong>第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动</strong>。如果你想要<strong>马上启动一个事务</strong>，可以使用<strong>start transaction with consistent snapshot</strong> 这个命令。</p><p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是<strong>默认autocommit&#x3D;1</strong>。</p></blockquote><p>在这个例子中，事务C没有显式地使用begin&#x2F;commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p><p>这时，如果我告诉你<strong>事务B查到的k的值是3</strong>，而<strong>事务A查到的k的值是1</strong>，你是不是感觉有点晕呢？</p><h3 id="read-view原理"><a href="#read-view原理" class="headerlink" title="read view原理"></a>read view原理</h3><p>InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p><ul><li>数组里面事务ID的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务ID的最大值加1记为<strong>高水位</strong>。</li><li>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</li><li>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</li><li>这个视图数组把所有的row trx_id 分成了几种不同的情况。</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230922142150072.png" alt="image-20230922142150072"></p><p><strong>read view规则：</strong></p><p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p><ol><li>如果落在<strong>绿色部分</strong>，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在<strong>红色部分</strong>，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在<strong>黄色部分</strong>，那就包括两种情况<br>a. 若 row trx_id<strong>在</strong>数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id<strong>不在</strong>数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><p><strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p>所以上面那道例题的分析如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230922142355909.png" alt="image-20230922142355909"></p><p>现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p><ul><li>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>细心的同学可能有疑问了：<strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p><p>你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p><blockquote><p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p><p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p><p>这里我们提到了一个概念，叫作当前读。其实，<strong>除了update语句外，select语句如果加锁，也是当前读。</strong></p></blockquote><p>READ VIEW分为快照读和当前读，**<font color="red">修改删除插入操作和加锁的select操作都属于当前读</font>**</p><p><strong>总结：</strong></p><p>1.innodb支持RC和RR隔离级别实现是用的一致性视图(consistent read view)</p><p>2.事务在启动时会拍一个快照,这个快照是基于整个库的.<br>基于整个库的意思就是说一个事务内,整个库的修改对于该事务都是不可见的(对于快照读的情况)</p><p>3.事务是如何实现的MVCC呢?<br>(1)每个事务都有一个事务ID,叫做transaction id(严格递增)<br>(2)事务在启动时,找到已提交的最大事务ID记为up_limit_id。<br>(3)事务在更新一条语句时,比如id&#x3D;1改为了id&#x3D;2.会把id&#x3D;1和该行之前的row trx_id写到undo log里,<br>并且在数据页上把id的值改为2,并且把修改这条语句的transaction id记在该行行头<br>(4)再定一个规矩,一个事务要查看一条数据时,必须先用该事务的up_limit_id与该行的transaction id做比对,<br>如果up_limit_id&gt;&#x3D;transaction id,那么可以看.如果up_limit_id&lt;transaction id,则只能去undo log里去取。去undo log查找数据的时候,也需要做比对,必须up_limit_id&gt;transaction id,才返回数据</p><p>4.什么是当前读,由于当前读都是<strong>先读后写</strong>,只能读当前的值,所以为当前读会更新事务内的up_limit_id为该事务的transaction id</p><p>5.为什么rr能实现可重复读而rc不能,分两种情况<br>(1)快照读的情况下,rr不能更新事务内的up_limit_id,<br>而rc每次会把up_limit_id更新为快照读之前最新已提交事务的transaction id,则rc不能可重复读<br>(2)当前读的情况下,rr是利用record lock+gap lock来实现的,而rc没有gap,所以rc不能可重复读</p><h1 id="09-讲普通索引和唯一索引，应该怎么选择"><a href="#09-讲普通索引和唯一索引，应该怎么选择" class="headerlink" title="09 讲普通索引和唯一索引，应该怎么选择"></a>09 讲普通索引和唯一索引，应该怎么选择</h1><p>在不同的业务场景下，应该选择普通索引，还是唯一索引？</p><p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from CUser where id_card = &#x27;xxxxxxxyyyyyyzzzzz&#x27;;</span><br></pre></td></tr></table></figure><p>所以，你一定会考虑在id_card字段上建索引。</p><p>由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p><p>现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p><h2 id="查询过程的区别"><a href="#查询过程的区别" class="headerlink" title="查询过程的区别"></a>查询过程的区别</h2><p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是，<strong>微乎其微</strong>。</p><h2 id="更新过程的区别"><a href="#更新过程的区别" class="headerlink" title="更新过程的区别"></a>更新过程的区别</h2><h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change buffer。</p><p>当需要<strong>更新一个数据页</strong>时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些<strong>更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页</strong>了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。</p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了<strong>访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中</strong>，也会执行merge操作。</p><p>显然，如果能够将更新操作先记录在change buffer，<strong>减少读磁盘</strong>，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>那么，<strong>什么条件下可以使用change buffer呢？</strong></p><ul><li>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要<strong>将数据页读入内存才能判断</strong>。如果都已经读入到内存了，那<strong>直接更新内存</strong>会更快，就没必要使用change buffer了。</li><li>因此，唯一索引的更新就不能使用change buffer，实际上也只有<strong>普通索引</strong>可以使用。</li></ul><p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数<strong>innodb_change_buffer_max_size</strong>来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><h3 id="更新区别"><a href="#更新区别" class="headerlink" title="更新区别"></a>更新区别</h3><p>现在，你已经理解了change buffer的机制，那么我们再一起来看看<strong>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的。</strong></p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p><p>但，这不是我们关注的重点。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及<strong>随机IO的访问，是数据库里面成本最高的操作之一</strong>。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p>之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p><h2 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h2><p>使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p><p>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，<strong>change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大</strong>。</p><ul><li>因此，对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时<strong>change buffer的使用效果最好</strong>。这种业务模型常见的就是账单类、日志类的系统。</li><li>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，<strong>反而增加了change buffer的维护代价</strong>。所以，对于这种业务模式来说，change buffer反而起到了副作用。</li></ul><p>这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我<strong>建议你尽量选择普通索引</strong>。</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p>使用普通索引：</p><ol><li>业务代码已经保证不会写入重复数据</li><li>归档库：归档数据已经是确保没有唯一键冲突了，要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。</li></ol><h2 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h2><p>现在，我们要在表上执行这个插入语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230924140201162.png" alt="image-20230924140201162"></p><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>比如，我们现在要执行 select * from t where k in (k1, k2)。这里，我画了这两个读请求的流程图。</p><p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230924140252534.png" alt="image-20230924140252534"></p><p>从图中可以看到：</p><ol><li>读Page 1的时候，<strong>直接从内存返回</strong>。有几位同学在前面文章的评论中问到，WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li><li>要读Page 2的时候，需要把Page 2从磁盘<strong>读入内存中，然后应用change buffer里面的操作日志</strong>，生成一个正确的版本并返回结果。</li></ol><p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，</p><ul><li><strong>redo log 主要节省的是<code>随机写</code>磁盘的IO消耗（转成顺序写）</strong></li><li><strong>而change buffer主要节省的则是<code>随机读</code>磁盘的IO消耗。</strong></li></ul><blockquote><p>注意：这里change buffer是针对<strong>insert</strong>操作的页更新，针对非唯一索引和唯一索引的<strong>update</strong>和<strong>delete</strong>而且条件是where 索引值&#x3D;这种情况，会采用锁定读，这时候要“<strong>先读后写</strong>”，读的时候数据会读入内存，更新的时候直接改内存，就<strong>不需要change buffer</strong>了</p></blockquote><p><strong>总结:</strong></p><p>选择普通索引还是唯一索引？<br>对于查询过程来说：<br>a、普通索引，查到满足条件的第一个记录后，继续查找下一个记录，知道第一个不满足条件的记录<br>b、唯一索引，由于索引唯一性，查到第一个满足条件的记录后，停止检索<br>但是，两者的性能差距微乎其微。因为InnoDB根据数据页来读写的。<br>对于更新过程来说：<br>概念：change buffer<br>当需要更新一个数据页，如果数据页在内存中就直接更新，如果不在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中。下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中的与这个页有关的操作。</p><p>change buffer是可以持久化的数据。在内存中有拷贝，也会被写入到磁盘上</p><p>purge:将change buffer中的操作应用到原数据页上，得到最新结果的过程，成为merge<br>访问这个数据页会触发merge，系统有后台线程定期merge，在数据库正常关闭的过程中，也会执行merge</p><p>唯一索引的更新不能使用change buffer</p><p>change buffer用的是buffer pool里的内存，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。<br>change buffer 因为减少了随机磁盘访问，所以对更新性能的提升很明显。</p><p>change buffer使用场景<br>在一个数据页做purge之前，change buffer记录的变更越多，收益就越大。<br>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer,但之后由于马上要访问这个数据页，会立即触发purge过程。<br>这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p><p>索引的选择和实践：<br>尽可能使用普通索引。<br>redo log主要节省的是随机写磁盘的IO消耗(转成顺序写)，而change buffer主要节省的则是随机读磁盘的IO消耗。</p><p>思考题：<br>change buffer不会丢失，因为change buffer是可以持久化的数据，在磁盘上占据了系统表空间ibdata，对应的内部系统表名为SYS_IBUF_TABLE，并且changebuffer的变更也会写入到redo log，因此在异常关机的时候，不会丢失。</p><h1 id="10-讲MySQL为什么有时候会选错索引"><a href="#10-讲MySQL为什么有时候会选错索引" class="headerlink" title="10 讲MySQL为什么有时候会选错索引"></a>10 讲MySQL为什么有时候会选错索引</h1><h2 id="MySQL选错索引举例"><a href="#MySQL选错索引举例" class="headerlink" title="MySQL选错索引举例"></a>MySQL选错索引举例</h2><p>前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。</p><p>不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索引，而导致执行速度变得很慢？</p><p>我们一起来看一个例子吧。</p><p>我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB；</span><br></pre></td></tr></table></figure><p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p><p>接下来，我们分析一条SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure><p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。</p><p>你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/2cfce769551c6eac9bfbee0563d48fe3.png" alt="img"></p><p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索引a。</p><p>不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做如下操作。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/1e5ba1c2934d3b2c0d96b210a27e1a1e.png" alt="img"></p><p>这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删除后，又调用了 idata这个存储过程，插入了10万行数据。</p><p>这时候，session B的查询语句select * from t where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。</p><p>为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用force index(a)来让优化器强制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）。</p><p>下面的三条SQL语句，就是这个实验过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set long_query_time=0;</span><br><span class="line">select * from t where a between 10000 and 20000; /*Q1*/</span><br><span class="line">select * from t force index(a) where a between 10000 and 20000;/*Q2*/</span><br></pre></td></tr></table></figure><ul><li>第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</li><li>第二句，Q1是session B原来的查询；</li><li>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</li></ul><p>如图3所示是这三条SQL语句执行完成后的慢查询日志。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7c58b9c71853b8bba1a8ad5e926de1f6.png" alt="img"></p><p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间。</p><p>这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。</p><h2 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h2><p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。</p><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。</p><p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p><p>我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出问题了。</p><p>那么，问题就是：<strong>扫描行数是怎么判断的？</strong></p><p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p><p>我们可以使用show index方法，看到一个索引的基数。如图4所示，就是表t的show index 的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/16dbf8124ad529fec0066950446079d4.png" alt="img"></p><h3 id="基数统计方法"><a href="#基数统计方法" class="headerlink" title="基数统计方法"></a>基数统计方法</h3><p>那么，<strong>MySQL是怎样得到索引的基数的呢？</strong>这里，我给你简单介绍一下MySQL采样统计的方法。</p><p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p><p>采样统计的时候，InnoDB默认会选择<strong>N个数据页</strong>，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过<strong>1&#x2F;M</strong>的时候，会自动触发重新做一次索引统计。</p><p>在MySQL中，有两种存储索引统计的方式，可以通过设置参数<strong>innodb_stats_persistent</strong>的值来选择：</p><ul><li>设置为<strong>on</strong>的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。</li><li>设置为<strong>off</strong>的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。</li></ul><p>由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。</p><p>你可以从图4中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。</p><h3 id="预估扫描行数"><a href="#预估扫描行数" class="headerlink" title="预估扫描行数"></a>预估扫描行数</h3><p>其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。</p><p>接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/e2bc5f120858391d4accff05573e1289.png" alt="img"></p><p>图5 意外的explain结果</p><p>rows这个字段表示的是预计扫描行数。</p><p>其中，Q1的结果还是符合预期的，rows的值是104620；<strong>但是Q2的rows值是37116，偏差就大了</strong>。而图1中我们用explain命令看到的rows是只有10001行，<strong>是这个偏差误导了优化器的判断</strong>。</p><p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢？</p><p>这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。</p><p>而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。</p><p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p><p>使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，但图1的选择是对的。也就是说，这个策略并没有问题。</p><p>所以冤有头债有主，MySQL选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。</p><blockquote><p><strong>为什么会得到错误的扫描行数？</strong></p><p>1.为什么没有session A,session B扫描的行数是1W<br>由于mysql是使用标记删除来删除记录的,并不从索引和数据文件中真正的删除。<br>如果delete和insert中间的间隔相对较小,purge线程还没有来得及清理该记录。<br>如果主键相同的情况下,<strong>新插入的insert会沿用之前删除的delete的记录的空间</strong>。<br>由于相同的数据量以及表大小,所以导致了统计信息没有变化<br>2.为什么开启了session A,session B扫描行数变成3W<br>由于session A开启了一致性读,目的为了保证session A的可重复读,insert只能<br>另起炉灶,<strong>不能占用delete的空间</strong>。所以出现的情况就是delete虽然删除了,但是<br>未释放空间,insert又增加了空间。导致统计信息有误</p><p>delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来的10万行。</p><p>但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数据。</p><p>这样，索引a上的数据其实就有两份。</p><p>然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令看到的扫描行数为什么还是100000左右？（潜台词，如果这个也翻倍，也许优化器还会认为选字段a作为索引更合适）</p><p>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是show table status的值。</p></blockquote><h3 id="修正统计信息"><a href="#修正统计信息" class="headerlink" title="修正统计信息"></a>修正统计信息</h3><p>既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。我们来看一下执行效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/209e9d3514688a3bcabbb75e54e1e49c.png" alt="img"></p><p>图6 执行analyze table t 命令恢复的explain结果</p><p>这回对了。</p><p>所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法来处理。</p><p>其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优化器可不止是看扫描行数。</p><h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><p>依然是基于这个表t，我们看看另外一个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;</span><br></pre></td></tr></table></figure><p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。</p><p>在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？</p><p>为了便于分析，我们先来看一下a、b这两个索引的结构图。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230924143943300.png" alt="image-20230924143943300"></p><p>图7 a、b索引的结构图</p><p>如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。</p><p>如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描50001行。</p><p>所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底是不是这么一回事儿。</p><p>图8是执行explain的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/483bcb1ef3bb902844e80d9cbdd73ab8.png" alt="img"></p><p>图8 使用explain方法查看执行计划 2</p><p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行数是50198。</p><p>从这个结果中，你可以得到两个结论：</p><ol><li>扫描行数的估计值依然不准确；</li><li>这个例子里MySQL又选错了索引。</li></ol><h2 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h2><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p><p><strong>一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。</strong>MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p><p>我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行效果：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9582401a6bed6cb8fd803c9555750b54.png" alt="img"></p><p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化器的选择快了40多倍。</p><p>也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。</p><p>不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。</p><p>但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。</p><p>所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？</p><p>既然优化器放弃了使用索引a，说明a还不够合适，所以<strong>第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。</strong>比如，在这个例子里，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p>我们来看看改之后的效果：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/14cd598e52a2b72dd334a42603e5b894.png" alt="img"></p><p>图10 order by b,a limit 1 执行结果</p><p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。</p><p>现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。</p><p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才可以这么做。</p><p>如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from  (select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 100)alias limit 1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/b1a2ad43c78477d7f93dbc692cbaa0d7.png" alt="img"></p><p>图11 改写SQL的explain</p><p>在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数据特征诱导了一下优化器，也不具备通用性。</p><p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p><p>不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。</p><p>如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子，最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</p><h1 id="11-讲怎么给字符串字段加索引"><a href="#11-讲怎么给字符串字段加索引" class="headerlink" title="11 讲怎么给字符串字段加索引"></a>11 讲怎么给字符串字段加索引</h1><h2 id="字符串前缀索引"><a href="#字符串前缀索引" class="headerlink" title="字符串前缀索引"></a>字符串前缀索引</h2><p>现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天要讨论的问题。</p><p>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table SUser(</span><br><span class="line">ID bigint unsigned primary key,</span><br><span class="line">email varchar(64), </span><br><span class="line">... </span><br><span class="line">)engine=innodb; </span><br></pre></td></tr></table></figure><p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select f1, f2 from SUser where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure><p>从第4和第5篇讲解索引的文章中，我们可以知道，如果email这个字段上没有索引，那么这个语句就只能做全表扫描。</p><p>同时，MySQL是支持前缀索引的，也就是说，你可以<strong>定义字符串的一部分作为索引</strong>。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><p>比如，这两个在email字段上创建索引的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure><p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。</p><p>那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引的示意图。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230925162512042.png" alt="image-20230925162512042"></p><p>从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以<strong>占用的空间会更小</strong>，这就是使用前缀索引的优势。</p><blockquote><p>执行时：使用前缀索引会一直回表进行判断，<strong>增加了回表次数</strong>，在此例中，要回主键索引取4次数据，也就是扫描了4行。</p><p>而使用完全索引只用扫描一行</p><p>通过这个对比，你很容易就可以发现，<strong>使用前缀索引后，可能会导致查询语句读数据的次数变多</strong>。</p></blockquote><p>但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了。</p><p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><h2 id="怎么定义好前缀索引"><a href="#怎么定义好前缀索引" class="headerlink" title="怎么定义好前缀索引"></a>怎么定义好前缀索引</h2><p>于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p><p>实际上，我们在建立索引时关注的是区分度，<strong>区分度越高越好</strong>。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br></pre></td></tr></table></figure><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure><p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。</p><h2 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h2><p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。</p><p>你先来看看这个SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure><p>与前面例子中的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure><p>相比，这个语句只要求返回id和email字段。</p><p>所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p><p>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><blockquote><p>使用前缀索引，就算包含了要查询的所有字段，也都会回表，<strong>不能使用覆盖索引</strong></p></blockquote><h2 id="定义字符串索引的其他方式"><a href="#定义字符串索引的其他方式" class="headerlink" title="定义字符串索引的其他方式"></a>定义字符串索引的其他方式</h2><p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。</p><p>按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。</p><p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p><p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p><p>答案是，有的。</p><h3 id="倒序存储"><a href="#倒序存储" class="headerlink" title="倒序存储"></a>倒序存储</h3><p>如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card = reverse(&#x27;input_id_card_string&#x27;);</span><br></pre></td></tr></table></figure><p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。</p><h3 id="hash字段"><a href="#hash字段" class="headerlink" title="hash字段"></a>hash字段</h3><p>你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure><p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure><p>这样，索引的长度变成了<strong>4个字节</strong>，比原来小了很多。</p><h3 id="倒序和hash的异同"><a href="#倒序和hash的异同" class="headerlink" title="倒序和hash的异同"></a>倒序和hash的异同</h3><p>接下来，我们再一起看看<strong>使用倒序存储和使用hash字段这两种方法的异同点。</strong></p><p><strong>相同点：</strong></p><p>都<strong>不支持范围查询</strong></p><ul><li>倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash字段的方式也只能支持等值查询。</li></ul><p>它们的<strong>区别</strong>，主要体现在以下三个方面：</p><ol><li>从占用的额外空间来看，<strong>倒序</strong>存储方式在主键索引上，<strong>不会消耗额外的存储空间</strong>，而<strong>hash</strong>字段方法<strong>需要增加一个字段</strong>。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段的int类型也差不多抵消了。</li><li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，<strong>reverse函数额外消耗的CPU资源会更小些</strong>。</li><li>从查询效率上看，使用<strong>hash</strong>字段方式的查询性能相对<strong>更稳定一些</strong>。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ol><h1 id="12-讲为什么我的MySQL会“抖”一下"><a href="#12-讲为什么我的MySQL会“抖”一下" class="headerlink" title="12 讲为什么我的MySQL会“抖”一下"></a>12 讲为什么我的MySQL会“抖”一下</h1><p>平时的工作中，不知道你有没有遇到过这样的场景，一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</p><p>看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。</p><h2 id="为什么会突然变慢？"><a href="#为什么会突然变慢？" class="headerlink" title="为什么会突然变慢？"></a>为什么会突然变慢？</h2><p>在前面第2篇文章<a href="https://time.geekbang.org/column/article/68633">《日志系统：一条SQL更新语句是如何执行的？》</a>中，我为你介绍了WAL机制。现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写完redo log后，就返回给客户端，本次更新成功。</p><p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。</p><p>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是flush。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p><p>接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10文，这次又要赊9文。</p><p><strong>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</strong></p><h2 id="什么时候会flush"><a href="#什么时候会flush" class="headerlink" title="什么时候会flush"></a>什么时候会flush</h2><p>那么，什么情况会引发数据库的flush过程呢？</p><ul><li>第一种场景是，<strong>粉板满了，记不下了</strong>。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。<br>这个场景，对应的就是<strong>InnoDB的redo log写满了</strong>。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。</li></ul><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/image-20230925165033023.png" alt="image-20230925165033023" style="zoom:50%;"><p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图中从write pos到CP’之间就是可以再写入的redo log的区域。</p><ul><li><p>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。<br>这种场景，对应的就是<strong>系统内存不足</strong>。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。<strong>如果淘汰的是“脏页”，就要先将脏页写到磁盘</strong>。<br>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</p><ul><li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。</li></ul></li><li><p>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。<br>这种场景，对应的就是MySQL认为<strong>系统“空闲”的时候</strong>。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</p></li><li><p>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。<br>这种场景，对应的就是<strong>MySQL正常关闭的情况</strong>。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ul><h2 id="flush操作对系统性能的影响"><a href="#flush操作对系统性能的影响" class="headerlink" title="flush操作对系统性能的影响"></a>flush操作对系统性能的影响</h2><p>其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前两种场景下的性能问题。</p><p>第一种是“<strong>redo log写满了，要flush脏页</strong>”，<strong>这种情况是InnoDB要尽量避免的</strong>。因为出现这种情况的时候，整个系统就<strong>不能再接受更新</strong>了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</p><p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li></ul><p>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显<strong>影响性能</strong>的：</p><ol><li><strong>一个查询要淘汰的脏页个数太多</strong>，会导致查询的响应时间明显变长；</li><li><strong>日志写满</strong>，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li></ol><p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><h2 id="InnoDB刷脏页速度的控制策略"><a href="#InnoDB刷脏页速度的控制策略" class="headerlink" title="InnoDB刷脏页速度的控制策略"></a>InnoDB刷脏页速度的控制策略</h2><h3 id="主机IO能力"><a href="#主机IO能力" class="headerlink" title="主机IO能力"></a>主机IO能力</h3><p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。</p><p>首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</p><p>这就要用到<strong>innodb_io_capacity</strong>这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><p>其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，说MySQL的写入速度很慢，TPS很低，但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。</p><p>他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</p><p>虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按照“全力”的百分比来刷脏页。</p><blockquote><p>InnoDB的刷盘速度就是要参考这两个因素：一个是<strong>脏页比例</strong>，一个是<strong>redo log写盘速度</strong>。</p></blockquote><h3 id="脏页比例"><a href="#脏页比例" class="headerlink" title="脏页比例"></a>脏页比例</h3><p>参数<strong>innodb_max_dirty_pages_pct</strong>是**<code>脏页比例上限</code><strong>，默认值是</strong>75%<strong>。InnoDB会根据当前的</strong><code>脏页比例</code>（假设为M）**，算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：(<strong>我自己测试mysql8默认值为90%</strong>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷脏页的速度计算"><a href="#刷脏页的速度计算" class="headerlink" title="刷脏页的速度计算"></a>刷脏页的速度计算</h3><p>InnoDB每次写入的日志都有一个序号，当前<strong>写入的序号跟checkpoint对应的序号之间的<code>差值</code>，我们假设为N</strong>。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道<strong>N越大，算出来的值越大就好了</strong>。</p><blockquote><p>即checkpoint和write pos差的越远，说明空间不多了，刷的越快</p></blockquote><p>然后，<strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p><blockquote><p>R &#x3D; max(F1(M), F2(N))</p><p>刷脏页的速度 &#x3D; innodb_io_capacity * R</p></blockquote><p>当前<strong>脏页比例越高</strong>，<strong>redo log越久没merge</strong>，即越久没同步磁盘数据，当前<strong>刷脏页速度越快</strong>，**<font color="red">但都需要定义好主机IO能力innodb_io_capacity这个变量</font>**</p><p>现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</p><p>要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且**平时要多关注脏页比例，不要让它经常接近75%**。</p><p>其中，脏页比例是通过Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total得到的，具体的命令参考下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_dirty&#x27;;</span><br><span class="line">select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_total&#x27;;</span><br><span class="line">select @a/@b;</span><br></pre></td></tr></table></figure><blockquote><p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，<strong>如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉</strong>；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是<strong>对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷</strong>。</p><p>在InnoDB中，<strong>innodb_flush_neighbors</strong> 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><p>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</p><p>而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</p><p><strong>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</strong></p></blockquote><h1 id="13-讲为什么表数据删掉一半，表文件大小不变"><a href="#13-讲为什么表数据删掉一半，表文件大小不变" class="headerlink" title="13 讲为什么表数据删掉一半，表文件大小不变"></a>13 讲为什么表数据删掉一半，表文件大小不变</h1><p>经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</p><p>那么今天，我就和你聊聊数据库表的空间回收，看看如何解决这个问题。</p><p>这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。一个InnoDB表包含两部分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以我们今天主要讨论的是表数据。</p><p>接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。</p><h2 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="headerlink" title="参数innodb_file_per_table"></a>参数innodb_file_per_table</h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p><ol><li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</li></ol><p>从MySQL 5.6.6版本开始，它的默认值就是ON了。</p><p>我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>所以，<strong>将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p><p>我们在删除整个表的时候，可以使用<strong>drop table命令回收表空间</strong>。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><p>我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。</p><blockquote><p>当innodb_file_per_table为ON时，使用drop table能回收表空间</p></blockquote><p>接下来要看的是使用delete删除数据的情况：</p><h2 id="delete删除数据"><a href="#delete删除数据" class="headerlink" title="delete删除数据"></a>delete删除数据</h2><p>因为<strong>记录和数据页都可以被复用</strong></p><p>所以使用delete删除后，表空间未被回收掉，文件大小没减小</p><blockquote><p>但是，<strong>数据页的复用跟记录的复用是不同的。</strong></p><p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</p><p>而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新页的时候，page A是可以被复用的。</p></blockquote><p>进一步地，如果我们<strong>用delete命令把整个表的数据删除</strong>呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，<strong>文件不会变小</strong>。</p><p>delete命令其实只是把记录的位置，或者数据页标记为了<strong>“可复用”</strong>，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是<strong>“空洞”</strong>。</p><p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。页分裂会时页的空间利用率降低，造成空洞</p><p><strong>更新索引上的值</strong>，可以理解为删除一个旧的值，再插入一个新值。不难理解，这<strong>也是会造成空洞</strong>的。</p><p>也就是说，经过大量<strong>增删改</strong>的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p><blockquote><p>insert、delete、update都会造成空洞</p></blockquote><p>而重建表，就可以达到这样的目的。</p><h2 id="解决方法：重建表"><a href="#解决方法：重建表" class="headerlink" title="解决方法：重建表"></a>解决方法：重建表</h2><p>你可以使用alter table A engine&#x3D;InnoDB命令来重建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table A engine=InnoDB</span><br></pre></td></tr></table></figure><p>但是分为两种情况，执行的具体过程不同</p><p>分为<strong>MySQL 5.5版本之前和之后</strong></p><p>在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230926151135184.png" alt="image-20230926151135184"></p><blockquote><p>MySQL5.5之前，是采用在<strong>server层</strong>创建<strong>临时表</strong>来完成表的重建的</p><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，<strong>在整个DDL过程中，表A中不能有更新</strong>。也就是说，<strong>这个DDL不是Online的</strong>。</p></blockquote><p><strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><p>我给你简单描述一下引入了Online DDL之后，重建表的流程：</p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个<strong>日志文件（row log）</strong>中，对应的是图中state2的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li><li>用临时文件替换表A的数据文件。</li></ol><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230926151320804.png" alt="image-20230926151320804"></p><blockquote><p>MySQL5.6开始，是在<strong>存储引擎</strong>创建<strong>临时文件</strong>完成的，并且由于<strong>日志文件</strong>记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表A做增删改操作。这也就是<strong>Online DDL</strong>名字的来源。</p><p>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就<strong>退化成读锁</strong>了。所以可以进行表的更新</p><p>为什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。</p></blockquote><p>需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很<strong>消耗IO和CPU资源</strong>的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。</p><blockquote><p>注意：在重建表的时候，<strong>InnoDB不会把整张表占满，每个页留了1&#x2F;16给后续的更新用</strong>。也就是说，其实重建表之后<strong>不是“最”紧凑</strong>的。</p></blockquote><h2 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h2><p>MySQL5.5之前，我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。</p><p>MySQL5.5之后，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。<strong>整个DDL过程都在InnoDB内部完成</strong>。对于server层来说，没有把数据挪动到临时表，是一个<strong>“原地”操作</strong>，这就是<strong>“inplace”</strong>名称的来源。</p><p>所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p><p>答案是不能。因为，tmp_file也是要占用临时空间的。</p><p>我们重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=inplace;</span><br></pre></td></tr></table></figure><p>跟inplace对应的就是拷贝表的方式了，用法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=copy;</span><br></pre></td></tr></table></figure><p>当你使用ALGORITHM&#x3D;copy的时候，表示的是强制拷贝表，对应的流程就是MySQL5.5之前的操作过程。</p><p>但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？</p><p>其实不是的，只是在重建表这个逻辑中刚好是这样而已。</p><p>比如，如果我要给InnoDB表的一个字段加全文索引或空间索引，写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add FULLTEXT(field_name);</span><br></pre></td></tr></table></figure><p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p><p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p><ol><li>DDL过程如果是Online的，就一定是inplace的；</li><li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li></ol><blockquote><p>意思就是：MySQL5.6开始，alter语句除了添加全文索引和空间索引，都支持Online DDL</p><p><strong>不影响增删改，就是 Online；相对 Server层没有新建临时表，就是 inplace</strong></p></blockquote><ul><li>从MySQL 5.6版本开始，alter table t engine &#x3D; InnoDB（也就是recreate）默认的就是上面MySQL5.5之后的流程了；</li><li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li><li>optimize table t 等于recreate+analyze。</li></ul><h1 id="14-讲count-这么慢，我该怎么办"><a href="#14-讲count-这么慢，我该怎么办" class="headerlink" title="14 讲count(*)这么慢，我该怎么办"></a>14 讲count(*)这么慢，我该怎么办</h1><p>你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。然后你可能就想了，MySQL怎么这么笨啊，记个总数，每次要查的时候直接读出来，不就好了吗。</p><p>那么今天，我们就来聊聊count(*)语句到底是怎样实现的，以及MySQL为什么会这么实现。然后，我会再和你说说，如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎么做。</p><h2 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h2><p>你首先要明确的是，在不同的MySQL引擎中，count(*)有不同的实现方式。</p><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p><p>在前面的文章中，我们一起分析了为什么要使用InnoDB，因为不论是在事务支持、并发能力还是在数据安全方面，InnoDB都优于MyISAM。我猜你的表也一定是用了InnoDB引擎。这就是当你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。</p><p>当然，现在这个看上去笨笨的MySQL，在执行<strong>count(*)操作的时候还是做了优化</strong>的。</p><p>你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到<strong>最小的那棵树</strong>来遍历。*<em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</em></em></p><p>如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？</p><p>你可能还记得在第10篇文章<a href="https://time.geekbang.org/column/article/71173">《 MySQL为什么有时候会选错索引？》</a>中我提到过，索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到40%到50%。<strong>所以，show table status命令显示的行数也不能直接使用。</strong></p><p>到这里我们小结一下：</p><ul><li>MyISAM表虽然count(*)很快，但是不支持事务；</li><li>show table status命令虽然返回很快，但是不准确；</li><li>InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><p>到底应该怎么办呢？你需要<strong>自己找一个地方</strong>，把操作记录表的行数存起来。</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？</p><p>没错，缓存系统可能会丢失更新。</p><p>当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p><p>但实际上，<strong>将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工作，这个值还是逻辑上不精确的。</strong></p><p>你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。</p><p>我们是这么定义不精确的：</p><ol><li>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</li><li>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。</li></ol><p>这两种情况，都是逻辑不一致的。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230926153605478.png" alt="image-20230926153605478"></p><p>或者反过来，也是不精确的</p><p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><p>根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，<strong>如果我们把这个计数直接放到数据库里单独的一张计数表C中，又会怎么样呢？</strong></p><p>首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p><p>我们这篇文章要解决的问题，都是由于InnoDB要支持事务，从而导致InnoDB表不能把count(*)直接存起来，然后查询的时候直接返回形成的。</p><p>所谓以子之矛攻子之盾，现在我们就利用<strong>“事务”</strong>这个特性，把问题解决掉。</p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/image-20230926153851388.png" alt="image-20230926153851388" style="zoom:50%;"><p>我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p><p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p><h2 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h2><p>在前面文章的评论区，有同学留言问到：在select count(?) from t这样的查询语句里面，count(* )、count(主键id)、count(字段)和count(1)等不同用法的性能，有哪些差别。今天谈到了count(*)的性能问题，我就借此机会和你详细说明一下这几种用法的性能差别。</p><p>需要注意的是，下面的讨论还是<strong>基于InnoDB</strong>引擎的。</p><p>这里，首先你要弄清楚count()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p><p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p><p>至于分析性能差别的时候，你可以记住这么几个原则：</p><ol><li>server层要什么就给什么；</li><li>InnoDB只给必要的值；</li><li>现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol><p>这是什么意思呢？接下来，我们就一个个地来看看。</p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li></ol><p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p><p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是<strong>专门做了优化</strong>，不取值。count(*)肯定不是null，按行累加。会找到<strong>最小的那棵树</strong>遍历</p><p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照count(*)来处理，多么简单的优化啊。</p><p>当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且MySQL已经优化过count(*)了，你直接使用这种用法就可以了。</p><p>所以结论是：按照效率排序的话，*<em>count(字段)&lt;count(主键id)&lt;count(1)≈count(</em> )*<em>，所以我建议你，尽量使用count(</em>)。</p><blockquote><p>其实，把计数放在Redis里面，不能够保证计数和MySQL表里的数据精确一致的原因，是<strong>这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong>而把计数值也放在MySQL中，就解决了一致性视图的问题。</p><p>InnoDB引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。这也是InnoDB引擎备受青睐的原因之一。</p></blockquote><h1 id="15-讲答疑文章（一）：日志和索引相关问题"><a href="#15-讲答疑文章（一）：日志和索引相关问题" class="headerlink" title="15 讲答疑文章（一）：日志和索引相关问题"></a>15 讲答疑文章（一）：日志和索引相关问题</h1><h2 id="两阶段提交不同异常重启的现象"><a href="#两阶段提交不同异常重启的现象" class="headerlink" title="两阶段提交不同异常重启的现象"></a>两阶段提交不同异常重启的现象</h2><p>《02》</p><p><strong>在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。</strong></p><p>如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生crash，那崩溃恢复的时候MySQL会怎么处理？</p><p>我们先来看一下崩溃恢复时的判断规则。</p><ol><li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li><li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol><h4 id="追问1：MySQL怎么知道binlog是完整的"><a href="#追问1：MySQL怎么知道binlog是完整的" class="headerlink" title="追问1：MySQL怎么知道binlog是完整的?"></a>追问1：MySQL怎么知道binlog是完整的?</h4><p>回答：一个事务的binlog是有完整格式的：</p><ul><li>statement格式的binlog，最后会有<strong>COMMIT</strong>；</li><li>row格式的binlog，最后会有一个<strong>XID event</strong>。</li></ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><h4 id="追问2：redo-log-和-binlog是怎么关联起来的"><a href="#追问2：redo-log-和-binlog是怎么关联起来的" class="headerlink" title="追问2：redo log 和 binlog是怎么关联起来的?"></a>追问2：redo log 和 binlog是怎么关联起来的?</h4><p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p><ul><li>如果碰到既有prepare、又有commit的redo log，就直接提交；</li><li>如果碰到只有parepare、而没有commit的redo log，就<strong>拿着XID去binlog找对应的事务</strong>。</li></ul><h4 id="追问3：处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"><a href="#追问3：处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计" class="headerlink" title="追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?"></a>追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</h4><p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个binlog恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h4 id="追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h4><p>回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p><h4 id="追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"></a>追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</h4><p>回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？</p><p>答案是不可以。</p><p>如果说<strong>历史原因</strong>的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是MyISAM，设计之初就有没有支持崩溃恢复。</p><p>InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。</p><p>InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log好了。</p><p>而如果说<strong>实现上的原因</strong>的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流程，我画了一张示意图，这里就没有redo log了。</p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/image-20230927100447599.png" alt="image-20230927100447599" style="zoom:50%;"><p>这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。</p><p>如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生了crash。</p><p>重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经认为提交完成了，不会再应用一次binlog1。</p><p>但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。</p><p>也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此时，binlog里面并没有记录数据页的更新细节，是补不回来的。</p><p>你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个redo log出来。</p><p>所以，至少现在的binlog能力，还不能支持崩溃恢复。</p><h4 id="追问6：那能不能反过来，只用redo-log，不要binlog？"><a href="#追问6：那能不能反过来，只用redo-log，不要binlog？" class="headerlink" title="追问6：那能不能反过来，只用redo log，不要binlog？"></a>追问6：那能不能反过来，只用redo log，不要binlog？</h4><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。</p><p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是开着的。因为binlog有着redo log无法替代的功能。</p><p>一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。</p><p>一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。</p><p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，这些下游系统就没法输入了。</p><p>总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo log还做不到。你看，发展生态是多么重要。</p><h4 id="追问7：redo-log一般设置多大？"><a href="#追问7：redo-log一般设置多大？" class="headerlink" title="追问7：redo log一般设置多大？"></a>追问7：redo log一般设置多大？</h4><p>回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力就发挥不出来了。</p><p>所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧。</p><h4 id="追问8：正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？"><a href="#追问8：正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？" class="headerlink" title="追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？"></a>追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</h4><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。</p><p>实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由redo log更新过去”的情况。</p><ol><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</li><li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li></ol><h4 id="追问9：redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？"><a href="#追问9：redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？" class="headerlink" title="追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？"></a>追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？</h4><p>回答：这两个问题可以一起回答。</p><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t1 ...</span><br><span class="line">insert into t2 ...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><p>（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p><p>单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p><h2 id="修改一样的数据MySQL会怎样运行"><a href="#修改一样的数据MySQL会怎样运行" class="headerlink" title="修改一样的数据MySQL会怎样运行"></a>修改一样的数据MySQL会怎样运行</h2><p>这时候，表t里有唯一的一行数据(1,2)。假设，我现在要执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t set a=2 where id=1;</span><br></pre></td></tr></table></figure><p>你会看到这样的结果：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/367b3f299b94353f32f75ea825391170.png" alt="img"><br>结果显示，匹配(rows matched)了一行，修改(Changed)了0行。</p><p>仅从现象上看，MySQL内部在处理这个命令的时候，可以有以下三种选择：</p><ol><li>更新都是先读后写的，MySQL读出数据，发现a的值本来就是2，不更新，直接返回，执行结束；</li><li>MySQL调用了InnoDB引擎提供的“修改为(1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</li><li>InnoDB认真执行了“把这个值修改成(1,2)”这个操作，该加锁的加锁，该更新的更新。</li></ol><blockquote><p>MySQL采取的措施是第三条</p></blockquote><h1 id="16-讲“orderby”是怎么工作的"><a href="#16-讲“orderby”是怎么工作的" class="headerlink" title="16 讲“orderby”是怎么工作的"></a>16 讲“orderby”是怎么工作的</h1><p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前1000个人的姓名、年龄。</p><p>假设这个表的部分定义是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `city` varchar(16) NOT NULL,</span><br><span class="line">  `name` varchar(16) NOT NULL,</span><br><span class="line">  `age` int(11) NOT NULL,</span><br><span class="line">  `addr` varchar(128) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>这时，你的SQL语句可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000  ;</span><br></pre></td></tr></table></figure><p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么执行的，以及有什么参数会影响执行的行为。</p><h2 id="filesort归并排序"><a href="#filesort归并排序" class="headerlink" title="filesort归并排序"></a>filesort归并排序</h2><p>如果name字段不能使用索引排序，那么将会使用filesort</p><p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索引。</p><p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/826579b63225def812330ef6c344a303.png" alt="img"></p><p>​图1 使用explain命令查看语句的执行情况</p><p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p>为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230927101107961.png" alt="image-20230927101107961"></p><p>​图2 city字段的索引示意图</p><p>从图中可以看到，满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。</p><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>当<strong>sort_buffer_size &gt; 要排序的数据</strong>时，</p><p>这个语句执行流程如下所示 ：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p>我们暂且把这个排序过程，称为<strong>全字段排序</strong>，执行流程的示意图如下所示，下一篇文章中我们还会用到这个排序。</p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/6c821828cddf46670f9d56e126e3e772.jpg" alt="img" style="zoom:50%;"><p>​图3 全字段排序</p><p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取<strong>决于排序所需的内存和参数sort_buffer_size</strong>。</p><p>sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。<strong>如果要排序的数据量小于sort_buffer_size，排序就在内存中完成</strong>。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><blockquote><p>你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 打开optimizer_trace，只对本线程有效 */</span><br><span class="line">SET optimizer_trace=&#x27;enabled=on&#x27;; </span><br><span class="line"></span><br><span class="line">/* @a保存Innodb_rows_read的初始值 */</span><br><span class="line">select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name = &#x27;Innodb_rows_read&#x27;;</span><br><span class="line"></span><br><span class="line">/* 执行语句 */</span><br><span class="line">select city, name,age from t where city=&#x27;杭州&#x27; order by name limit 1000; </span><br><span class="line"></span><br><span class="line">/* 查看 OPTIMIZER_TRACE 输出 */</span><br><span class="line">SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"></span><br><span class="line">/* @b保存Innodb_rows_read的当前值 */</span><br><span class="line">select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = &#x27;Innodb_rows_read&#x27;;</span><br><span class="line"></span><br><span class="line">/* 计算Innodb_rows_read差值 */</span><br><span class="line">select @b-@a;</span><br></pre></td></tr></table></figure><p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/89baf99cdeefe90a22370e1d6f5e6495.png" alt="img"></p><p>​图4 全排序的OPTIMIZER_TRACE部分结果</p><ul><li>number_of_tmp_files：排序过程中使用的临时文件数<ul><li>内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件。</strong></li><li>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成</li></ul></li><li>examined_rows&#x3D;4000，表示参与排序的行数是4000行。</li><li>sort_mode 里面的packed_additional_fields的意思是，<strong>全字段排序</strong>，并在排序过程对字符串做了“紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</li><li>最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。<ul><li>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会显示为4001。这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数据从临时表取出来的时候，会让Innodb_rows_read的值加1。</li></ul></li></ul></blockquote><h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，<strong>要分成很多个临时文件，排序的性能会很差</strong>。</p><p>所以<strong>如果单行很大，这个方法效率不够好</strong>。</p><p>接下来，我来修改一个参数，让MySQL采用另外一种算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET max_length_for_sort_data = 16;</span><br></pre></td></tr></table></figure><p>max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我们再来看看计算过程有什么改变。</p><p>新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。</p><p>但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并<strong>按照id的值回到原表</strong>中取出city、name和age三个字段返回给客户端。</li></ol><p>这个执行流程的示意图如下，我把它称为rowid排序。</p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/dc92b67721171206a302eb679c83e86d.jpg" alt="img" style="zoom:50%;"><p>​图5 rowid排序</p><p>对比图3的全字段排序流程图你会发现，<strong>rowid排序多访问了一次表t的主键索引</strong>，就是步骤7。</p><p>需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><p>根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？</p><p>现在，我们就来看看结果有什么不同。</p><p>首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a这个语句的值变成5000了。</p><p>因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因此会多读1000行。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/27f164804d1a4689718291be5d10f89b.png" alt="img"></p><p>​图6 rowid排序的OPTIMIZER_TRACE部分输出</p><p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。</p><ul><li>sort_mode变成了&lt;sort_key, **rowid**&gt;，表示参与排序的只有name和id这两个字段。</li><li>number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><h3 id="全字段排序-VS-rowid排序"><a href="#全字段排序-VS-rowid排序" class="headerlink" title="全字段排序 VS rowid排序"></a>全字段排序 VS rowid排序</h3><ul><li>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li><li>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li></ul><p>这也就体现了MySQL的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p><strong>对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></p><blockquote><p>全字段排序<br>1.通过索引将所需的字段全部读取到sort_buffer中<br>2.按照排序字段进行排序<br>3.将结果集返回给客户端</p><p>缺点：<br>1.造成sort_buffer中存放不下很多数据，因为除了排序字段还存放其他字段，对sort_buffer的利用效率不高<br>2.当所需排序数据量很大时，会有很多的临时文件，排序性能也会很差</p><p>优点：MySQL认为内存足够大时会优先选择全字段排序，因为这种方式比rowid 排序避免了一次回表操作</p><p>rowid排序<br>1.通过控制排序的行数据的长度来让sort_buffer中尽可能多的存放数据，max_length_for_sort_data<br>2.只将需要排序的字段和主键读取到sort_buffer中，并按照排序字段进行排序<br>3.按照排序后的顺序，取id进行回表取出想要获取的数据<br>4.将结果集返回给客户端</p><p>优点：更好的利用内存的sort_buffer进行排序操作，尽量减少对磁盘的访问</p><p>缺点：回表的操作是随机IO，会造成大量的随机读，不一定就比全字段排序减少对磁盘的访问</p></blockquote><h2 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h2><p>其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p><p>你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢？</p><p>确实是这样的。</p><p>所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user(city, name);</span><br></pre></td></tr></table></figure><p>作为与city索引的对比，我们来看看这个索引的示意图。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230927102414680.png" alt="image-20230927102414680"></p><p>​图7 city和name联合索引示意图</p><p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。</p><p>这样整个查询过程的流程就变成了：</p><ol><li>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name)取下一个记录主键id；</li><li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li></ol><p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一下。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/fc53de303811ba3c46d344595743358a.png" alt="img"></p><p>​图9 引入(city,name)联合索引后，查询语句的执行计划</p><p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了。也就</p><p>是说，在我们这个例子里，只需要扫描1000次。</p><p>这里我们可以再稍微复习一下。<strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p><p>按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。</p><p>针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure><p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p><ol><li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li></ol><p>然后，我们再来看看explain的结果。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9e40b7b8f0e3f81126a9171cc22e3423.png" alt="img"></p><p>​图11 引入(city,name,age)联合索引后，查询语句的执行计划</p><p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p><p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where city in (&#x27;杭州&#x27;,&quot;苏州&quot;) order by name limit 100;</span><br></pre></td></tr></table></figure><p>那么，这个语句执行的时候会有排序过程吗，为什么？</p><blockquote><p>虽然有(city,name)联合索引，对于单个city内部，name是递增的。但是由于这条SQL语句不是要单独地查一个city的值，而是同时查了”杭州”和” 苏州 “两个城市，因此所有满足条件的name就不是递增的了。也就是说，<strong>这条SQL语句需要排序。</strong></p><p>那怎么避免排序呢？</p><p>这里，我们要用到(city,name)联合索引的特性，把这一条语句拆成两条语句，执行流程如下：</p><ol><li>执行select * from t where city&#x3D;“杭州” order by name limit 100; 这个语句是不需要排序的，客户端用一个长度为100的内存数组A保存结果。</li><li>执行select * from t where city&#x3D;“苏州” order by name limit 100; 用相同的方法，假设结果被存进了内存数组B。</li><li>现在A和B是两个有序数组，然后你可以用归并排序的思想，得到name最小的前100值，就是我们需要的结果了。</li></ol></blockquote><h1 id="17-orderby-2-如何正确地显示随机消息"><a href="#17-orderby-2-如何正确地显示随机消息" class="headerlink" title="17 orderby 2 如何正确地显示随机消息"></a>17 orderby 2 如何正确地显示随机消息</h1><p>这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在，如果让你来设计这个SQL语句，你会怎么写呢？</p><p>为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择3个单词，有什么方法实现，存在什么问题以及如何改进。</p><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><p>首先，你会想到用**order by rand()**来实现这个逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点复杂的。</p><p>我们先用explain命令来看看这个语句的执行情况。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>​图1 使用explain命令查看语句的执行情况</p><p>Extra字段显示<strong>Using temporary</strong>，表示的是需要使用临时表；<strong>Using filesort</strong>，表示的是需要执行排序操作。</p><p>因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。</p><p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一下上一篇文章的一个结论：<strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p>我强调了“InnoDB表”，你肯定想到了，<strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。</p><p>理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们来尝试分析一下语句的扫描行数。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li><li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li><li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li><li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li><li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li><li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li></ol><p>接下来，我们通过<strong>慢查询日志（slow log）</strong>来验证一下我们分析得到的扫描行数是否正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span><br><span class="line">SET timestamp=1541402277;</span><br><span class="line">select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p><p>这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有趣，分析对了开心，分析错了但是弄清楚了也很开心。</p><p>现在，我来把完整的排序执行流程图画出来。</p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/image-20230928180111638.png" alt="image-20230928180111638" style="zoom:50%;"><p>​图4 随机排序完整流程图1</p><p>图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章中，我们对InnoDB表排序的时候，明明用的还是ID字段。</p><p>这时候，我们就要回到一个基本概念：<strong>MySQL的表是用什么方法来定位“一行数据”的。</strong></p><p>在前面<a href="https://time.geekbang.org/column/article/69236">第4</a>和<a href="https://time.geekbang.org/column/article/69636">第5</a>篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是不是就没有主键，就没办法回表了？</p><p>其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p><p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li><li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li><li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li></ul><p>到这里，我来稍微小结一下：<strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><h2 id="磁盘临时表InnoDB"><a href="#磁盘临时表InnoDB" class="headerlink" title="磁盘临时表InnoDB"></a>磁盘临时表InnoDB</h2><blockquote><p>磁盘临时表是上一节中归并排序的两种方式，</p><p>而内存临时表内存（tmp_table_size）不足时才会别为磁盘临时表，</p><ul><li>使用内存临时表会优先选择rowid排序，因为在内存中回表消耗不大，不用读磁盘</li></ul><p>磁盘临时表是<strong>InnoDB表</strong>，有三种排序方式，一般情况下速度从快到满依次是：</p><ol><li>优先队列排序limit数据量大小 &lt; sort_buffer_size，在内存中构造大顶堆完成</li><li>全字段排序      sort_buffer_size &gt; 数据量大小，不使用磁盘文件</li><li>rowid排序      sort_buffer_size &lt; 数据量大小，使用磁盘文件，需要回表读磁盘，最慢</li></ol></blockquote><p>那么，是不是所有的临时表都是内存表呢？</p><p>其实不是的。<strong>tmp_table_size</strong>这个配置限制了内存临时表的大小，默认值是<strong>16M</strong>。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p><strong>磁盘临时表使用的引擎默认是InnoDB</strong>，是由参数internal_tmp_disk_storage_engine控制的。</p><p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。</p><p>为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set tmp_table_size=1024;</span><br><span class="line">set sort_buffer_size=32768;</span><br><span class="line">set max_length_for_sort_data=16;</span><br><span class="line">/* 打开 optimizer_trace，只对本线程有效 */</span><br><span class="line">SET optimizer_trace=&#x27;enabled=on&#x27;; </span><br><span class="line"></span><br><span class="line">/* 执行语句 */</span><br><span class="line">select word from words order by rand() limit 3;</span><br><span class="line"></span><br><span class="line">/* 查看 OPTIMIZER_TRACE 输出 */</span><br><span class="line">SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/78d2db9a4fdba81feadccf6e878b4aab.png" alt="img"></p><p>​图5 OPTIMIZER_TRACE部分结果</p><p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。</p><p>因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字段组成的行。</p><h3 id="优先队列排序"><a href="#优先队列排序" class="headerlink" title="优先队列排序"></a>优先队列排序</h3><p>这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，<strong>超过了sort_buffer_size 定义的 32768字节</strong>了。但是，number_of_tmp_files的值居然是0，难道不需要用临时文件吗？</p><p>这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，即：<strong>优先队列排序算法</strong>。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序算法，而是采用了优先队列排序算法。</p><p>其实，我们现在的SQL语句，<strong>只需要取R值最小的3个rowid</strong>。但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。</p><p>也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，想一下就明白了，这浪费了非常多的计算量。</p><p>而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p><ol><li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li></ol><p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p><ol><li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；</li><li>重复第2步，直到第10000个(R’,rowid’)完成比较。</li></ol><p>这里我简单画了一个优先队列排序过程的示意图。</p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/e9c29cb20bf9668deba8981e444f6897.png" alt="img" style="zoom: 33%;"><p>​图6 优先队列排序算法示例</p><p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个<strong>最大堆</strong>。</p><p>图5的OPTIMIZER_TRACE结果中，<strong>filesort_priority_queue_optimization这个部分的chosen&#x3D;true</strong>，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的number_of_tmp_files是0。</p><p>这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一样了。</p><p>我们再看一下上面一篇文章的SQL查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000  ;</span><br></pre></td></tr></table></figure><p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，<strong>超过了我设置的sort_buffer_size大小</strong>，所以只能使用<strong>归并排序算法</strong>。</p><h2 id="解决文章开头随机排序的方法"><a href="#解决文章开头随机排序的方法" class="headerlink" title="解决文章开头随机排序的方法"></a>解决文章开头随机排序的方法</h2><p><strong>方法1</strong></p><p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p><ol><li>取得这个表的主键id的最大值M和最小值N;</li><li>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</li><li>取不小于X的第一个ID的行。</li></ol><p>我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select max(id),min(id) into @M,@N from t ;</span><br><span class="line">set @X= floor((@M-@N+1)*rand() + @N);</span><br><span class="line">select * from t where id &gt;= @X limit 1;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p><p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id&#x3D;4的这一行的概率是取得其他行概率的两倍。</p><p>如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。</p><p>解决：</p><p>对应单词这种总量不是很多的数据，第一感觉应该装jdk缓存或者<strong>redis缓存</strong>。由于需要随机访问，数组比较好。假如一个单词平均10个字节，10*10000，不到1M就装下了。<br>如果一定要用数据库来做，老师的方案1比较好，空洞的问题，如果单词库不变，可以在上线前<strong>整理数据</strong>，把空洞处理调。比如：原来单词存在A表，新建B表 ，执行 insert into B(word) select word from A. B的id是自增的，就会生成连续的主键。当然如果A表写比较频繁，且数据量较大，业务上禁用这种写法，RR的隔离级别会锁A表</p></blockquote><p><strong>方法2</strong></p><p>所以，为了得到严格随机的结果，你可以用下面这个流程:</p><ol><li>取得整个表的行数，并记为C。</li><li>取得 Y &#x3D; floor(C * rand())。 floor函数在这里的作用，就是取整数部分。</li><li>再用limit Y,1 取得一行。</li></ol><p>我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line">set @Y = floor(@C * rand());</span><br><span class="line">set @sql = concat(&quot;select * from t limit &quot;, @Y, &quot;,1&quot;);</span><br><span class="line">prepare stmt from @sql;</span><br><span class="line">execute stmt;</span><br><span class="line">DEALLOCATE prepare stmt;</span><br></pre></td></tr></table></figure><blockquote><p>由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。</p><p>这个随机算法2，解决了算法1里面明显的概率不均匀问题。</p><p>MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，执行代价比随机算法1的代价要高。</p><p>当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。</p><p>你可能问了，如果按照这个表有10000行来计算的话，C&#x3D;10000，要是随机到比较大的Y值，那扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小很多呢？我就把这个问题留给你去课后思考吧。</p></blockquote><p><strong>方法3：即方法2取多值</strong></p><p>现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p><ol><li>取得整个表的行数，记为C；</li><li>根据相同的随机方法得到Y1、Y2、Y3；</li><li>再执行三个limit Y, 1语句得到三行数据。</li></ol><p>我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line">set @Y1 = floor(@C * rand());</span><br><span class="line">set @Y2 = floor(@C * rand());</span><br><span class="line">set @Y3 = floor(@C * rand());</span><br><span class="line">select * from t limit @Y1，1； //在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行</span><br><span class="line">select * from t limit @Y2，1；</span><br><span class="line">select * from t limit @Y3，1；</span><br></pre></td></tr></table></figure><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p><p>这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后执行下面这条SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t limit N, M-N+1;</span><br></pre></td></tr></table></figure><p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。</p><p>当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以的</p><h1 id="18-讲为什么这些SQL语句逻辑相同，性能却差异巨大"><a href="#18-讲为什么这些SQL语句逻辑相同，性能却差异巨大" class="headerlink" title="18 讲为什么这些SQL语句逻辑相同，性能却差异巨大"></a>18 讲为什么这些SQL语句逻辑相同，性能却差异巨大</h1><h1 id="（即索引失效）"><a href="#（即索引失效）" class="headerlink" title="（即索引失效）"></a>（即索引失效）</h1><h2 id="索引字段使用函数"><a href="#索引字段使用函数" class="headerlink" title="索引字段使用函数"></a>索引字段使用函数</h2><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>两张表，一张未utf8，一张为utf8mb4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /*语句Q1*/</span><br></pre></td></tr></table></figure><p>也就是说，实际上这个语句等同于下面这个写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p><p>这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>到这里，你终于明确了，字符集不同只是条件之一，<strong>连接过程中要求在被驱动表的索引字段上加函数操作</strong></p><p><strong>两种解决办法：</strong></p><ul><li>比较常见的优化方法是，把trade_detail表上的tradeid字段的<strong>字符集也改成utf8mb4</strong>，这样就没有字符集转换的问题了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</span><br></pre></td></tr></table></figure><ul><li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大，或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </span><br></pre></td></tr></table></figure><p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看到，这次索引走对了。</p><h1 id="19-讲为什么我只查一行的语句，也执行这么慢"><a href="#19-讲为什么我只查一行的语句，也执行这么慢" class="headerlink" title="19 讲为什么我只查一行的语句，也执行这么慢"></a>19 讲为什么我只查一行的语句，也执行这么慢</h1><h2 id="影响查询速度的几种情况"><a href="#影响查询速度的几种情况" class="headerlink" title="影响查询速度的几种情况"></a>影响查询速度的几种情况</h2><p>为了便于描述，我还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段id和c，并且我在里面插入了10万行记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h3><p>如图1所示，在表t执行下面的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure><p>查询结果长时间不返回。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/8707b79d5ed906950749f5266014f22a.png" alt="img"></p><p>​图1 查询长时间不返回</p><p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一下show processlist命令，看看当前语句处于什么状态。</p><p>然后我们再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。</p><h4 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h4><p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/5008d7e9e22be88a9c80916df4f4b328.png" alt="img"></p><p>​图2 Waiting for table metadata lock状态示意图</p><p>出现<strong>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</strong></p><p>这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。</p><p>但是，由于在show processlist的结果里面，session A的Command列是“Sleep”，导致查找起来很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需要设置performance_schema&#x3D;on，相比于设置为off会有10%左右的性能损失)</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select blocking_pid from sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/74fb24ba3826e3831eeeff1670990c01.png" alt="img"></p><p>​图4 查获加表锁的线程id</p><h4 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h4><p>接下来，我给你举另外一种查询被堵住的情况。</p><p>我在表t上，执行下面的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.processlist where id=1;</span><br></pre></td></tr></table></figure><p>这里，我先卖个关子。</p><p>你可以看一下图5。我查出来这个线程的状态是Waiting for table flush，你可以设想一下这是什么原因。<br><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/2d8250398bc7f8f7dce8b6b1923c3724.png" alt="img"></p><p>​图5 Waiting for table flush状态示意图</p><p>这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用法，一般有以下两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables t with read lock;</span><br><span class="line"></span><br><span class="line">flush tables with read lock;</span><br></pre></td></tr></table></figure><p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p><p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p><p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。</p><p>现在，我们一起来复现一下这种情况，<strong>复现步骤</strong>如图6所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/2bbc77cfdb118b0d9ef3fdd679d0a69c.png" alt="img"></p><p>​图6 Waiting for table flush的复现步骤</p><h4 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h4><p>现在，经过了表级锁的考验，我们的select 语句终于来到引擎里了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1 lock in share mode; </span><br></pre></td></tr></table></figure><p>上面这条语句的用法你也很熟悉了，我们在第8篇<a href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>文章介绍当前读时提到过。</p><p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p><p>复现步骤和现场如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3e68326b967701c59770612183277475.png" alt="img"></p><p>​图 8 行锁复现</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3c266e23fc307283aa94923ecbbc738f.png" alt="img"></p><p>图 9 行锁show processlist 现场</p><p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。</p><p>这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到。</p><p>查询方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t sys.innodb_lock_waits where locked_table=`&#x27;test&#x27;.&#x27;t&#x27;`\G</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/d8603aeb4eaad3326699c13c46379118.png" alt="img" style="zoom:67%;"><p>​图10 通过sys.innodb_lock_waits 查行锁</p><p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是KILL QUERY 4或KILL 4。</p><p>不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，现在执行KILL QUERY，无法让这个事务去掉id&#x3D;1上的行锁。</p><p>实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了id&#x3D;1上的行锁。</p><h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><p>经过了重重封“锁”，我们再来看看一些查询慢的例子。</p><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>先来看一条你一定知道原因的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where c=50000 limit 1;</span><br></pre></td></tr></table></figure><p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p><p>作为确认，你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接后先执行了 set long_query_time&#x3D;0，将慢查询日志的时间阈值设置为0。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d8b2b5f97c60ae4fc4a03c616847503c.png" alt="img"></p><p>​图11 全表扫描5万行的slow log</p><p>Rows_examined显示扫描了50000行。你可能会说，不是很慢呀，11.5毫秒就返回了，我们线上一般都配置超过1秒才算慢查询。但你要记住：<strong>坏查询不一定是慢查询</strong>。我们这个例子里面只有10万行记录，数据量大起来的话，执行时间就线性涨上去了。</p><p>扫描行数多，所以执行慢，这个很好理解。</p><h4 id="undo链太长"><a href="#undo链太长" class="headerlink" title="undo链太长"></a>undo链太长</h4><p>但是接下来，我们再看一个只扫描一行，但是执行很慢的语句。</p><p>如图12所示，是这个例子的slow log。可以看到，执行的语句是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1；</span><br></pre></td></tr></table></figure><p>虽然扫描行数是1，但执行时间却长达800毫秒。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/66f26bb885401e8e460451ff6b0c0746.png" alt="img"></p><p>​图12 扫描一行却执行得很慢</p><p>是不是有点奇怪呢，这些时间都花在哪里了？</p><p>如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id&#x3D;1 lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/bde83e269d9fa185b27900c8aa8137d2.png" alt="img"></p><p>​图 13 加上lock in share mode的slow log</p><p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。</p><p>可能有的同学已经有答案了。如果你还没有答案的话，我再给你一个提示信息，图14是这两个语句的执行输出结果。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/1fbb84bb392b6bfa93786fe032690b1c.png" alt="img"></p><p>​图14 两个语句的输出结果</p><p>第一个语句的查询结果里c&#x3D;1，带lock in share mode的语句返回的是c&#x3D;1000001。看到这里应该有更多的同学知道原因了。如果你还是没有头绪的话，也别着急。我先跟你说明一下复现步骤，再分析原因。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/84667a3449dc846e393142600ee7a2ff.png" alt="img"></p><p>​图15 复现步骤</p><p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p><p>session B执行完100万次update语句后，id&#x3D;1这一行处于什么状态呢？你可以从图16中找到答案。</p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)实战45讲笔记.assets/46bb9f5e27854678bfcaeaf0c3b8a98c.png" alt="img" style="zoom:50%;"><p>​图16 id&#x3D;1的数据状态</p><p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><p>注意，undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方便你看图。</p><h1 id="20-讲幻读是什么，幻读有什么问题"><a href="#20-讲幻读是什么，幻读有什么问题" class="headerlink" title="20 讲幻读是什么，幻读有什么问题"></a>20 讲幻读是什么，幻读有什么问题</h1><h2 id="非索引字段更新语句的加锁情况"><a href="#非索引字段更新语句的加锁情况" class="headerlink" title="非索引字段更新语句的加锁情况"></a>非索引字段更新语句的加锁情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。</p><p>上期我留给你的问题是，下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where d=5 for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><blockquote><p>先说结论：</p><ul><li>RC级别下，非索引字段的更新操作会对全表每一条记录加行锁</li><li>RR级别下，非索引字段的更新操作会对全表每一条记录邻间锁（记录锁+间隙锁）</li></ul></blockquote><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读指的是<strong>一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</strong></p><p>这里，我需要对“幻读”做一个说明：</p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读”下才会出现</strong><ul><li>若是快照读，MVCC机制已经解决了幻读问题</li><li>若是当前读，采用加间隙锁的方式解决幻读</li></ul></li><li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅<strong>专指“新插入的行”</strong>。</li></ol><h2 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h2><p>现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是<strong>间隙锁(Gap Lock)。</strong></p><p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230930153653250.png" alt="image-20230930153653250"></p><p>这样，当你执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p><p><strong>间隙锁之间都不存在冲突关系。</strong></p><p>这句话不太好理解，我给你举个例子：</p><p><img src="https://www.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/../../image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7c37732d936650f1cda7dbf27daf7498.png" alt="img"></p><p>​图7 间隙锁之间不互锁</p><p>这里session B并不会被堵住。因为表t里并没有c&#x3D;7这个记录，因此session A加的是间隙锁(5,10)。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]。</p><p><strong>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p><p>间隙锁容易造成<strong>死锁</strong>，且<strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong></p><blockquote><p><strong>间隙锁是在可重复读隔离级别下才会生效</strong>的。所以，你如果把隔离级别设置为<strong>读提交</strong>的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要<strong>把binlog格式设置为row</strong>。这，也是现在不少公司使用的配置组合。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(5)日志与备份篇</title>
      <link href="/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/"/>
      <url>/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>redo log 和 undo log 在事务篇之中 </p></blockquote><h1 id="第17章-其他数据库日志"><a href="#第17章-其他数据库日志" class="headerlink" title="第17章_其他数据库日志"></a>第17章_其他数据库日志</h1><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715141705004.png" alt="image-20220715141705004" style="float:left;"><p><strong>千万不要小看日志</strong>。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才 能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数 据库应用开发能力至关重要。</p><p>MySQL8.0 官网日志地址：“ <a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a> ”</p><h2 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a>1. MySQL支持的日志</h2><h3 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a>1.1 日志类型</h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 <code>二进制日志</code> 、 <code>错误日志</code> 、 <code>通用查询日志</code> 和 <code>慢查询日志</code> ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使 用这些日志文件，可以查看MySQL内部发生的事情。</p><p>这6类日志分别为：</p><ul><li><strong>慢查询日志</strong>：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。 </li><li><strong>通用查询日志</strong>：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。 </li><li><strong>错误日志</strong>：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的 状态，从而对服务器进行维护。 </li><li><strong>二进制日志</strong>：记录所有更改数据的语句，可以用于<strong>主从服务器之间的数据同步</strong>，以及服务器<strong>遇到故障</strong>时数据的无损失恢复。 </li><li><strong>中继日志</strong>：用于主从服务器架构中，从服务器用来<strong>存放主服务器二进制日志内容的一个中间文件</strong>。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。 </li><li><strong>数据定义语句日志</strong>：记录数据定义语句执行的元数据操作。</li></ul><p>除二进制日志外，其他日志都是 <code>文本文件</code> 。默认情况下，所有日志创建于 <code>MySQL数据目录</code> 中。</p><h3 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a>1.2 日志的弊端</h3><ul><li>日志功能会 <code>降低MySQL数据库的性能</code> 。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。</li><li>日志会 <code>占用大量的磁盘空间</code> 。对于用户量非常大，操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</li></ul><h2 id="2-慢查询日志-slow-query-log"><a href="#2-慢查询日志-slow-query-log" class="headerlink" title="2. 慢查询日志(slow query log)"></a>2. 慢查询日志(slow query log)</h2><p>前面章节《第09章_性能分析工具的使用》已经详细讲述。</p><h2 id="3-通用查询日志-general-query-log"><a href="#3-通用查询日志-general-query-log" class="headerlink" title="3. 通用查询日志(general query log)"></a>3. 通用查询日志(general query log)</h2><p>通用查询日志用来 <code>记录用户的所有操作</code> ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止 时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志， 还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p><h3 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a>3.1 问题场景</h3><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715145650406.png" alt="image-20220715145650406" style="float:left;"><h3 id="3-2-查看当前状态"><a href="#3-2-查看当前状态" class="headerlink" title="3.2 查看当前状态"></a>3.2 查看当前状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%general%&#x27;;</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| Variable_name    | Value                        |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| general_log      | OFF                          | #通用查询日志处于关闭状态</span><br><span class="line">| general_log_file | /var/lib/mysql/atguigu01.log | #通用查询日志文件的名称是atguigu01.log</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715155010381.png" alt="image-20220715155010381" style="float:left;"><h3 id="3-3-启动日志"><a href="#3-3-启动日志" class="headerlink" title="3.3 启动日志"></a>3.3 启动日志</h3><p><strong>方式1：永久性方式</strong></p><p>修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="string">ON</span></span><br><span class="line"><span class="attr">general_log_file</span>=<span class="string">[path[filename]] #日志文件所在目录路径，filename为日志文件</span></span><br></pre></td></tr></table></figure><p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中， hostname表示主机名。</p><p><strong>方式2：临时性方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=on; # 开启通用查询日志</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure><p>对应的，关闭操作SQL命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=off; # 关闭通用查询日志</span><br></pre></td></tr></table></figure><p>查看设置后情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="3-4-查看日志"><a href="#3-4-查看日志" class="headerlink" title="3.4 查看日志"></a>3.4 查看日志</h3><p>通用查询日志是以 <code>文本文件</code> 的形式存储在文件系统中的，可以使用 <code>文本编辑器</code> 直接打开日志文件。每台 MySQL服务器的通用查询日志内容是不同的。</p><ul><li>在Windows操作系统中，使用文本文件查看器； </li><li>在Linux系统中，可以使用vi工具或者gedit工具查看； </li><li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li></ul><p>从 <code>SHOW VARIABLES LIKE &#39;general_log%&#39;</code>; 结果中可以看到通用查询日志的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/mysqld, Version: 8.0.26 (MySQL Community Server - GPL). started with:</span><br><span class="line">Tcp port: 3306 Unix socket: /var/lib/mysql/mysql.sock</span><br><span class="line">Time Id Command Argument</span><br><span class="line">2022-01-04T07:44:58.052890Z 10 Query SHOW VARIABLES LIKE &#x27;%general%&#x27;</span><br><span class="line">2022-01-04T07:45:15.666672Z 10 Query SHOW VARIABLES LIKE &#x27;general_log%&#x27;</span><br><span class="line">2022-01-04T07:45:28.970765Z 10 Query select * from student</span><br><span class="line">2022-01-04T07:47:38.706804Z 11 Connect root@localhost on using Socket</span><br><span class="line">2022-01-04T07:47:38.707435Z 11 Query select @@version_comment limit 1</span><br><span class="line">2022-01-04T07:48:21.384886Z 12 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:21.385253Z 12 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:21.385640Z 12 Query USE `atguigu12`</span><br><span class="line">2022-01-04T07:48:21.386179Z 12 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:23.901778Z 13 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:23.902128Z 13 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:23.905179Z 13 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:23.905825Z 13 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:32.163833Z 14 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:32.164451Z 14 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:32.164840Z 14 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:40.006687Z 14 Query select * from account</span><br></pre></td></tr></table></figure><p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。</p><h3 id="3-5-停止日志"><a href="#3-5-停止日志" class="headerlink" title="3.5 停止日志"></a>3.5 停止日志</h3><p><strong>方式1：永久性方式</strong></p><p>修改 <code>my.cnf</code> 或者 <code>my.ini</code> 文件，把[mysqld]组下的 <code>general_log</code> 值设置为 <code>OFF</code> 或者把general_log一项 注释掉。修改保存后，再<code>重启MySQL服务</code> ，即可生效。 </p><p>举例1：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="string">OFF</span></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#general_log=ON</span></span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><p>使用SET语句停止MySQL通用查询日志功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=off;</span><br></pre></td></tr></table></figure><p>查询通用日志功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="3-6-删除-刷新日志"><a href="#3-6-删除-刷新日志" class="headerlink" title="3.6 删除\刷新日志"></a>3.6 删除\刷新日志</h3><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p><p><strong>手动删除文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure><p>可以看出，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志 atguigu01.log</p><p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文件。前提一定要开启通用日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure><p>如果希望备份旧的通用查询日志，就必须先将旧的日志文件复制出来或者改名，然后执行上面的mysqladmin命令。正确流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd mysql-data-directory # 输入自己的通用日志文件所在目录</span><br><span class="line">mv mysql.general.log mysql.general.log.old # 指定旧的文件名 以及 新的文件名</span><br><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure><h2 id="4-错误日志-error-log"><a href="#4-错误日志-error-log" class="headerlink" title="4. 错误日志(error log)"></a>4. 错误日志(error log)</h2><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715160249271.png" alt="image-20220715160249271" style="float:left;"><h3 id="4-1-启动日志"><a href="#4-1-启动日志" class="headerlink" title="4.1 启动日志"></a>4.1 启动日志</h3><p>在MySQL数据库中，错误日志功能是 <code>默认开启</code> 的。而且，错误日志 <code>无法被禁止</code> 。</p><p>默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 <code>mysqld.log</code> （Linux系统）或 <code>hostname.err</code> （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">log-error</span>=<span class="string">[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span></span><br></pre></td></tr></table></figure><p>修改配置项后，需要重启MySQL服务以生效。</p><h3 id="4-2-查看日志"><a href="#4-2-查看日志" class="headerlink" title="4.2 查看日志"></a>4.2 查看日志</h3><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。</p><p>查询错误日志的存储路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;log_err%&#x27;;</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| Variable_name              | Value                                  |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| log_error                  | /var/log/mysqld.log                    |</span><br><span class="line">| log_error_services         | log_filter_internal; log_sink_internal |</span><br><span class="line">| log_error_suppression_list |                                        |</span><br><span class="line">| log_error_verbosity        | 2                                      |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。</p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715160657093.png" alt="image-20220715160657093" style="float:left;"><h3 id="4-3-删除-刷新日志"><a href="#4-3-删除-刷新日志" class="headerlink" title="4.3 删除\刷新日志"></a>4.3 删除\刷新日志</h3><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除， 以保证MySQL服务器上的 <code>硬盘空间</code> 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以 <code>直接删除</code> 。</p><ul><li><p>第一步（方式1）：删除操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /var/lib/mysql/mysqld.log</span><br></pre></td></tr></table></figure><p>在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件。</p></li><li><p>第一步（方式2）：重命名文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/log/mysqld.log /var/log/mysqld.log.old</span><br></pre></td></tr></table></figure></li><li><p>第二步：重建日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure><p>可能会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@atguigu01 log]# mysqladmin -uroot -p flush-logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: &#x27;Could not open file &#x27;/var/log/mysqld.log&#x27; for</span><br><span class="line">error logging.&#x27;</span><br></pre></td></tr></table></figure><p>官网提示：</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715161132368.png" alt="image-20220715161132368"></p></li></ul><p>补充操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715161216556.png" alt="image-20220715161216556" style="float:left;"><h3 id="4-4-MySQL-8-0-新特性"><a href="#4-4-MySQL-8-0-新特性" class="headerlink" title="4.4 MySQL 8.0 新特性"></a>4.4 MySQL 8.0 新特性</h3><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715161321565.png" alt="image-20220715161321565" style="float:left;"><blockquote><p>小结：</p><p>通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p></blockquote><h2 id="5-二进制日志-bin-log"><a href="#5-二进制日志-bin-log" class="headerlink" title="5. 二进制日志(bin log)"></a>5. 二进制日志(bin log)</h2><p>binlog可以说是MySQL中比较 <code>重要</code> 的日志了，在日常开发及运维过程中，经常会遇到。</p><p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的 <code>DDL</code> 和 <code>DML</code> 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。</p><p>它以<code>事件形式</code>记录并保存在<code>二进制文件</code>中。通过这些信息，我们可以再现数据更新操作的全过程。</p><blockquote><p>如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通用查询日志。</p></blockquote><p>binlog主要应用场景：</p>  <img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715161800635.png" alt="image-20220715161800635" style="zoom:100%;"><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715161842703.png" alt="image-20220715161842703"></p><h3 id="5-1-查看默认情况"><a href="#5-1-查看默认情况" class="headerlink" title="5.1 查看默认情况"></a>5.1 查看默认情况</h3><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name                   | Value                            |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin                         | ON                               |</span><br><span class="line">| log_bin_basename                | /var/lib/mysql/binlog            |</span><br><span class="line">| log_bin_index                   | /var/lib/mysql/binlog.index      |</span><br><span class="line">| log_bin_trust_function_creators | OFF                              |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                              |</span><br><span class="line">| sql_log_bin                     | ON                               |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715163520596.png" alt="image-20220715163520596" style="float:left;"><blockquote><p>log_bin_basename：数据库每次重启都会生成一个binlog文件，或者达到最大大小后重新生成一个binlog文件（1G）</p></blockquote><h3 id="5-2-日志参数设置"><a href="#5-2-日志参数设置" class="headerlink" title="5.2 日志参数设置"></a>5.2 日志参数设置</h3><p><strong>方式1：永久性方式</strong></p><p>修改MySQL的 <code>my.cnf</code> 或 <code>my.ini</code> 文件可以设置二进制日志的相关参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">atguigu-bin</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">600</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">100M</span></span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715163811664.png" alt="image-20220715163811664" style="float:left;"><p>重新启动MySQL服务，查询二进制日志的信息，执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name                   | Value                            |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin                         | ON                               |</span><br><span class="line">| log_bin_basename                | /var/lib/mysql/atguigu-bin       |</span><br><span class="line">| log_bin_index                   | /var/lib/mysql/atguigu-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                              |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                              |</span><br><span class="line">| sql_log_bin                     | ON                               |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span></span><br></pre></td></tr></table></figure><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R -v mysql:mysql binlog</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715164107352.png" alt="image-20220715164107352" style="float:left;"><p><strong>方式2：临时性方式</strong></p><p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是 在mysql8中只有 <code>会话级别</code> 的设置，没有了global级别的设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># global 级别</span><br><span class="line">mysql&gt; set global sql_log_bin=0;</span><br><span class="line">ERROR 1228 (HY000): Variable &#x27;sql_log_bin&#x27; is a SESSION variable and can`t be used</span><br><span class="line">with SET GLOBAL</span><br><span class="line"></span><br><span class="line"># session级别</span><br><span class="line">mysql&gt; SET sql_log_bin=0;</span><br><span class="line">Query OK, 0 rows affected (0.01 秒)</span><br></pre></td></tr></table></figure><h3 id="5-3-查看日志"><a href="#5-3-查看日志" class="headerlink" title="5.3 查看日志"></a>5.3 查看日志</h3><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。</p><p>MySQL服务 <code>重新启动一次</code> ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同；如果日志长度超过了 <code>max_binlog_size</code> 的上限（默认是1GB），就会创建一个新的日志文件。</p><p>查看当前的二进制日志文件列表及大小。指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW BINARY LOGS;</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| Log_name           | File_size | Encrypted |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| atguigu-bin.000001 | 156       | No        |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">1 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure><p>所有对数据库的修改都会记录在binlog中。但binlog是二进制文件，无法直接查看，想要更直观的观测它就要借助<code>mysqlbinlog</code>命令工具了。指令如下：在查看执行，先执行一条SQL语句，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update student set name=&#x27;张三_back&#x27; where id=1;</span><br></pre></td></tr></table></figure><h4 id="方式一：mysqlbinlog"><a href="#方式一：mysqlbinlog" class="headerlink" title="方式一：mysqlbinlog"></a>方式一：mysqlbinlog</h4><p>开始查看binlog</p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715164718970.png" alt="image-20220715164718970" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715164743351.png" alt="image-20220715164743351" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715164809401.png" alt="image-20220715164809401" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -v &quot;/var/lib/mysql/binlog.000003&quot;</span><br><span class="line"></span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 324 CRC32 0x6b31978b Query thread_id=10</span><br><span class="line">exec_time=0 error_code=0</span><br><span class="line">SET TIMESTAMP=1641345397/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=10/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0,</span><br><span class="line">@@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1168113696/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C utf8mb3 *//*!*/;</span><br><span class="line">SET</span><br><span class="line">@@session.character_set_client=33,@@session.collation_connection=33,@@session.collatio</span><br><span class="line">n_server=255/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 324</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 391 CRC32 0x74f89890 Table_map:</span><br><span class="line">`atguigu14`.`student` mapped to number 85</span><br><span class="line"># at 391</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 470 CRC32 0xc9920491 Update_rows: table id</span><br><span class="line">85 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">dfHUYRMBAAAAQwAAAIcBAAAAAFUAAAAAAAEACWF0Z3VpZ3UxNAAHc3R1ZGVudAADAw8PBDwAHgAG</span><br><span class="line">AQEAAgEhkJj4dA==</span><br><span class="line">dfHUYR8BAAAATwAAANYBAAAAAFUAAAAAAAEAAgAD//8AAQAAAAblvKDkuIkG5LiA54+tAAEAAAAL</span><br><span class="line">5byg5LiJX2JhY2sG5LiA54+tkQSSyQ==</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line">### UPDATE `atguigu`.`student`</span><br><span class="line">### WHERE</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line">### SET</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三_back&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line"># at 470</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 501 CRC32 0xca01d30f Xid = 15</span><br><span class="line">COMMIT/*!*/;</span><br></pre></td></tr></table></figure><p>前面的命令同时显示 binlog格式 语句，使用如下命令不显示它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -v --base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog.000003&quot;</span><br><span class="line"></span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 324 CRC32 0x6b31978b Query thread_id=10</span><br><span class="line">exec_time=0 error_code=0</span><br><span class="line">SET TIMESTAMP=1641345397/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=10/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0,</span><br><span class="line">@@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1168113696/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C utf8mb3 *//*!*/;</span><br><span class="line">SET</span><br><span class="line">@@session.character_set_client=33,@@session.collation_connection=33,@@session.collatio</span><br><span class="line">n_server=255/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 324</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 391 CRC32 0x74f89890 Table_map:</span><br><span class="line">`atguigu14`.`student` mapped to number 85</span><br><span class="line"># at 391</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 470 CRC32 0xc9920491 Update_rows: table id</span><br><span class="line">85 flags: STMT_END_F</span><br><span class="line">### UPDATE `atguigu14`.`student`</span><br><span class="line">### WHERE</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line">### SET</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三_back&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line"># at 470</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 501 CRC32 0xca01d30f Xid = 15</span><br></pre></td></tr></table></figure><p>关于<strong>mysqlbinlog</strong>工具的使用技巧还有很多，例如只解析对某个库的操作或者某个时间段内的操作等。简单分享几个常用的语句，更多操作可以参考官方文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 可查看参数帮助</span><br><span class="line">mysqlbinlog --no-defaults --help</span><br><span class="line"># 查看最后100行</span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv &quot;/var/lib/mysql/binlog.000003&quot; |tail -100</span><br><span class="line"># 根据position查找</span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv &quot;/var/lib/mysql/binlog.000003&quot; |grep -A</span><br><span class="line">20 &#x27;4939002&#x27;</span><br></pre></td></tr></table></figure><h4 id="方式二：show-binlog-events"><a href="#方式二：show-binlog-events" class="headerlink" title="方式二：show binlog events"></a>方式二：show binlog events</h4><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];</span><br></pre></td></tr></table></figure><ul><li><code>IN &#39;log_name&#39;</code> ：指定要查询的binlog文件名（不指定就是第一个binlog文件）　 </li><li><code>FROM pos</code> ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算） </li><li><code>LIMIT [offset]</code> ：偏移量(不指定就是0) </li><li><code>row_count</code> :查询总条数（不指定就是所有行）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;atguigu-bin.000002&#x27;;</span><br><span class="line"></span><br><span class="line">+--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span><br><span class="line">| Log_name           | Pos | Event_type     | Server_id | End_log_pos | Info                                                   |</span><br><span class="line">+--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span><br><span class="line">| atguigu-bin.000002 | 4   | Format_desc    | 1         | 125         | Server ver: 8.0.26, Binlog ver: 4                      |</span><br><span class="line">| atguigu-bin.000002 | 125 | Previous_gtids | 1         | 156         |                                                        |</span><br><span class="line">| atguigu-bin.000002 | 156 | Anonymous_Gtid | 1         | 235         | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;                   |</span><br><span class="line">| atguigu-bin.000002 | 235 | Query          | 1         | 324         | BEGIN                                                  |</span><br><span class="line">| atguigu-bin.000002 | 324 | Table_map      | 1         | 391         | table_id: 85(atguigu14.student)                        |</span><br><span class="line">| atguigu-bin.000002 | 391 | Update_rows    | 1         | 470         | table_id: 85flags: STMT_END_F                          |</span><br><span class="line">| atguigu-bin.000002 | 470 | Xid            | 1         | 501         | COMMIT /*xid=15 */                                     |</span><br><span class="line">| atguigu-bin.000002 | 501 | Anonymous_Gtid | 1         | 578         | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;                   |</span><br><span class="line">| atguigu-bin.000002 | 578 | Query     | 1 | 721 | use `atguigu14`; create table test(id int, title varchar(100)) /* xid=19 */ |</span><br><span class="line">| atguigu-bin.000002 | 721 | Anonymous_Gtid | 1         | 800         | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;                   |</span><br><span class="line">| atguigu-bin.000002 | 800 | Query          | 1         | 880         | BEGIN                                                  |</span><br><span class="line">| atguigu-bin.000002 | 880 | Table_map      | 1         | 943         | table_id: 89(atguigu14.test)                           |</span><br><span class="line">| atguigu-bin.000002 | 943 | Write_rows     | 1         | 992         | table_id: 89 flags: STMT_END_F                         |</span><br><span class="line">| atguigu-bin.000002 | 992 | Xid            | 1         | 1023        | COMMIT /*xid=21 */                                     |</span><br><span class="line">+--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span><br><span class="line">14 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715165603879.png" alt="image-20220715165603879" style="float:left;"><h4 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h4><p>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;binlog_format&#x27;;</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| Variable_name | Value     |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| binlog_format | STATEMENT |</span><br><span class="line">+---------------+-----------+</span><br></pre></td></tr></table></figure><p>除此之外，binlog还有2种格式，分别是<code>Statement</code>和<code>Mixed</code></p><ul><li><p><strong>Statement</strong>（基于SQL语句的复制(statement-based replication, <strong>SBR</strong>)）（默认）</p><p>每一条会修改数据的sql都会记录在binlog中。</p><p>优点：</p><ul><li>不需要记录每一行的变化，<strong>减少了binlog日志量，节约了IO，减少某些sql语句行锁的数量，提高性能</strong>。</li></ul><p>缺点：</p><ul><li>当sql语句含有存储过程、函数和事件的时候，将会造成数据不一致问题，</li><li>需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 ROW 请求更多的<strong>行级锁</strong></li></ul></li><li><p><strong>Row</strong>（基于行的复制(row-based replication, <strong>RBR</strong>)）</p><p>5.1.5版本的MySQL才开始支持row level 的复制，它<strong>不记录sql</strong>语句上下文相关信息，<strong>仅保存哪条记录被修改为什么</strong>。</p><p>优点：</p><ul><li>row level 的日志内容会非常清楚的记录下每一行数据修改的细节。</li><li>而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</li><li>以下几种语句时的<strong>行锁</strong>更少：<strong>INSERT … SELECT</strong>、<strong>包含 AUTO_INCREMENT 字段的 INSERT</strong>、 <strong>没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</strong></li></ul><p>缺点：</p><ul><li>binlog 大了很多 </li><li>复杂的回滚时 binlog 中会包含大量的数据 </li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题 </li><li>无法看到具体的sql</li></ul></li><li><p><strong>Mixed</strong></p><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p><p>详细情况，下章讲解。</p></li></ul><blockquote><p>binlog格式还有在18章 3.2 中有讲+</p></blockquote><h3 id="5-4-使用日志恢复数据"><a href="#5-4-使用日志恢复数据" class="headerlink" title="5.4 使用日志恢复数据"></a>5.4 使用日志恢复数据</h3><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中回复数据。</p><p>mysqlbinlog恢复数据的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename | mysql –uuser -ppass;</span><br></pre></td></tr></table></figure><p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p><ul><li><p><code>filename</code> ：是日志文件名。</p></li><li><p><code>option</code> ：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。</p><ul><li><code>--start-date</code> 和<code> --stop-date</code> ：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position</code>和<code>--stop-position</code> ：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><p><strong>方式1</strong>：使用命令show binlog查看position恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush logs</span><br></pre></td></tr></table></figure><blockquote><p>先新建一个binlog文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show binlog events in &#x27;binlog.000003&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>自己的binlog文件，查询binlog：show binary logs;</p></blockquote><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20230918192713714.png" alt="image-20230918192713714"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysqlbinlog --start-position=2247 --stop-position=3226 --database=atguigudb3 /var/lib/mysql/binlog.000003 | /usr/bin/mysql -uroot -p123456 -v atguigudb3</span><br></pre></td></tr></table></figure><blockquote><p>换为自己的position区间</p></blockquote><p><strong>方式2</strong>：使用命令mysqlbinlog查看时间戳恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush logs</span><br></pre></td></tr></table></figure><blockquote><p>先新建一个binlog文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv &quot;/var/lib/mysql/binlog.000003&quot; | tail -300</span><br></pre></td></tr></table></figure><blockquote><p>改为自己的filename和想要的tail数据量</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysqlbinlog --start-datetime=&quot;2023-09-16 14:57:38&quot; --stop-datetime=&quot;2023-09-16 14:58:39&quot; --database=atguigudb3 /var/lib/mysql/binlog.000003 | /usr/bin/mysql -uroot -p123456 -v atguigudb3</span><br></pre></td></tr></table></figure><blockquote><p>–start-datetime和–stop-datetime改为自己的时间，还有数据库选择，binlog文件选择</p></blockquote><p><strong>附录：</strong>mysqlbinlog查询结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 854467540</span><br><span class="line">#230916 14:57:38 server id 1  end_log_pos 854467621 CRC32 0xa73fc810 Querythread_id=58exec_time=0error_code=0</span><br><span class="line">SET TIMESTAMP=1694847458/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 854467621</span><br><span class="line">#230916 14:57:38 server id 1  end_log_pos 854467689 CRC32 0x40bb9b80 Table_map: `atguigudb3`.`student` mapped to number 195</span><br><span class="line"># at 854467689</span><br><span class="line">#230916 14:57:38 server id 1  end_log_pos 854467737 CRC32 0x9c284b28 Write_rows: table id 195 flags: STMT_END_F</span><br><span class="line">### INSERT INTO `atguigudb3`.`student`</span><br><span class="line">### SET</span><br><span class="line">###   @1=21 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&#x27;AA&#x27; /* VARSTRING(60) meta=60 nullable=1 is_null=0 */</span><br><span class="line">###   @3=&#x27;NO.1&#x27; /* VARSTRING(30) meta=30 nullable=1 is_null=0 */</span><br><span class="line"># at 854467737</span><br><span class="line">#230916 14:57:38 server id 1  end_log_pos 854467768 CRC32 0xf3dd9041 Xid = 218189253</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 854467768</span><br><span class="line">#230916 14:57:41 server id 1  end_log_pos 854467847 CRC32 0xee13b4b4 Anonymous_GTIDlast_committed=180sequence_number=181rbr_only=yesoriginal_committed_timestamp=1694847461607270immediate_commit_timestamp=1694847461607270transaction_length=307</span><br><span class="line">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class="line"># original_commit_timestamp=1694847461607270 (2023-09-16 14:57:41.607270 CST)</span><br><span class="line"># immediate_commit_timestamp=1694847461607270 (2023-09-16 14:57:41.607270 CST)</span><br><span class="line">/*!80001 SET @@session.original_commit_timestamp=1694847461607270*//*!*/;</span><br><span class="line">/*!80014 SET @@session.original_server_version=80025*//*!*/;</span><br><span class="line">/*!80014 SET @@session.immediate_server_version=80025*//*!*/;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 854468768</span><br><span class="line">#230916 14:58:22 server id 1  end_log_pos 854468858 CRC32 0xaabd71e2 Querythread_id=58exec_time=0error_code=0</span><br><span class="line">SET TIMESTAMP=1694847502/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 854468858</span><br><span class="line">#230916 14:58:22 server id 1  end_log_pos 854468926 CRC32 0xc3ba182a Table_map: `atguigudb3`.`student` mapped to number 195</span><br><span class="line"># at 854468926</span><br><span class="line">#230916 14:58:22 server id 1  end_log_pos 854468988 CRC32 0x0bb221f5 Update_rows: table id 195 flags: STMT_END_F</span><br><span class="line">### UPDATE `atguigudb3`.`student`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=22 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&#x27;AA&#x27; /* VARSTRING(60) meta=60 nullable=1 is_null=0 */</span><br><span class="line">###   @3=&#x27;NO.1&#x27; /* VARSTRING(30) meta=30 nullable=1 is_null=0 */</span><br><span class="line">### SET</span><br><span class="line">###   @1=22 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&#x27;BB&#x27; /* VARSTRING(60) meta=60 nullable=1 is_null=0 */</span><br><span class="line">###   @3=&#x27;NO.1&#x27; /* VARSTRING(30) meta=30 nullable=1 is_null=0 */</span><br><span class="line"># at 854468988</span><br><span class="line">#230916 14:58:22 server id 1  end_log_pos 854469019 CRC32 0x0d3c4273 Xid = 218189258</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 854469019</span><br><span class="line">#230916 14:58:39 server id 1  end_log_pos 854469098 CRC32 0x3ddd90bd Anonymous_GTIDlast_committed=184sequence_number=185rbr_only=yesoriginal_committed_timestamp=1694847519315715immediate_commit_timestamp=1694847519315715transaction_length=320</span><br><span class="line">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class="line"># original_commit_timestamp=1694847519315715 (2023-09-16 14:58:39.315715 CST)</span><br><span class="line"># immediate_commit_timestamp=1694847519315715 (2023-09-16 14:58:39.315715 CST)</span><br><span class="line">/*!80001 SET @@session.original_commit_timestamp=1694847519315715*//*!*/;</span><br><span class="line">/*!80014 SET @@session.original_server_version=80025*//*!*/;</span><br><span class="line">/*!80014 SET @@session.immediate_server_version=80025*//*!*/;</span><br></pre></td></tr></table></figure><h3 id="5-5-删除二进制日志"><a href="#5-5-删除二进制日志" class="headerlink" title="5.5 删除二进制日志"></a>5.5 删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。 <code>PURGE MASTER LOGS</code> 只删除指定部分的二进制日志文件， <code>RESET MASTER</code> 删除所有的二进制日志文 件。具体如下：</p><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p><p>PURGE MASTER LOGS语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’</span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715171712026.png" alt="image-20220715171712026" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715172015185.png" alt="image-20220715172015185" style="float:left;"><p><strong>2. RESET MASTER: 删除所有二进制日志文件</strong></p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715172104967.png" alt="image-20220715172104967" style="float:left;"><h3 id="5-6-其它场景"><a href="#5-6-其它场景" class="headerlink" title="5.6 其它场景"></a>5.6 其它场景</h3><p>二进制日志可以通过数据库的 <code>全量备份</code> 和二进制日志中保存的 <code>增量信息</code> ，完成数据库的 <code>无损失恢复</code> 。 但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p><p>在这种情况下，一个有效的解决办法是 <code>配置主从数据库服务器</code> ，甚至是 <code>一主多从</code> 的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。</p><h2 id="6-再谈二进制日志-binlog"><a href="#6-再谈二进制日志-binlog" class="headerlink" title="6. 再谈二进制日志(binlog)"></a>6. 再谈二进制日志(binlog)</h2><h3 id="6-1-写入机制"><a href="#6-1-写入机制" class="headerlink" title="6.1 写入机制"></a>6.1 写入机制</h3><p>binlog的写入时机也非常简单，<strong>事务执行过程中，先把日志写到 <code>binlog cache</code> ，事务提交的时候，再把binlog cache写到binlog文件中</strong>。因为一个事务的binlog不能被拆开，<strong>无论这个事务多大，也要确保一次性写入</strong>，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。binlog日志刷盘流程如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715172958729.png" alt="image-20220715172958729"></p><blockquote><ul><li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快</li><li>上图的fsync，才是将数据持久化到磁盘的操作</li></ul></blockquote><p>write和fsync的时机，可以由参数 <code>sync_binlog</code> 控制，默认是 <code>1</code> 。</p><p>为<strong>0</strong>的时候，表示<strong>每次提交事务都只 write，由系统自行判断什么时候执行fsync</strong>（相当于redo log的参数为<strong>2</strong>的情况）。虽然性能得到提升，但是机器宕机，page cache里面的 binglog 会丢失。如下图：</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715193749462.png" alt="image-20220715193749462"></p><p>为了安全起见，可以设置为默认值 <code>1</code> ，表示每次<strong>提交事务都会执行fsync</strong>，就如同<strong>redo log 默认刷盘流程</strong>一样（redo log参数为1时）。 最后还有一种折中方式，可以<strong>设置为N(N&gt;1)<strong>，表示每次提交事务都write，但</strong>累积N个事务后才fsync</strong>。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715194624080.png" alt="image-20220715194624080"></p><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h3 id="6-2-binlog与redolog对比"><a href="#6-2-binlog与redolog对比" class="headerlink" title="6.2 binlog与redolog对比"></a>6.2 binlog与redolog对比</h3><ul><li>redo log 它是 <code>物理日志</code> ，记录内容是“在某个数据页上做了什么修改”，属于 <strong>InnoDB 存储引擎层</strong>产生的。</li><li>而 binlog 是 <code>逻辑日志</code> ，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于 <strong>MySQL Server 层</strong>。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。<ul><li>redo log让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性。</li></ul></li></ul><h3 id="6-3-两阶段提交"><a href="#6-3-两阶段提交" class="headerlink" title="6.3 两阶段提交"></a>6.3 两阶段提交</h3><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，<strong>redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入</strong>，所以redo log与binlog的 <code>写入时机</code> 不一样。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715194959405.png" alt="image-20220715194959405"></p><p><strong>redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？</strong></p><p>以update语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段c值更新为<code>1</code>，SQL语句为update T set c &#x3D; 1 where id &#x3D; 2。</p><p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715195016492.png" alt="image-20220715195016492"></p><p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后<strong>从库</strong>用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值为0，而<strong>原库</strong>因为redo log日志恢复，这一行c的值是1，最终<strong>数据不一致</strong>。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715195521986.png" alt="image-20220715195521986"></p><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。原理很简单，将<code>redo log的写入拆成了两个步骤</code>prepare和commit，这就是<strong>两阶段提交</strong>。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715195635196.png" alt="image-20220715195635196"></p><p>使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715200248193.png" alt="image-20220715200248193" style="zoom:150%;"><p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715200321717.png" alt="image-20220715200321717" style="zoom:150%;"><p><strong>并不会回滚事务</strong>，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是<strong>能通过事务id找到对应的binlog日志</strong>，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h2 id="7-中继日志-relay-log"><a href="#7-中继日志-relay-log" class="headerlink" title="7. 中继日志(relay log)"></a>7. 中继日志(relay log)</h2><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入 <code>本地的日志文件</code> 中，这个从服务器本地的日志文件就叫 <code>中继日志</code> 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主 从服务器的 数据同步 。</p><p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p><p>文件名的格式是：<code> 从服务器名 -relay-bin.序号</code> 。中继日志还有一个索引文件：<code>从服务器名 -relaybin.index</code> ，用来定位当前正在使用的中继日志。</p><h3 id="7-2-查看中继日志"><a href="#7-2-查看中继日志" class="headerlink" title="7.2 查看中继日志"></a>7.2 查看中继日志</h3><p>中继日志与二进制日志的格式相同，可以用 <code>mysqlbinlog</code> 工具进行查看。下面是中继日志的一个片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SET TIMESTAMP=1618558728/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 950</span><br><span class="line">#210416 15:38:48 server id 1 end_log_pos 832 CRC32 0xcc16d651 Table_map:</span><br><span class="line">`atguigu`.`test` mapped to number 91</span><br><span class="line"># at 1000</span><br><span class="line">#210416 15:38:48 server id 1 end_log_pos 872 CRC32 0x07e4047c Delete_rows: table id</span><br><span class="line">91 flags: STMT_END_F -- server id 1 是主服务器，意思是主服务器删了一行数据</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span><br><span class="line">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 1040</span><br></pre></td></tr></table></figure><p>这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定位到表 atguigu.test 编号是 91 的记录，日志位置是 832；</span><br><span class="line">删除编号是 91 的记录，日志位置是 872</span><br></pre></td></tr></table></figure><h3 id="7-3-恢复的典型错误"><a href="#7-3-恢复的典型错误" class="headerlink" title="7.3 恢复的典型错误"></a>7.3 恢复的典型错误</h3><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的 <code>服务器名称</code> 与之前 <code>不同</code> 。而中继日志里是 <code>包含从服务器名</code> 的。在这种情况下，就可能导致你恢复从服务器的时候，无法 从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p><h2 id="附录：日志文件总结"><a href="#附录：日志文件总结" class="headerlink" title="附录：日志文件总结"></a>附录：日志文件总结</h2><table><thead><tr><th>日志</th><th align="left">def</th><th>参数查询</th><th>重要参数大小(默认,限制)</th><th>相关命令</th></tr></thead><tbody><tr><td>redo</td><td align="left">on</td><td>%innodb_log%</td><td>redo log buffer(16M,[1M,4096M])<br>redo log block(512B)<br>innodb_log_files_in_group(2,&lt;&#x3D;100)<br>innodb_log_file_size(48M,&lt;&#x3D;512G)<br><strong>innodb_flush_log_at_trx_commit(1,[0,2])</strong></td><td></td></tr><tr><td>undo</td><td align="left">on</td><td>%innodb_undo%</td><td>innodb_rollback_segments(128)<br>innodb_undo_tablespaces(2)</td><td></td></tr><tr><td>gener</td><td align="left">off</td><td>%general%</td><td></td><td></td></tr><tr><td>error</td><td align="left">on</td><td>%log_error%</td><td></td><td></td></tr><tr><td>slow</td><td align="left">off</td><td>%slow_quer%<br>%long_quer%</td><td>long_query_time(10s)</td><td>mysqldumpslow</td></tr><tr><td>bin</td><td align="left">on</td><td>%log_bin%<br>%binlog%</td><td>binlog_expire_logs_seconds(2592000即30天)<br>binlog_cache_size(32KB)<br>max_binlog_size(1G,&lt;&#x3D;1G)<br>log_bin_trust_function_creators(OFF)<br><strong>sync_binlog(1,[0,N])</strong></td><td>mysqlbinlog<br>show binlog events<br>show binary logs</td></tr><tr><td>relay</td><td align="left">on</td><td>%relay_log%</td><td></td><td>mysqlbinlog</td></tr></tbody></table><h2 id="附录：命令总结"><a href="#附录：命令总结" class="headerlink" title="附录：命令总结"></a>附录：命令总结</h2><table><thead><tr><th>命令类别</th><th></th></tr></thead><tbody><tr><td>show</td><td>show status like<br>show table status like<br>show create table<br>show variables like<br>show open tables<br>show profilings<br>show profiles<br>show profile for query<br>show processlist<br>show engines<br>show binlog events<br>show binary logs<br>show master status<br>show slavef status<br>show index from</td></tr><tr><td>mysql开头</td><td>mysqldumpslow<br>mysqlbinlog<br>mysql<br>mysqldump(备份)</td></tr><tr><td>刷新日志</td><td>命令行: mysqladmin -uroot -p flush-logs<br>flush logs</td></tr><tr><td>锁监控</td><td>show status like ‘innodb_row_lock%’;<br>查询正在被锁阻塞的sql语句：SELECT * FROM information_schema.INNODB_TRX\G;<br>查询阻塞锁情况：SELECT * FROM performance_schema.data_lock_waits\G;<br>查询所有锁的情况：SELECT * from performance_schema.data_locks\G;</td></tr><tr><td>索引</td><td>《索引篇》9. MySQL监控分析视图-sys schema<br>trace命令 默认关闭<br>explain<br>slow log慢查询日志</td></tr><tr><td>事务</td><td>查询大于60s的长事务：select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</td></tr></tbody></table><h1 id="第18章-主从复制"><a href="#第18章-主从复制" class="headerlink" title="第18章_主从复制"></a>第18章_主从复制</h1><h2 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1. 主从复制概述"></a>1. 主从复制概述</h2><h3 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a>1.1 如何提升数据库并发能力</h3><p>在实际工作中，我们常常将<code>Redis</code>作为缓存与<code>MySQL</code>配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就<code>提升了读取的效率</code>，也减少了对后端数据库的<code>访问压力</code>。Redis的缓存架构是<code>高并发架构</code>中非常重要的一环。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715202237535.png" alt="image-20220715202237535"></p><p>此外，一般应用对数据库而言都是“ <code>读多写少</code> ”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做 <code>主从架构</code> 、进行 <code>读写分离</code> ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何 <code>优化SQL和索引</code> ，这种方式 简单有效；其次才是采用 <code>缓存的策略</code> ，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用 <code>主从架构</code> ，进行读写分离。</p><p>按照上面的方式进行优化，使用和维护的成本是由低到高的。</p><h3 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a>1.2 主从复制的作用</h3><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。</p><p><strong>第1个作用：读写分离。</strong>我们可以通过主从复制的方式来<code>同步数据</code>，然后通过读写分离提高数据库并发处理能力。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715212521601.png" alt="image-20220715212521601"></p><p>其中一个是Master主库，负责写入数据，我们称之为：写库。</p><p>其他都是Slave从库，负责读取数据，我们称之为：读库。</p><p>当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库进行读取。</p><p>面对“读多写少”的需求，采用读写分离的方式，可以实现<code>更高的并发访问</code>。同时，我们还能对从服务器进行<code>负载均衡</code>，让不同的读请求按照策略均匀地分发到不同的从服务器上，让<code>读取更加顺畅</code>。读取顺畅的另一个原因，就是<code>减少了锁表</code>的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p><p><strong>第2个作用就是数据备份。</strong>我们通过主从复制将主库上的数据复制到从库上，相当于一种<code>热备份机制</code>，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p><p><strong>第3个作用是具有高可用性。</strong>数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当主服务器出现故障或宕机的情况下，可以切换到从服务器上（分为从机和备机，从机负责读，备机负责主机宕机后的写，这里指的是备机），保证服务的正常运行。</p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220715214055057.png" alt="image-20220715214055057" style="float:left;"><h2 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2. 主从复制的原理"></a>2. 主从复制的原理</h2><p><code>Slave</code> 会从 <code>Master</code> 读取 <code>binlog</code> 来进行数据同步。</p><h3 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a>2.1 原理剖析</h3><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 <code>3 个线程</code> 来操 作，一个主库线程，两个从库线程。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715215944767.png" alt="image-20220715215944767"></p><p><code>二进制日志转储线程</code> （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进 制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 <code>加锁</code> ，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程</code> 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code> 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715220037213.png" alt="image-20220715220037213"></p><blockquote><p>注意：</p><p>不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。</p><p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p></blockquote><p><strong>复制三步骤</strong></p><p>步骤1： <code>Master</code> 将写操作记录到二进制日志（ <code>binlog</code> ）。</p><p>步骤2： <code>Slave</code> 将 <code>Master</code> 的binary log events拷贝到它的中继日志（ <code>relay log</code> ）；</p><p>步骤3： <code>Slave</code> 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从 <code>接入点</code> 开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题： <code>延时</code></p><h3 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a>2.2 复制的基本原则</h3><ul><li>每个 <code>Slave</code> 只有一个 <code>Master</code></li><li>每个 <code>Slave</code> 只能有一个唯一的服务器ID</li><li>每个 <code>Master</code> 可以有多个 <code>Slave</code></li></ul><h2 id="3-一主一从架构搭建"><a href="#3-一主一从架构搭建" class="headerlink" title="3. 一主一从架构搭建"></a>3. 一主一从架构搭建</h2><p>一台 <code>主机</code> 用于处理所有 <code>写请求</code> ，一台 <code>从机</code> 负责所有 <code>读请求</code> ，架构图如下:</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220715220852836.png" alt="image-20220715220852836"></p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><p>1、准备 2台 CentOS 虚拟机 （具体设置内容在P192）</p><p>2、每台虚拟机上需要安装好MySQL (可以是MySQL8.0 )</p><p>说明：前面我们讲过如何克隆一台CentOS。大家可以在一台CentOS上安装好MySQL，进而通过克隆的方式复制出1台包含MySQL的虚拟机。</p><p>注意：克隆的方式需要修改新克隆出来主机的：① <code>MAC地址</code> ② <code>hostname</code> ③<code> IP 地址</code> ④ <code>UUID</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p>此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如： <code>show slave status\G</code> ，报如下的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have</span><br><span class="line">equal MySQL server UUIDs; these UUIDs must be different for replication to work.</span><br></pre></td></tr></table></figure><p>修改MySQL Server 的UUID方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/mysql/auto.cnf</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="3-2-主机配置文件"><a href="#3-2-主机配置文件" class="headerlink" title="3.2 主机配置文件"></a>3.2 主机配置文件</h3><p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在 <code>[mysqld]</code> 节点下，且都是小写字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p>具体参数配置如下：</p><ul><li>必选</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]主服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">atguigu-bin</span></span><br></pre></td></tr></table></figure><ul><li>可选</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置日志文件保留的时长，单位是秒</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">6000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">200M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置不要复制的数据库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">需要复制的主数据库名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置binlog格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br></pre></td></tr></table></figure><p>重启后台mysql服务，使配置生效。</p><blockquote><p>注意：</p><p><strong>先搭建完主从复制，再创建数据库。</strong></p><p>MySQL<strong>主从复制起始时，从机不继承主机数据</strong>。</p></blockquote><p><strong>① binlog格式设置：</strong></p><p>格式1： <code>STATEMENT模式 </code>默认格式 （基于SQL语句的复制(statement-based replication, SBR)）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br></pre></td></tr></table></figure><p>每一条会修改数据的<code>sql</code>语句会记录到binlog中。这是默认的binlog格式。</p><ul><li>SBR 的优点：<ul><li>历史悠久，技术成熟 </li><li>不需要记录每一行的变化，减少了binlog日志量，文件较小 </li><li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况 </li><li>binlog可以用于实时的还原，而不仅仅用于复制 </li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li></ul></li><li>SBR 的缺点：<ul><li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li></ul></li><li>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)<ul><li>INSERT … SELECT 会产生比 RBR 更多的行级锁 </li><li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁 </li><li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句 </li><li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响 </li><li>执行复杂语句如果出错的话，会消耗更多资源</li><li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li></ul></li></ul><p><strong>② ROW模式（基于行的复制(row-based replication, RBR)）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">ROW</span></span><br></pre></td></tr></table></figure><p>5.1.5版本的MySQL才开始支持，不记录每条sql语句的上下文信息，仅<code>记录哪条数据被修改了，修改成什么样了</code>。</p><ul><li>RBR 的优点：<ul><li>任何情况都可以被复制，这对复制来说是最 <code>安全可靠</code> 的。（比如：<strong>不会出现某些特定情况下的存储过程、function、trigger的调用和触发无法被正确复制的问题</strong>） </li><li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多 </li><li>复制以下几种语句时的行锁更少：INSERT … SELECT、包含 AUTO_INCREMENT 字段的 INSERT、 没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句 </li><li>执行 INSERT，UPDATE，DELETE 语句时锁更少 </li><li>从服务器上采用 多线程 来执行复制成为可能</li></ul></li><li>RBR 的缺点：<ul><li>binlog 大了很多 </li><li>复杂的回滚时 binlog 中会包含大量的数据 </li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题 </li><li>无法从 binlog 中看到都复制了些什么语句</li></ul></li></ul><blockquote><p>若设置为statement，3.6测试中sql使用变量导致数据不一致，若是使用row，记录的将是值，不会不一致</p></blockquote><p><strong>③ MIXED模式（混合模式复制(mixed-based replication, MBR)）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">MIXED</span></span><br></pre></td></tr></table></figure><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p><p>在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。</p><p>MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h3 id="3-3-从机配置文件"><a href="#3-3-从机配置文件" class="headerlink" title="3.3 从机配置文件"></a>3.3 从机配置文件</h3><p>要求主从所有配置项都配置在 <code>my.cnf</code> 的 <code>[mysqld]</code> 栏位下，且都是小写字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><ul><li><p>必选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[必须]从服务器唯一ID</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure></li><li><p>可选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[可选]启用中继日志</span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure></li></ul><p>重启后台mysql服务，使配置生效。</p><blockquote><p>注意：主从机都关闭防火墙<br>service iptables stop #CentOS 6<br>systemctl stop firewalld.service #CentOS 7</p></blockquote><h3 id="3-4-主机：建立账户并授权"><a href="#3-4-主机：建立账户并授权" class="headerlink" title="3.4 主机：建立账户并授权"></a>3.4 主机：建立账户并授权</h3><p><strong>MySQL5.0:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在主机MySQL里执行授权主从复制的命令</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@&#x27;从机器数据库IP&#x27; IDENTIFIED BY &#x27;abc123&#x27;; #5.5,5.7</span><br></pre></td></tr></table></figure><p>注意：如果使用的是<strong>MySQL8</strong>，需要如下的方式建立账户，并授权slave:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;slave1&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">#此语句必须执行。否则见下面。</span><br><span class="line">ALTER USER &#x27;slave1&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在从机执行show slave status\G时报错： </p><p>Last_IO_Error: error connecting to master ‘<a href="mailto:&#x73;&#x6c;&#97;&#118;&#101;&#49;&#x40;&#49;&#x39;&#x32;&#x2e;&#x31;&#54;&#56;&#46;&#x31;&#46;&#49;&#x35;&#48;">&#x73;&#x6c;&#97;&#118;&#101;&#49;&#x40;&#49;&#x39;&#x32;&#x2e;&#x31;&#54;&#56;&#46;&#x31;&#46;&#49;&#x35;&#48;</a>:3306’ - retry-time: 60 retries: 1 message: </p><p>Authentication plugin ‘caching_sha2_password’ reported error: Authentication requires secure connection.</p></blockquote><p>查询Master的状态，并记录下File和Position的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+---------------------+----------+----------------------+------------------+-------------------+</span><br><span class="line">| File                | Position | Binlog_Do_DB         | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+---------------------+----------+----------------------+------------------+-------------------+</span><br><span class="line">| atguigu-bin.000002  |     1136 | atguigu_master_slave |                  |                   |</span><br><span class="line">+---------------------+----------+----------------------+------------------+-------------------+</span><br></pre></td></tr></table></figure><ul><li>记录下File和Position的值</li></ul><blockquote><p>注意：执行完此步骤后<strong>不要再操作主服务器MySQL</strong>，防止主服务器状态值变化。</p></blockquote><h3 id="3-5-从机：配置需要复制的主机"><a href="#3-5-从机：配置需要复制的主机" class="headerlink" title="3.5 从机：配置需要复制的主机"></a>3.5 从机：配置需要复制的主机</h3><p><strong>步骤1：</strong>从机上复制主机的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO</span><br><span class="line">MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;主机用户名&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;主机用户名的密码&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,</span><br><span class="line">MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure><p>举例：(前面show master status的数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.111.100&#x27;,MASTER_USER=&#x27;slave1&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;atguigu-bin.000002&#x27;,MASTER_LOG_POS=1136;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718140946747.png" alt="image-20220718140946747"></p><blockquote><p>如果报错是因为重复配置，需要先stop slave;</p></blockquote><p><strong>步骤2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#启动slave同步</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718141825228.png" alt="image-20220718141825228"></p><p>如果报错：</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718141841862.png" alt="image-20220718141841862"></p><p>可以执行如下操作，删除之前的relay_log信息。然后重新执行 CHANGE MASTER TO …语句即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; reset slave; #删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件</span><br></pre></td></tr></table></figure><p>接着，查看同步状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW SLAVE STATUS\G;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718141951374.png" alt="image-20220718141951374"></p><blockquote><p>上面两个参数都是Yes，则说明主从配置成功！</p></blockquote><p>显式如下的情况，就是不正确的。可能错误的原因有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 网络不通</span><br><span class="line">2. 账户密码错误</span><br><span class="line">3. 防火墙</span><br><span class="line">4. mysql配置文件问题</span><br><span class="line">5. 连接服务器时语法</span><br><span class="line">6. 主服务器mysql权限</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718142045114.png" alt="image-20220718142045114" style="zoom:80%;"><h3 id="3-6-测试"><a href="#3-6-测试" class="headerlink" title="3.6 测试"></a>3.6 测试</h3><p>主机新建库、新建表、insert记录，从机复制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE atguigu_master_slave;</span><br><span class="line"></span><br><span class="line">USE atguigu_master_slave;</span><br><span class="line"></span><br><span class="line">CREATE TABLE mytbl(id INT,NAME VARCHAR(16));</span><br><span class="line"></span><br><span class="line">INSERT INTO mytbl VALUES(1, &#x27;zhang3&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO mytbl VALUES(2,@@hostname);</span><br></pre></td></tr></table></figure><blockquote><p>这里会出现主从库的数据不一致的情况，因为使用了@@hostname</p><p>若binlog格式设置为statement，记录的是sql，若是使用row，记录的将是值，不会不一致</p></blockquote><h3 id="3-7-停止主从同步"><a href="#3-7-停止主从同步" class="headerlink" title="3.7 停止主从同步"></a>3.7 停止主从同步</h3><ul><li><p>停止主从同步命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure></li><li><p>如何重新配置主从</p><p>如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718142549168.png" alt="image-20220718142549168"></p></li></ul><p>重新配置主从，需要在从机上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># [特殊情况选用 慎用！！！]</span><br><span class="line">reset slave</span><br><span class="line">reset master; #删除Master中所有的binglog文件，并将日志索引文件清空，重新开始所有新的日志文件(慎用)</span><br></pre></td></tr></table></figure><h3 id="3-8-后续"><a href="#3-8-后续" class="headerlink" title="3.8 后续"></a>3.8 后续</h3><p><strong>搭建主从复制：双主双从</strong></p><p>一个主机m1用于处理所有写请求，它的从机s1和另一台主机m2还有它的从机s2负责所有读请求。当m1主机宕机后，m2主机负责写请求，m1、m2互为备机。结构图如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718143705843.png" alt="image-20220718143705843"></p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718143716620.png" alt="image-20220718143716620"></p><p>后续内容都在中间件Mycat中讲解</p><h2 id="4-同步数据一致性问题"><a href="#4-同步数据一致性问题" class="headerlink" title="4. 同步数据一致性问题"></a>4. 同步数据一致性问题</h2><p><strong>主从同步的要求：</strong></p><ul><li>读库和写库的数据一致(最终一致)； </li><li>写数据必须写到写库； </li><li>读数据必须到读库(不一定)；</li></ul><h3 id="4-1-理解主从延迟问题"><a href="#4-1-理解主从延迟问题" class="headerlink" title="4.1 理解主从延迟问题"></a>4.1 理解主从延迟问题</h3><p>进行主从同步的内容是二进制日志，它是一个文件，在进行 <code>网络传输</code> 的过程中就一定会 <code>存在主从延迟</code> （比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的 <code>数据不一致性</code> 问题。</p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718144051094.png" alt="image-20220718144051094" style="float:left;"><h3 id="4-2-主从延迟问题原因"><a href="#4-2-主从延迟问题原因" class="headerlink" title="4.2 主从延迟问题原因"></a>4.2 主从延迟问题原因</h3><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong>造成原因：</p><p>1、从库的机器性能比主库要差 </p><p>2、从库的压力大 </p><p>3、大事务的执行</p><p><strong>举例1：</strong>一次性用delete语句删除太多数据 </p><p>结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。 </p><p><strong>举例2：</strong>一次性用insert…select插入太多数据 </p><p><strong>举例3：</strong>大表DDL </p><p>比如在主库对一张500W的表添加一个字段耗费了10分钟，那么从节点上也会耗费10分钟。</p><h3 id="4-3-如何减少主从延迟"><a href="#4-3-如何减少主从延迟" class="headerlink" title="4.3 如何减少主从延迟"></a>4.3 如何减少主从延迟</h3><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ol><li>降低多线程大事务并发的概率，优化业务逻辑 </li><li>优化SQL，避免慢SQL， <code>减少批量操作</code> ，建议写脚本以update-sleep这样的形式完成。 </li><li><code>提高从库机器的配置</code> ，减少主库写binlog和从库读binlog的效率差。 </li><li>尽量采用 <code>短的链路</code> ，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。 </li><li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li></ol><h3 id="4-4-如何解决一致性问题"><a href="#4-4-如何解决一致性问题" class="headerlink" title="4.4 如何解决一致性问题"></a>4.4 如何解决一致性问题</h3><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是 <code>备份</code> ，并没有起到 <code>读写分离</code> ，分担主库 <code>读压力</code> 的作用。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718144341584.png" alt="image-20220718144341584"></p><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 <code>数据复制方式</code> 的问题，如果按照数据一致性 <code>从弱到强</code> 来进行划分，有以下 3 种复制方式。</p><h4 id="方法-1：异步复制"><a href="#方法-1：异步复制" class="headerlink" title="方法 1：异步复制"></a>方法 1：异步复制</h4><p>异步模式就是客户端<strong>提交 COMMIT 之后不需要等从库返回任何结果，而是直接将结果返回给客户端</strong>，这样做的好处是不会影响主库写的效率，但<strong>可能会存在主库宕机</strong>，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718144410731.png" alt="image-20220718144410731"></p><h4 id="方法-2：半同步复制"><a href="#方法-2：半同步复制" class="headerlink" title="方法 2：半同步复制"></a>方法 2：半同步复制</h4><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718144926758.png" alt="image-20220718144926758" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718144958357.png" alt="image-20220718144958357"></p><h4 id="方法-3：组复制"><a href="#方法-3：组复制" class="headerlink" title="方法 3：组复制"></a>方法 3：组复制</h4><p>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。</p><p>组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p><p><strong>MGR 是如何工作的</strong></p><p>首先我们将多个节点共同组成一个复制组，在 <code>执行读写（RW）事务</code> 的时候，需要通过<strong>一致性协议层</strong> （Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节 点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对 <code>只读（RO）事务</code> 则不需要经过组内同意，直接 COMMIT 即可。</p><p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消 息和全局有序消息，从而保证组内数据的一致性。</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718145235499.png" alt="image-20220718145235499"></p><p>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为 <code>分布式一致性算法</code> 被广泛应用，比如 Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p><h2 id="5-知识延伸-数据库中间件"><a href="#5-知识延伸-数据库中间件" class="headerlink" title="5. 知识延伸 数据库中间件"></a>5. 知识延伸 数据库中间件</h2><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以<code> 自己编写程序</code> ，也可以通过 <code>第三方的中间件</code> 来实现。</p><ul><li>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要 求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</li><li>采用中间件的方法有很明显的优势，<code> 功能强大</code> ， <code>使用简单</code> 。但因为在客户端和数据库之间增加了 中间件层会有一些 <code>性能损耗</code> ，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718145428456.png" alt="image-20220718145428456"></p><p>① <code>Cobar</code> 属于阿里B2B事业群，始于2008年，在阿里服役3年多，接管3000+个MySQL数据库的 schema,集群日处理在线SQL请求50亿次以上。由于Cobar发起人的离职，Cobar停止维护。 </p><p>② <code>Mycat</code> 是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许 多新的功能在其中。青出于蓝而胜于蓝。</p><p>③ <code>OneProxy</code> 基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业 收费 的中 间件。舍弃了一些功能，专注在 性能和稳定性上 。 </p><p>④ <code>kingshard</code> 由小团队用go语言开发，还需要发展，需要不断完善。 </p><p>⑤ <code>Vitess</code> 是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用 需要大量改造成 本 。 </p><p>⑥ <code>Atlas</code> 是360团队基于mysql proxy改写，功能还需完善，高并发下不稳定。 </p><p>⑦ <code>MaxScale</code> 是mariadb（MySQL原作者维护的一个版本） 研发的中间件 </p><p>⑧ <code>MySQLRoute</code> 是MySQL官方Oracle公司发布的中间件</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718145523643.png" alt="image-20220718145523643"></p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718145534856.png" alt="image-20220718145534856"></p><p>主备切换：</p><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718145548526.png" alt="image-20220718145548526"></p><ul><li>主动切换 </li><li>被动切换</li><li>如何判断主库出问题了？如何解决过程中的数据不一致性问题 ?</li></ul><h1 id="第19章-数据库备份与恢复"><a href="#第19章-数据库备份与恢复" class="headerlink" title="第19章_数据库备份与恢复"></a>第19章_数据库备份与恢复</h1><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718145936444.png" alt="image-20220718145936444" style="float:left;"><h2 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1. 物理备份与逻辑备份"></a>1. 物理备份与逻辑备份</h2><p><strong>物理备份：</strong>备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用 <code>xtrabackup</code> 工具来进行物理备份。因为InnoDB的表文件不能直接复制，所以<strong>物理备份只适用于MySIAM</strong></p><p><strong>逻辑备份：</strong>对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 <code>mysqldump</code> 。逻辑备份就是 <code>备份sql语句</code> ，在恢复的 时候执行备份的sql语句实现数据库数据的重现。</p><h2 id="2-mysqldump实现逻辑备份"><a href="#2-mysqldump实现逻辑备份" class="headerlink" title="2. mysqldump实现逻辑备份"></a>2. mysqldump实现逻辑备份</h2><p>mysqldump是MySQL提供的一个非常有用的数据库备份工具。</p><h3 id="2-1-备份一个数据库"><a href="#2-1-备份一个数据库" class="headerlink" title="2.1 备份一个数据库"></a>2.1 备份一个数据库</h3><blockquote><p>普通备份默认不包含存储过程、函数和事件，详见2.8</p></blockquote><p>mysqldump命令执行时，可以将数据库备份成一个<code>文本文件</code>，该文件中实际上包含多个<code>CREATE</code>和<code>INSERT</code>语句，使用这些语句可以重新创建表和插入数据。</p><ul><li>查出需要备份的表的结构，在文本文件中生成一个CREATE语句</li><li>将表中的所有记录转换为一条INSERT语句。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure><blockquote><p>说明： 备份的文件并非一定要求后缀名为.sql，例如后缀名为.txt的文件也是可以的。</p></blockquote><p>举例：使用root用户备份atguigu数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 atguigudb3 &gt; atguigudb3.sql #备份文件存储在当前目录下</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 atguigudb3 &gt; /var/lib/mysql/backup/atguigudb3.sql</span><br></pre></td></tr></table></figure><p>备份文件剖析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">-- MySQL dump 10.13 Distrib 8.0.26, for Linux (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: localhost Database: atguigu</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version 8.0.26</span><br><span class="line"></span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!50503 SET NAMES utf8mb4 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;</span><br><span class="line">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">-- Current Database: `atguigu`</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">CREATE DATABASE /*!32312 IF NOT EXISTS*/ `atguigu` /*!40100 DEFAULT CHARACTER SET</span><br><span class="line">utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */;</span><br><span class="line"></span><br><span class="line">USE `atguigu`;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">-- Table structure for table `student`</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `student`;</span><br><span class="line">/*!40101 SET @saved_cs_client = @@character_set_client */;</span><br><span class="line">/*!50503 SET character_set_client = utf8mb4 */;</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">`studentno` int NOT NULL,</span><br><span class="line">`name` varchar(20) DEFAULT NULL,</span><br><span class="line">`class` varchar(20) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`studentno`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;</span><br><span class="line">/*!40101 SET character_set_client = @saved_cs_client */;</span><br><span class="line">INSERT INTO `student` VALUES (1,&#x27;张三_back&#x27;,&#x27;一班&#x27;),(3,&#x27;李四&#x27;,&#x27;一班&#x27;),(8,&#x27;王五&#x27;,&#x27;二班&#x27;),</span><br><span class="line">(15,&#x27;赵六&#x27;,&#x27;二班&#x27;),(20,&#x27;钱七&#x27;,&#x27;&gt;三班&#x27;),(22,&#x27;zhang3_update&#x27;,&#x27;1ban&#x27;),(24,&#x27;wang5&#x27;,&#x27;2ban&#x27;);</span><br><span class="line">/*!40000 ALTER TABLE `student` ENABLE KEYS */;</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;</span><br><span class="line">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;</span><br><span class="line">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;</span><br><span class="line">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;</span><br><span class="line">-- Dump completed on 2022-01-07 9:58:23</span><br></pre></td></tr></table></figure><h3 id="2-2-备份全部数据库"><a href="#2-2-备份全部数据库" class="headerlink" title="2.2 备份全部数据库"></a>2.2 备份全部数据库</h3><p>若想用mysqldump备份整个实例，可以使用 –all-databases 或 -A 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --all-databases &gt; all_database.sql</span><br><span class="line">mysqldump -uroot -p123456 -A &gt; all_database.sql</span><br></pre></td></tr></table></figure><h3 id="2-3-备份部分数据库"><a href="#2-3-备份部分数据库" class="headerlink" title="2.3 备份部分数据库"></a>2.3 备份部分数据库</h3><p>使用 <code>--databases</code> 或 <code>-B</code> 参数了，该参数后面跟数据库名称，多个数据库间用空格隔开。如果指定 databases参数，备份文件中会存在创建数据库的语句，如果不指定参数，则不存在。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p --databases atguigu atguigu12 &gt; two_database.sql</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p -B atguigu atguigu12 &gt; two_database.sql</span><br></pre></td></tr></table></figure><h3 id="2-4-备份部分表"><a href="#2-4-备份部分表" class="headerlink" title="2.4 备份部分表"></a>2.4 备份部分表</h3><p>比如，在表变更前做个备份。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure><p>举例：备份atguigu数据库下的book表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu book &gt; book.sql</span><br></pre></td></tr></table></figure><p>备份多张表使用下面的命令，比如备份book和account表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#备份多张表</span><br><span class="line">mysqldump -uroot -p atguigu book account &gt; 2_tables_bak.sql</span><br></pre></td></tr></table></figure><h3 id="2-5-备份单表的部分数据"><a href="#2-5-备份单表的部分数据" class="headerlink" title="2.5 备份单表的部分数据"></a>2.5 备份单表的部分数据</h3><p>有些时候一张表的数据量很大，我们只需要部分数据。这时就可以使用 –where 选项了。where后面附带需要满足的条件。</p><p>举例：备份student表中id小于10的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu student --where = &quot;id &lt; 10 &quot; &gt; student_part_id10_low_bak.sql</span><br></pre></td></tr></table></figure><p>内容如下所示，insert语句只有id小于10的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES `student` WRITE;</span><br><span class="line">/*!40000 ALTER TABLE `student` DISABLE KEYS */;</span><br><span class="line">INSERT INTO `student` VALUES (1,100002,&#x27;JugxTY&#x27;,157,280),(2,100003,&#x27;QyUcCJ&#x27;,251,277),</span><br><span class="line">(3,100004,&#x27;lATUPp&#x27;,80,404),(4,100005,&#x27;BmFsXI&#x27;,240,171),(5,100006,&#x27;mkpSwJ&#x27;,388,476),</span><br><span class="line">(6,100007,&#x27;ujMgwN&#x27;,259,124),(7,100008,&#x27;HBJTqX&#x27;,429,168),(8,100009,&#x27;dvQSQA&#x27;,61,504),</span><br><span class="line">(9,100010,&#x27;HljpVJ&#x27;,234,185);</span><br></pre></td></tr></table></figure><h3 id="2-6-排除某些表的备份"><a href="#2-6-排除某些表的备份" class="headerlink" title="2.6 排除某些表的备份"></a>2.6 排除某些表的备份</h3><p>如果我们想备份某个库，但是某些表数据量很大或者与业务关联不大，这个时候可以考虑排除掉这些表，同样的，选项 <code>--ignore-table</code> 可以完成这个功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql</span><br></pre></td></tr></table></figure><p>通过如下指定判定文件中没有student表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;student&quot; no_stu_bak.sql</span><br></pre></td></tr></table></figure><h3 id="2-7-只备份结构或只备份数据"><a href="#2-7-只备份结构或只备份数据" class="headerlink" title="2.7 只备份结构或只备份数据"></a>2.7 只备份结构或只备份数据</h3><p>只备份结构的话可以使用 <code>--no-data</code> 简写为 <code>-d</code> 选项；只备份数据可以使用 <code>--no-create-info</code> 简写为 <code>-t</code>选项。</p><ul><li><p>只备份结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --no-data &gt; atguigu_no_data_bak.sql</span><br><span class="line">#使用grep命令，没有找到insert相关语句，表示没有数据备份。</span><br><span class="line">[root@node1 ~]# grep &quot;INSERT&quot; atguigu_no_data_bak.sql</span><br><span class="line">[root@node1 ~]#</span><br></pre></td></tr></table></figure></li><li><p>只备份数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --no-create-info &gt; atguigu_no_create_info_bak.sql</span><br><span class="line">#使用grep命令，没有找到create相关语句，表示没有数据结构。</span><br><span class="line">[root@node1 ~]# grep &quot;CREATE&quot; atguigu_no_create_info_bak.sql</span><br><span class="line">[root@node1 ~]#</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-8-备份中包含存储过程、函数、事件"><a href="#2-8-备份中包含存储过程、函数、事件" class="headerlink" title="2.8 备份中包含存储过程、函数、事件"></a>2.8 备份中包含存储过程、函数、事件</h3><p>mysqldump备份<strong>默认是不包含存储过程，自定义函数及事件</strong>的。可以使用 <code>--routines</code> 或 <code>-R</code> 选项来备份存储过程及函数，使用 <code>--events</code> 或 <code>-E</code> 参数来备份事件。</p><p>举例：备份整个atguigu库，包含存储过程及事件：</p><ul><li>使用下面的SQL可以查看当前库有哪些存储过程或者函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SPECIFIC_NAME,ROUTINE_TYPE ,ROUTINE_SCHEMA FROM</span><br><span class="line">information_schema.Routines WHERE ROUTINE_SCHEMA=&quot;atguigu&quot;;</span><br><span class="line">+---------------+--------------+----------------+</span><br><span class="line">| SPECIFIC_NAME | ROUTINE_TYPE | ROUTINE_SCHEMA |</span><br><span class="line">+---------------+--------------+----------------+</span><br><span class="line">| rand_num      | FUNCTION     | atguigu        |</span><br><span class="line">| rand_string   | FUNCTION     | atguigu        |</span><br><span class="line">| BatchInsert   | PROCEDURE    | atguigu        |</span><br><span class="line">| insert_class  | PROCEDURE    | atguigu        |</span><br><span class="line">| insert_order  | PROCEDURE    | atguigu        |</span><br><span class="line">| insert_stu    | PROCEDURE    | atguigu        |</span><br><span class="line">| insert_user   | PROCEDURE    | atguigu        |</span><br><span class="line">| ts_insert     | PROCEDURE    | atguigu        |</span><br><span class="line">+---------------+--------------+----------------+</span><br><span class="line">9 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>下面备份atguigu库的数据，函数以及存储过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p -R -E --databases atguigu &gt; fun_atguigu_bak.sql</span><br></pre></td></tr></table></figure><p>查询备份文件中是否存在函数，如下所示，可以看到确实包含了函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">grep -C 5 &quot;rand_num&quot; fun_atguigu_bak.sql</span><br><span class="line">--</span><br><span class="line">--</span><br><span class="line">-- Dumping routines for database &#x27;atguigu&#x27;</span><br><span class="line">--</span><br><span class="line">/*!50003 DROP FUNCTION IF EXISTS `rand_num` */;</span><br><span class="line">/*!50003 SET @saved_cs_client = @@character_set_client */ ;</span><br><span class="line">/*!50003 SET @saved_cs_results = @@character_set_results */ ;</span><br><span class="line">/*!50003 SET @saved_col_connection = @@collation_connection */ ;</span><br><span class="line">/*!50003 SET character_set_client = utf8mb3 */ ;</span><br><span class="line">/*!50003 SET character_set_results = utf8mb3 */ ;</span><br><span class="line">/*!50003 SET collation_connection = utf8_general_ci */ ;</span><br><span class="line">/*!50003 SET @saved_sql_mode = @@sql_mode */ ;</span><br><span class="line">/*!50003 SET sql_mode =</span><br><span class="line">&#x27;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISIO</span><br><span class="line">N_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27; */ ;</span><br><span class="line">DELIMITER ;;</span><br><span class="line">CREATE DEFINER=`root`@`%` FUNCTION `rand_num`(from_num BIGINT ,to_num BIGINT) RETURNS</span><br><span class="line">bigint</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i BIGINT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END ;;</span><br><span class="line">--</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO class ( classname,address,monitor ) VALUES</span><br><span class="line">    (rand_string(8),rand_string(10),rand_num());</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END ;;</span><br><span class="line">DELIMITER ;</span><br><span class="line">--</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    SET i = i + 1; #赋值</span><br><span class="line">    INSERT INTO order_test (order_id, trans_id ) VALUES</span><br><span class="line">    (rand_num(1,7000000),rand_num(100000000000000000,700000000000000000));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT; #提交事务</span><br><span class="line">END ;;</span><br><span class="line">DELIMITER ;</span><br><span class="line">--</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    SET i = i + 1; #赋值</span><br><span class="line">    INSERT INTO student (stuno, name ,age ,classId ) VALUES</span><br><span class="line">    ((START+i),rand_string(6),rand_num(),rand_num());</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT; #提交事务</span><br><span class="line">END ;;</span><br><span class="line">DELIMITER ;</span><br><span class="line">--</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO `user` ( name,age,sex ) VALUES (&quot;atguigu&quot;,rand_num(1,20),&quot;male&quot;);</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END ;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="2-9-mysqldump常用选项"><a href="#2-9-mysqldump常用选项" class="headerlink" title="2.9 mysqldump常用选项"></a>2.9 mysqldump常用选项</h3><p>mysqldump其他常用选项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">--add-drop-database：在每个CREATE DATABASE语句前添加DROP DATABASE语句。</span><br><span class="line"></span><br><span class="line">--add-drop-tables：在每个CREATE TABLE语句前添加DROP TABLE语句。</span><br><span class="line"></span><br><span class="line">--add-locking：用LOCK TABLES和UNLOCK TABLES语句引用每个表转储。重载转储文件时插入得更快。</span><br><span class="line"></span><br><span class="line">--all-database, -A：转储所有数据库中的所有表。与使用--database选项相同，在命令行中命名所有数据库。</span><br><span class="line"></span><br><span class="line">--comment[=0|1]：如果设置为0，禁止转储文件中的其他信息，例如程序版本、服务器版本和主机。--skipcomments与--comments=0的结果相同。默认值为1，即包括额外信息。</span><br><span class="line"></span><br><span class="line">--compact：产生少量输出。该选项禁用注释并启用--skip-add-drop-tables、--no-set-names、--skipdisable-keys和--skip-add-locking选项。</span><br><span class="line"></span><br><span class="line">--compatible=name：产生与其他数据库系统或旧的MySQL服务器更兼容的输出，值可以为ansi、MySQL323、MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_table_options或者no_field_options。</span><br><span class="line"></span><br><span class="line">--complete_insert, -c：使用包括列名的完整的INSERT语句。</span><br><span class="line"></span><br><span class="line">--debug[=debug_options], -#[debug_options]：写调试日志。</span><br><span class="line"></span><br><span class="line">--delete，-D：导入文本文件前清空表。</span><br><span class="line"></span><br><span class="line">--default-character-set=charset：使用charsets默认字符集。如果没有指定，就使用utf8。</span><br><span class="line"></span><br><span class="line">--delete--master-logs：在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用-masterdata。</span><br><span class="line"></span><br><span class="line">--extended-insert，-e：使用包括几个VALUES列表的多行INSERT语法。这样使得转储文件更小，重载文件时可以加速插入。</span><br><span class="line"></span><br><span class="line">--flush-logs，-F：开始转储前刷新MySQL服务器日志文件。该选项要求RELOAD权限。</span><br><span class="line"></span><br><span class="line">--force，-f：在表转储过程中，即使出现SQL错误也继续。</span><br><span class="line"></span><br><span class="line">--lock-all-tables，-x：对所有数据库中的所有表加锁。在整体转储过程中通过全局锁定来实现。该选项自动关闭--single-transaction和--lock-tables。</span><br><span class="line"></span><br><span class="line">--lock-tables，-l：开始转储前锁定所有表。用READ LOCAL锁定表以允许并行插入MyISAM表。对于事务表（例如InnoDB和BDB），--single-transaction是一个更好的选项，因为它根本不需要锁定表。</span><br><span class="line"></span><br><span class="line">--no-create-db，-n：该选项禁用CREATE DATABASE /*!32312 IF NOT EXIST*/db_name语句，如果给出--database或--all-database选项，就包含到输出中。</span><br><span class="line"></span><br><span class="line">--no-create-info，-t：只导出数据，而不添加CREATE TABLE语句。</span><br><span class="line"></span><br><span class="line">--no-data，-d：不写表的任何行信息，只转储表的结构。</span><br><span class="line"></span><br><span class="line">--opt：该选项是速记，它可以快速进行转储操作并产生一个能很快装入MySQL服务器的转储文件。该选项默认开启，但可以用--skip-opt禁用。</span><br><span class="line"></span><br><span class="line">--password[=password]，-p[password]：当连接服务器时使用的密码。</span><br><span class="line"></span><br><span class="line">-port=port_num，-P port_num：用于连接的TCP/IP端口号。</span><br><span class="line"></span><br><span class="line">--protocol=&#123;TCP|SOCKET|PIPE|MEMORY&#125;：使用的连接协议。</span><br><span class="line"></span><br><span class="line">--replace，-r –replace和--ignore：控制替换或复制唯一键值已有记录的输入记录的处理。如果指定--replace，新行替换有相同的唯一键值的已有行；如果指定--ignore，复制已有的唯一键值的输入行被跳过。如果不指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。</span><br><span class="line"></span><br><span class="line">--silent，-s：沉默模式。只有出现错误时才输出。</span><br><span class="line"></span><br><span class="line">--socket=path，-S path：当连接localhost时使用的套接字文件（为默认主机）。</span><br><span class="line"></span><br><span class="line">--user=user_name，-u user_name：当连接服务器时MySQL使用的用户名。</span><br><span class="line"></span><br><span class="line">--verbose，-v：冗长模式，打印出程序操作的详细信息。</span><br><span class="line"></span><br><span class="line">--xml，-X：产生XML输出。</span><br></pre></td></tr></table></figure><p>运行帮助命令 <code>mysqldump --help</code> ，可以获得特定版本的完整选项列表。</p><blockquote><p>提示 如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内 存。如果转储大数据库可能会出现问题，该选项默认启用，但可以用–skip-opt禁用。如果使用最 新版本的mysqldump程序备份数据，并用于恢复到比较旧版本的MySQL服务器中，则不要使用–opt 或-e选项。</p></blockquote><h2 id="3-mysql命令恢复数据"><a href="#3-mysql命令恢复数据" class="headerlink" title="3. mysql命令恢复数据"></a>3. mysql命令恢复数据</h2><p>使用mysqldump命令将数据库中的数据备份成一个文本文件。需要恢复时，可以使用<code>mysql命令</code>来恢复备份的数据。</p><p>mysql命令可以执行备份文件中的<code>CREATE语句</code>和<code>INSERT语句</code>。通过CREATE语句来创建数据库和表。通过INSERT语句来插入备份的数据。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p [dbname] &lt; backup.sql</span><br></pre></td></tr></table></figure><p>其中，dbname参数表示数据库名称。该参数是可选参数，可以指定数据库名，也可以不指定。指定数据库名时，表示还原该数据库下的表。此时需要确保MySQL服务器中已经创建了该名的数据库。不指定数据库名，表示还原文件中所有的数据库。此时sql文件中包含有CREATE DATABASE语句，不需要MySQL服务器中已存在的这些数据库。</p><h3 id="3-1-单库备份中恢复单库"><a href="#3-1-单库备份中恢复单库" class="headerlink" title="3.1 单库备份中恢复单库"></a>3.1 单库备份中恢复单库</h3><p>使用root用户，将之前练习中备份的atguigu.sql文件中的备份导入数据库中，命令如下：</p><p>如果备份文件中包含了创建数据库的语句，则恢复的时候不需要指定数据库名称，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt; atguigu.sql</span><br></pre></td></tr></table></figure><p>否则需要指定数据库名称，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p atguigu4 &lt; atguigu.sql</span><br></pre></td></tr></table></figure><h3 id="3-2-全量备份恢复"><a href="#3-2-全量备份恢复" class="headerlink" title="3.2 全量备份恢复"></a>3.2 全量备份恢复</h3><p>如果我们现在有昨天的全量备份，现在想整个恢复，则可以这样操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –uroot –p &lt; all.sql</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p123456 &lt; all.sql</span><br></pre></td></tr></table></figure><p>执行完后，MySQL数据库中就已经恢复了all.sql文件中的所有数据库。</p><h3 id="3-3-从全量备份中恢复单库"><a href="#3-3-从全量备份中恢复单库" class="headerlink" title="3.3 从全量备份中恢复单库"></a>3.3 从全量备份中恢复单库</h3><p>可能有这样的需求，比如说我们只想恢复某一个库，但是我们有的是整个实例的备份，这个时候我们可以<strong>从全量备份中分离出单个库</strong>的备份。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/^-- Current Database: `atguigudb3`/,/^-- Current Database: `/p&#x27; all_database.sql &gt; atguigudb3_1.sql</span><br></pre></td></tr></table></figure><p>分离完成后我们再执行3.1 中的步骤，导入atguigudb3.sql即可恢复单个库</p><h3 id="3-4-从单库备份中恢复单表"><a href="#3-4-从单库备份中恢复单表" class="headerlink" title="3.4 从单库备份中恢复单表"></a>3.4 从单库备份中恢复单表</h3><p>这个需求还是比较常见的。比如说我们知道哪个表误操作了，那么就可以用单表恢复的方式来恢复。</p><p>举例：我们有atguigudb3整库的备份，但是由于student表误操作，需要单独恢复出这张表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat atguigudb3.sql | sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/CREATE TABLE `student`/!d;q&#x27; &gt; student_structure.sql</span><br><span class="line">cat atguigudb3.sql | grep --ignore-case &#x27;insert into `student`&#x27; &gt; student_data.sql</span><br><span class="line">#用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复</span><br><span class="line"></span><br><span class="line">use atguigudb3;</span><br><span class="line">mysql&gt; source /var/lib/mysql/backup/student_structure.sql;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; source /var/lib/mysql/backup/student_data.sql;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><h2 id="4-物理备份：直接复制整个数据库"><a href="#4-物理备份：直接复制整个数据库" class="headerlink" title="4. 物理备份：直接复制整个数据库"></a>4. 物理备份：直接复制整个数据库</h2><p>直接将MySQL中的数据库文件复制出来。这种方法最简单，速度也最快。MySQL的数据库目录位置不一 定相同：</p><ul><li>在Windows平台下，MySQL 8.0存放数据库的目录通常默认为 “ C:\ProgramData\MySQL\MySQL Server 8.0\Data ”或者其他用户自定义目录； </li><li>在Linux平台下，数据库目录位置通常为&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;； </li><li>在MAC OSX平台下，数据库目录位置通常为“&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data”</li></ul><p>但为了保证备份的一致性。需要保证：</p><ul><li>方式1：备份前，将服务器停止。</li><li>方式2：备份前，对相关表执行 FLUSH TABLES WITH READ LOCK 操作。这样当复制数据库目录中 的文件时，允许其他客户继续查询表。同时，FLUSH TABLES语句来确保开始备份前将所有激活的索 引页写入硬盘。</li></ul><p>这种方式方便、快速，但不是最好的备份方法，因为实际情况可能 <code>不允许停止MySQL服务器</code> 或者 <code>锁住表</code> ，而且这种方法 <strong>对InnoDB存储引擎的表不适用</strong>。对于MyISAM存储引擎的表，这样备份和还原很方便，但是还原时最好是相同版本的MySQL数据库，否则可能会存在文件类型不同的情况。</p><p>注意，物理备份完毕后，执行 UNLOCK TABLES 来结算其他客户对表的修改行为。</p><blockquote><p>说明： 在MySQL版本号中，第一个数字表示主版本号，主版本号相同的MySQL数据库文件格式相同。</p></blockquote><p><strong>演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;</span><br><span class="line"></span><br><span class="line">[root@redis100 mysql] cp -r atguigudb05 ./backup/</span><br><span class="line"></span><br><span class="line">mysql&gt; UNLOCK TABLES;</span><br></pre></td></tr></table></figure><p>此外，还可以考虑使用相关工具实现备份。比如， <code>MySQLhotcopy</code> 工具。MySQLhotcopy是一个Perl脚本，它使用LOCK TABLES、FLUSH TABLES和cp或scp来快速备份数据库。它是备份数据库或单个表最快的途径，但它只能运行在数据库目录所在的机器上，并且只能备份MyISAM类型的表。多用于mysql5.5之前。</p><h2 id="5-物理恢复：直接复制到数据库目录"><a href="#5-物理恢复：直接复制到数据库目录" class="headerlink" title="5. 物理恢复：直接复制到数据库目录"></a>5. 物理恢复：直接复制到数据库目录</h2><p><strong>步骤：</strong></p><p>1）演示删除备份的数据库中指定表的数据 </p><p>2）将备份的数据库数据拷贝到数据目录下，并重启MySQL服务器</p><p>3）查询相关表的数据是否恢复。需要使用下面的<code> chown</code> 操作。</p><p><strong>要求：</strong></p><ul><li>必须确保备份数据的数据库和待恢复的数据库服务器的主版本号相同。<ul><li>因为只有MySQL数据库主版本号相同时，才能保证这两个MySQL数据库文件类型是相同的。</li></ul></li><li>这种方式对 <code>MyISAM类型的表比较有效</code> ，对于InnoDB类型的表则不可用。<ul><li><strong>因为InnoDB表的表空间不能直接复制。</strong></li></ul></li><li>在Linux操作系统下，复制到数据库目录后，一定要将数据库的用户和组变成mysql，命令如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql.mysql /var/lib/mysql/atguigudb5</span><br></pre></td></tr></table></figure><p>其中，两个mysql分别表示组和用户；“-R”参数可以改变文件夹下的所有子文件的用户和组；“dbname”参数表示数据库目录。</p><blockquote><p>提示 Linux操作系统下的权限设置非常严格。通常情况下，MySQL数据库只有root用户和mysql用户 组下的mysql用户才可以访问，因此将数据库目录复制到指定文件夹后，一定要使用chown命令将 文件夹的用户组变为mysql，将用户变为mysql。</p></blockquote><p><strong>演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@redis100 mysql] cp -r ./backup/atguigudb05 ./</span><br><span class="line"></span><br><span class="line">mysql&gt; chown -R mysql.mysql /var/lib/mysql/atguigudb5</span><br></pre></td></tr></table></figure><h2 id="6-表的导出与导入"><a href="#6-表的导出与导入" class="headerlink" title="6. 表的导出与导入"></a>6. 表的导出与导入</h2><h3 id="6-1-表的导出"><a href="#6-1-表的导出" class="headerlink" title="6.1 表的导出"></a>6.1 表的导出</h3><h4 id="1-使用SELECT…INTO-OUTFILE导出文本文件"><a href="#1-使用SELECT…INTO-OUTFILE导出文本文件" class="headerlink" title="1. 使用SELECT…INTO OUTFILE导出文本文件"></a>1. 使用SELECT…INTO OUTFILE导出文本文件</h4><p>在MySQL中，可以使用SELECT…INTO OUTFILE语句将表的内容导出成一个文本文件。</p><p><strong>举例：</strong>使用SELECT…INTO OUTFILE将atguigu数据库中account表中的记录导出到文本文件。 </p><p>（1）选择数据库atguigu，并查询account表，执行结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use atguigu;</span><br><span class="line">select * from account;</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| 1 | 张三 | 90 |</span><br><span class="line">| 2 | 李四 | 100 |</span><br><span class="line">| 3 | 王五 | 0 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>（2）mysql默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。</p><p>查询secure_file_priv值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;%secure%&#x27;;</span><br><span class="line">+--------------------------+-----------------------+</span><br><span class="line">| Variable_name            | Value                 |</span><br><span class="line">+--------------------------+-----------------------+</span><br><span class="line">| require_secure_transport | OFF                   |</span><br><span class="line">| secure_file_priv         | /var/lib/mysql-files/ |</span><br><span class="line">+--------------------------+-----------------------+</span><br><span class="line">2 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718163627669.png" alt="image-20220718163627669" style="float:left;"><p>（3）上面结果中显示，secure_file_priv变量的值为&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;，导出目录设置为该目录，SQL语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM account INTO OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;</span><br></pre></td></tr></table></figure><p>（4）查看 &#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;account.txt&#96;文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 张三 90</span><br><span class="line">2 李四 100</span><br><span class="line">3 王五 0</span><br></pre></td></tr></table></figure><h4 id="2-使用mysqldump命令导出文本文件"><a href="#2-使用mysqldump命令导出文本文件" class="headerlink" title="2. 使用mysqldump命令导出文本文件"></a>2. 使用mysqldump命令导出文本文件</h4><p><strong>举例1：</strong>使用mysqldump命令将将atguigu数据库中account表中的记录导出到文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account</span><br></pre></td></tr></table></figure><p>mysqldump命令执行完毕后，在指定的目录&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;下生成了account.sql和account.txt文件。</p><p>打开account.sql文件，其内容包含创建account表的CREATE语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql-files]# cat account.sql</span><br><span class="line">-- MySQL dump 10.13 Distrib 8.0.26, for Linux (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: localhost Database: atguigu</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version 8.0.26</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!50503 SET NAMES utf8mb4 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">-- Table structure for table `account`</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `account`;</span><br><span class="line">/*!40101 SET @saved_cs_client = @@character_set_client */;</span><br><span class="line">/*!50503 SET character_set_client = utf8mb4 */;</span><br><span class="line">CREATE TABLE `account` (</span><br><span class="line">`id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` varchar(255) NOT NULL,</span><br><span class="line">`balance` int NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3;</span><br><span class="line">/*!40101 SET character_set_client = @saved_cs_client */;</span><br><span class="line"></span><br><span class="line">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;</span><br><span class="line"></span><br><span class="line">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;</span><br><span class="line">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;</span><br><span class="line"></span><br><span class="line">-- Dump completed on 2022-01-07 23:19:27</span><br></pre></td></tr></table></figure><p>打开account.txt文件，其内容只包含account表中的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql-files]# cat account.txt</span><br><span class="line">1 张三 90</span><br><span class="line">2 李四 100</span><br><span class="line">3 王五 0</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong>使用mysqldump将atguigu数据库中的account表导出到文本文件，使用FIELDS选项，要求字段之 间使用逗号“，”间隔，所有字符类型字段值用双引号括起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account --fields-terminated-by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span><br></pre></td></tr></table></figure><p>语句mysqldump语句执行成功之后，指定目录下会出现两个文件account.sql和account.txt。</p><p>打开account.sql文件，其内容包含创建account表的CREATE语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql-files]# cat account.sql</span><br><span class="line">-- MySQL dump 10.13 Distrib 8.0.26, for Linux (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: localhost Database: atguigu</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version 8.0.26</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!50503 SET NAMES utf8mb4 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line">--</span><br><span class="line">-- Table structure for table `account`</span><br><span class="line">--</span><br><span class="line">DROP TABLE IF EXISTS `account`;</span><br><span class="line">/*!40101 SET @saved_cs_client = @@character_set_client */;</span><br><span class="line">/*!50503 SET character_set_client = utf8mb4 */;</span><br><span class="line">CREATE TABLE `account` (</span><br><span class="line">`id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` varchar(255) NOT NULL,</span><br><span class="line">`balance` int NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3;</span><br><span class="line">/*!40101 SET character_set_client = @saved_cs_client */;</span><br><span class="line">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;</span><br><span class="line">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;</span><br><span class="line">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;</span><br><span class="line">-- Dump completed on 2022-01-07 23:36:39</span><br></pre></td></tr></table></figure><p>打开account.txt文件，其内容包含创建account表的数据。从文件中可以看出，字段之间用逗号隔开，字符类型的值被双引号括起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql-files]# cat account.txt</span><br><span class="line">1,&quot;张三&quot;,90</span><br><span class="line">2,&quot;李四&quot;,100</span><br><span class="line">3,&quot;王五&quot;,0</span><br></pre></td></tr></table></figure><h4 id="3-使用mysql命令导出文本文件"><a href="#3-使用mysql命令导出文本文件" class="headerlink" title="3. 使用mysql命令导出文本文件"></a>3. 使用mysql命令导出文本文件</h4><p><strong>举例1：</strong>使用mysql语句导出atguigu数据中account表中的记录到文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p --execute=&quot;SELECT * FROM account;&quot; atguigu &gt; &quot;/var/lib/mysql-files/account.txt&quot;</span><br></pre></td></tr></table></figure><p>打开account.txt文件，其内容包含创建account表的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql-files]# cat account.txt</span><br><span class="line">id name balance</span><br><span class="line">1 张三 90</span><br><span class="line">2 李四 100</span><br><span class="line">3 王五 0</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong>将atguigu数据库account表中的记录导出到文本文件，使用–veritcal参数将该条件记录分为多行显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p --vertical --execute=&quot;SELECT * FROM account;&quot; atguigu &gt; &quot;/var/lib/mysql-files/account_1.txt&quot;</span><br></pre></td></tr></table></figure><p>打开account_1.txt文件，其内容包含创建account表的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql-files]# cat account_1.txt</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">id: 1</span><br><span class="line">name: 张三</span><br><span class="line">balance: 90</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">id: 2</span><br><span class="line">name: 李四</span><br><span class="line">balance: 100</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">id: 3</span><br><span class="line">name: 王五</span><br><span class="line">balance: 0</span><br></pre></td></tr></table></figure><p><strong>举例3：</strong>将atguigu数据库account表中的记录导出到xml文件，使用–xml参数，具体语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p --xml --execute=&quot;SELECT * FROM account;&quot; atguigu&gt;&quot;/var/lib/mysqlfiles/account_3.xml&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql-files]# cat account_3.xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;resultset statement=&quot;SELECT * FROM account&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br><span class="line">&lt;row&gt;</span><br><span class="line">&lt;field name=&quot;id&quot;&gt;1&lt;/field&gt;</span><br><span class="line">&lt;field name=&quot;name&quot;&gt;张三&lt;/field&gt;</span><br><span class="line">&lt;field name=&quot;balance&quot;&gt;90&lt;/field&gt;</span><br><span class="line">&lt;/row&gt;</span><br><span class="line">&lt;row&gt;</span><br><span class="line">&lt;field name=&quot;id&quot;&gt;2&lt;/field&gt;</span><br><span class="line">&lt;field name=&quot;name&quot;&gt;李四&lt;/field&gt;</span><br><span class="line">&lt;field name=&quot;balance&quot;&gt;100&lt;/field&gt;</span><br><span class="line">&lt;/row&gt;</span><br><span class="line">&lt;row&gt;</span><br><span class="line">&lt;field name=&quot;id&quot;&gt;3&lt;/field&gt;</span><br><span class="line">&lt;field name=&quot;name&quot;&gt;王五&lt;/field&gt;</span><br><span class="line">&lt;field name=&quot;balance&quot;&gt;0&lt;/field&gt;</span><br><span class="line">&lt;/row&gt;</span><br><span class="line">&lt;/resultset&gt;</span><br></pre></td></tr></table></figure><p>说明：如果要将表数据导出到html文件中，可以使用 <code>--html</code> 选项。然后可以使用浏览器打开。</p><h3 id="6-2-表的导入"><a href="#6-2-表的导入" class="headerlink" title="6.2 表的导入"></a>6.2 表的导入</h3><h4 id="1-使用LOAD-DATA-INFILE方式导入文本文件"><a href="#1-使用LOAD-DATA-INFILE方式导入文本文件" class="headerlink" title="1. 使用LOAD DATA INFILE方式导入文本文件"></a>1. 使用LOAD DATA INFILE方式导入文本文件</h4><p><strong>举例1：</strong></p><p>使用SELECT…INTO OUTFILE将atguigu数据库中account表的记录导出到文本文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM atguigu.account INTO OUTFILE &#x27;/var/lib/mysql-files/account_0.txt&#x27;;</span><br></pre></td></tr></table></figure><p>删除account表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM atguigu.account;</span><br></pre></td></tr></table></figure><p>从文本文件account.txt中恢复数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE &#x27;/var/lib/mysql-files/account_0.txt&#x27; INTO TABLE atguigu.account;</span><br></pre></td></tr></table></figure><p>查询account表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| 1 | 张三     | 90      |</span><br><span class="line">| 2 | 李四     | 100     |</span><br><span class="line">| 3 | 王五     | 0       |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong> 选择数据库atguigu，使用SELECT…INTO OUTFILE将atguigu数据库account表中的记录导出到文本文件，使用FIELDS选项和LINES选项，要求字段之间使用逗号”，”间隔，所有字段值用双引号括起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM atguigu.account INTO OUTFILE &#x27;/var/lib/mysql-files/account_1.txt&#x27; FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;</span><br></pre></td></tr></table></figure><p>删除account表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM atguigu.account;</span><br></pre></td></tr></table></figure><p>从&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;account.txt中导入数据到account表中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE &#x27;/var/lib/mysql-files/account_1.txt&#x27; INTO TABLE atguigu.account FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;</span><br></pre></td></tr></table></figure><p>查询account表中的数据，具体SQL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from account;</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| 1 | 张三     | 90      |</span><br><span class="line">| 2 | 李四     | 100     |</span><br><span class="line">| 3 | 王五     | 0       |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="2-使用mysqlimport方式导入文本文件"><a href="#2-使用mysqlimport方式导入文本文件" class="headerlink" title="2. 使用mysqlimport方式导入文本文件"></a>2. 使用mysqlimport方式导入文本文件</h4><p><strong>举例：</strong></p><p>导出文件account.txt，字段之间使用逗号”，”间隔，字段值用双引号括起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM atguigu.account INTO OUTFILE &#x27;/var/lib/mysql-files/account.txt&#x27; FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;</span><br></pre></td></tr></table></figure><p>删除account表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM atguigu.account;</span><br></pre></td></tr></table></figure><p>使用mysqlimport命令将account.txt文件内容导入到数据库atguigu的account表中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport -uroot -p atguigu &#x27;/var/lib/mysql-files/account.txt&#x27; --fields-terminated-by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span><br></pre></td></tr></table></figure><p>查询account表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from account;</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| 1 | 张三     | 90      |</span><br><span class="line">| 2 | 李四     | 100     |</span><br><span class="line">| 3 | 王五     | 0       |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="7-数据库迁移"><a href="#7-数据库迁移" class="headerlink" title="7. 数据库迁移"></a>7. 数据库迁移</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p>数据迁移（data migration）是指选择、准备、提取和转换数据，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统的过程</strong>。此外，<code> 验证迁移数据的完整性</code> 和 <code>退役原来旧的数据存储</code> ，也被认为是整个数据迁移过程的一部分。</p><p>数据库迁移的原因是多样的，包括服务器或存储设备更换、维护或升级，应用程序迁移，网站集成，灾难恢复和数据中心迁移。</p><p>根据不同的需求可能要采取不同的迁移方案，但总体来讲，MySQL 数据迁移方案大致可以分为<code>物理迁移</code>和 <code>逻辑迁移</code> 两类。通常以尽可能 <code>自动化</code> 的方式执行，从而将人力资源从繁琐的任务中解放出来。</p><h3 id="7-2-迁移方案"><a href="#7-2-迁移方案" class="headerlink" title="7.2 迁移方案"></a>7.2 迁移方案</h3><ul><li>物理迁移</li></ul><p>物理迁移适用于大数据量下的整体迁移。使用物理迁移方案的优点是比较快速，但需要停机迁移并且要 求 MySQL 版本及配置必须和原服务器相同，也可能引起未知问题。</p><p>物理迁移包括拷贝数据文件和使用 XtraBackup 备份工具两种。</p><p>不同服务器之间可以采用物理迁移，我们可以在新的服务器上安装好同版本的数据库软件，创建好相同目录，建议配置文件也要和原数据库相同，然后从原数据库方拷贝来数据文件及日志文件，配置好文件组权限，之后在新服务器这边使用 mysqld 命令启动数据库。</p><ul><li>逻辑迁移</li></ul><p>逻辑迁移适用范围更广，无论是 <code>部分迁移</code> 还是 <code>全量迁移</code> ，都可以使用逻辑迁移。逻辑迁移中使用最多的就是通过 mysqldump 等备份工具。</p><h3 id="7-3-迁移注意点"><a href="#7-3-迁移注意点" class="headerlink" title="7.3 迁移注意点"></a>7.3 迁移注意点</h3><p><strong>1. 相同版本的数据库之间迁移注意点</strong></p><p>指的是在主版本号相同的MySQL数据库之间进行数据库移动。</p><p><code>方式1</code>： 因为迁移前后MySQL数据库的 <code>主版本号相同</code> ，所以可以通过复制数据库目录来实现数据库迁移，但是物理迁移方式只适用于MyISAM引擎的表。对于InnoDB表，不能用直接复制文件的方式备份数据库。</p><p><code>方式2</code>： 最常见和最安全的方式是使用 <code>mysqldump命令</code> 导出数据，然后在目标数据库服务器中使用 MySQL命令导入。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#host1的机器中备份所有数据库,并将数据库迁移到名为host2的机器上</span><br><span class="line">mysqldump –h host1 –uroot –p –-all-databases|</span><br><span class="line">mysql –h host2 –uroot –p</span><br></pre></td></tr></table></figure><p>在上述语句中，“|”符号表示管道，其作用是将mysqldump备份的文件给mysql命令；“–all-databases”表示要迁移所有的数据库。通过这种方式可以直接实现迁移。</p><p><strong>2. 不同版本的数据库之间迁移注意点</strong></p><p>例如，原来很多服务器使用5.7版本的MySQL数据库，在8.0版本推出来以后，改进了5.7版本的很多缺陷， 因此需要把数据库升级到8.0版本</p><p>旧版本与新版本的MySQL可能使用不同的默认字符集，例如有的旧版本中使用latin1作为默认字符集，而最新版本的MySQL默认字符集为utf8mb4。如果数据库中有中文数据，那么迁移过程中需要对 <code>默认字符集</code> 进行修改 ，不然可能无法正常显示数据。</p><p>高版本的MySQL数据库通常都会 <code>兼容低版本</code> ，因此可以从低版本的MySQL数据库迁移到高版本的MySQL 数据库。</p><p><strong>3. 不同数据库之间迁移注意点</strong></p><p>不同数据库之间迁移是指从其他类型的数据库迁移到MySQL数据库，或者从MySQL数据库迁移到其他类 型的数据库。这种迁移没有普适的解决方法。</p><p>迁移之前，需要了解不同数据库的架构， <code>比较它们之间的差异</code> 。不同数据库中定义相同类型的数据的 <code>关键字可能会不同</code> 。例如，MySQL中日期字段分为DATE和TIME两种，而ORACLE日期字段只有DATE；SQL Server数据库中有ntext、Image等数据类型，MySQL数据库没有这些数据类型；MySQL支持的ENUM和SET 类型，这些SQL Server数据库不支持。</p><p>另外，数据库厂商并没有完全按照SQL标准来设计数据库系统，导致不同的数据库系统的 <code>SQL语句</code> 有差别。例如，微软的SQL Server软件使用的是T-SQL语句，T-SQL中包含了非标准的SQL语句，不能和MySQL的SQL语句兼容。</p><p>不同类型数据库之间的差异造成了互相 <code>迁移的困难</code> ，这些差异其实是商业公司故意造成的技术壁垒。但 是不同类型的数据库之间的迁移并 <code>不是完全不可能</code> 。例如，可以使用<code> MyODBC</code> 实现MySQL和SQL Server之 间的迁移。MySQL官方提供的工具 <code>MySQL Migration Toolkit</code> 也可以在不同数据之间进行数据迁移。 MySQL迁移到Oracle时，需要使用mysqldump命令导出sql文件，然后， <code>手动更改</code> sql文件中的CREATE语句。</p><h3 id="7-4-迁移小结"><a href="#7-4-迁移小结" class="headerlink" title="7.4 迁移小结"></a>7.4 迁移小结</h3><p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87.assets/image-20220718165515965.png" alt="image-20220718165515965"></p><h2 id="8-删库了不敢跑，能干点啥？"><a href="#8-删库了不敢跑，能干点啥？" class="headerlink" title="8. 删库了不敢跑，能干点啥？"></a>8. 删库了不敢跑，能干点啥？</h2><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718165738367.png" alt="image-20220718165738367" style="float:left;"><h3 id="8-1-delete：误删行"><a href="#8-1-delete：误删行" class="headerlink" title="8.1 delete：误删行"></a>8.1 delete：误删行</h3><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718165909464.png" alt="image-20220718165909464" style="float:left;"><h3 id="8-2-truncate-drop-：误删库-表"><a href="#8-2-truncate-drop-：误删库-表" class="headerlink" title="8.2 truncate&#x2F;drop ：误删库&#x2F;表"></a>8.2 truncate&#x2F;drop ：误删库&#x2F;表</h3><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718170026929.png" alt="image-20220718170026929" style="float:left;"><h3 id="8-3-预防使用truncate-drop误删库-表"><a href="#8-3-预防使用truncate-drop误删库-表" class="headerlink" title="8.3 预防使用truncate&#x2F;drop误删库&#x2F;表"></a>8.3 预防使用truncate&#x2F;drop误删库&#x2F;表</h3><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718170132339.png" alt="image-20220718170132339" style="float:left;"><p>CHANGE MASTERRR TO MASTER_DELAY &#x3D; N</p><img src="https://www.hahhome.top/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/../../image/MySQL(5)日志与备份篇.assets/image-20220718170215247.png" alt="image-20220718170215247" style="float:left;"><h3 id="8-4-rm：误删MySQL实例"><a href="#8-4-rm：误删MySQL实例" class="headerlink" title="8.4 rm：误删MySQL实例"></a>8.4 rm：误删MySQL实例</h3><p>对于一个有高可用机制的MySQL集群来说，不用担心 rm删除数据 了。只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。我们要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p><p>但如果是恶意地把整个集群删除，那就需要考虑跨机房备份，跨城市备份。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(4)事务篇</title>
      <link href="/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/"/>
      <url>/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="第13章-事务基础知识"><a href="#第13章-事务基础知识" class="headerlink" title="第13章_事务基础知识"></a>第13章_事务基础知识</h1><h2 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a>1. 数据库事务概述</h2><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持<code>一致性</code>，同时我们还能通过事务的机制<code>恢复到某个时间点</code>，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p><h3 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h3><p><code>SHOW ENGINES</code> 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708124306444.png" alt="image-20220708124306444"></p><p>能看出在 MySQL 中，只有InnoDB 是支持事务的。</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则：</strong>保证所有事务都作为 <code>一个工作单元</code> 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( <code>commit</code> )，那么这些修改就 <code>永久</code> 地保 <code>存下来</code>；要么数据库管理系统将 <code>放弃</code> 所作的所有 <code>修改</code> ，整个事务回滚( <code>rollback</code> )到最初状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例：AA用户给BB用户转账100</span><br><span class="line">update account set money = money - 100 where name = &#x27;AA&#x27;;</span><br><span class="line"># 服务器宕机</span><br><span class="line">update account set money = money + 100 where name = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure><h3 id="1-3-事务的ACID特性"><a href="#1-3-事务的ACID特性" class="headerlink" title="1.3 事务的ACID特性"></a>1.3 事务的ACID特性</h3><ul><li><strong>原子性（atomicity）：</strong></li></ul><p><code>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚</code>。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>一致性（Consistency）：<code>事务完成时，必须使所有的数据都保持一致状态。</code></p><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）</p><p>根据定义，<strong>一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code></strong> 。这种状态是 <code>语义上</code> 的而不是语法上的，跟具体的业务有关。</p><p>那什么是合法的数据状态呢？满足 <code>预定的约束</code> 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。</p><p><strong>举例1：</strong>A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须&gt;&#x3D;0。</p><p><strong>举例2：</strong>A账户有200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时的数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。</p><p><strong>举例3：</strong>在数据表中我们将<code>姓名</code>字段设置为<code>唯一性约束</code>，这时当事务进行提交或者事务发生回滚的时候，如果数据表的姓名不唯一，就破坏了事务的一致性要求。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p><code>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</code></p><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE accounts SET money = money - 50 WHERE NAME = &#x27;AA&#x27;;</span><br><span class="line">UPDATE accounts SET money = money + 50 WHERE NAME = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708164610193.png" alt="image-20220708164610193"></p><p><strong>持久性（durability）：</strong></p><p><code>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的</code> ，接下来的其他操作和数据库 故障不应该对其有任何影响。</p><p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。</p><blockquote><p>总结</p><p>ACID是事务的四大特征，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p><p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称为一个事务。</p></blockquote><h3 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h3><p>我们现在知道 <code>事务</code> 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把 <code>事务</code> 大致划分成几个状态：</p><ul><li><p><strong>活动的（active）</strong></p><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <code>活动的</code> 状态。</p></li><li><p><strong>部分提交的（partially committed）</strong></p><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <code>没有刷新到磁盘</code> 时，我们就说该事务处在 <code>部分提交的</code> 状态。</p></li><li><p><strong>失败的（failed）</strong></p><p>当事务处在 <code>活动的</code> 或者 部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p></li><li><p><strong>中止的（aborted）</strong></p><p>如果事务执行了一部分而变为 <code>失败的</code> 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <code>回滚</code> 。当 <code>回滚</code> 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 <code>中止的</code> 状态。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE accounts SET money = money - 50 WHERE NAME = &#x27;AA&#x27;;</span><br><span class="line"></span><br><span class="line">UPDATE accounts SET money = money + 50 WHERE NAME = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><strong>提交的（committed）</strong></p><p>当一个处在 <code>部分提交的</code> 状态的事务将修改过的数据都 <code>同步到磁盘</code> 上之后，我们就可以说该事务处在了 <code>提交的</code> 状态。</p><p>一个基本的状态转换图如下所示：</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220708171859055.png" alt="image-20220708171859055" style="zoom:80%;"><p>图中可见，只有当事务处于<code>提交的</code>或者<code>中止的</code>状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p></li></ul><h2 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a>2. 如何使用事务</h2><p>使用事务有两种方式，分别为 <code>显式事务</code> 和 <code>隐式事务</code> 。</p><h3 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h3><p><strong>步骤1：</strong> START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">#或者</span><br><span class="line">mysql&gt; START TRANSACTION;</span><br></pre></td></tr></table></figure><p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个 <code>修饰符</code> ：</p><p>① <code>READ ONLY</code> ：标识当前事务是一个 <code>只读事务</code> ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><blockquote><p>补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用 CREATE TMEPORARY TABLE 创建的表），由于它们只能再当前会话中可见，所以<strong>只读事务其实也是可以对临时表进行增、删、改操作的</strong>。</p></blockquote><p>② <code>READ WRITE（默认）</code> ：标识当前事务是一个 <code>读写事务</code> ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。</p><p>③ <code>WITH CONSISTENT SNAPSHOT</code> ：启动一致性读。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY; # 开启一个只读事务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT # 开启只读事务和一致性读</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT # 开启读写事务和一致性读</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，<strong>一个事务的访问模式不能同时即设置为<code>只读</code>的也设置为<code>读写</code>的</strong>，所以不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。</li><li>如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式</li></ul><p><strong>步骤2：</strong>一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3：</strong>提交事务 或 中止事务（即回滚事务）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql&gt; COMMIT;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line"></span><br><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure><h4 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h4><p>其中关于SAVEPOINT相关操作有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span><br><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除某个保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><h3 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h3><p>MySQL中有一个系统变量 <code>autocommit</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    |  ON   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>当然，如果我们想关闭这种 <code>自动提交</code> 的功能，可以使用下边两种方法之一：</p><ul><li><p>显式的的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p></li><li><p>把系统变量 <code>autocommit</code> 的值设置为 <code>OFF</code> ，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br><span class="line">#或</span><br><span class="line">SET autocommit = 0;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h3><ul><li><p>数据定义语言（Data definition language，缩写为：DDL）</p><p>数据库对象，指的就是<code>数据库、表、视图、存储过程</code>等结构。当我们<code>CREATE、ALTER、DROP</code>等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p>隐式使用或修改mysql数据库中的表</p><p>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p></li><li><p>事务控制或关于锁定的语句</p><p>① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line">BEGIN; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure><p>② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交前边语句所属的事务。</p><p>③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</p></li><li><p>加载数据的语句</p><p>使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会<code>隐式的提交</code>前边语句所属的事务。</p></li><li><p>关于MySQL复制的一些语句</p><p>使用<code>START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO</code>等语句会隐式的提交前边语句所属的事务</p></li><li><p>其他的一些语句</p><p>使用<code>ANALYZE TABLE、CACHE INDEX、CAECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET</code>等语句也会隐式的提交前边语句所属的事务。</p></li></ul><h3 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h3><p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么。</p><p><strong>情况1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user(name varchar(20), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;张三&#x27;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">Query OK, 1 rows affected (0.00 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">Duplicate entry &#x27;李四&#x27; for key &#x27;user.PRIMARY&#x27;</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.01 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| 张三    |</span><br><span class="line">+--------+</span><br><span class="line">1 行于数据集 (0.01 秒)</span><br></pre></td></tr></table></figure><p><strong>情况2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (name varchar(20), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;张三&#x27;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>运行结果（2 行数据）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM user;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| 张三    |</span><br><span class="line">| 李四    |</span><br><span class="line">+--------+</span><br><span class="line">2 行于数据集 (0.01 秒)</span><br></pre></td></tr></table></figure><h4 id="completion-type"><a href="#completion-type" class="headerlink" title="completion_type"></a>completion_type</h4><p><strong>情况3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">SET @@completion_type = 1;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;张三&#x27;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM user;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| 张三    |</span><br><span class="line">+--------+</span><br><span class="line">1 行于数据集 (0.01 秒)</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708201221316.png" alt="image-20220708201221316"></p><blockquote><p>当我们设置 autocommit&#x3D;0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p><p>当我们设置 autocommit&#x3D;1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效， 在 ROLLBACK 时才会回滚。</p></blockquote><h3 id="2-5-使用举例2：测试不支持事务的engine"><a href="#2-5-使用举例2：测试不支持事务的engine" class="headerlink" title="2.5 使用举例2：测试不支持事务的engine"></a>2.5 使用举例2：测试不支持事务的engine</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test1(i INT) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE test2(i INT) ENGINE=MYISAM;</span><br></pre></td></tr></table></figure><p>针对于InnoDB表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test1 VALUES(1);</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test1;</span><br></pre></td></tr></table></figure><p>结果：没有数据</p><p>针对于MYISAM表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test1 VALUES(1);</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2;</span><br></pre></td></tr></table></figure><p>结果：有一条数据</p><h3 id="2-6-使用举例3：SAVEPOINT"><a href="#2-6-使用举例3：SAVEPOINT" class="headerlink" title="2.6 使用举例3：SAVEPOINT"></a>2.6 使用举例3：SAVEPOINT</h3><p>创建表并添加数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(15),</span><br><span class="line">balance DECIMAL(10,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO account(NAME,balance)</span><br><span class="line">VALUES</span><br><span class="line">(&#x27;张三&#x27;,1000),</span><br><span class="line">(&#x27;李四&#x27;,1000);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE account SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">UPDATE account SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">SAVEPOINT s1; # 设置保存点</span><br><span class="line">UPDATE account SET balance = balance + 1 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">ROLLBACK TO s1; # 回滚到保存点</span><br></pre></td></tr></table></figure><p>结果：张三：800.00</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>结果：张三：1000.00</p><h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个会话（ <code>Session</code> ）。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 <code>隔离性</code> 的特性，理论上在某个事务 <code>对某个数据进行访问</code> 时，其他事务应该进行<code>排队</code> ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <code>性能影响太大</code> ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <code>性能尽量高些</code> ，那就看二者如何权衡取 舍了。</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">    studentno INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    class varchar(20),</span><br><span class="line">    PRIMARY KEY (studentno)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>然后向这个表里插入一条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student VALUES(1, &#x27;小谷&#x27;, &#x27;1班&#x27;);</span><br></pre></td></tr></table></figure><p>现在表里的数据就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">| studentno | name   | class |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">|      1    |   小谷  | 1班   |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也 就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p><p><strong>1. 脏写（ Dirty Write ）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A <code>修改了</code> 另一个 <code>未提交</code> 事务Session B <code>修改过</code> 的数据，那就意味着发生了 <code>脏写</code>，示意图如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708214453902.png" alt="image-20220708214453902"></p><p>Session A 和 Session B 各开启了一个事务，Sesssion B 中的事务先将studentno列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离性比较了解的话，会发现默认隔离级别下，上面Session A中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样的现象。</p><p><strong>2. 脏读（ Dirty Read ）</strong></p><p> 对于两个事务 Session A、Session B，Session A <code>读取</code> 了已经被 Session B <code>更新</code> 但还 <code>没有被提交</code> 的字段。 之后若 Session B <code>回滚</code> ，Session A <code>读取 </code>的内容就是 <code>临时且无效</code> 的。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708215109480.png" alt="image-20220708215109480"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 <code>脏读</code> 。</p><p><strong>3. 不可重复读（ Non-Repeatable Read ）</strong></p><p>对于两个事务Session A、Session B，Session A <code>读取</code>了一个字段，然后 Session B <code>更新</code>了该字段。 之后 Session A <code>再次读取</code> 同一个字段， <code>值就不同</code> 了。那就意味着发生了不可重复读。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708215626435.png" alt="image-20220708215626435"></p><p>我们在Session B中提交了几个 <code>隐式事务</code> （注意是隐式事务，意味着语句结束事务就提交了），这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 <code>不可重复读 </code>。</p><p><strong>4. 幻读（ Phantom ）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中 <code>读取</code> 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A <code>再次读取</code> 同一个表, 就会多出几行。那就意味着发生了<code>幻读</code>。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708220102342.png" alt="image-20220708220102342"></p><p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录； 之后Session B中提交了一个 <code>隐式事务</code> ，该事务向表student中插入了一条新记录；之后Session A中的事务 再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 <code>幻影记录</code> 。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220708220228436.png" alt="image-20220708220228436" style="float:left;"><blockquote><p>解决幻读的两种方法：①MVCC ②加锁（间隙锁）</p><p>以下是描述幻读的典型情况：</p><ol><li>事务A在Repeatable Read隔离级别下执行了一个查询操作，得到了一些行的结果集。</li><li>在事务A的查询操作完成之后，但事务A尚未提交或回滚时，事务B插入了新的记录，这些记录与事务A的查询条件匹配。</li><li>如果事务A再次执行相同的查询操作，它将会看到第一次查询中不存在的新记录，从而导致了幻读。</li></ol><p><strong>这种幻读可以通过InnoDB的MVCC机制解决，在InnoDB RR下不会出现这种幻读</strong></p><p>还有一种幻读的情况：</p><ol><li>在RR隔离级别下，事务A查询到某id没有记录值，准备进行插入，但这时事务B先插入了这个id的记录，并提交；</li><li>事务A插入时发现主键冲突无法插入造成幻读</li></ol><p><strong>这种幻读在RR隔离级别下，需要通过手动添加间隙锁来解决幻读问题，或者将隔离级别换为SERIALIZABLE</strong></p></blockquote><h3 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 <code>SQL标准</code> 中设立了4个 <code>隔离级别</code> ：</p><ul><li><code>READ UNCOMMITTED</code> ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。 </li><li><code>READ COMMITTED</code> ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。 </li><li><code>REPEATABLE READ</code> ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。 </li><li><code>SERIALIZABLE</code> ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。</li></ul><p><code>SQL标准</code> 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220708220917267.png" alt="image-20220708220917267"></p><p><code>脏写 </code>怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220708220957108.png" alt="image-20220708220957108" style="zoom:80%;"><h3 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h3><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220708221639979.png" alt="image-20220708221639979" style="float:left;"><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL 5.7.20的版本之前：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;tx_isolation&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"># 查看隔离级别，MySQL 5.7.20的版本及之后：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line">SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure><h3 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h3><p><strong>通过下面的语句修改事务的隔离级别：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ UNCOMMITTED</span><br><span class="line">&gt; READ COMMITTED</span><br><span class="line">&gt; REPEATABLE READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ-UNCOMMITTED</span><br><span class="line">&gt; READ-COMMITTED</span><br><span class="line">&gt; REPEATABLE-READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure><p><strong>关于设置时使用GLOBAL或SESSION的影响：</strong></p><ul><li><p>使用 GLOBAL 关键字（在全局范围影响）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET GLOBAL TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>当前已经存在的会话无效</li><li>只对执行完该语句之后产生的会话起作用</li></ul></li><li><p>使用 <code>SESSION</code> 关键字（在会话范围影响）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET SESSION TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>对当前会话的所有后续的事务有效</li><li>如果在事务之间执行，则对后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li></ul></li></ul><p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction_isolation</code>的值。比如，在启动服务器时指定了<code>transaction_isolation=SERIALIZABLE</code>，那么事务的默认隔离界别就从原来的<code>REPEATABLE-READ</code>变成了<code>SERIALIZABLE</code>。</p><blockquote><p>小结： </p><p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p></blockquote><h3 id="3-6-不同隔离级别举例"><a href="#3-6-不同隔离级别举例" class="headerlink" title="3.6 不同隔离级别举例"></a>3.6 不同隔离级别举例</h3><p>初始化数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE account;</span><br><span class="line">INSERT INTO account VALUES (1,&#x27;张三&#x27;,&#x27;100&#x27;), (2,&#x27;李四&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220708223250773.png" alt="image-20220708223250773" style="float:left;"><p><strong>演示1. 读未提交之脏读</strong></p><p>设置隔离级别为未提交读：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710193920008.png" alt="image-20220710193920008"></p><p>脏读就是指当前事务就在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。</p><p><strong>演示2：读已提交</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710194440101.png" alt="image-20220710194440101"></p><p><strong>演示3. 不可重复读</strong></p><p>设置隔离级别为可重复读，事务的执行流程如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710194144826.png" alt="image-20220710194144826"></p><p>当我们将当前会话的隔离级别设置为可重复读的时候，当前会话可以重复读，就是每次读取的结果集都相同，而不管其他事务有没有提交。但是在可重复读的隔离级别上会出现幻读的问题。</p><p><strong>演示4：幻读</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710194042096.png" alt="image-20220710194042096"></p><blockquote><p>当事务隔离级别为<strong>REPEATABLE-READ</strong>时：因为可重复读的原因，明明查询到id为3没有数据，可是却无法插入</p><p>当事务隔离级别为<strong>SERIALIZABLE</strong>时：因为加锁的原因，只有当前事务先<strong>进行了查询操作</strong>，那么另一个事务就无法插入数据，会进行等待操作，只能等待前一个事务提交或回滚后才能继续执行；若当前事务并<strong>没有执行过查询操作</strong>，那么下一个事务可以进行插入，但是前一个事务再次查询时却能看到多了数据，不会发生幻读（自己测试结果，不一定正确）</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710194612317.png" alt="image-20220710194612317" style="float:left;"><h2 id="4-事务的常见分类"><a href="#4-事务的常见分类" class="headerlink" title="4. 事务的常见分类"></a>4. 事务的常见分类</h2><p>从事务理论的角度来看，可以把事务分为以下几种类型：</p><ul><li>扁平事务（Flat Transactions） </li><li>带有保存点的扁平事务（Flat Transactions with Savepoints） </li><li>链事务（Chained Transactions） </li><li>嵌套事务（Nested Transactions） </li><li>分布式事务（Distributed Transactions）</li></ul><h1 id="第14章-MySQL事务日志"><a href="#第14章-MySQL事务日志" class="headerlink" title="第14章_MySQL事务日志"></a>第14章_MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由 <code>锁机制</code> 实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为 <code>重做日志 </code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO都可以视为是一种 <code>恢复操作</code>，但是：</p><ul><li>redo log: 是存储引擎层 (innodb) 生成的日志，记录的是<code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性。</li><li>undo log: 是存储引擎层 (innodb) 生成的日志，记录的是 <code>逻辑操作</code> 日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录<strong>一条与之相反的DELETE操作</strong>。主要用于 <code>事务的回滚</code> (undo log 记录的是每个修改操作的 <code>逆操作</code>) 和 <code>一致性非锁定读</code> (undo log 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li></ul><h2 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a>1. redo日志</h2><p><strong>只有InnoDB才有redo log</strong>。InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。所有的变更都必须<code>先更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘 (<code>checkPoint</code>机制)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><p>redo log维护事务的<strong>持久性</strong>（D）</p><h3 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a>1.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发</code> 的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含 <code>持久性</code> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题:</p><ul><li><p><strong>修改量与刷新磁盘工作量严重不成比例</strong></p><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个默认页面时16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是小题大做了。</p></li><li><p><strong>随机IO刷新较慢</strong></p><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面<code>刷新到磁盘</code>时，需要进行很多的<code>随机IO</code>，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p></li></ul><p><code>另一个解决的思路</code> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 <code>修改</code> 了哪些东西 <code>记录一下</code> 就好。<strong>比如，某个事务将系统表空间中第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2</strong> 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2 </p><p>InnoDB引擎的事务采用了WAL技术 (<code>Write-Ahead Logging</code>)，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710202517977.png" alt="image-20220710202517977"></p><blockquote><p>即立马刷新数据页会有<strong>修改量与刷新磁盘工作量严重不成比例</strong> 和 <strong>随机IO刷新较慢</strong>两个缺点，</p><p>所以采取先简单记录一下更新的地方，写入一个redo log文件，速度很快</p></blockquote><h3 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a>1.2 REDO日志的好处、特点</h3><h4 id="1-好处"><a href="#1-好处" class="headerlink" title="1. 好处"></a>1. 好处</h4><ul><li>redo日志降低了刷盘频率 </li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul><li><p><strong>redo日志是顺序写入磁盘的</strong></p><p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p></li><li><p><strong>事务执行过程中，redo log不断记录</strong></p><p><strong>redo log</strong>跟<strong>bin log</strong>的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p></li></ul><h3 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer)</code> ，保存在内存中，是易失的。</li></ul><p>在服务器启动时就会向操作系统申请了一大片称之为 redo log buffer 的 <code>连续内存</code> 空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分为若干个连续的<code>redo log block</code>。一个redo log block占用<code>512字节</code>大小。</p><blockquote><p>因为磁盘一个扇区的大小为512字节，若写入的数据超过512B，那么这次写入将不是原子性的（详见1.7 3）</p></blockquote><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710204114543.png" alt="image-20220710204114543"></p><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认 <code>16M</code> ，最大值是4096M，最小值为1M。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%innodb_log_buffer_size%&#x27;;</span><br><span class="line">+------------------------+----------+</span><br><span class="line">| Variable_name          | Value    |</span><br><span class="line">+------------------------+----------+</span><br><span class="line">| innodb_log_buffer_size | 16777216 |</span><br><span class="line">+------------------------+----------+</span><br></pre></td></tr></table></figure><ul><li><code>重做日志文件 (redo log file) </code>，保存在硬盘中，是持久的。</li></ul><p>REDO日志文件如图所示，其中<code>ib_logfile0</code>和<code>ib_logfile1</code>即为REDO日志。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710204427616.png" alt="image-20220710204427616"></p><h3 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a>1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710204810264-16574572910841.png" alt="image-20220710204810264"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</span><br><span class="line">第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</span><br><span class="line">第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</span><br><span class="line">第4步：定期将内存中修改的数据刷新到磁盘中</span><br></pre></td></tr></table></figure><blockquote><p>体会： Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h3 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a>1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以<code>一 定的频率</code>刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710205015302.png" alt="image-20220710205015302"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <code>文件系统缓存 （page cache）</code>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步） 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 第4步：定期将内存中修改的数据刷新到磁盘中 </li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </li><li><code>设置为2</code> ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710205948156.png" alt="image-20220710205948156" style="float:left;"><p>另外，InnoDB存储引擎有一个后台线程，每隔<code>1秒</code>，就会把<code>redo log buffer</code>中的内容写到文件系统缓存(<code>page cache</code>)，然后调用刷盘操作。（<font color="red">无论参数设置为多少都会在后台每隔一秒进行同步</font>）</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710210339724.png" alt="image-20220710210339724"></p><p>也就是说，一个没有提交事务的<code>redo log</code>记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 <code>redo log buffer</code>中，这些redo log 记录会被<code>后台线程</code>刷盘。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710210532805.png" alt="image-20220710210532805"></p><p>除了后台线程每秒<code>1次</code>的轮询操作，还有一种情况，当<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>（这个参数默认是16M）的<strong>一半</strong>的时候，后台线程会主动刷盘。</p><h3 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h3><h4 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1. 流程图"></a>1. 流程图</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710210751414.png" alt="image-20220710210751414" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710211318120.png" alt="image-20220710211318120" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710211335379.png" alt="image-20220710211335379" style="float:left;"><blockquote><p>小结innodb_flush_log_at_trx_commit&#x3D;2<br>为<code>2</code>时，只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存(<code>page cache</code>)。<br>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是操作系统宕机可能会有<code>1</code>秒数据的丢失，这种情况下无<br>法满足ACID中的D。但是数值2肯定是<strong>效率适中</strong>的。</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710211831675.png" alt="image-20220710211831675" style="float:left;"><blockquote><p>小结：innodb_flush_log_at_trx_commit&#x3D;0<br>为<code>0</code>时，master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。<br>(master thread,是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)<br>数值0的话，是一种折中的做法，它的IO效率理论是<strong>最高的</strong>，这种策略也有丢失数据的风险，也无法保证D。</p></blockquote><h4 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h4><p>比较innodb_flush_log_at_trx_commit对事务的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test_load(</span><br><span class="line">a INT,</span><br><span class="line">b CHAR(80)</span><br><span class="line">)ENGINE=INNODB;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER//</span><br><span class="line">CREATE PROCEDURE p_load(COUNT INT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE s INT UNSIGNED DEFAULT 1;</span><br><span class="line">DECLARE c CHAR(80) DEFAULT REPEAT(&#x27;a&#x27;,80);</span><br><span class="line">WHILE s&lt;=COUNT DO</span><br><span class="line">INSERT INTO test_load SELECT NULL, c;</span><br><span class="line">COMMIT;</span><br><span class="line">SET s=s+1;</span><br><span class="line">END WHILE;</span><br><span class="line">END //</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710215001482.png" alt="image-20220710215001482" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CALL p_load(30000);</span><br><span class="line">Query OK, 0 rows affected(1 min 23 sec)</span><br></pre></td></tr></table></figure><p><code>1 min 23 sec</code>的时间显然是不能接受的。而造成时间比较长的原因就在于fsync操作所需要的时间。</p><p>修改参数innodb_flush_log_at_trx_commit，设置为0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global innodb_flush_log_at_trx_commit = 0;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CALL p_load(30000);</span><br><span class="line">Query OK, 0 rows affected(38 sec)</span><br></pre></td></tr></table></figure><p>修改参数innodb_flush_log_at_trx_commit，设置为2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global innodb_flush_log_at_trx_commit = 2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CALL p_load(30000);</span><br><span class="line">Query OK, 0 rows affected(46 sec)</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710215353893.png" alt="image-20220710215353893" style="float:left;"><h3 id="1-7-写入redo-log-buffer-过程-了解"><a href="#1-7-写入redo-log-buffer-过程-了解" class="headerlink" title="1.7 写入redo log buffer 过程 了解"></a>1.7 写入redo log buffer 过程 了解</h3><h4 id="1-补充概念：Mini-Transaction"><a href="#1-补充概念：Mini-Transaction" class="headerlink" title="1. 补充概念：Mini-Transaction"></a>1. 补充概念：Mini-Transaction</h4><p>MySQL把对底层页面中的一次原子访问过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如，向某个索引对应的B+树中插入一条记录的过程就是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组redo日志，在进行崩溃恢复时这一组<code>redo</code>日志可以作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个 <code>mtr</code> 组成，每一个 <code>mtr</code> 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710220653131.png" alt="image-20220710220653131"></p><h4 id="2-redo-日志写入log-buffer"><a href="#2-redo-日志写入log-buffer" class="headerlink" title="2. redo 日志写入log buffer"></a>2. redo 日志写入log buffer</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710220838744.png" alt="image-20220710220838744" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710220919271.png" alt="image-20220710220919271"></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710221221981.png" alt="image-20220710221221981" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710221318271.png" alt="image-20220710221318271"></p><p>不同的事务可能是 <code>并发</code> 执行的，所以 T1 、 T2 之间的 mtr 可能是 <code>交替执行</code> 的。没当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当做一个整体来画）：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710221620291.png" alt="image-20220710221620291"></p><p>有的mtr产生的redo日志量非常大，比如<code>mtr_t1_2</code>产生的redo日志占用空间比较大，占用了3个block来存储。</p><h4 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3. redo log block的结构图"></a>3. redo log block的结构图</h4><p>一个redo log block是由<code>日志头、日志体、日志尾</code>组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据是512-12-8&#x3D;492字节。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220710223117420.png" alt="image-20220710223117420" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220710223135374.png" alt="image-20220710223135374"></p><p>真正的redo日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓<code>管理信息</code>都有什么。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711144546439.png" alt="image-20220711144546439"></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711144608223.png" alt="image-20220711144608223" style="float:left;"><h3 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h3><h4 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1. 相关参数设置"></a>1. 相关参数设置</h4><ul><li><p><code>innodb_log_group_home_dir</code> ：指定 redo log 文件组所在的路径，默认值为 <code>./</code> ，表示在数据库 的数据目录下。MySQL的默认数据目录（ <code>var/lib/mysql</code>）下默认有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志 文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1… iblogfilen。默认2个，最大100个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_log_files_in_group&#x27;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| innodb_log_files_in_group | 2     |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">#ib_logfile0</span><br><span class="line">#ib_logfile1</span><br></pre></td></tr></table></figure></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为1。</p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 <code>48M</code> 。最大值为512G，注意最大值 指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大 于最大值512G。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_log_file_size&#x27;;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Variable_name        | Value    |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| innodb_log_file_size | 50331648 |</span><br><span class="line">+----------------------+----------+</span><br></pre></td></tr></table></figure></li></ul><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/my.cnf</span><br><span class="line">innodb_log_file_size=200M</span><br></pre></td></tr></table></figure><blockquote><p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log 数组和大小。但也不推荐 redo log 设置过大，在MySQL崩溃时会重新执行REDO日志中的记录。</p></blockquote><h4 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2. 日志文件组"></a>2. 日志文件组</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711152137012.png" alt="image-20220711152137012" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711152242300.png" alt="image-20220711152242300"></p><p>总共的redo日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group</code> 。</p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。</p><h4 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3. checkpoint"></a>3. checkpoint</h4><p>在整个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p><ul><li><code>write pos</code>是当前记录的位置，一边写一边后移</li><li><code>checkpoint</code>是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把check point后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711152631108.png" alt="image-20220711152631108" style="zoom:80%;"><p>如果 write pos 追上 checkpoint ，表示<code>日志文件组</code>满了，这时候不能再写入新的 redo log记录，MySQL 得 停下来，清空一些记录，把 checkpoint 推进一下。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711152802294.png" alt="image-20220711152802294" style="zoom:80%;"><h3 id="1-9-redo-log-小结"><a href="#1-9-redo-log-小结" class="headerlink" title="1.9 redo log 小结"></a>1.9 redo log 小结</h3><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711152930911.png" alt="image-20220711152930911" style="float:left;"><h2 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a>2. Undo日志</h2><p>redo log是事务持久性的保证，undo log是事务<strong>原子性</strong>（A）的保证。在事务中 <code>更新数据</code> 的 <code>前置操作</code> 其实是要先写入一个 <code>undo log</code> 。</p><h3 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a>2.1 如何理解Undo日志</h3><p>事务需要保证 <code>原子性 </code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code> 服务器本身的错误</code> ， <code>操作系统错误</code> ，甚至是突然 <code>断电</code> 导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <code>回滚</code> ，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合 <code>原子性</code> 要求。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711153523704.png" alt="image-20220711153523704" style="float:left;"><p>此外，undo log<code>会产生redo log</code>,也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h3 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a>2.2 Undo日志的作用</h3><ul><li><strong>作用1：回滚数据</strong></li></ul><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711153645204.png" alt="image-20220711153645204" style="float:left;"><blockquote><p>并不是物理上恢复之前的效果，知识逻辑、效果上看起来是之前的效果</p></blockquote><ul><li><strong>作用2：MVCC</strong></li></ul><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录以及被其他事务占用，<strong>当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取</strong>。</p><blockquote><p>大致理解：</p><p>Innodb每一行数据都有一个回滚指针（InnoDB三个隐藏列中的回滚指针，详情看2.5 2），用于指向该行修改前的最后一个历史版本，这个历史版本存放在undo log中，如果要执行更新操作，会将原纪录放入undo log，并通过隐藏的回滚指针指向undo log中的原纪录。其他事务此时需要查询时，就是查询undo log中这行数据的最后一个历史版本。（详情看2.3 3.回滚段中的数据分类）</p></blockquote><h3 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h3><h4 id="1-回滚段与undo页"><a href="#1-回滚段与undo页" class="headerlink" title="1. 回滚段与undo页"></a>1. 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 <code>回滚段（rollback segment）</code> 。每个回滚段记录了 <code>1024</code> 个 <code>undo log segment</code> ，而在每个undo log segment段中进行 <code>undo页</code> 的申请。</p><ul><li>在<code> InnoDB1.1版本之前</code> （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 <code>1024</code> 。虽然对绝大多数的应用来说都已经够用。 </li><li>从1.1版本开始InnoDB支持最大 <code>128个rollback segment</code> ，故其支持同时在线的事务限制提高到 了 <code>128*1024</code> 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_rollback_segments&#x27;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_rollback_segments | 128   |</span><br><span class="line">+--------------------------+-------+</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711154936382.png" alt="image-20220711154936382" style="float:left;"><p>第二个参数在mysql8种是<strong>innodb_rollback_segments</strong></p><h5 id="undo页的重用"><a href="#undo页的重用" class="headerlink" title="undo页的重用"></a>undo页的重用</h5><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711155044078.png" alt="image-20220711155044078" style="float:left;"><h4 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2. 回滚段与事务"></a>2. 回滚段与事务</h4><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会<strong>覆盖最初的盘区</strong>或者在回滚段<strong>允许的情况下扩展新的盘区</strong>来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在<strong>多个</strong>undo表空间，但<strong>同一时刻</strong>只能使用<strong>一个</strong> undo表空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_undo_tablespaces&#x27;;</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| innodb_undo_tablespaces | 2     |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line"># undo log的数量，最少为2. undo log的truncate操作有purge协调线程发起。在truncate某个undo log表空间的过程中，保证有一个可用的undo log可用。</span><br></pre></td></tr></table></figure></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入链表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用（低于3&#x2F;4），若可以分配给下个事务使用</li></ul></li></ol><h4 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3. 回滚段中的数据分类"></a>3. 回滚段中的数据分类</h4><ol><li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li><li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，就优先覆盖“事务已经提交并过期的数据”。</li></ol><p>事务提交后不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log以undo log所在页由purge线程来判断，<strong>因为可能有别的事务正在访问之前的版本</strong>。</p><h3 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><p>insert undo log</p><p>insert undo log是指insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p></li><li><p>update undo log</p><p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供<strong>MVCC</strong>机制，因此不能在事务提交时就进行删除。提交时放入undo log<strong>链表</strong>，等待purge线程决定清除的行为，然后才进行最后的删除。</p></li></ul><h3 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h3><h4 id="1-简要生成过程"><a href="#1-简要生成过程" class="headerlink" title="1. 简要生成过程"></a>1. 简要生成过程</h4><p>以下是undo+redo事务的简化过程</p><p>假设有两个数值，分别为A&#x3D;1和B&#x3D;2，然后将A修改为3，B修改为4</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711162414928.png" alt="image-20220711162414928" style="float:left;"><p><strong>只有Buffer Pool的流程：</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711162505008.png" alt="image-20220711162505008"></p><p><strong>有了Redo Log和Undo Log之后：</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711162642305.png" alt="image-20220711162642305"></p><p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p><h4 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711162919157.png" alt="image-20220711162919157" style="float:left;"><p><strong>当我们执行INSERT时：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">INSERT INTO user (name) VALUES (&quot;tom&quot;);</span><br></pre></td></tr></table></figure><p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…，那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711163725129.png" alt="image-20220711163725129"></p><p><strong>当我们执行UPDATE时：</strong></p><p>对应更新的操作会产生update undo log，并且会分更新主键和不更新主键的，假设现在执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user SET name=&quot;Sun&quot; WHERE id=1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711164138414.png" alt="image-20220711164138414"></p><p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log（undo no&#x3D;0）。</p><p>假设现在执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user SET id=2 WHERE id=1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711164421494.png" alt="image-20220711164421494"></p><p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增。</p><p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号<code>依次向前推</code>，就可以找到我们的原始数据了。</p><h4 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3. undo log是如何回滚的"></a>3. undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除 </li><li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </li><li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </li><li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li></ol><h4 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4. undo log的删除"></a>4. undo log的删除</h4><ul><li><p>针对于insert undo log</p><p>因为<strong>insert</strong>操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在<strong>事务提交后直接删除</strong>，不需要进行purge操作。</p></li><li><p>针对于update undo log</p><p><strong>update和delete</strong>的undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时<strong>放入undo log链表</strong>，等待purge线程<strong>决定清除的行为</strong>（可能有其它事务在访问undo链上的数据，删除的话是看<code>重用</code>还是<code>删除</code>），然后才进行最后的删除。</p></li></ul><blockquote><p>补充：</p><p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清理page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种“假删除”，只是做了个标记，真正的删除工作需要后台purge线程去完成。</p></blockquote><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711165612956.png" alt="image-20220711165612956"></p><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p><h1 id="第15章-锁"><a href="#第15章-锁" class="headerlink" title="第15章_锁"></a>第15章_锁</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻<code>最多只有一个线程</code>在访问，保证数据的<code>完整性</code>和<code>一致性</code>。在开发过程中加锁是为了保证数据的一致性，这个思相在据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code> ，因此产生了 <code>锁</code> 。同时 <code>锁机制</code> 也为实现MySQL 的各个隔离级别提供了保证。 <code>锁冲突</code> 也是影响数据库 <code>并发访问性能</code> 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p><h3 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h3><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h3 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h3><p><code>写-写</code> 情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生 <code>脏写</code> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 <code>排队执行</code> ，这个排队的过程其实是通过 <code>锁</code> 来实现的。这个所谓的锁其实是一个内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，如图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711181120639.png" alt="image-20220711181120639"></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构</code> ，当没有的时候 就会在内存中生成一个 <code>锁结构</code> 与之关联。比如，事务<code> T1</code> 要对这条记录做改动，就需要生成一个 <code>锁结构</code> 与之关联：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711192633239.png" alt="image-20220711192633239"></p><p>在<code>锁结构</code>里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：</p><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待。</li></ul><p>在事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称值为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。</p><p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711193732567.png" alt="image-20220711193732567"></p><p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果就是这样。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711194904328.png" alt="image-20220711194904328"></p><p>小结几种说法：</p><ul><li><p>不加锁</p><p>意思就是不需要在内存中生成对应的 <code>锁结构</code> ，可以直接执行操作。</p></li><li><p>获取锁成功，或者加锁成功</p><p>意思就是在内存中生成了对应的 <code>锁结构</code> ，而且锁结构的 <code>is_waiting</code> 属性为 <code>false</code> ，也就是事务 可以继续执行操作。</p></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><p>意思就是在内存中生成了对应的 <code>锁结构</code> ，不过锁结构的 <code>is_waiting</code> 属性为 <code>true</code> ，也就是事务 需要等待，不可以继续执行操作。</p></li></ul><h3 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h3><p><code>读-写</code> 或 <code>写-读 </code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <code>脏读 、 不可重复读 、 幻读</code> 的问题。</p><p>各个数据库厂商对 <code>SQL标准</code> 的支持都可能不一样。比如MySQL在 <code>REPEATABLE READ</code> 隔离级别上就已经解决了 <code>幻读</code> 问题。</p><h3 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h3><p>怎么解决 <code>脏读 、 不可重复读 、 幻读</code> 这些问题呢？其实有两种可选的解决方案：</p><ul><li>⭐方案一：读操作利用多版本并发控制（ <code>MVCC</code> ，下章讲解），写操作进行 <code>加锁</code> 。</li></ul><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711202206405.png" alt="image-20220711202206405" style="float:left;"><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中<strong>每次执行SELECT操作时都会生成一个ReadView</strong>，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code> ，也就是避免了脏读现象；</li><li>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 <strong>第一次执行SELECT操作才会生成一个ReadView</strong>，之后的SELECT操作都 <code>复用</code> 这个ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><ul><li>方案二：读、写操作都采用 <code>加锁</code> 的方式。</li></ul><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711203250284.png" alt="image-20220711203250284" style="float:left;"><ul><li><p>小结对比发现：</p><ul><li>采用 <code>MVCC</code> 方式的话， 读-写 操作彼此并不冲突， <strong>性能更高</strong> 。</li><li>采用 <code>加锁</code> 方式的话， 读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li></ul><p>一般情况下我们当然愿意采用 <code>MVCC</code> 来解决 <code>读-写</code> 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <code>加锁 </code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p></li></ul><h2 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h2><p>锁的分类图，如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711203519162.png" alt="image-20220711203519162"></p><h3 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h3><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711203723941.png" alt="image-20220711203723941" style="float:left;"><ul><li><code>读锁</code> ：也称为 <code>共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code> ：也称为 <code>排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711204843684.png" alt="image-20220711204843684" style="float:left;"><h4 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1. 锁定读"></a>1. 锁定读</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711212931912.png" alt="image-20220711212931912" style="float: left; zoom: 150%;"><blockquote><p>for share 和 for update 不仅加上S锁和X锁，还会加上<strong>意向锁</strong>（具体见3.2 1 ②）</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711213741630.png" alt="image-20220711213741630" style="float: left; zoom: 150%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where c1 = 2 for update nowait/skip locked</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711214013208.png" alt="image-20220711214013208" style="float:left;"><h4 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711214412163.png" alt="image-20220711214412163" style="float: left; zoom: 150%;"><blockquote><ol><li>执行<strong>insert</strong>语句，对要操作的页加RW-X-LATCH，然后<strong>判断是否有和插入意向锁冲突的锁(别的事务的间隙锁)<strong>，如果</strong>有</strong>，加插入意向锁，进入锁等待，如果<strong>没有</strong>，直接写数据，不加任何锁(隐式锁)，结束后释放RW-X-LATCH；</li><li>执行<strong>select … lock in share mode</strong>语句，对要操作的页加RW-X-LATCH，如果页面上存在RW-X-LATCH会被阻塞，没有的话则判断记录上是否有活跃的事务，如果<strong>存在</strong>，则<strong>为insert事务创建一个排他记录锁</strong>，并将自己加入锁等待队列，最后也会释放RW-X-LATCH</li></ol><p>详见3.4 1 隐式锁</p></blockquote><blockquote><p><strong>innodb行级锁</strong>是通过锁索引记录实现的，如果<strong>更新</strong>的列<strong>没建索引是会锁住整个表</strong>的。</p></blockquote><h3 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711214719510.png" alt="image-20220711214719510" style="float:left;"><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1. 表锁（Table Lock）"></a>1. 表锁（Table Lock）</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711214805088.png" alt="image-20220711214805088" style="float:left;"><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>一般情况下，<strong>不会使用</strong>InnoDB存储引擎提供的表级别的 <code>S锁</code> 和 <code>X锁</code> 。只会在一些特殊情况下，比方说 <code>崩溃恢复</code> 过程中用到。比如，在系统变量 <code>autocommit=0，innodb_table_locks = 1</code> 时， 手动获取 InnoDB存储引擎提供的表t 的 <code>S锁</code> 或者 <code>X锁</code> 可以这么写：</p><ul><li><p><code>LOCK TABLES t READ</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>S锁 </code>。</p></li><li><p><code>LOCK TABLES t WRITE</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>X锁</code> 。</p></li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用 <code>LOCK TABLES</code> 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 <code>行锁</code> ，关于 InnoDB表级别的 <code>S锁</code> 和<code> X锁</code> 大家了解一下就可以了。</p><p><strong>举例：</strong>下面我们讲解<strong>MyISAM</strong>引擎下的表锁。</p><p>步骤1：创建表并添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mylock(</span><br><span class="line">id INT NOT NULL PRIMARY KEY auto_increment,</span><br><span class="line">NAME VARCHAR(20)</span><br><span class="line">)ENGINE myisam;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line">INSERT INTO mylock(NAME) VALUES(&#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line"># 查询表中所有数据</span><br><span class="line">SELECT * FROM mylock;</span><br><span class="line">+----+------+</span><br><span class="line">| id | Name |</span><br><span class="line">+----+------+</span><br><span class="line">| 1  | a    |</span><br><span class="line">+----+------+</span><br></pre></td></tr></table></figure><p>步骤二：查看表上加过的锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES; # 主要关注In_use字段的值</span><br><span class="line">或者</span><br><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711220342251.png" alt="image-20220711220342251" style="float:left;"><p>或者</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711220418859.png" alt="image-20220711220418859" style="float:left;"><p>上面的结果表明，当前数据库中没有被锁定的表</p><p>步骤3：手动增加表锁命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t READ; # 存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或S锁（Share的缩写）</span><br><span class="line">LOCK TABLES t WRITE; # 存储引擎会对表t加表级别的排他锁。排他锁也叫独占锁、写锁或X锁（exclusive的缩写）</span><br></pre></td></tr></table></figure><p>比如：</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711220442269.png" alt="image-20220711220442269" style="float:left;"><p>步骤4：释放表锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES; # 使用此命令解锁当前加锁的表</span><br></pre></td></tr></table></figure><p>比如：</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711220502141.png" alt="image-20220711220502141" style="float:left;"><p>步骤5：加读锁</p><p>我们为mylock表加read锁（读阻塞写），观察阻塞的情况，流程如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711220553225.png" alt="image-20220711220553225"></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711220616537.png" alt="image-20220711220616537"></p><p>步骤6：加写锁</p><p>为mylock表加write锁，观察阻塞的情况，流程如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711220711630.png" alt="image-20220711220711630"></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711220730112.png" alt="image-20220711220730112"></p><p>总结：</p><p><strong>MyISAM</strong>在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。<strong>InnoDB存储引擎是不会为这个表添加表级别的读锁和写锁</strong>的。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p><ul><li><p>表共享读锁（Table Read Lock）</p></li><li><p>表独占写锁（Table Write Lock）</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220711220929248.png" alt="image-20220711220929248"></p></li></ul><h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p>InnoDB 支持 <code>多粒度锁（multiple granularity locking）</code> ，它允许 <code>行级锁</code> 与 <code>表级锁</code> 共存，而<code>意向锁</code>就是其中的一种 <code>表锁</code> 。</p><ol><li>意向锁的存在是为了<strong>协调行锁和表锁的关系</strong>，支持多粒度（表锁和行锁）的锁并存。</li><li>意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</li><li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li></ol><p>意向锁分为两种：</p><ul><li><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure></li><li><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure></li></ul><p>即：意向锁是由存储引擎 <code>自己维护的</code> ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前， InooDB 会先获取该数据行 <code>所在数据表的对应意向锁</code> 。</p><p><strong>1. 意向锁要解决的问题</strong></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220711222132300.png" alt="image-20220711222132300" style="float:left;"><p><strong>举例：</strong>创建表teacher,插入6条数据，事务的隔离级别默认为<code>Repeatable-Read</code>，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">    `name` varchar(255) NOT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line">INSERT INTO `teacher` VALUES</span><br><span class="line">(&#x27;1&#x27;, &#x27;zhangsan&#x27;),</span><br><span class="line">(&#x27;2&#x27;, &#x27;lisi&#x27;),</span><br><span class="line">(&#x27;3&#x27;, &#x27;wangwu&#x27;),</span><br><span class="line">(&#x27;4&#x27;, &#x27;zhaoliu&#x27;),</span><br><span class="line">(&#x27;5&#x27;, &#x27;songhongkang&#x27;),</span><br><span class="line">(&#x27;6&#x27;, &#x27;leifengyang&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><p>假设事务A获取了某一行的排他锁，并未提交，语句如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 6 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>事务B想要获取teacher表的表读锁，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220712124209006.png" alt="image-20220712124209006" style="float:left;"><blockquote><p>意向锁之间是<strong>互相兼容</strong>的:</p><p>因为意向锁是由行级锁产生的，行行之间本就没有关联，若是行号相等，互斥的也是行级锁而不是意向锁</p><p>与意向锁互斥的是<strong>表锁</strong>：</p><p>因为意向锁是表级锁，是为了示意该表中已经有某些行上了行锁（行X或S锁）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 6 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>此时teacher表存在两把锁：teacher表上的意向排他锁与id未6的数据行上的排他锁。事务B想要获取teacher表的共享锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>此时事务B检测事务A持有teacher表的意向排他锁，就可以得知事务A必须持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被排斥（阻塞），<strong>而无需去检测表中的每一行数据是否存在排他锁</strong>。</p><p><strong>意向锁的并发性</strong></p><p><strong>意向锁不会与行级的 共享 &#x2F; 排他锁互斥</strong>！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p><p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）。</p><p>事务A先获得了某一行的排他锁，并未提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 6 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>事务A获取了teacher表上的意向排他锁。事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表上的共享锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>事务B检测到事务A持有teacher表的意向排他锁。事务B对teacher表的加锁请求被阻塞（排斥）。最后事务C也想获取teacher表中某一行的排他锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 5 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>事务C申请teacher表的意向排他锁。事务C检测到事务A持有teacher表的意向排他锁。因为意向锁之间并不互斥，所以事务C获取到了teacher表的意向排他锁。因为id为5的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的排他锁。</p><p><strong>从上面的案例可以得到如下结论：</strong></p><ol><li>InnoDB 支持 <code>多粒度锁</code> ，特定场景下，行级锁可以与表级锁共存。 </li><li><strong>意向锁之间互不排斥</strong>，但除了 IS 与 S 兼容外， <code>意向锁会与 表级共享锁 / 排他锁 互斥</code> 。 </li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。 </li><li>意向锁在保证并发性的前提下，实现了 <code>行锁和表锁共存</code> 且 <code>满足事务隔离性</code> 的要求。</li></ol><h5 id="③-自增锁（AUTO-INC锁）了解"><a href="#③-自增锁（AUTO-INC锁）了解" class="headerlink" title="③ 自增锁（AUTO-INC锁）了解"></a>③ 自增锁（AUTO-INC锁）了解</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 <code>AUTO_INCREMENT</code> 属性。举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` varchar(255) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改 如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `teacher` (name) VALUES (&#x27;zhangsan&#x27;), (&#x27;lisi&#x27;);</span><br></pre></td></tr></table></figure><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | zhangsan |</span><br><span class="line">| 2  | lisi     |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是 “ <code>Simple inserts</code> ”，“ <code>Bulk inserts</code> ”和“ <code>Mixed-mode inserts </code>”。</p><p><strong>1. “Simple inserts” （简单插入）</strong></p><p>可以 <code>预先确定要插入的行数</code> （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和 <code>REPLACE</code> 语句。比如我们上面举的例子就属于该类插入，<strong>已经确定要插入的行数</strong>。</p><p><strong>2. “Bulk inserts” （批量插入）</strong></p><p><code>事先不知道要插入的行数</code> （和所需自动递增值的数量）的语句。比如 <code>INSERT ... SELECT</code> ， <code>REPLACE ... SELECT</code> 和 <code>LOAD DATA</code> 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列</p><p><strong>3. “Mixed-mode inserts” （混合模式插入）</strong></p><p>这些是“Simple inserts”语句但是指定<strong>部分新行</strong>的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code> 只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220712175552985.png" alt="image-20220712175552985" style="float:left;"><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 <code>限制并发</code> 能力。</p><p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p><p>在 MySQL 8.0 之前，连续锁定模式是 <code>默认</code> 的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在 <code>mutex（轻量锁）</code> 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p><p>从 MySQL 8.0 开始，交错锁模式是 <code>默认</code> 设置。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，但是当使用基于语句的<strong>复制或恢复</strong>方案时，<strong>从二进制日志bin log重播SQL语句时，这是不安全的。</strong></p><p>在此锁定模式下，自动递增值 <code>保证</code> 在所有并发执行的所有类型的insert语句中是 <code>唯一</code> 且 <code>单调递增</code> 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p>如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了”Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然后，当执行”bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p><h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 <code>表结构做变更</code> ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><blockquote><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 <code>S锁</code> 或者 <code>X锁</code> 的。在对某个表执行一些诸如 <code>ALTER TABLE 、 DROP TABLE</code> 这类的 DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 <code>DDL</code> 语句也会 发生阻塞。这个过程其实是通过在 server层使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ， 简称 MDL ）结构来实现的。</p></blockquote><p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。</p><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删查改。读写锁之间、写锁之间都是互斥的，用来保证变更表结构操作的安全性，解决了DML、DDL和DDL操作之间的一致性问题。<code>不需要显式使用</code>，在访问一个表的时候会被自动加上。</p><p><strong>举例：元数据锁的使用场景模拟</strong></p><p><strong>会话A：</strong>从表中查询数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; SELECT COUNT(1) FROM teacher;</span><br><span class="line">+----------+</span><br><span class="line">| COUNT(1) |</span><br><span class="line">+----------+</span><br><span class="line">| 2        |</span><br><span class="line">+----------+</span><br><span class="line">1 row int set (7.46 sec)</span><br></pre></td></tr></table></figure><p><strong>会话B：</strong>修改表结构，增加新列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; alter table teacher add age int not null;</span><br></pre></td></tr></table></figure><p><strong>会话C：</strong>查看当前MySQL的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713142808924.png" alt="image-20220713142808924"></p><p>通过会话C可以看出会话B被阻塞，这是由于会话A拿到了teacher表的元数据读锁，会话B想申请teacher表的元数据写锁，由于读写锁互斥，会话B需要等待会话A释放元数据锁才能执行。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713143156759.png" alt="image-20220713143156759" style="float:left;"><blockquote><p>在InnoDB存储引擎下，一个<strong>事务</strong>中的SQL语句”SELECT xxx FOR SHARE&#x2F;UPDATE”会添加一个行级锁，并且可能会添加意向锁（Intention Lock），间接自动添加元数据读锁（Metadata Lock）。</p></blockquote><h4 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a>2. InnoDB中的行锁</h4><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录 row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现</strong>。</p><blockquote><p><strong>innodb行级锁</strong>是通过锁索引记录实现的，如果<strong>更新</strong>的列<strong>没建索引是会锁住整个表</strong>的。</p></blockquote><blockquote><p>表锁是MySQL最基本的锁策略，不依赖于存储引擎</p></blockquote><p><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</p><p><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p><p>InnoDB与MyISAM的最大不同有两点：一是<strong>支持事务</strong>（TRANSACTION）；二是采用了<strong>行级锁</strong>。</p><p>首先我们创建表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    class VARCHAR(10),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>向这个表里插入几条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student VALUES</span><br><span class="line">(1, &#x27;张三&#x27;, &#x27;一班&#x27;),</span><br><span class="line">(3, &#x27;李四&#x27;, &#x27;一班&#x27;),</span><br><span class="line">(8, &#x27;王五&#x27;, &#x27;二班&#x27;),</span><br><span class="line">(15, &#x27;赵六&#x27;, &#x27;二班&#x27;),</span><br><span class="line">(20, &#x27;钱七&#x27;, &#x27;三班&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713161549241.png" alt="image-20220713161549241" style="float:left;"><p>student表中的聚簇索引的简图如下所示。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713163353648.png" alt="image-20220713163353648"></p><p>这里把B+树的索引结构做了超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p><h5 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a>① 记录锁（Record Locks）</h5><p>记录锁也就是仅仅把一条记录锁，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比如我们把id值为8的那条记录加一个记录锁的示意图如果所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713164811567.png" alt="image-20220713164811567"></p><p>举例如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713164948405.png" alt="image-20220713164948405"></p><p>记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><h5 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a>② 间隙锁（Gap Locks）</h5><blockquote><p>RR隔离级别才有</p></blockquote><p><code>MySQL</code> 在 <code>REPEATABLE READ</code> 隔离级别下是可以解决<strong>幻读问题的，解决方案有两种，可以使用 <code>MVCC</code> 方 案解决，也可以采用 <code>加锁 </code>方案解决</strong>。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 <code>幻影记录</code> 加上 <code>记录锁</code> 。InnoDB提出了一种称之为 <code>Gap Locks</code> 的锁，官方的类型名称为：<code> LOCK_GAP</code> ，我们可以简称为 <code>gap锁</code> 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713171650888.png" alt="image-20220713171650888"></p><p>图中id值为8的记录加了gap锁，意味着 <code>不允许别的事务在id值为8的记录前边的间隙插入新记录</code> ，其实就是 id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新 记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入 操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的。</strong> </p><p><strong>间隙锁不互斥</strong>：虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），<strong>并不会限制其他事务对这条记录加记录锁或者继续加gap锁</strong>。</p><p><strong>举例：</strong></p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>select * from student where id&#x3D;5 lock in share mode;</td><td></td></tr><tr><td></td><td>select * from student where id&#x3D;5 for update;</td></tr></tbody></table><p>这里session2并不会被堵住。**因为表里并没有id&#x3D;5这条记录，因此session1加的是间隙锁(3,8)**。而session2也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙锁，不允许插入值。但，它们之间是不冲突的。</p><blockquote><p>若使用select xxx where id &#x3D; xxx <strong>for update</strong> &#x2F; <strong>for share</strong> 查询语句，若是<strong>存在的记录</strong>，将会给对应的行加上<strong>行锁（记录锁）</strong>，若是<strong>对应的行不存在</strong>，则会加上范围为紧邻两条数据之间（例如(3,8)）的<strong>间隙锁</strong>，导致其他事务操作时(3,8)之间的id都不能添加成功，若添加的间隙锁大于最大记录，则间隙锁的范围为**(最大记录,+∞)**</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713174726264.png" alt="image-20220713174726264" style="float:left;"><ul><li><code>Infimum</code>记录，表示该页面中最小的记录。</li><li><code>Supremun</code>记录，表示该页面中最大的记录。</li></ul><p>为了实现阻止其他事务插入id值再(20,正无穷)这个区间的新纪录，我们可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的Supremun记录加上一个gap锁，如图所示。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713174108634.png" alt="image-20220713174108634"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student where id &gt; 20 lock in share mode;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>检测：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713174551814.png" alt="image-20220713174551814"></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713174602102.png" alt="image-20220713174602102"></p><p><strong>但是间隙锁容易引发死锁问题</strong></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713175032619.png" alt="image-20220713175032619" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713192418730.png" alt="image-20220713192418730" style="float:left;"><blockquote><p>因为<strong>间隙锁不互斥</strong>，两个事务都能对同一范围添加了间隙锁，那么两个事务的添加操作都会阻塞，引发死锁问题</p><p>MySQL的解决：①超时机制②一方主动回滚（详见3.6）</p></blockquote><h5 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a>③ 临键锁（Next-Key Locks）</h5><p>有时候我们既想 <code>锁住某条记录</code> ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， innodb默认的锁就是Next-Key locks。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713192549340.png" alt="image-20220713192549340"></p><p><code>next-key锁</code>的本质就是<strong>一个<code>记录锁</code>和一个<code>gap锁</code>的合体</strong>，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from student where id &lt;=8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure><h5 id="④插入意向锁（Insert-Intention-Locks）"><a href="#④插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④插入意向锁（Insert Intention Locks）"></a>④插入意向锁（Insert Intention Locks）</h5><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713203124889.png" alt="image-20220713203124889" style="float:left;"><blockquote><p>插入意向锁不是意向锁，而是属于<strong>间隙锁</strong>，是一种行锁，主要是在插入insert时自动产生</p><p>插入意向锁是一种间隙锁形式的意向锁，在真正执行 INSERT 操作之前设置。<br>当执行插入操作时，总会检查当前插入操作的下一条记录（已存在的主索引节点）上是否存在gap锁对象，判断是否锁住了 gap，如果锁住了，则判定和插入意向锁冲突，当前插入操作就需要<strong>等待</strong>，也就是配合上面的间隙锁或者临键锁一起防止了幻读操作。</p><p>插入意向锁之间不会互相冲突，多个插入操作同时插入同一个 gap 时，无需互相等待，比如当前索引上有记录 4 和 8，两个并发 session 同时插入记录 6，7。他们会分别为(4,8)加上 GAP 锁，但相互之间并不冲突</p><p>插入意向锁主要起一个<strong>等待的作用</strong>，若是多个插入意向锁在同一间隙进行锁等待，如果索引等因素上没有冲突，两个事务将会并发插入成功，若是有冲突，则为先排队的那个事务插入执行成功后上锁</p></blockquote><blockquote><ol><li>执行<strong>insert</strong>语句，对要操作的页加RW-X-LATCH，然后<strong>判断是否有和插入意向锁冲突的锁(别的事务的间隙锁)<strong>，如果</strong>有</strong>，加插入意向锁，进入锁等待，如果<strong>没有</strong>，直接写数据，不加任何锁(隐式锁)，结束后释放RW-XLATCH；</li><li>执行<strong>select … lock in share mode</strong>语句，对要操作的页加RW-X-LATCH，如果页面上存在RW-X-LATCH会被阻塞，没有的话则判断记录上是否有活跃的事务，如果<strong>存在</strong>，则<strong>为insert事务创建一个排他记录锁</strong>，并将自己加入锁等待队列，最后也会释放RW-X-LATCH</li></ol><p>详见3.4 1 隐式锁</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713203532124.png" alt="image-20220713203532124" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713203619704.png" alt="image-20220713203619704" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713203714577.png" alt="image-20220713203714577" style="float:left;"><h4 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3. 页锁"></a>3. 页锁</h4><p>页锁就是在 <code>页的粒度</code> 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间， <code>锁空间的大小是有限的</code> 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 <code>锁升级</code> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h3 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a>3.3 从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待 <code>数据并发的思维方式</code> 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 <code>设计思想</code> 。</p><h4 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1. 悲观锁（Pessimistic Locking）"></a>1. 悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 <code>阻塞</code> 直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是悲观锁思想的实现。</p><p><strong>秒杀案例1：</strong></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713204544767.png" alt="image-20220713204544767" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713205010502.png" alt="image-20220713205010502" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713205135694.png" alt="image-20220713205135694" style="float:left;"><h4 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2. 乐观锁（Optimistic Locking）"></a>2. 乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用 <code>版本号机制</code> 或者 <code>CAS机制</code> 实现。<strong>乐观锁适用于多读的应用类型， 这样可以提高吞吐量</strong>。在Java中<code> java.util.concurrent.atomic</code> 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>1. 乐观锁的版本号机制</strong></p><p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version=version+1 WHERE version=version</code> 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p>这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p><p><strong>2. 乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713210951100.png" alt="image-20220713210951100" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713211139670.png" alt="image-20220713211139670" style="float:left;"><h4 id="3-两种锁的适用场景"><a href="#3-两种锁的适用场景" class="headerlink" title="3. 两种锁的适用场景"></a>3. 两种锁的适用场景</h4><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li><code>乐观锁</code> 适合 <code>读操作多</code> 的场景，相对来说写的操作比较少。它的优点在于 <code>程序实现</code> ， <code>不存在死锁</code> 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li><li><code>悲观锁</code> 适合 <code>写操作多</code> 的场景，因为写的操作具有 <code>排它性</code> 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 <code>读 - 写</code> 和 <code>写 - 写</code> 的冲突。</li></ol><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713211417909.png" alt="image-20220713211417909" style="float:left;"><h3 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a>3.4 按加锁的方式划分：显式锁、隐式锁</h3><h4 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1. 隐式锁"></a>1. 隐式锁</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713211525845.png" alt="image-20220713211525845" style="float:left;"><ul><li><strong>情景一</strong>：对于聚簇索引记录来说，有一个 <code>trx_id</code> 隐藏列，该隐藏列记录着最后改动该记录的 <code>事务 id</code> 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是当前事务的事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，<strong>首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务</strong>，如果<strong>是</strong>的话，那么就<strong>帮助当前事务创建一个 X 锁</strong> （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后<strong>自己进入等待状态</strong> （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li><li><strong>情景二</strong>：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 <code>PAGE_MAX_TRX_ID</code> 属性，该属性代表对该页面做改动的最大的 <code>事务id</code> ，如果 PAGE_MAX_TRX_ID 属性值<strong>小于</strong>当前最小的活跃事务id ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 <code>情景一</code> 的做法。</li></ul><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713214522709.png" alt="image-20220713214522709" style="float:left;"><p><strong>session 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; insert INTO student VALUES(34,&quot;周八&quot;,&quot;二班&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>session 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from student lock in share mode; #执行完，当前事务被阻塞</span><br></pre></td></tr></table></figure><p>执行下述语句，输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: 140562531358232:7:4:9:140562535668584</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 422037508068888</span><br><span class="line">REQUESTING_THREAD_ID: 64</span><br><span class="line">REQUESTING_EVENT_ID: 6</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 140562535668584</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: 140562531351768:7:4:9:140562535619104</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 15902</span><br><span class="line">BLOCKING_THREAD_ID: 64</span><br><span class="line">BLOCKING_EVENT_ID: 6</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 140562535619104</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>隐式锁的逻辑过程如下：</p><p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。 </p><p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 <code>隐式锁</code> 转换为 <code>显式锁</code> (就是为该事务添加一个锁)。 </p><p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。 </p><p>D. 等待加锁成功，被唤醒，或者超时。 </p><p>E. 写数据，并将自己的trx_id写入trx_id字段。</p><blockquote><ol><li>执行<strong>insert</strong>语句，对要操作的页加RW-X-LATCH，然后<strong>判断是否有和插入意向锁冲突的锁(别的事务的间隙锁)<strong>，如果</strong>有</strong>，加插入意向锁，进入锁等待，如果<strong>没有</strong>，直接写数据，不加任何锁(隐式锁)，结束后释放RW-XLATCH；</li><li>执行<strong>select … lock in share mode</strong>语句，对要操作的页加RW-X-LATCH，如果页面上存在RW-X-LATCH会被阻塞，没有的话则判断记录上是否有活跃的事务，如果<strong>存在</strong>，则<strong>为insert事务创建一个排他记录锁</strong>，并将自己加入锁等待队列，最后也会释放RW-X-LATCH</li></ol></blockquote><h4 id="2-显式锁"><a href="#2-显式锁" class="headerlink" title="2. 显式锁"></a>2. 显式锁</h4><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p><p>显示加共享锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... lock in share mode</span><br></pre></td></tr></table></figure><p>显示加排它锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... for update</span><br></pre></td></tr></table></figure><h3 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a>3.5 其它锁之：全局锁</h3><p>全局锁就是对 <code>整个数据库实例</code> 加锁。当你需要让整个库处于 <code>只读状态</code> 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 <code>场景</code> 是：做 <code>全库逻辑备份</code> 。</p><p>全局锁的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure><h3 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。</p><p><strong>举例1：</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713220714098.png" alt="image-20220713220714098"></p><p><strong>举例2：</strong></p><p>用户A给用户B转账100，再次同时，用户B也给用户A转账100。这个过程，可能导致死锁。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713220936236.png" alt="image-20220713220936236" style="float:left;"><p><strong>举例3：间隙锁</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 事务1# 事务2</span><br><span class="line">begin;</span><br><span class="line">select * from student where id = 5 for update;</span><br><span class="line">  select * from student where id = 4 for update;</span><br><span class="line">insert into student (id,name) values (5,&#x27;zx&#x27;);       insert into student (id,name) values (6,&#x27;xm&#x27;);</span><br></pre></td></tr></table></figure><h4 id="2-产生死锁的必要条件"><a href="#2-产生死锁的必要条件" class="headerlink" title="2. 产生死锁的必要条件"></a>2. 产生死锁的必要条件</h4><p><strong>产生死锁的原因主要是：</strong></p><p>（1） 因为系统资源不足。</p><p>（2） 进程运行推进的顺序不合适。</p><p>（3） 资源分配不当等。</p><p><strong>必要条件：</strong></p><p>（1） <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</p><p>（2） <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>（3） <strong>不可剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。</p><p>（4） <strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</p><ol><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ol><blockquote><p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p></blockquote><h4 id="3-如何处理死锁"><a href="#3-如何处理死锁" class="headerlink" title="3. 如何处理死锁"></a>3. 如何处理死锁</h4><p><strong>方式1：</strong>等待，直到超时（innodb_lock_wait_timeout&#x3D;50s)</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220713221418100.png" alt="image-20220713221418100" style="float:left;"><p><strong>方式2：</strong>使用死锁检测处理死锁程序（innodb_deadlock_detect&#x3D;on）</p><p>方式1检测死锁太过被动，innodb还提供了<code>wait-for graph算法</code>来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p><p>这是一种较为<code>主动的死锁检测机制</code>，要求数据库保存<code>锁的信息链表</code>和<code>事务等待链表</code>两部分信息。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713221758941.png" alt="image-20220713221758941"></p><p>基于这两个信息，可以绘制wait-for graph（等待图）</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220713221830455.png" alt="image-20220713221830455"></p><blockquote><p>死锁检测的原理是构建一个以事务为顶点，锁为边的有向图，判断有向图<strong>是否存在环</strong>，存在既有死锁。</p></blockquote><p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行（<code>innodb_deadlock_detect=on</code>表示开启这个逻辑）。</p><p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100&#x3D;1万次，1万个线程就会有1千万次检测。</p><p><strong>如何解决？</strong></p><ul><li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li><li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作。</li></ul><p><strong>进一步的思路：</strong></p><p>可以考虑通过将一行改成逻辑上的多行来减少<code>锁冲突</code>。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p><blockquote><p>死锁检测详细请查看《MySQL06实战45讲笔记》 07节</p></blockquote><h4 id="4-如何避免死锁"><a href="#4-如何避免死锁" class="headerlink" title="4. 如何避免死锁"></a>4. 如何避免死锁</h4><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220714131008260.png" alt="image-20220714131008260" style="float:left;"><h2 id="4-锁的内部结构"><a href="#4-锁的内部结构" class="headerlink" title="4. 锁的内部结构"></a>4. 锁的内部结构</h2><p>我们前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢？比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 事务T1</span><br><span class="line">SELECT * FROM user LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放在一个<code>锁结构</code>中。</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p><code>InnoDB</code> 存储引擎中的 <code>锁结构</code> 如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714132306208.png" alt="image-20220714132306208"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息 </code>：</p><p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个 事务的信息。</p><p>此 <code>锁所在的事务信息</code> 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><p><code>2. 索引信息</code> ：</p><p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code> ：</p><p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>记载了三个重要的信息：</p><ul><li><code>Space ID</code> ：记录所在表空间。</li><li><code>Page Number</code> ：记录所在页号。</li><li><code>n_bits </code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。</li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></blockquote></li></ul><p><code>4. type_mode</code> ：</p><p>这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分，如图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714133319666.png" alt="image-20220714133319666"></p><ul><li>锁的模式（ <code>lock_mode</code> ），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code> （十进制的 0 ）：表示共享意向锁，也就是 <code>IS锁</code> 。 </li><li><code>LOCK_IX</code> （十进制的 1 ）：表示独占意向锁，也就是 <code>IX锁</code> 。 </li><li><code>LOCK_S</code> （十进制的 2 ）：表示共享锁，也就是 <code>S锁</code> 。 </li><li><code>LOCK_X</code> （十进制的 3 ）：表示独占锁，也就是 <code>X锁</code> 。 </li><li><code>LOCK_AUTO_INC</code> （十进制的 4 ）：表示 <code>AUTO-INC锁</code> 。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（ <code>lock_type</code> ），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code> （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC </code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（ <code>rec_lock_type</code> ），使用其余的位来表示。只有在 <code>lock_type</code> 的值为 <code>LOCK_REC</code> 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code> （十进制的 0 ）：表示 <code>next-key锁</code> 。</li><li><code>LOCK_GAP</code> （十进制的 512 ）：也就是当第10个比特位置为1时，表示 <code>gap锁</code> 。</li><li><code>LOCK_REC_NOT_GAP</code> （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 <code>记录锁</code> 。</li><li><code>LOCK_INSERT_INTENTION</code> （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code> 属性呢？基于内存空间的节省，所以把 <code>is_waiting</code> 属性放到了 <code>type_mode</code> 这个32 位的数字中：<ul><li><code>LOCK_WAIT</code> （十进制的 256 ） ：当第9个比特位置为 1 时，表示 <code>is_waiting</code> 为 <code>true</code> ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 <code>is_waiting</code> 为 <code>false</code> ，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code> ：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code> ：</p><p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits</code> 属性 表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no</code> 属性，伪记录 <code>Infimum</code> 的 <code>heap_no</code> 值为 0 ， <code>Supremum</code> 的 <code>heap_no</code> 值为 1 ，之后每插入一条记录， <code>heap_no</code> 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no</code> ，即一个比特位映射 到页内的一条记录。</p><h2 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a>5. 锁监控</h2><p>关于MySQL锁的监控，我们一般可以通过检查 <strong>InnoDB_row_lock</strong> 等状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0     |</span><br><span class="line">| Innodb_row_lock_time          | 0     |</span><br><span class="line">| Innodb_row_lock_time_avg      | 0     |</span><br><span class="line">| Innodb_row_lock_time_max      | 0     |</span><br><span class="line">| Innodb_row_lock_waits         | 0     |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>对各个状态量的说明如下：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量； </li><li><code>Innodb_row_lock_time</code> ：从系统启动到现在锁定总时间长度；（等待总时长） </li><li><code>Innodb_row_lock_time_avg</code> ：每次等待所花平均时间；（等待平均时长） </li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间； </li><li><code>Innodb_row_lock_waits</code> ：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p>对于这5个状态变量，比较重要的3个见上面（灰色）。</p><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了 <code>information_schema</code> 库中，涉及到的三张表分别是 <strong><code>INNODB_TRX</code></strong> 、 <code>INNODB_LOCKS</code> 和 <code>INNODB_LOCK_WAITS</code> 。</p><p><code>MySQL5.7及之前</code> ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事 务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p><strong>MySQL8.0</strong>删除了information_schema.INNODB_LOCKS，添加了 <strong><code>performance_schema.data_locks</code></strong> ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同， performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被 <strong><code>performance_schema.data_lock_waits</code></strong> 所代 替。</p><p>我们模拟一个锁等待的场景，以下是从这三张表收集的信息</p><p>锁等待场景，我们依然使用记录锁中的案例，当事务2进行等待时，查询情况如下：</p><p>（1）查询正在被锁阻塞的sql语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure><p>重要属性代表含义已在上述中标注。</p><p>（2）查询锁等待情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM performance_schema.data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: 139750145405624:7:4:7:139747028690608</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 13845 #被阻塞的事务ID</span><br><span class="line">REQUESTING_THREAD_ID: 72</span><br><span class="line">REQUESTING_EVENT_ID: 26</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 139747028690608</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: 139750145406432:7:4:7:139747028813248</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 13844 #正在执行的事务ID，阻塞了13845</span><br><span class="line">BLOCKING_THREAD_ID: 71</span><br><span class="line">BLOCKING_EVENT_ID: 24</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 139747028813248</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>（3）查询锁的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; SELECT * from performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145405624:1068:139747028693520</span><br><span class="line">ENGINE_TRANSACTION_ID: 13847</span><br><span class="line">THREAD_ID: 72</span><br><span class="line">EVENT_ID: 31</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028693520</span><br><span class="line">LOCK_TYPE: TABLE</span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145405624:7:4:7:139747028690608</span><br><span class="line">ENGINE_TRANSACTION_ID: 13847</span><br><span class="line">THREAD_ID: 72</span><br><span class="line">EVENT_ID: 31</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028690608</span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: WAITING</span><br><span class="line">LOCK_DATA: 1</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145406432:1068:139747028816304</span><br><span class="line">ENGINE_TRANSACTION_ID: 13846</span><br><span class="line">THREAD_ID: 71</span><br><span class="line">EVENT_ID: 28</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028816304</span><br><span class="line">LOCK_TYPE: TABLE</span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: NULL</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145406432:7:4:7:139747028813248</span><br><span class="line">ENGINE_TRANSACTION_ID: 13846</span><br><span class="line">THREAD_ID: 71</span><br><span class="line">EVENT_ID: 28</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028813248</span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: 1</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>从锁的情况可以看出来，两个事务分别获取了IX锁，我们从意向锁章节可以知道，IX锁互相时兼容的。所 以这里不会等待，但是事务1同样持有X锁，此时事务2也要去同一行记录获取X锁，他们之间不兼容，导 致等待的情况发生。</p><h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h2><p><strong>间隙锁加锁规则（共11个案例）</strong></p><p>间隙锁是在可重复读隔离级别下才会生效的： next-key lock 实际上是由间隙锁加行锁实现的，如果切换 到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁 的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row 。也就是说，许多公司的配置为：读提交隔离级别加 binlog_format&#x3D;row。业务不 需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p><p>next-key lock的加锁规则</p><p>总结的加锁规则里面，包含了两个 “ “ 原则 ” ” 、两个 “ “ 优化 ” ” 和一个 “bug” 。</p><ol><li>原则 1 ：加锁的基本单位是 next-key lock 。 next-key lock 是前开后闭区间。 </li><li>原则 2 ：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终 都要回溯到主键上，在主键上也要加一把锁。 </li><li>优化 1 ：索引上的等值查询，给唯一索引加锁的时候， next-key lock 退化为行锁。也就是说如果 InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁 </li><li>优化 2 ：索引上（不一定是唯一索引）的等值查询，向右遍历时且最后一个值不满足等值条件的 时候， next-keylock 退化为间隙锁。 </li><li>一个 bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>我们以表test作为例子，建表语句和初始化语句如下：其中id为主键索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">`id` int(11) NOT NULL,</span><br><span class="line">`col1` int(11) DEFAULT NULL,</span><br><span class="line">`col2` int(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into test values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p><strong>案例一：唯一索引等值查询间隙锁</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714134603698.png" alt="image-20220714134603698"></p><p>由于表 test 中没有 id&#x3D;7 的记录</p><p>根据原则 1 ，加锁单位是 next-key lock ， session A 加锁范围就是 (5,10] ； 同时根据优化 2 ，这是一个等 值查询 (id&#x3D;7) ，而 id&#x3D;10 不满足查询条件， next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)</p><p><strong>案例二：非唯一索引等值查询锁</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714134623052-16577775838551.png" alt="image-20220714134623052"></p><p>这里 session A 要给索引 col1 上 col1&#x3D;5 的这一行加上读锁。</p><ol><li>根据原则 1 ，加锁单位是 next-key lock ，左开右闭，5是闭上的，因此会给 (0,5] 加上 next-key lock 。 </li><li>要注意 c 是普通索引，因此仅访问 c&#x3D;5 这一条记录是不能马上停下来的（可能有col1&#x3D;5的其他记 录），需要向右遍历，查到c&#x3D;10 才放弃。根据原则 2 ，访问到的都要加锁，因此要给 (5,10] 加 next-key lock 。 </li><li>但是同时这个符合优化 2 ：等值判断，向右遍历，最后一个值不满足 col1&#x3D;5 这个等值条件，因此退化成间隙锁 (5,10) 。</li><li>根据原则 2 ， 只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ol><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住 这个例子说明，锁是加在索引上的。</p><p>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>如果你要用 lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，因为覆盖索引不会访问主键索引，不会给主键索引上加锁</p><p><strong>案例三：主键索引范围查询锁</strong></p><p>上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id=10 for update</span><br><span class="line">select * from tets where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714134742049.png" alt="image-20220714134742049"></p><ol><li>开始执行的时候，要找到第一个 id&#x3D;10 的行，因此本该是 next-key lock(5,10] 。 根据优化 1 ，主键 id 上的等值条件，退化成行锁，只加了 id&#x3D;10 这一行的行锁。 </li><li>它是范围查询， 范围查找就往后继续找，找到 id&#x3D;15 这一行停下来，不满足条件，因此需要加 next-key lock(10,15] 。</li></ol><p>session A 这时候锁的范围就是主键索引上，行锁 id&#x3D;10 和 next-key lock(10,15] 。<strong>首次 session A 定位查找 id&#x3D;10 的行的时候，是当做等值查询来判断的，而向右扫描到 id&#x3D;15 的时候，用的是范围查询判断。</strong></p><p><strong>案例四：非唯一索引范围查询锁</strong></p><p>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引</p><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714134822160.png" alt="image-20220714134822160"></p><p>在第一次用 col1&#x3D;10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 col1 是非唯 一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-keylock 。</p><p>这里需要扫描到 col1&#x3D;15 才停止扫描，是合理的，因为 InnoDB 要扫到 col1&#x3D;15 ，才知道不需要继续往后找了。</p><p><strong>案例五：唯一索引范围查询锁 bug</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714134846740.png" alt="image-20220714134846740"></p><p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因 为 id 是唯一键，所以循环判断到 id&#x3D;15 这一行就应该停止了。</p><p>但是实现上， InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id&#x3D;20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id&#x3D;20 这一行的行为，其实是没有必要的。因为扫描到 id&#x3D;15 ，就可以确定不用往后再找了。</p><p><strong>案例六：非唯一索引上存在 “ “ 等值 “ “ 的例子</strong></p><p>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个c&#x3D;10的行</p><p><strong>但是它们的主键值 id 是不同的（分别是 10 和 30 ），因此这两个c&#x3D;10 的记录之间，也是有间隙的。</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714134923414.png" alt="image-20220714134923414"></p><p>这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select … for update 是类似的， 也就是我在文章开始总结的两个 “ 原则 ” 、两个 “ 优化 ” 和一个 “bug” 。</p><p>这时， session A 在遍历的时候，先访问第一个 col1&#x3D;10 的记录。同样地，根据原则 1 ，这里加的是 (col1&#x3D;5,id&#x3D;5) 到 (col1&#x3D;10,id&#x3D;10) 这个 next-key lock 。</p><p>由于c是普通索引，所以继续向右查找，直到碰到 (col1&#x3D;15,id&#x3D;15) 这一行循环才结束。根据优化 2 ，这是 一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1&#x3D;10,id&#x3D;10) 到 (col1&#x3D;15,id&#x3D;15) 的间隙锁。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714134945012.png" alt="image-20220714134945012"></p><p>这个 delete 语句在索引 c 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都 是虚线，表示开区间，即 (col1&#x3D;5,id&#x3D;5) 和 (col1&#x3D;15,id&#x3D;15) 这两行上都没有锁</p><p><strong>案例七： limit 语句加锁</strong></p><p>例子 6 也有一个对照案例，场景如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714135007118.png" alt="image-20220714135007118"></p><p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 c&#x3D;10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样</p><p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1&#x3D;10, id&#x3D;30) 这一行之后， 满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（ col1&#x3D;5,id&#x3D;5) 到（ col1&#x3D;10,id&#x3D;30) 这个前开后闭区间，如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714135025045-16577778257713.png" alt="image-20220714135025045"></p><p>这个例子对我们实践的指导意义就是， 在删除数据的时候尽量加 limit 。</p><p>这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p><p><strong>案例八：一个死锁的例子</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714135047760.png" alt="image-20220714135047760"></p><ol><li>session A 启动事务后执行查询语句加 lock in share mode ，在索引 col1 上加了 next-keylock(5,10] 和 间隙锁 (10,15) （索引向右遍历退化为间隙锁）； </li><li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待； 实际上分成了两步， 先是加 (5,10) 的间隙锁，加锁成功；然后加 col1&#x3D;10 的行锁，因为sessionA上已经给这行加上了读 锁，此时申请死锁时会被阻塞 </li><li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁， InnoDB 让 session B 回滚</li></ol><p><strong>案例九：order by索引排序的间隙锁1</strong></p><p>如下面一条语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test where id&gt;9 and id&lt;12 order by id desc for update;</span><br></pre></td></tr></table></figure><p>下图为这个表的索引id的示意图。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714135130668.png" alt="image-20220714135130668"></p><ol><li>首先这个查询语句的语义是 order by id desc ，要拿到满足条件的所有行，优化器必须先找到 “ 第 一个 id&lt;12 的值 ” 。 </li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id&#x3D;12 的这个值，只是最终 没找到，但找到了 (10,15) 这个间隙。（ id&#x3D;15 不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15) 。）</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id&#x3D;5 这一行，又因为区间是左开右 闭的，所以会加一个next-key lock (0,5] 。 也就是说，在执行过程中，通过树搜索的方式定位记录 的时候，用的是 “ 等值查询 ” 的方法。</li></ol><p><strong>案例十：order by索引排序的间隙锁2</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714135206504.png" alt="image-20220714135206504"></p><ol><li><p>由于是 order by col1 desc ，第一个要定位的是索引 col1 上 “ 最右边的 ”col1&#x3D;20 的行。这是一个非唯一索引的等值查询：</p><p>左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1&#x3D;25不满足条件，退化为间隙锁 所以会 加上间隙锁(20,25) 和 next-key lock (15,20] 。</p></li><li><p>在索引 col1 上向左遍历，要扫描到 col1&#x3D;10 才停下来。同时又因为左开右闭区间，所以 next-key lock 会加到 (5,10] ，这正是阻塞session B 的 insert 语句的原因。</p></li><li><p>在扫描过程中， col1&#x3D;20 、 col1&#x3D;15 、 col1&#x3D;10 这三行都存在值，由于是 select * ，所以会在主键 id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：</p><ol><li>索引 col1 上 (5, 25) ；</li><li>主键索引上 id&#x3D;15 、 20 两个行锁。</li></ol></li></ol><p><strong>案例十一：update修改数据的例子-先插入后删除</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714135300189.png" alt="image-20220714135300189"></p><p>注意：根据 col1&gt;5 查到的第一个记录是 col1&#x3D;10 ，因此不会加 (0,5] 这个 next-key lock 。</p><p>session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。</p><p>之后 session B 的第一个 update 语句，要把 col1&#x3D;5 改成 col1&#x3D;1 ，你可以理解为两步：</p><ol><li>插入 (col1&#x3D;1, id&#x3D;5) 这个记录；</li><li>删除 (col1&#x3D;5, id&#x3D;5) 这个记录。</li></ol><p>通过这个操作， session A 的加锁范围变成了图 7 所示的样子:</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714135333089.png" alt="image-20220714135333089"></p><p>好，接下来 session B 要执行 update t set col1 &#x3D; 5 where col1 &#x3D; 1 这个语句了，一样地可以拆成两步：</p><ol><li>插入 (col1&#x3D;5, id&#x3D;5) 这个记录；</li><li>删除 (col1&#x3D;1, id&#x3D;5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了。</li></ol><h1 id="第16章-多版本并发控制"><a href="#第16章-多版本并发控制" class="headerlink" title="第16章_多版本并发控制"></a>第16章_多版本并发控制</h1><h2 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a>1. 什么是MVCC</h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 <code>并发控制 </code>。这项技术使得在InnoDB的事务隔离级别下执行 <code>一致性读</code> 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。</p><p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的（大家可以参考相关的DBMS文档）。这里讲解InnoDB中MVCC的实现机制（MySQL其他的存储引擎并不支持它）。</p><h2 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到 即使有读写冲突时，也能做到 <code>不加锁</code> ， <code>非阻塞并发读</code> ，而这个读指的就是 <code>快照读</code> , 而非 <code>当前读</code> 。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><h3 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h3><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的 SELECT 都属于快照读</strong>，即不加锁的非阻塞 读；比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。 </p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h3 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h3><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务 不能修改当前记录，<strong>会对读取的记录进行加锁</strong>。<code>加锁的 SELECT</code>，或者对数据进行增删改都会进行当前读。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ... # 排他锁</span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br><span class="line">UPDATE student SET ... # 排他锁</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="red">修改删除操作和加锁的select操作都属于当前读</font></strong></p></blockquote><h2 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a>3. 复习</h2><h3 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714140441064.png" alt="image-20220714140441064"></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220714140510426.png" alt="image-20220714140510426" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714140541555.png" alt="image-20220714140541555"></p><h3 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a>3.2 隐藏字段、Undo Log版本链</h3><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li><code>trx_id</code> ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 <code>事务id</code> 赋值给 <code>trx_id</code> 隐藏列。 </li><li><code>roll_pointer</code> ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 <code>undo日志</code> 中，然 后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220714140716427.png" alt="image-20220714140716427" style="float:left;"><p>假设插入该记录的<code>事务id</code>为<code>8</code>，那么此刻该条记录的示意图如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714140801595.png" alt="image-20220714140801595"></p><blockquote><p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p></blockquote><p>假设之后两个事务id分别为 <code>10</code> 、 <code>20</code> 的事务对这条记录进行<code> UPDATE</code> 操作，操作流程如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714140846658.png" alt="image-20220714140846658"></p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220714140908661.png" alt="image-20220714140908661" style="float:left;"><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 <code>roll_pointer</code> 属性 （ <code>INSERT</code> 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 <code>undo日志</code> 都连起来，串成一个链表：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220714141012874.png" alt="image-20220714141012874"></p><p>对该记录每次更新后，都会将旧值放到一条 <code>undo日志</code> 中，就算是该记录的一个旧版本，随着更新次数 的增多，所有的版本都会被 <code>roll_pointer</code> 属性连接成一个链表，我们把这个链表称之为 <code>版本链</code> ，版 本链的头节点就是当前记录最新的值。</p><p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p><h2 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a>4. MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：<code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code>。</p><h3 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h3><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220714141154235.png" alt="image-20220714141154235" style="float:left;"><h3 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h3><p>使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p><strong>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务</strong>，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><blockquote><p>只有<strong>RC</strong>和<strong>RR</strong>隔离级别才能使用到Read View</p></blockquote><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><p><code>creator_trx_id</code> ，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在<strong>一个只读事务中的事务id值都默认为0。</strong></p></blockquote></li><li><p><code>trx_ids</code> ，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p></li><li><p><code>up_limit_id</code> ，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id</code> ，表示生成ReadView时系统中应该<strong>分配给下一个事务</strong>的 <code>id</code> 值。即系统最大事务id + 1，low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，5这三个事务，之后id为5的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是6。</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220714142254768.png" alt="image-20220714142254768" style="float:left;"><h3 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h3><p>有了这个ReadView，这样某个<code>事务</code>在访问某条<code>记录</code>时，只需要按照下边的步骤判断<strong>记录的某个版本</strong>是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 <code>creator_trx_id</code> 值相同，意味着<strong>当前事务在访问它自己修改过的记录</strong>，所以该版本<strong>可以</strong>被当前事务访问。 </li><li>如果被访问版本的trx_id属性值小于ReadView中的 <code>up_limit_id</code> 值，表明生成该版本的事务在<strong>当前事务生成ReadView前已经提交</strong>，所以该版本<strong>可以</strong>被当前事务访问。 </li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 <code>low_limit_id</code> 值，表明生成该版本的事务在<strong>当前事务生成ReadView后才开启</strong>，所以该版本<strong>不可以</strong>被当前事务访问。 </li><li>如果被访问版本的trx_id属性值在ReadView的 <code>up_limit_id</code> 和 <code>low_limit_id</code> 之间，那就需要判断一下trx_id属性值是不是在 <code>trx_ids</code> 列表中。<ul><li>如果<strong>在</strong>，说明<strong>创建ReadView时生成该版本的事务还是活跃</strong>的，该版本<strong>不可以</strong>被访问。 </li><li>如果<strong>不在</strong>，说明<strong>创建ReadView时生成该版本的事务已经被提交</strong>，该版本<strong>可以</strong>被访问。</li></ul></li></ul><blockquote><p>某个事务访问某条记录时，查询这条记录的版本号：</p><p>一共只有三种情况表示能访问到记录当前版本：只有当<font color="orange">①记录版本的trx_id等于事务创建read view的creator_tx_id</font>或者<font color="orange">②记录版本的trx_id小于read view的up_limit_id</font>或者<font color="orange">③不在活跃的trx+ids当中</font>时才表示可以被当前事务访问到此纪录的当前版本</p><p>其它时候，如在read view活跃的trx_ids当中或者大于等于low_limit_id，都只能<font color="cornflowerblue">沿着undo log链表往前查找自己能够访问的版本</font></p></blockquote><h3 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a>4.4 MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li>首先获取事务自己的版本号，也就是事务 ID； </li><li>获取 ReadView； </li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照； </li><li>最后返回符合规则的数据。</li></ol><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715130639408.png" alt="image-20220715130639408" style="float:left;"><ul><li>在隔离级别为<strong>读已提交（Read Committed）</strong>时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。</li></ul><p>如表所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715130843147.png" alt="image-20220715130843147"></p><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><ul><li>当隔离级别为<strong>可重复读</strong>的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715130916437.png" alt="image-20220715130916437"></p><h2 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. 举例说明</h2><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715131200077.png" alt="image-20220715131200077" style="float:left;"><h3 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a>5.1 READ COMMITTED隔离级别下</h3><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView。</strong></p><p>现在有两个 <code>事务id</code> 分别为 <code>10</code> 、 <code>20</code> 的事务在执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"></span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>说明：事务执行过程中，<strong>select操作的事务id会是默认值0</strong>，只有在第一次真正修改<strong>记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id</strong>，这个事务id是递增的。所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。</p></blockquote><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715133640655.png" alt="image-20220715133640655"></p><p>假设现在有一个使用 <code>READ COMMITTED</code> 隔离级别的事务开始执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715134540737.png" alt="image-20220715134540737" style="float:left;"><p>之后，我们把 <code>事务id</code> 为 <code>10</code> 的事务提交一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>然后再到 <code>事务id</code> 为 <code>20</code> 的事务中更新一下表 <code>student</code> 中 <code>id</code> 为 <code>1</code> 的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure><p>此刻，表student中 <code>id</code> 为 <code>1</code> 的记录的版本链就长这样：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715134839081.png" alt="image-20220715134839081"></p><p>然后再到刚才使用 <code>READ COMMITTED</code> 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;王五&#x27;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715135017000.png" alt="image-20220715135017000" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715135143939.png" alt="image-20220715135143939" style="float:left;"><h3 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h3><p>使用 <code>REPEATABLE READ</code> 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 <code>ReadView</code> ，之后的查询就不会重复生成了。</p><p>比如，系统里有两个 <code>事务id</code> 分别为 <code>10</code> 、 <code>20</code> 的事务在执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715140006061.png" alt="image-20220715140006061"></p><p>假设现在有一个使用 <code>REPEATABLE READ</code> 隔离级别的事务开始执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715140155744.png" alt="image-20220715140155744" style="float:left;"><p>之后，我们把 <code>事务id</code> 为 <code>10</code> 的事务提交一下，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>然后再到 <code>事务id</code> 为 <code>20</code> 的事务中更新一下表 <code>student</code> 中 <code>id</code> 为 <code>1</code> 的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure><p>此刻，表student 中 <code>id</code> 为 <code>1</code> 的记录的版本链长这样：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715140354217.png" alt="image-20220715140354217"></p><p>然后再到刚才使用 <code>REPEATABLE READ</code> 隔离级别的事务中继续查找这个 <code>id</code> 为 <code>1</code> 的记录，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值仍为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715140555172.png" alt="image-20220715140555172" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715140620328.png" alt="image-20220715140620328" style="float:left;"><p>这次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>张三</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记录，得到的结果还是<code>张三</code>，具体执行过程大家可以自己分析一下。</p><h3 id="5-3-当前读情况"><a href="#5-3-当前读情况" class="headerlink" title="5.3 当前读情况"></a>5.3 当前读情况</h3><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20230922150310865.png" alt="image-20230922150310865"></p><p>事务B读出的值为(1,3)</p><p>但是：<strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p><p>事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p><blockquote><p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p><p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p><p>这里我们提到了一个概念，叫作当前读。其实，<strong>除了update语句外，select语句如果加锁，也是当前读。</strong></p></blockquote><p>READ VIEW分为快照读和当前读，**<font color="red">修改删除操作和加锁的select操作都属于当前读</font>**</p><h3 id="5-4-如何解决幻读"><a href="#5-4-如何解决幻读" class="headerlink" title="5.4 如何解决幻读"></a>5.4 如何解决幻读</h3><p>接下来说明InnoDB 是如何解决幻读的。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715141002035.png" alt="image-20220715141002035" style="zoom:80%;"><p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code> 的事务 id 为 <code>20</code> ， <code>事务 B</code> 的事务 id 为 <code>30</code> 。</p><p><strong>步骤1</strong>：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id &gt;= 1;</span><br></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <code>trx_ids= [20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20</code> 。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView 机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，<strong>目前只能读取到一条数据</strong>，id&#x3D;1。</p><p><strong>步骤2</strong>：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#x27;李四&#x27;);</span><br><span class="line">insert into student(id,name) values(3,&#x27;王五&#x27;);</span><br></pre></td></tr></table></figure><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715141208667.png" alt="image-20220715141208667"></p><p><strong>步骤3</strong>：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，<strong>可以</strong>被事务 A 看到。 </p><p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表 示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据<strong>不能</strong>让事务 A 看到。</p><p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也<strong>不能</strong>被事务 A 看见。</p><p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87.assets/image-20220715141243993.png" alt="image-20220715141243993"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样 的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这里介绍了 MVCC 在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两种隔离级别的事务在执行快照读操作时 访问记录的版本链的过程。这样使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理， <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两个隔离级别的一个很大不同 就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code> 在每一次进行普通SELECT操作前都会生成一个ReadView </li><li><code>REPEATABLE READ</code> 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复 使用这个ReadView就好了。</li></ul><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715141413135.png" alt="image-20220715141413135" style="float:left;"><p>通过MVCC我们可以解决：</p><img src="https://www.hahhome.top/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/../../image/MySQL(4)事务篇.assets/image-20220715141515370.png" alt="image-20220715141515370" style="float:left;">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(3)索引和调优篇</title>
      <link href="/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/"/>
      <url>/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="索引和调优篇"><a href="#索引和调优篇" class="headerlink" title="索引和调优篇"></a>索引和调优篇</h1><h1 id="第06章-索引的数据结构"><a href="#第06章-索引的数据结构" class="headerlink" title="第06章_索引的数据结构"></a>第06章_索引的数据结构</h1><h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616141351236.png" alt="image-20220616141351236"></p><p>如上图所示，数据库没有索引的情况下，数据<code>分布在硬盘不同的位置上面</code>，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果<code>数据顺序摆放</code>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，<code>依旧非常耗时</code>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从Col 2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<code>上千万条数据</code>，就意味着要做<code>很多很多次硬盘I/0</code>才能找到。现在要查找 Col 2 &#x3D; 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I&#x2F;O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）</p><p>假如给数据使用 <code>二叉树</code> 这样的数据结构进行存储，如下图所示</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616142723266.png" alt="image-20220616142723266"></p><p>对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 <code>二叉搜索树</code>。二叉搜索树的每个结点存储的是 <code>(K, V) 结构</code>，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：<code>(34, 0x07)</code>。现在对 Col 2 添加了索引，这时再去查找 Col 2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89&#x3D;&#x3D;89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 <code>查找两次</code> 就可以定位到记录的地址，查询速度就提高了。</p><p>这就是我们为什么要建索引，目的就是为了 <code>减少磁盘I/O的次数</code>，加快查询速率。</p><h2 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2. 索引及其优缺点"></a>2. 索引及其优缺点</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构。</strong></p><p><strong>索引的本质</strong>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。</p><p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 <code>最大索引数</code>和 <code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。 </p><p>（2）通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p><p>（3）在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 </p><p>（4）在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。</p><h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面： </p><p>（1）创建索引和维护索引要 <strong>耗费时间</strong> ，并 且随着数据量的增加，所耗费的时间也会增加。 </p><p>（2）索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， <strong>存储在磁盘上</strong> ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 </p><p>（3）虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p><blockquote><p>提示：</p><p><font color="red">索引可以提高查询的速度，但是会影响插入记录的速度</font>。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><h2 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3. InnoDB中索引的推演"></a>3. InnoDB中索引的推演</h2><h3 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h3><p>先来看一个精确匹配的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure><h4 id="1-在一个页中的查找"><a href="#1-在一个页中的查找" class="headerlink" title="1. 在一个页中的查找"></a>1. 在一个页中的查找</h4><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li><p>以主键为搜索条件</p><p>可以在页目录中使用 <code>二分法</code> 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</p></li><li><p>以其他列作为搜索条件</p><p>因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 <code>最小记录</code> 开始 <code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p></li></ul><h4 id="2-在很多页中查找"><a href="#2-在很多页中查找" class="headerlink" title="2. 在很多页中查找"></a>2. 在很多页中查找</h4><p>在很多页中查找记录的活动可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 <code>从第一个页</code>沿着<code>双向链表</code> 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 <code>超级耗时</code> 的。如果一个表有一亿条记录呢？此时 <code>索引</code> 应运而生。</p><blockquote><p>在根目录页中采用二分法找到想要的页，定位到下一个页内继续采用<strong>页目录</strong>进行二分法查找</p></blockquote><h3 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h3><p>建一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">    -&gt; c1 INT,</span><br><span class="line">    -&gt; c2 INT,</span><br><span class="line">    -&gt; c3 CHAR(1),</span><br><span class="line">    -&gt; PRIMARY KEY(c1)</span><br><span class="line">    -&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure><p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616152453203.png" alt="image-20220616152453203"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><code>record_type</code> ：记录头信息的一项属性，表示记录的类型， <code>0</code> 表示普通记录、 <code>2</code> 表示最小记 录、 <code>3 </code>表示最大记录、 <code>1</code> 暂时还没用过，下面讲。 </li><li><code>next_record</code> ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。 </li><li><code>各个列的值</code> ：这里只记录在 <code>index_demo</code> 表中的三个列，分别是 <code>c1 、 c2 和 c3</code> 。 </li><li><code>其他信息</code> ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220616152727234.png" alt="image-20220616152727234" style="zoom:80%;"><p>把一些记录放到页里的示意图就是：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616152651878.png" alt="image-20220616152651878"></p><h4 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h4><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而<strong>建立一个目录</strong> ，建这个目录必须完成下边这些事：</p><ul><li><p><strong><code>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</code></strong></p><p>假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设后我们向<code>index_demo</code>表插入3条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO index_demo VALUES(1, 4, &#x27;u&#x27;), (3, 9, &#x27;d&#x27;), (5, 3, &#x27;y&#x27;);</span><br></pre></td></tr></table></figure></li></ul><p>​       那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616153518456.png" alt="image-20220616153518456"></p><p>从图中可以看出来， <code>index_demo</code> 表中的3条记录都被插入到了编号为<code>10</code>的数据页中了。此时我们再来插入一条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO index_demo VALUES(4, 4, &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>因为 <strong>页10</strong> 最多只能放3条记录，所以我们不得不再分配一个新页：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616155306705.png" alt="image-20220616155306705"></p><p>注意：新分配的 <strong>数据页编号可能并不是连续的</strong>。它们只是通过维护者上一个页和下一个页的编号而建立了 <strong>链表</strong> 关系。另外，<strong>页10</strong>中用户记录最大的主键值是<strong>5</strong>，而<strong>页28</strong>中有一条记录的主键值是<strong>4</strong>，因为<strong>5&gt;4</strong>，所以这就不符合<code>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</code>的要求，所以在插入主键值为4的记录的时候需要伴随着一次 <strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616160216525.png" alt="image-20220616160216525"></p><p>这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 <strong>记录移动</strong> 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 <strong>页分裂</strong>。</p><ul><li><strong>给所有的页建立一个目录项。</strong></li></ul><p>由于数据页的 <strong>编号可能是不连续</strong> 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616160619525.png" alt="image-20220616160619525"></p><p>因为这些<code>16KB</code>的页在物理存储上是<code>不连续</code>的，所以如果想从这么多页中根据主键值<code>快速定位某些记录所在的页</code>，我们需要给它们做个 <strong>目录</strong>，每个页对应一个目录项，每个目录项包括下边两个部分：</p><p>1）页的用户记录中最小的主键值，我们用 <strong>key</strong> 来表示。</p><p>2）页号，我们用 <strong>page_on</strong> 表示。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616160857381.png" alt="image-20220616160857381"></p><p>以 <code>页28</code> 为例，它对应 <code>目录项2</code> ，这个目录项中包含着该页的页号 <code>28</code> 以及该页中用户记录的最小主 键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为<code> 20</code> 的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据<code>二分法</code>快速确定出主键值为 <code>20</code> 的记录在 <code>目录项3</code> 中（因为 <code>12 &lt; 20 &lt; 209</code> ），它对应的页是 <code>页9</code> 。 </li><li>再根据前边说的在页中查找记录的方式去 <code>页9 </code>中定位具体的记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。</p><h4 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h4><h5 id="①-迭代1次：目录项纪录的页"><a href="#①-迭代1次：目录项纪录的页" class="headerlink" title="① 迭代1次：目录项纪录的页"></a>① 迭代1次：目录项纪录的页</h5><p>上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用<code>二分法</code>快速定位具体的目录项而<code>假设</code>所有目录项都可以在物理存储器上<code>连续存储</code>，但是这样做有几个问题：</p><ul><li>InnoDB是<font color="cornflowerblue">使用页来作为管理存储空间的基本单位</font>，最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要<code>非常大的连续的存储空间</code>才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们时常会对<code>记录进行增删</code>，假设我们把<code>页28中</code>的记录都删除了，那意味着<code>目录项</code>也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。</li></ul><p>所以，我们需要一种可以<code>灵活管理所有目录项</code>的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是<code>主键</code>和<code>页号</code>而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。那InnoDB怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？使用记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>1</code>：目录项记录</li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616162944404.png" alt="image-20220616162944404"></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 <strong><code>目录项记录</code></strong> 和普通的 <strong><code>用户记录</code></strong> 的<strong>不同点</strong>：</p><ul><li><strong><code>目录项记录</code></strong> 的 record_type 值是1，而 <strong><code>普通用户记录</code></strong> 的 record_type 值是0。 </li><li>目录项记录只有 <strong><code>主键值和页的编号</code></strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 <strong><code>很多列</code></strong> ，另外还有InnoDB自己添加的<strong>隐藏列</strong>。 </li><li>了解：记录头信息里还有一个叫 <strong><code>min_rec_mask</code></strong> 的属性，只有在存储 <strong><code>目录项记录</code></strong> 的页中的主键值最小的 <strong><code>目录项记录</code></strong> 的 <strong><code>min_rec_mask</code></strong> 值为 <strong><code>1</code></strong> ，其他别的记录的 <strong><code>min_rec_mask</code></strong> 值都是 <strong>0</strong> 。</li></ul><p><strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成**<code>Page Directory （页目录）</code>**，从而在按照主键值进行查找时可以使用 <strong><code>二分法</code></strong> 来加快查询速度。</p><p>现在以查找主键为 <code>20</code> 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页30中通过 <code>二分法</code> 快速定位到对应目录项，因为 <code>12 &lt; 20 &lt; 209</code> ，所以定位到对应的记录所在的页就是页9。 </li><li>再到存储用户记录的页9中根据 <code>二分法</code> 快速定位到主键值为 <code>20</code> 的用户记录。</li></ol><h5 id="②-迭代2次：多个目录项纪录的页"><a href="#②-迭代2次：多个目录项纪录的页" class="headerlink" title="② 迭代2次：多个目录项纪录的页"></a>② 迭代2次：多个目录项纪录的页</h5><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于<strong>一个数据页不足以存放所有的目录项记录</strong>，如何处理呢？</p><p>这里我们假设一个存储目录项记录的页<code>最多只能存放4条目录项记录</code>，所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个<code>新的存储目录项记录</code>的页：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616171135082.png" alt="image-20220616171135082"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 <code>页3</code>1 。 </li><li>因为原先存储目录项记录的 <code>页30的容量已满</code> （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 <code>页32</code> 来存放 <code>页31</code> 对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 <code>20</code> 的记录为例：</p><ol><li><p>确定 <code>目录项记录页</code> 我们现在的存储目录项记录的页有两个，即 <code>页30</code> 和 <code>页32</code> ，又因为页30表示的目录项的主键值的 范围是 <code>[1, 320) </code>，页32表示的目录项的主键值不小于 <code>320</code> ，所以主键值为<code> 20</code> 的记录对应的目 录项记录在 <code>页30</code> 中。 </p></li><li><p>通过目录项记录页 <code>确定用户记录真实所在的页</code>。 </p><p>在一个存储 <code>目录项记录 </code>的页中通过主键值定位一条目录项记录的方式说过了。 </p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p></li></ol><h5 id="③-迭代3次：目录项记录页的目录页"><a href="#③-迭代3次：目录项记录页的目录页" class="headerlink" title="③ 迭代3次：目录项记录页的目录页"></a>③ 迭代3次：目录项记录页的目录页</h5><p>问题来了，在这个查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些<code>页是不连续</code>，的如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个<code>更高级的目录</code>，就像是一个多级目录一样，<font color="red"><strong>大目录里嵌套小目录</strong></font>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616173512780.png" alt="image-20220616173512780"></p><p>如图，我们生成了一个存储更高级目录项的 <code>页33</code> ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 <code>[1, 320)</code> 之间，则到页30中查找更详细的目录项记录，如果主键值<code> 不小于320</code> 的 话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616173717538.png" alt="image-20220616173717538"></p><p>这个数据结构，它的名称是 <code>B+树</code> 。</p><h5 id="④迭代n次"><a href="#④迭代n次" class="headerlink" title="④迭代n次"></a>④迭代n次</h5><p>像上面一样套娃，迭代n次，<code>不断采用大目录套小目录的方式</code>，就形成了B+树，B+树一般最多有4层即可达到非常恐怖的数据量，只有最后一层的叶子节点才是存储的数据，上面几层都是页目录。</p><h5 id="⑤-B-Tree"><a href="#⑤-B-Tree" class="headerlink" title="⑤ B+Tree"></a>⑤ B+Tree</h5><p>不论是存放<code>用户记录</code>的数据页，还是存放<code>目录项记录</code>的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中B+树最上边的那个节点也称为<code>根节点</code>。</p><blockquote><p>注意真实的B+树的形成过程并不是从下往上，而是<strong>从上往下形成</strong>的，这里只是为了便于理解</p><p>对应下面 3.4 &gt; 1</p></blockquote><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。</p><p><strong>上面都是模拟情况下的数据量，真实情况下：</strong></p><p>其实真实环境中一个页存放的记录数量是非常大的，<code>一个数据页的大小是16KB</code>，假设所有存放用户记录 的叶子节点代表的数据页可以存放 <code>100</code>条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 <code>1000</code>条目录项记录 ，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。 </li><li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。 </li><li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！</li></ul><p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以一般情况下，我们用到的 <strong>B+树都不会超过4层</strong> ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为<font color="red">在每个页面内有所谓的 <strong>Page Directory</strong> （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速 定位记录。</font></p><h3 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。</p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子结点），也就是所谓的 <code>索引即数据，数据即索引</code>(InnoDB中数据和索引都存储在一个文件中，即.ibd文件)。</p><blockquote><p><font color="red">主键</font>构建的B+树，叫做聚簇索引，非主键构建的叫做非聚簇索引</p><ul><li>显式声明：用户可以在建表的时候通过primary key关键字来声明主键列；</li><li>唯一索引：如果用户没有声明主键列，那么InnoDB会使用第一个非空唯一列作为主键</li><li>自动生成：如果满足以上两种条件的列都不存在，那么InnoDB会使用隐藏列RowId自动作为主键；</li></ul></blockquote><blockquote><p>术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起</p></blockquote><p><strong>特点：</strong></p><ul><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p><ul><li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code> 。 </li><li>各个存放 <code>用户记录的页</code> 也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code> 。 </li><li>存放 <code>目录项记录的页</code> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <code>双向链表</code> 。</li></ul></li><li><p>B+树的 <code>叶子节点</code> 存储的是完整的用户记录。 </p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括<strong>隐藏列</strong>）。</p><blockquote><p><strong><font color="red">页内单向链表，页间双向链表</font></strong></p><p><strong><font color="cornflowerblue">InnoDB存储引擎中，聚簇索引比二级索引多存储隐藏列信息</font></strong></p></blockquote></li></ul><p>我们把具有这两种特性的B+树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引<code>并不需要</code>我们在MySQL语句中显式的使用**<code>INDEX</code>** 语句去创建， <strong><code>InnDB</code></strong> 存储引擎会 <code>自动</code> 的为我们创建聚簇索引。</p><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 </li><li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快 </li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的io操作</code> 。</li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></li><li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code> ，<strong>第一次找到主键值，第二次根据主键值找到行数据</strong></li></ul><p><strong>限制：</strong></p><ul><li>对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个MySQL的<code>表只能有一个聚簇索引</code>。一般情况下就是该表的主键。</li><li>如果没有定义主键，Innodb会选择<code>非空的唯一索引代替</code>。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引(<code>即RowId</code>)。</li><li>为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量<code>选用有序的顺序id</code>,而不建议用无序的id,比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul><h4 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h4><p>如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。</p><p>答案：我们可以<code>多建几颗B+树</code>，不同的B+树中的数据采用不同的排列规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616203852043.png" alt="image-20220616203852043"></p><p>这个B+树与上边介绍的聚簇索引有几处不同：</p><ul><li>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：<ul><li>页内的记录是按照c2列的大小顺序排成一个<code>单向链表</code>。</li><li>各个存放<code>用户记录的页</code>也是根据页中记录的c2列大小顺序排成一个<code>双向链表</code>。</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个<code>双向链表</code>。</li></ul></li><li>B+树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</li><li>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。（实际为c2列+加主键+页号）</li></ul><p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚网刚建好的这个B+树了。以查找c2列的值为<code>4</code>的记录为例，查找过程如下：</p><ol><li><p>确定<code>目录项记录页</code></p><p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位<code>到目录项记录</code>所在的页为<code>页4</code>2（因为<code>2&lt;4&lt;9</code>）。</p></li><li><p>通过<code>目录项记录</code>页确定用户记录真实所在的页。</p><p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2列</code>并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2&lt;4≤4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p><p>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p></li><li><p>但是这个B+树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>(也就是<code>主键</code>)两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p></li></ol><blockquote><p>即非聚簇索引B+树<code>叶子节点</code>存储的是<code>c2列+主键</code>的组合，然后使用查询到的主键利用回表操作到聚簇索引的B+树中查找</p></blockquote><blockquote><p>二级索引列可能不是unique的，所以当该列一致时，目录页中无法判断先后顺序，所以实际上二级索引B+树目录页（<strong>非叶子节点</strong>）存储的都是<strong>索引列+加主键+页号</strong>的组合，额外保存了主键用于判断索引列相同的情况</p><p>对应下面3.4 &gt; 2</p></blockquote><p>**概念：回表 **</p><p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 <code>聚簇索引</code> 中再查一遍，这个过程称为<code> 回表</code> 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 <code>2</code> 棵B+树！</p><p><strong>问题</strong>：为什么我们还需要一次 <code>回表</code> 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p><p><strong>回答</strong>：</p><p>如果把完整的用户记录放到叶子结点是可以不用回表。但是<code>太占地方</code>了，相当于每建立一课二级索引B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p><p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>，或者<code>辅助索引</code>。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616213109383.png" alt="image-20220616213109383"></p><p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p><ol><li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li><li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li><li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但由于非聚簇索引不会影响数据行的物理存储顺序，如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li></ol><h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 <code>c2和c3列</code> 的大小进行排序，这个包含两层含义： </p><ul><li>先把各个记录和页按照c2列进行排序。 </li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p>为c2和c3建立的索引的示意图如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220616215251172.png" alt="image-20220616215251172"></p><p>如图所示，我们需要注意以下几点：</p><ul><li>每条<code>目录项</code>都有<code>c2、c3、页号</code>这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li><li>B+树<code>叶子节点</code>处的用户记录由<code>c2、c3和主键c1列</code>组成</li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 <code>联合索引</code> ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： </p><ul><li>建立 <code>联合索引</code> 只会建立如上图一样的<strong>1棵B+树</strong>。 </li><li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li></ul><h3 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h3><h4 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h4><p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录顶记录的内节点，实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <code>根结点</code> 页面。最开始表中没有数据的时候，每个B+树索引对应的 <code>根结点</code> 中即没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code> 中。</li><li>当根节点中的可用 <code>空间用完时</code> 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 <code>页a</code> 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如<code>页b</code> 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 <code>页a</code> 或者 <code>页b</code> 中，而 <code>根节点</code> 便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 <code>InnoDB</code> 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。</p><blockquote><p><font color="red">B+树的形成不是像上面一样从下往上形成的，而是从根节点开始从上往下形成的</font></p></blockquote><h4 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h4><p>我们知道B+树索引的内节点中目录项记录的内容是 <code>索引列 + 页号</code> 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 <code>index_demo</code> 表为例，假设这个表中的数据是这样的：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617151918786.png" alt="image-20220617151918786"></p><p>如果二级索引中目录项记录的内容只是 <code>索引列 + 页号</code> 的搭配的话，那么为 <code>c2</code> 列简历索引后的B+树应该长这样：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617152906690.png" alt="image-20220617152906690"></p><p>如果我们想新插入一行记录，其中 <code>c1</code> 、<code>c2</code> 、<code>c3</code> 的值分别是: <code>9</code>、<code>1</code>、<code>c</code>, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 页号</code> 的值构成的，<code>页3</code> 中的两条目录项记录对应的 c2 列的值都是1，而我们 <code>新插入的这条记录</code> 的 c2 列的值也是 <code>1</code>，那我们这条新插入的记录到底应该放在 <code>页4</code> 中，还是应该放在 <code>页5</code> 中？</p><p>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于<strong>二级索引的内节点的目录项记录的内容实际上是由三个部分构成</strong>的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617154135258.png" alt="image-20220617154135258"></p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code> 时，由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 主键 + 页号</code> 的值构成的，可以先把新纪录的 <code>c2</code> 列的值和 <code>页3</code> 中各目录项记录的 <code>c2</code> 列的值作比较，如果 <code>c2</code> 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 <code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 <code>页5</code> 中。</p><blockquote><p>二级索引列可能不是unique的，所以当该列一致时，目录页中无法判断先后顺序，所以实际上二级索引B+树目录页（非叶子节点）存储的都是<strong>索引列+加主键+页号</strong>的组合，额外保存了主键用于判断索引列相同的情况</p></blockquote><h4 id="3-一个页面最少存储-2-条记录"><a href="#3-一个页面最少存储-2-条记录" class="headerlink" title="3. 一个页面最少存储 2 条记录"></a>3. 一个页面最少存储 2 条记录</h4><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p><h2 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h2><p>B+树索引使用存储引擎如表所示：</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用 <code>B+Tree</code> 作为索引结构，叶子节点的data域存放的是<code> 数据记录的地址</code>(因为MyISAL的表文件数据和索引是分开存储的) 。</p><blockquote><p>B+树就是B树，是基于B树的改进</p></blockquote><h3 id="4-1-MyISAM索引的原理"><a href="#4-1-MyISAM索引的原理" class="headerlink" title="4.1 MyISAM索引的原理"></a>4.1 MyISAM索引的原理</h3><p>我们知道<code>InnoDB中索引即数据</code>，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却<code>将索引和数据分开存储</code>：</p><ul><li>将表中的记录<code>按照记录的插入顺序</code>单独存储在一个文件中，称之为<code>数据文件</code>（.MYD文件）。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并<code>没有刻意按照主键大小排序</code>，所以我们并不能在这些数据上使用二分法进行查找。</li><li>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中（.MYI文件）。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值+数据记录地址</code>的组合。</li></ul><blockquote><p>可以理解为MyISAM没有聚簇索引，全是二级索引</p></blockquote><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617160413479.png" alt="image-20220617160413479"></p><p>这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出<br><strong>MyISAM的索引文件仅仅保存数据记录的地址</strong>。在MyISAM中，主键索引和二级索引(Secondary key)在结构上没<br>有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立一个二级索<br>引，则此索引的结构如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617160625006.png" alt="image-20220617160625006"></p><p>司样也是一棵B+Tree,data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算<br>去搜索索引，如果指定的Key存在,则取出其data域的值，然后以data域的值为地址，读取相应数据记录</p><h3 id="4-2-MyISAM-与-InnoDB对比"><a href="#4-2-MyISAM-与-InnoDB对比" class="headerlink" title="4.2 MyISAM 与 InnoDB对比"></a>4.2 MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</strong></p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对 <code>聚簇索引</code> 进行一次查找就能找到对应的记录，而在 <code>MyISAM</code> 中却需要进行一次 <code>回表</code> 操作，意味着MyISAM中建立的索引相当于全部都是 <code>二级索引</code> 。</p><p> ② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 <code>分离的</code> ，索引文件仅保存数据记录的地址。</p><p> ③ InnoDB的非聚簇索引data域存储相应记录 <code>主键的值</code> ，而MyISAM索引记录的是 <code>地址</code> 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</p><p> ④ MyISAM的回表操作是十分 <code>快速</code> 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。（<strong>所以说InnoDB速度比不上MyISAM</strong>）</p><p>⑤ InnoDB要求表 <code>必须有主键</code> （ <code>MyISAM可以没有 </code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段rowId作为主键，这个字段长度为6个字节，类型为长整型。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>了解不同存储引擎的索实现方式对于正确使用和优化索引都非常有帮助。比如：</p><p>举例1：知道了InnoDB的索实现后，就很容易明白<code>为什么不建议使用过长的字段作为主键</code>，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</p><p>举例2：用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree,非单调的主键会造成在插入新记录时，数据文件为了维持B+Tre的特性而频繁的分裂调整，十分低效，而使用<code>自增字段作为主键则是一个很好的选择</code>。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617161151125.png" alt="image-20220617161151125"></p><h2 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><p><strong>空间上的代价</strong></p><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 <code>16KB</code> 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p></li><li><p><strong>时间上的代价</strong></p><p>每次对表中的数据进行 <code>增、删、改</code> 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 <code>从小到大的顺序排序</code> 而组成了<code>双向链表</code>。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 <code>记录移位</code> ， <code>页面分裂</code> 、 <code>页面回收</code> 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p></li></ul><blockquote><p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p></blockquote><h2 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6. MySQL数据结构选择的合理性"></a>6. MySQL数据结构选择的合理性</h2><blockquote><p>即为什么选择B+树作为索引的数据结构？</p></blockquote><p>从MySQL的角度讲，不得不考虑一个现实问题就是磁盘IO。如果我们能让索引的数据结构尽量减少硬盘的I&#x2F;O操作，所消耗的时间也就越小。可以说，<code>磁盘的I/0操作次数</code>对索引的使用效率至关重要，相对而言，<strong>内存中算法的事件复杂度就没那么重要了</strong><br>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引是存储在外部磁盘上的</strong>。当我们利用索引查询的时候不可能把整个索引全部加载到内存，只能<code>逐一加载</code>，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p><h3 id="6-1-全表查询"><a href="#6-1-全表查询" class="headerlink" title="6.1 全表查询"></a>6.1 全表查询</h3><p>这里都懒得说了。</p><h3 id="6-2-Hash查询"><a href="#6-2-Hash查询" class="headerlink" title="6.2 Hash查询"></a>6.2 Hash查询</h3><p>Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p><p>Hash算法是通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。<code>相同的输入永远可以得到相同的输出</code>，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p><p>举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把Hsh函数计算得到的结果告诉你即可，然后在本地同样对文件进行Hsh函数的运算，最后通过比较这两个Hash函数的结果是否相同，就可以知道这两个文件是否相同。</p><p><strong>加快查找速度的数据结构，常见的有两类：</strong></p><p>(1) 树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(log₂N)</code>;</p><p>(2)哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(1)</code>; (key, value)</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617162153587.png" alt="image-20220617162153587"></p><p>采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次I&#x2F;O操作，<code>从效率来说Hash比B+树更快</code>。</p><p>在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h,根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[0…m-1]的槽位上。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617162604272.png" alt="image-20220617162604272"></p><p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 <code>碰撞</code> ，在数据库中一般采用 <code>链接法</code> 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617162703006.png" alt="image-20220617162703006"></p><p>实验：体会数组和hash表的查找方面的效率区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 算法复杂度为 O(n)</span><br><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    int[] arr = new int[100000];</span><br><span class="line">    for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">        arr[i] = i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    for(int j = 1; j&lt;=100000;j++)&#123;</span><br><span class="line">        int temp = j;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            if(temp == arr[i])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;time： &quot; + (end - start)); //time： 823</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 算法复杂度为 O(1)</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(100000);</span><br><span class="line">    for(int i = 0;i &lt; 100000;i++)&#123;</span><br><span class="line">    set.add(i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    for(int j = 1; j&lt;=100000;j++) &#123;</span><br><span class="line">        int temp = j;</span><br><span class="line">        boolean contains = set.contains(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;time： &quot; + (end - start)); //time： 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hash结构效率高，那为什么索引结构要设计成树型呢？</strong></p><p>原因1：Hash索引仅能满足(&#x3D;)(&lt;&gt;)和IN查询。如果进行<code>范围查询</code>，哈希型的索引，<strong>时间复杂度会退化为O(n)</strong>;而树型的“有序”特性，依然能够保持O(log₂N)的高效率。</p><p>原因2：Hash索引还有一个缺陷，数据的存储是<code>没有顺序的</code>，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</p><p>原因3：对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。即<strong>无法实行最左前缀原则</strong></p><p>原因4：对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<code>索引列的重复值如果很多，效率就会降低</code>。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</p><p><strong>Hash索引适用存储引擎如表所示：</strong></p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td><code>支持</code></td></tr></tbody></table><p><strong>Hash索引的适用性：</strong></p><p>Hash索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索效率更高，比如在键值型(Key-Value)数据库中，<code>Redis存储的核心就是Hash表</code>。</p><p>MySQL中的Memory存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<code>等值查询</code>的时候，采用Hsh索引是个不错的选择。</p><p>另外，<strong>InnoDB本身不支持Hash索引</strong>,但是提供<code>自适应Hash索引</code>(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617163657697.png" alt="image-20220617163657697"></p><p>采用自适应 Hash 索引目的是方便根据 <code>SQL</code> 的查询条件加速定位到<code>叶子节点</code>，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显<code>提高数据的检索效率</code>。</p><p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| innodb_adaptive_hash_index | ON    |</span><br><span class="line">+----------------------------+-------+</span><br></pre></td></tr></table></figure><h3 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><strong>1. 二叉搜索树的特点</strong></p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点，比我大的向右，比我小的向左</li></ul><p><strong>2. 查找规则</strong></p><p>我们先来看下最基础的二叉搜索树(Binary Search Tree),搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:</p><ol><li>如果ky大于根节点，则在右子树中进行查找：</li><li>如果key小于根节点，则在左子树中进行查找：</li><li>如果ky等于根节点，也就是找到了这个节点，返回根节点即可。</li></ol><p>举个例子，我们对数列(34,22,89,5,23,77,91)创造出来的二分查找树如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617164022728.png" alt="image-20220617164022728"></p><p>但是特殊情况，就是有时候二叉树的深度非常大，比如：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617164053134.png" alt="image-20220617164053134"></p><p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了<code>O()</code>。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。I</p><p>为了提高查询效率，就需要 <code>减少磁盘IO数</code> 。为了减少磁盘IO的次数，就需要尽量 <code>降低树的高度</code> ，需要把 <strong>原来“瘦高”的树结构变的“矮胖”</strong>，树的每层的分叉越多越好。</p><h3 id="6-4平衡二叉树（AVL树）"><a href="#6-4平衡二叉树（AVL树）" class="headerlink" title="6.4平衡二叉树（AVL树）"></a>6.4平衡二叉树（AVL树）</h3><p>为了解决上面二叉查找树退化成链表的问题，人们提出了<code>平衡二叉搜索树(Balanced Binary Tree)</code>,又称为<code>AVL树</code>（有别于AVL算法），它在二叉搜索树的基础上增加了约束，具有以下性质：</p><p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p><p>这里说一下，常见的平衡二叉树有很多种，包括了<code>平衡二叉搜索树</code>、<code>红黑树</code>、<code>数堆</code>、<code>伸展树</code>。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是<code>O(log₂n)</code>。<br>数据查询的时间主要依赖于磁盘I&#x2F;O的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是O(log₂n),当n比较大时，深度也是比较高的，比如下图的情况：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617165105005.png" alt="image-20220617165105005"></p><p><code>每访问一次节点就需要进行一次磁盘 I/O 操作</code>，对于上面的树来说，我们需要进行 5次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。</p><p>针对同样的数据，如果我们把<strong>二叉树改成 <code>M 叉树</code></strong> （M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617165124685.png" alt="image-20220617165124685"></p><p>你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把 <code>树从“瘦高” 变 “矮胖”</code>。</p><h3 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h3><p>B 树的英文是 Balance Tree，也就是 <code>多路平衡查找树</code>。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p><p>B 树的结构如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617165937875.png" alt="image-20220617165937875"></p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<code>M称为B树的阶</code>。每个磁盘块中包括了<code>关键字</code>和<code>子节点的指针</code>。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2,M]。 </li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li><li>所有叶子节点位于同一层。</li></ol><blockquote><p>假设 M &#x3D; 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个<strong>（M-1个）数据和</strong>最多有 3 个<strong>（M个）子节点</strong></p></blockquote><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要 <code>查找的关键字是 9</code> ，那么步骤可以分为以下几步：</p><ol><li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </li><li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </li><li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 <code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code> ， 在数据查询中比平衡二叉树效率要高。所以 <code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code> 。</p><p><strong>小结：</strong></p><ol><li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中，即<strong>叶子节点和非叶子节点都存放数据</strong>。搜索有可能在非叶子节点结束</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ol><p><strong>再举例1：</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617170526488.png" alt="image-20220617170526488"></p><h3 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h3><p>B+树也是一种多路搜索树，<code>基于B树做出了改进</code>，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree,<code>B+Tree适合文件索引系统</code>。</p><ul><li>MySQL官网说明：</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617170710329.png" alt="image-20220617170710329"></p><h3 id="6-7-各个索引数据结构之间的对比"><a href="#6-7-各个索引数据结构之间的对比" class="headerlink" title="6.7 各个索引数据结构之间的对比"></a>6.7 各个索引数据结构之间的对比</h3><p><strong>B+ 树和 B 树的差异在于以下几点：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。 </li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中，<code>非叶子节点既保存索引，也保存数据记录 </code>。 </li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol><p>下图就是一棵B+树，阶数为3，根节点中的关键字1、18、35分别是子节点(1,8,14)，(18,24,31)和(35,41,53)中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230818175118780.png" alt="image-20230818175118780"></p><p>比如，我们想要查找关键字16，B+树会自顶向下逐层进行查找：</p><ul><li>与根节点的关键字(1,18,35)进行比较，16在1和18之间，得到指针P1(指向磁盘块2)</li><li>找到磁盘块2，关键字为(1,8,14)，因为16大于14，所以得到指针P3(指向磁盘块7)</li><li>找到磁盘块7，关键字为(14,16,17)，然后我们找到了关键字16，所以可以找到关键字16所对应的数据。</li></ul><p>整个过程一共进行了3次I&#x2F;O操作，看起来B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在于，<strong>B+树的中间节点并不直接存储数据</strong>。这样的好处都有什么呢</p><ul><li><p>首先，<strong>B+树查询效率更稳定</strong>（无论什么情况下都是O(log₂n)的复杂度）。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p></li><li><p>其次，<strong>B+树的查询效率更高</strong>(B+树更矮胖，一页中存储的记录条数也更多，<strong>因为内节点不用存储数据</strong>)。这是因为通常B+树比B树更矮胖（阶数更大，深度更低），查询所需要的磁盘I&#x2F;O也会更少。<font color="cornflowerblue">同样的磁盘页大小，B+树可以存储更多的节点关键字</font>。</p></li><li><p><strong>B+ 树的插入和删除效率更高</strong>。B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，<strong>可能涉及复杂的树的变形</strong>;B+ 树有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。</p></li><li><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高</strong>（B+树所有数据都在叶子节点上，只需要通过<code>链表单调查找</code>即可，而B树还需要进行<code>树的中序遍历</code>）。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p></li></ul><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p></blockquote><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p></blockquote><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB,一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值（因为是估值，为方便计算，这里的K取值为 10^3^ 。也就是说一个深度为3的B+Tree索引可以维护 10^3^ * 10^3^ * 10^3^ &#x3D;10亿条记录。（这里假设一个数据页也存储 10^3^ 条行记录数据了）</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。MySQL的InnoDB存储引擎<br>在设计时是将<strong>根节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要<strong>1~3次磁盘I&#x2F;O操作</strong>。</p></blockquote><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><blockquote><p>1、B+树的磁盘读写代价更低<br>B+树的内部结点并没有指向关键字具体信息的指针。<code>因此其内部结点相对B树更小</code>。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。这是因为Hash索引指向的数据是无序的，范围查询时事件复杂度下降为O(n)，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hsh值。因此如果用到联合索引的一个或者几个索时，联合索引无法被利用。</p><p>3、Hash索引<code>不支持ORDER BY排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p><p>4、<code>InnoDB不支持哈希索引</code>，但支持自适应哈希默认开启</p><p>5、Hash索引容易重复</p></blockquote><p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong></p><blockquote><p>你能看到，针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，<code>无法使用Hash索引</code>。InnoDB提供的<code>自适应Hash是不需要手动指定的</code>。如果是Memory&#x2F;Heap和NDB存储引擎，是可以进行选择Hash索引的。</p></blockquote><h3 id="6-8-R树-了解"><a href="#6-8-R树-了解" class="headerlink" title="6.8 R树(了解)"></a>6.8 R树(了解)</h3><p>R-Tree在MySQL很少使用，仅支持 <code>geometry数据类型</code> ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果 没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记 录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 <code>解决了这种高维空间搜索问题</code> 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来<code> 存储高维数据的平衡树</code> 。相对于B-Tree，R-Tree 的优势在于范围查找。</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>R-Tree索引</td><td>支持</td><td>支持</td><td><code>不支持</code></td></tr></tbody></table><h3 id="6-9-小结"><a href="#6-9-小结" class="headerlink" title="6.9 小结"></a>6.9 小结</h3><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）。<br>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管<code>索引不是万能的</code>，但<code>数据量大的时候不使用索引是不可想象的</code>，毕竟索引的本质，是帮助我们提升数据检索的效率。</p><h3 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617175516191.png" alt="image-20220617175516191"></p><h1 id="第7章-InnoDB数据存储结构"><a href="#第7章-InnoDB数据存储结构" class="headerlink" title="第7章_InnoDB数据存储结构"></a>第7章_InnoDB数据存储结构</h1><h2 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h2><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据：</p><p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InnoDB存储引擎的数据存储结构。</p><h3 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h3><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<strong>16KB</strong>。</p><p>以<code>页</code>作为磁盘和内存之间交互的<code>基本单位</code>，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page),数据库I&#x2F;O操作的最小单位是页</strong>。一个页中可以存储多个行记录。</p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I&#x2F;O操作）只能处理一行数据，效率会非常低</p></blockquote><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230818220931563.png" alt="image-20230818220931563"></p><h3 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h3><p>页a、页b、页c.页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><h3 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h3><p>不同的数据库管理系统（简称DBMS）的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 <code>16KB</code>，我们可以通过下面的命令来进行查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%innodb_page_size%&#x27;</span><br></pre></td></tr></table></figure><p>SQL Server 中页的大小为 <code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>“ （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p><h3 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h3><p>另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617194256988.png" alt="image-20220617194256988"></p><p>区(Extent)是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB,所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。<br>段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页）不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位</code>，<code>不同类型的数据库对象以不同的段形式存在</code>。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。<br>表空间(Tablespace)是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<strong>系统表空间</strong>、<strong>用户表空间</strong>、<strong>撤销表空间</strong>、<strong>临时表空间</strong>等。</p><h2 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h2><p>页如果按类型划分的话，常见的有 <code>数据页（保存B+树节点）、系统表、Undo 页 和 事务数据页</code> 等。数据页是我们最常使用的页。</p><p>数据页的 <code>16KB</code> 大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum + supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p><p>页结构的示意图如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617195012446.png" alt="image-20220617195012446"></p><p>如下表所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220617195148164.png" alt="image-20220617195148164"></p><p>我们可以把这7个结构分为3个部分。</p><h3 id="第一部分：File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header (文件头部) 和 File Trailer (文件尾部)"></a>第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</h3><p>见文件<a href="mj-map:///E:\MyNotes3\MySQL\InnoDB%20data%20storage%20structure.mmap#oid={A29FFD5E-9644-4202-8E71-A7E6BD872C73}">InnoDB数据库存储结构.mmap（InnoDB data storage structure.mmap）</a></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230819155905656.png" alt="image-20230819155905656"></p><h3 id="第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h3><p>见文件<a href="mj-map:///E:\MyNotes3\MySQL\InnoDB%20data%20storage%20structure.mmap#oid={A2A36009-904A-453D-BE92-51BA3910C440}">InnoDB数据库存储结构.mmap（InnoDB data storage structure.mmap）</a></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230819155914917.png" alt="image-20230819155914917"></p><p>用户记录是以一定的行格式进行存储的，InnoDB和MyISAM默认的行格式都是<strong>Dynamic</strong></p><p>我们以最经典的<strong>Compact</strong>行格式为说法</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230820144121317.png" alt="image-20230820144121317"></p><blockquote><p>Dynamic和Compressed行格式只是在行溢出时是<code>完全行溢出</code>，Compact和Redundant(冗余)行格式是<code>部分行溢出（存放768个前缀字节）</code></p></blockquote><p>行格式详情见文件<a href="mj-map:///E:\MyNotes3\MySQL\InnoDB%20data%20storage%20structure.mmap#oid={559A7803-6D7A-4084-88DC-4C27CCBF034C}">InnoDB数据库存储结构.mmap（InnoDB data storage structure.mmap）</a></p><h3 id="第三部分：Page-Directory-页目录-和-Page-Header-页面头部"><a href="#第三部分：Page-Directory-页目录-和-Page-Header-页面头部" class="headerlink" title="第三部分：Page Directory (页目录) 和 Page Header (页面头部)"></a>第三部分：Page Directory (页目录) 和 Page Header (页面头部)</h3><p>见文件<a href="mj-map:///E:\MyNotes3\MySQL\InnoDB%20data%20storage%20structure.mmap#oid={288001B7-A046-48E2-A08E-85AAC5A30C26}">InnoDB数据库存储结构.mmap（InnoDB data storage structure.mmap）</a></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230819155931155.png" alt="image-20230819155931155"></p><h3 id="2-3-从数据库页的角度看B-树如何查询"><a href="#2-3-从数据库页的角度看B-树如何查询" class="headerlink" title="2.3 从数据库页的角度看B+树如何查询"></a>2.3 从数据库页的角度看B+树如何查询</h3><p>一颗B+树按照字节类型可以分为两部分：</p><ol><li>叶子节点，B+ 树最底层的节点，节点的高度为0，存储行记录。</li><li>非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。</li></ol><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220620221112635.png" alt="image-20220620221112635"></p><p>当我们从页结构来理解 B+ 树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：</p><p><strong>1.B+树是如何进行记录检索的？</strong></p><p>如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽(slot)采用<code>二分查找</code>的方式先找到一个粗略的记录分组(<font color="cornflowerblue">先找到对应所在的slot的前一个槽位，因为页目录中指针指向的是slot的<strong>最后一条记录</strong>（见页目录结构部分），然后下一跳记录就是我们想要找的slot了</font>)，然后再在分组中通过<code>链表遍历</code>的方式查找记录。</p><p><strong>2.普通索引和唯一索引在查询效率上有什么不同？</strong>（区分聚簇索引和二级索引）</p><p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？</p><p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB,在一个页中可能存储着上干个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。</p><h2 id="3-InnoDB行格式-或记录格式"><a href="#3-InnoDB行格式-或记录格式" class="headerlink" title="3. InnoDB行格式 (或记录格式)"></a>3. InnoDB行格式 (或记录格式)</h2><p>见文件InnoDB数据库存储结构.mmap（InnoDB data storage structure.mmap）</p><h3 id="附录：为什么「变长字段长度列表」的信息要按照逆序存放？"><a href="#附录：为什么「变长字段长度列表」的信息要按照逆序存放？" class="headerlink" title="附录：为什么「变长字段长度列表」的信息要按照逆序存放？"></a>附录：为什么「变长字段长度列表」的信息要按照逆序存放？</h3><p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p><p>同样的道理， NULL 值列表的信息也需要逆序存放。</p><h3 id="附录：-varchar-n-中-n-最大取值为多少？"><a href="#附录：-varchar-n-中-n-最大取值为多少？" class="headerlink" title="附录： varchar(n) 中 n 最大取值为多少？"></a>附录： varchar(n) 中 n 最大取值为多少？</h3><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。</p><p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><h4 id="单字段的情况"><a href="#单字段的情况" class="headerlink" title="单字段的情况"></a>单字段的情况</h4><p>前面我们知道了，一行记录最大只能存储 65535 字节的数据。</p><p>那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？</p><p>不着急说结论，我们先来做个实验验证一下。</p><p>我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test ( </span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">65535</span>)  <span class="keyword">NULL</span></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br></pre></td></tr></table></figure><p>看能不能成功创建一张表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/error.png" alt="img"></p><p>可以看到，创建失败了。</p><p>从报错信息就可以知道<strong>一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead</strong>。</p><p>问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说<strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong>。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。</p><p>这是因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li>NULL 标识，如果不允许为NULL，这部分不需要</li></ul><blockquote><p>本次案例中，「NULL 值列表」所占用的字节数是多少？</p></blockquote><p>前面我创建表的时候，字段是允许为 NULL 的，所以<strong>会用 1 字节来表示「NULL 值列表」</strong>。</p><blockquote><p>本次案例中，「变长字段长度列表」所占用的字节数是多少？</p></blockquote><p>「变长字段长度列表」所占用的字节数 &#x3D; 所有「变长字段长度」占用的字节数之和。</p><p>所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：</p><ul><li>条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；</li><li>条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；</li></ul><p>我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。</p><p><strong>因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」&#x3D; 1 个「变长字段长度」占用的字节数，也就是 2 字节</strong>。</p><p>因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532</strong>。</p><p>我们先来测试看看 varchar(65533) 是否可行？</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/65533.png" alt="img"></p><p>可以看到，还是不行，接下来看看 varchar(65532) 是否可行？</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/65532.png" alt="img"></p><p>可以看到，创建成功了。说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。</p><p>当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：</p><ul><li>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</li></ul><p>上面所说的只是针对于一个字段的计算方式。</p><h4 id="多字段的情况"><a href="#多字段的情况" class="headerlink" title="多字段的情况"></a>多字段的情况</h4><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</strong>。</p><h2 id="4-区、段与碎片区"><a href="#4-区、段与碎片区" class="headerlink" title="4. 区、段与碎片区"></a>4. 区、段与碎片区</h2><h3 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h3><p><code>B+树</code>的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢的</code>，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p><p>引入<code>区</code>的概念，一个区就是在物理位置上<code>连续的64个页</code>。因为InnoDB中的页大小默认是16KB,所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I&#x2F;O,<code>功大于过</code>！</p><h3 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h3><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment)</code>,存放非叶子节点的区的集合也算是一个段。也就是说<strong>一个索引会生成2个段</strong>，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理</p><p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><h3 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h3><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，<strong>一个索引会生成2个段</strong>，而段是以区为单位申请存储空间的，一个区默认占用1M(64*16Kb&#x3D;1024Kb)存储空间，所以<strong>默认情况下一个只存了几条记录的小表需要2M的存储空间么？</strong>以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片(fragment)区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎区中的页可以用于不同的目的，比如有些页用于段“，有些页用于段B,有些页甚至哪个段都不属于。<code>碎片区直于表空间</code>，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以<code>单个页面为单位</code>来分配存储空间的。</li><li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>以及<code>一些完整的区</code>的集合。</p><h3 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h3><p>区大体上可以分为4种类型：</p><ul><li><code>空闲的区 (FREE)</code> : 现在还没有用到这个区中的任何页面。</li><li><code>有剩余空间的碎片区 (FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li><li><code>没有剩余空间的碎片区 (FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li><code>附属于某个段的区 (FSEG)</code>：每一个索引都可以分为叶子节点段和非叶子节点段。</li></ul><p>处于<code>FREE</code>、<code>FREE_FRAG</code> 以及 <code>FULL_FRAG</code> 这三种状态的区都是独立的，<strong>直属于表空间</strong>。而处于 <code>FSEG</code> 状态的区是<strong>附属于某个段的</strong>。</p><blockquote><p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于<code> FSEG</code> 的区全部隶属于某个段，而处于 <code>FREE、FREE_FRAG</code> 以及 <code>FULL_FRAG</code> 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p></blockquote><h2 id="5-表空间"><a href="#5-表空间" class="headerlink" title="5. 表空间"></a>5. 表空间</h2><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p><p>表空间是一个<code>逻辑容器</code>，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>(Systemtablespace)、<code>独立表空间</code>(File-per-table tablespace)、<code>撤销表空间</code>(Undo Tablespace)和<code>临时表空间</code>(Temporary Tablespace)等。</p><h3 id="5-1-独立表空间"><a href="#5-1-独立表空间" class="headerlink" title="5.1 独立表空间"></a>5.1 独立表空间</h3><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行 <code>迁移</code>。</p><p>空间可以回收 (DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收) 。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table TableName engine&#x3D;innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p><p><strong>独立表空间结构</strong></p><p>独立表空间由段、区、页组成。</p><p><strong>真实表空间对应的文件大小</strong></p><p>我们到数据目录里看，会发现一个新建的表对应的 <code>.ibd</code> 文件只占用了 <code>96K</code>，才6个页面大小 (MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是<code>自扩展的</code>，随着表中数据的增多，表空间对应的文件也逐渐增大。</p><p><strong>查看 InnoDB 的表空间类型：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_file_per_table&#x27;</span><br></pre></td></tr></table></figure><p>你能看到 innodb_file_per_table&#x3D;ON, 这就意味着每张表都会单词保存一个 .ibd 文件。</p><h3 id="5-2-系统表空间"><a href="#5-2-系统表空间" class="headerlink" title="5.2 系统表空间"></a>5.2 系统表空间</h3><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p><p><strong>InnoDB数据字典</strong></p><p>每当我们向一个表中插入一条记录的时候，<code>MySQL校验过程</code>如下：</p><p>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p><blockquote><p>-某个表属于哪个表空间，表里边有多少列<br>-表对应的每一个列的类型是什么<br>-该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面<br>-该表有哪些外键，外键对应哪个表的哪些列<br>-某个表空间对应文件系统上文件路径是什么<br>-…</p></blockquote><p>删除这些数据并不是我们使用 <code>INSERT</code> 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得以引入的一些额外数据，这些数据页称为 <code>元数据</code>。InnoDB 存储引擎特意定义了一些列的 <code>内部系统表</code> (internal system table) 来记录这些元数据：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621150924922.png" alt="image-20220621150924922" style="float:left;"><p>这些系统表也称为 <code>数据字典</code>，它们都是以 <code>B+</code> 树的形式保存在系统表空间的某个页面中。其中 <code>SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS</code> 这四个表尤其重要，称之为基本系统表 (basic system tables) ，我们先看看这4个表的结构：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621151139759.png" alt="image-20220621151139759" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621151158361.png" alt="image-20220621151158361" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621151215274.png" alt="image-20220621151215274" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621151238157.png" alt="image-20220621151238157" style="float:left;"><p>注意：<code>用户不能直接访问</code> InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 <code>information_schema</code> 中提供了一些以 <code>innodb_sys</code> 开头的表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE information_schema;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;</span><br></pre></td></tr></table></figure><p>在 <code>information_scheme</code> 数据库中的这些以 <code>INNODB_SYS</code> 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 <code>SYS</code> 开头的那些表)，而是在存储引擎启动时读取这些以 <code>SYS</code> 开头的系统表，然后填充到这些以 <code>INNODB_SYS</code> 开头的表中。以 <code>INNODB_SYS</code> 开头的表和以 <code>SYS</code> 开头的表中的字段并不完全一样，但仅供大家参考已经足矣。</p><h2 id="附录：数据页加载的三种方式"><a href="#附录：数据页加载的三种方式" class="headerlink" title="附录：数据页加载的三种方式"></a>附录：数据页加载的三种方式</h2><p>InnoDB从磁盘中读取数据 <code>最小单位</code> 是数据页。而你想得到的 id &#x3D; xxx 的数据，就是这个数据页众多行中的一行。</p><p>对于MySQL存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按 <code>数据页</code> 形式进行存放的，当其加载到 MySQL 中我们称之为 <code>缓存页</code>。</p><p>如果缓冲池没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取速率是不同的：</p><p><strong>1. 内存读取</strong></p><p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220621135638283.png" alt="image-20220621135638283"></p><p><strong>2. 随机读取</strong></p><p>如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在<code>10ms</code>左右，这10ms中有6ms是磁盘的实际繁忙时间（包括了<code>寻道和半圈旋转时间</code>），有3ms是对可能发生的排队时间的估计值，另外还有1ms的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区中。这10ms看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220621135737422.png" alt="image-20220621135737422"></p><p><strong>3. 顺序读取</strong></p><p>顺序读取其实是一种批量读取的方式，因为我们请求的<code>数据在磁盘上往往都是相邻存储的</code>，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘I&#x2F;O操作了。如果一个磁盘的吞吐量是40MB&#x2F;S,那么对于一个16KB大小的页来说，一次可以顺序读取2560(40MB&#x2F;16KB)个页，相当于个页的读取时间为0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，<strong>效率也比从<code>内存</code>中只单独读取一个页的效率要高</strong>。</p><blockquote><p>所以我们更想要顺序存储，于是区就诞生了，一个区包含64个页，大小为16KB*64&#x3D;1MB</p></blockquote><h1 id="第8章-索引的创建与设计原则"><a href="#第8章-索引的创建与设计原则" class="headerlink" title="第8章_索引的创建与设计原则"></a>第8章_索引的创建与设计原则</h1><h2 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a>1. 索引的声明与使用</h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><p>从 <code>功能逻辑</code> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 </p><p>按照 <code>物理实现方式</code> ，索引可以分为 2 种：聚簇索引和非聚簇索引。 </p><p>按照 <code>作用字段个数</code> 进行划分，分成单列索引和联合索引。</p><p><strong>1. 普通索引</strong></p><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<code>任何数据类型</code>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索以后，可以通过索引进行查询。例如，在表<code>student</code>的字段<code>name</code>上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><p><strong>2. 唯一性索引</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621202850551.png" alt="image-20220621202850551" style="float:left;"><p><strong>3. 主键索引</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621203302303.png" alt="image-20220621203302303" style="float:left;"><p><strong>4. 单列索引</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621203333925.png" alt="image-20220621203333925" style="float:left;"><p><strong>5. 多列 (组合、联合) 索引</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621203454424.png" alt="image-20220621203454424" style="float:left;"><p><strong>6. 全文检索</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621203645789.png" alt="image-20220621203645789" style="float:left;"><p><strong>7. 补充：空间索引</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220621203736098.png" alt="image-20220621203736098" style="float:left;"><p>**小结：不同的存储引擎支持的索引类型也不一样 **</p><p>InnoDB ：支持 B-tree、Full-text(5.7之前MyISAM，之后InnoDB和MyISAM) 等索引，不支持 Hash 索引； </p><p>MyISAM ： 支持 B-tree、Full-text、SPATIAL 等索引，不支持 Hash 索引； </p><p>Memory ：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；</p><p>NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引； </p><p>Archive ：不支 持 B-tree、Hash、Full-text 等索引；</p><p>降序索引：MySQL8之后InnoDB</p><h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h3><p>MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句 CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。</p><h4 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1. 创建表的时候创建索引"></a>1. 创建表的时候创建索引</h4><p><strong>隐式创建索引：</strong></p><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义<code>主键约束</code>、<code>外键约束</code>或者<code>唯一性约束</code>，而不论创建哪种约束，<u>在定义约束的同时相当于在指定列上创建了一个索引</u>。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">    dept_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">    emp_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    emp_name VARCHAR(20) UNIQUE,</span><br><span class="line">    dept_id INT,</span><br><span class="line">    CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但是，如果<strong>显式创建表时创建索引</strong>的话，基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name (</span><br><span class="line">    [col_name data_type]</span><br><span class="line">    ...</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>UNIQUE</code> 、 <code>FULLTEXT</code> 和 <code>SPATIAL</code> 为可选参数，分别表示唯一索引、全文索引和空间索引； </li><li><code>INDEX</code> 与 <code>KEY</code> 为同义词，两者的作用相同，用来指定创建索引； </li><li><code>index_name</code> 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </li><li><code>col_name</code> 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </li><li><code>length</code> 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </li><li><code>ASC</code> 或 <code>DESC</code> 指定升序或者降序的索引值存储。</li></ul><p><strong>1. 创建普通索引</strong></p><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE book(</span><br><span class="line">    book_id INT ,</span><br><span class="line">    book_name VARCHAR(100),</span><br><span class="line">    authors VARCHAR(100),</span><br><span class="line">    info VARCHAR(100) ,</span><br><span class="line">    comment VARCHAR(100),</span><br><span class="line">    year_publication YEAR,</span><br><span class="line">    INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="附录：查看和监测索引"><a href="#附录：查看和监测索引" class="headerlink" title="附录：查看和监测索引"></a>附录：查看和监测索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM book \G;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table book;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from book where book_name = &#x27;MySQL高级&#x27;;</span><br></pre></td></tr></table></figure><p><strong>2. 创建唯一索引</strong></p><blockquote><p>唯一索引和唯一约束会互相创建</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name varchar(30) NOT NULL,</span><br><span class="line">UNIQUE INDEX uk_idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from test1\G;</span><br></pre></td></tr></table></figure><p><strong>3. 主键索引</strong></p><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p><ul><li>随表一起建索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">id INT(10) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">student_no VARCHAR(200),</span><br><span class="line">student_name VARCHAR(200),</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>删除主键索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">drop PRIMARY KEY;</span><br></pre></td></tr></table></figure><ul><li>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</li></ul><p><strong>4. 创建单列索引</strong></p><p>引举:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test2(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(50) NULL,</span><br><span class="line">INDEX single_idx_name(name(20))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test2 \G</span><br></pre></td></tr></table></figure><p><strong>5. 创建组合索引</strong></p><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test3(</span><br><span class="line">id INT(11) NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT(11) NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW INDEX 查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test3 \G</span><br></pre></td></tr></table></figure><p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test3 WHERE id=1 AND name=&#x27;songhongkang&#x27; \G</span><br></pre></td></tr></table></figure><p>可以看到，查询id和name字段时，使用了名称为MultiIdx的索引，如果查询 (name, age) 组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL, 并没有使用在t3表中创建的索引进行查询。</p><p><strong>6. 创建全文索引</strong></p><p>FULLTEXT全文索引可以用于全文检索，并且只为 <code>CHAR</code> 、<code>VARCHAR</code> 和 <code>TEXT</code> 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。</p><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test4(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><blockquote><p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p></blockquote><p>语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test4 \G</span><br></pre></td></tr></table></figure><p>由结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。</p><p>举例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles (</span><br><span class="line">id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">title VARCHAR (200),</span><br><span class="line">body TEXT,</span><br><span class="line">FULLTEXT index (title, body)</span><br><span class="line">) ENGINE = INNODB;</span><br></pre></td></tr></table></figure><p>创建了一个给title和body字段添加全文索引的表。</p><p>举例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `papers` (</span><br><span class="line">`id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">`title` varchar(200) DEFAULT NULL,</span><br><span class="line">`content` text,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>不同于like方式的的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;</span><br></pre></td></tr></table></figure><p>全文索引用match+against方式查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure><p>明显的提高查询效率。</p><blockquote><p>注意点 </p><ol><li>使用全文索引前，搞清楚版本支持情况； </li><li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li><li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li></ol></blockquote><p><strong>7. 创建空间索引</strong></p><p>空间索引创建中，要求空间类型的字段必须为 非空 。</p><p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test5(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test5 \G</span><br></pre></td></tr></table></figure><p>可以看到，test5表的geo字段上创建了名称为spa_idx_geo的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p><h4 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2. 在已经存在的表上创建索引"></a>2. 在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p><p><strong>1. 使用ALTER TABLE语句创建索引</strong> ALTER TABLE语句创建索引的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]</span><br><span class="line">[index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><p><strong>2. 使用CREATE INDEX创建索引</strong> CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h3><p><strong>1. 使用ALTER TABLE删除索引</strong>  ALTER TABLE删除索引的基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure><blockquote><p>提示：<strong>使用AUTO_INCREMENT约束字段的唯一索引不能被删除。</strong></p></blockquote><p><strong>2. 使用DROP INDEX语句删除索引</strong> DROP INDEX删除索引的基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><blockquote><p>提示: 删除表中的列时，如果要删除的列为联合索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p></blockquote><h2 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a>2. MySQL8.0索引新特性</h2><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h3><p>降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDBc存储引擎)。</p><p>MySQL在<strong>8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率</strong>。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</span><br></pre></td></tr></table></figure><p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下:</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220622224124267.png" alt="image-20220622224124267"></p><p>从结果可以看出，索引仍然是默认的升序</p><p>在MySQL 8.0版本中查看数据表ts1的结构，结果如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220622224205048.png" alt="image-20220622224205048"></p><p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE ts_insert()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">WHILE i &lt; 800</span><br><span class="line">DO</span><br><span class="line">insert into ts1 select rand()*80000, rand()*80000;</span><br><span class="line">SET i = i+1;</span><br><span class="line">END WHILE;</span><br><span class="line">commit;</span><br><span class="line">END //</span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL ts_insert();</span><br></pre></td></tr></table></figure><p>在MySQL 5.7版本中查看数据表ts1的执行计划:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a, b DESC LIMIT 5;</span><br></pre></td></tr></table></figure><p>在MySQL 8.0版本中查看数据表 ts1 的执行计划。</p><p>从结果可以看出，修改后MySQL 8.0 的执行计划要明显好于MySQL 5.7。</p><h3 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h3><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发展删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较 大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>从MySQL 8.x开始支持 <code>隐藏索引（invisible indexes</code>） ，只需要将待删除的索引设置为隐藏索引，使 查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 <code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p><p>同时，如果你想验证某个索引删除之后的 <code>查询性能影响</code>，就可以暂时先隐藏该索引（<strong>查询某个索引是否有用</strong>）。</p><blockquote><p>注意：</p><p><strong>主键不能被设置为隐藏索引</strong>。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p></blockquote><p>索引默认是可见的，在使用CREATE TABLE, CREATE INDEX 或者 ALTER TABLE 等语句时可以通过 <code>VISIBLE</code> 或者 <code>INVISIBLE</code> 关键词设置索引的可见性。</p><p><strong>1. 创建表时直接创建</strong></p><p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">propname1 type1[CONSTRAINT1],</span><br><span class="line">propname2 type2[CONSTRAINT2],</span><br><span class="line">……</span><br><span class="line">propnamen typen,</span><br><span class="line">INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。</p><p><strong>2. 在已经存在的表上创建</strong></p><p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexname</span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p><strong>3. 通过ALTER TABLE语句创建</strong></p><p>语法形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p><strong>4. 切换索引可见状态</strong></p><p>已存在的索引可通过如下语句切换可见状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure><p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。</p><blockquote><p>注意<br>当索引被隐藏时，<font color="cornflowerblue">它的内容仍然是和正常索引一样实时更新的</font>。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p></blockquote><p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p><p><strong>5. 使隐藏索引对查询优化器可见</strong></p><p>在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 (use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果use_invisible_indexes 设置为off (默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引。</p><p>（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure><p>在输出的结果信息中找到如下属性配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=off</span><br></pre></td></tr></table></figure><p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p><p>（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>SQL语句执行成功，再次查看查询优化器的开关设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch:</span><br><span class="line">index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_</span><br><span class="line">intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co</span><br><span class="line">st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on</span><br><span class="line">,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on</span><br><span class="line">,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind</span><br><span class="line">exes=on,skip_scan=on,hash_join=on</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>此时，在输出结果中可以看到如下属性配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=on</span><br></pre></td></tr></table></figure><p>use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。</p><p>（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from classes where cname = &#x27;高一2班&#x27;;</span><br></pre></td></tr></table></figure><p>查询优化器会使用隐藏索引来查询数据。</p><p>（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=off&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>再次查看查询优化器的开关设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure><p>此时，use_invisible_indexes属性的值已经被设置为“off”。</p><h2 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a>3. 索引的设计原则</h2><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。</strong>高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p><strong>第1步：创建数据库、创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE atguigudb1;</span><br><span class="line">USE atguigudb1;</span><br><span class="line">#1.创建学生表和课程表</span><br><span class="line">CREATE TABLE `student_info` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`student_id` INT NOT NULL ,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`course_id` INT NOT NULL ,</span><br><span class="line">`class_id` INT(11) DEFAULT NULL,</span><br><span class="line">`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `course` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`course_id` INT NOT NULL ,</span><br><span class="line">`course_name` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p><strong>第2步：创建模拟数据必需的存储函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#函数1：创建随机产生字符串函数</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT)</span><br><span class="line">RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#函数2：创建随机数函数</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建函数，假如报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure><p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p><p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。</p><ul><li>查看mysql是否允许创建函数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_bin_trust_function_creators&#x27;;</span><br></pre></td></tr></table></figure><ul><li>命令开启：允许创建函数设置：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure><ul><li><p>mysqld重启，上述参数又会消失。永久方法：</p><ul><li><p>windows下：my.ini[mysqld]加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure></li><li><p>linux下：&#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>第3步：创建插入模拟数据的存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程1：创建插入课程表存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_course( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO course (course_id, course_name ) VALUES</span><br><span class="line">(rand_num(10000,10100),rand_string(6));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程2：创建插入学生信息表存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES</span><br><span class="line">(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>第4步：调用存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_course(100);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_stu(1000000);</span><br></pre></td></tr></table></figure><h3 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h3><h4 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1. 字段的数值有唯一性的限制"></a>1. 字段的数值有唯一性的限制</h4><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中如果<strong>某个字段是唯一性的</strong>，就可以直接<strong>创建唯一性索引</strong>，或者<strong>主键索引</strong>。这样可以更快速地通过该索引来确定某条记录。</p><p>例如，学生表中<strong>学号</strong>是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用<strong>姓名</strong>的话，可能存在同名现象，从而降低查询速度。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也<strong>必须</strong>建成唯一索引。（来源：Alibaba） </p><p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p><p><strong><font color="red">即：唯一值的字段例如学号身份证号等，必须添加唯一约束(索引)</font></strong></p></blockquote><h4 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2. 频繁作为 WHERE 查询条件的字段"></a>2. 频繁作为 WHERE 查询条件的字段</h4><p>某个字段在SELECT语句的 <code>WHERE</code> 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。 </p><p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id&#x3D;123110 的用户信息。</p><h4 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3. 经常 GROUP BY 和 ORDER BY 的列"></a>3. 经常 GROUP BY 和 ORDER BY 的列</h4><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code> 。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code> 。</p><h4 id="4-UPDATE、DELETE-的-WHERE-条件列"><a href="#4-UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE 的 WHERE 条件列"></a>4. UPDATE、DELETE 的 WHERE 条件列</h4><p>对数据按照某个条件进行查询后再进行 <code>UPDATE </code>或 <code>DELETE </code>的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><h4 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5.DISTINCT 字段需要创建索引"></a>5.DISTINCT 字段需要创建索引</h4><p>有时候我们需要对某个字段进行去重，使用 <code>DISTINCT</code>，那么对这个字段创建索引，也会提升查询效率。 </p><p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.683s ）</p><p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.010s ）</p><p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p><h4 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6. 多表 JOIN 连接操作时，创建索引注意事项"></a>6. 多表 JOIN 连接操作时，创建索引注意事项</h4><p>首先， <code>连接表的数量尽量不要超过 3 张</code> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。 </p><p>其次， <code>对 WHERE 条件创建索引</code> ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。 </p><p>最后， <code>对用于连接的字段创建索引</code> ，并且该字段在多张表中的 <code>类型必须一致</code> 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p><blockquote><p>因为使用函数隐式转换类型过后，索引就会失效</p></blockquote><p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.course_id, name, s.student_id, c.course_name</span><br><span class="line">FROM student_info s JOIN course c</span><br><span class="line">ON s.course_id = c.course_id</span><br><span class="line">WHERE name = &#x27;462eed7ac6e791292a79&#x27;;</span><br></pre></td></tr></table></figure><p>运行结果（1 条数据，运行时间 0.189s ）</p><p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。</p><h4 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a>7. 使用列的类型小的创建索引</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220623175306282.png" alt="image-20220623175306282" style="float:left;"><h4 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a>8. 使用字符串前缀创建索引</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220623175513439.png" alt="image-20220623175513439" style="float:left;"><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table shop(address varchar(120) not null);</span><br><span class="line">alter table shop add index(address(12));</span><br></pre></td></tr></table></figure><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字 段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？</p><p>先看一下字段在全部数据中的选择度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct address) / count(*) from shop</span><br></pre></td></tr></table></figure><p>通过不同长度去计算，与全表的选择性对比：</p><p>公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br><span class="line">from shop;</span><br></pre></td></tr></table></figure><blockquote><p>越接近于1越好，说明越有区分度</p></blockquote><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p><p>如果使用了索引列前缀，比方说前边只把address列的 <code>前12个字符</code> 放到了二级索引中，下边这个查询可能就有点尴尬了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM shop</span><br><span class="line">ORDER BY address</span><br><span class="line">LIMIT 12;</span><br></pre></td></tr></table></figure><p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式 <code>无法支持使用索引排序</code> ，只能使用文件排序。</p><blockquote><p><strong>拓展：Alibaba《Java开发手册》</strong><br>【 <code>强制</code> 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。<br>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</p></blockquote><h4 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9. 区分度高(散列性高)的列适合作为索引"></a>9. 区分度高(散列性高)的列适合作为索引</h4><p><code>列的基数</code> 指的是某一列中不重复数据的个数，比方说某个列包含值 <code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是3。也就是说<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的<code>基数大的列建立索引</code>，为基数太小的列的简历索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a) / count(*) from t1</code> 计算区分度，<strong>越接近1越好</strong>，一般超过<code>33%</code>就算比较高效的索引了。</p><p>扩展：联合索引把区分度搞(散列性高)的列放在前面。</p><h4 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a>10. 使用最频繁的列放到联合索引的左侧</h4><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p><h4 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11. 在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11. 在多个字段都要创建索引的情况下，联合索引优于单值索引</h4><h3 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220627151947786.png" alt="image-20220627151947786" style="float:left;"><h3 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h3><h4 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1. 在where中使用不到的字段，不要设置索引"></a>1. 在where中使用不到的字段，不要设置索引</h4><p>WHERE条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT course_id, student_id, create_time</span><br><span class="line">FROM student_info</span><br><span class="line">WHERE student_id = 41251;</span><br></pre></td></tr></table></figure><p>因为我们是按照 student_id 来进行检索的，所以不需要对其他字段创建索引，即使这些字段出现在SELECT字段中。</p><h4 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2. 数据量小的表最好不要使用索引"></a>2. 数据量小的表最好不要使用索引</h4><p>如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引 <code>对查询效率的影响并不大</code>。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p><p>举例：创建表1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_without_index(</span><br><span class="line">a INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">b INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>提供存储过程1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE t_wout_insert()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 1;</span><br><span class="line">    WHILE i &lt;= 900</span><br><span class="line">    DO</span><br><span class="line">        INSERT INTO t_without_index(b) SELECT RAND()*10000;</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL t_wout_insert()</span><br></pre></td></tr></table></figure><p>创建表2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_with_index(</span><br><span class="line">a INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">b INT,</span><br><span class="line">INDEX idx_b(b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建存储过程2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE t_with_insert()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 1;</span><br><span class="line">    WHILE i &lt;= 900</span><br><span class="line">    DO</span><br><span class="line">        INSERT INTO t_with_index(b) SELECT RAND()*10000;</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL t_with_insert();</span><br></pre></td></tr></table></figure><p>查询对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_without_index where b = 9879;</span><br><span class="line">+------+------+</span><br><span class="line">| a | b |</span><br><span class="line">+------+------+</span><br><span class="line">| 1242 | 9879 |</span><br><span class="line">+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_with_index where b = 9879;</span><br><span class="line">+-----+------+</span><br><span class="line">| a | b |</span><br><span class="line">+-----+------+</span><br><span class="line">| 112 | 9879 |</span><br><span class="line">+-----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>你能看到运行结果相同，但是在数据量不大的情况下，索引就发挥不出作用了。</p><blockquote><p>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p></blockquote><h4 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3. 有大量重复数据的列上不要建立索引"></a>3. 有大量重复数据的列上不要建立索引</h4><p>在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的”性别”字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会<code>严重降低数据更新速度</code>。</p><p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先 访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p><p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p><p>学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student_gender(</span><br><span class="line">    student_id INT(11) NOT NULL,</span><br><span class="line">    student_name VARCHAR(50) NOT NULL,</span><br><span class="line">    student_gender TINYINT(1) NOT NULL,</span><br><span class="line">    PRIMARY KEY(student_id)</span><br><span class="line">)ENGINE = INNODB;</span><br></pre></td></tr></table></figure><p>如果我们要筛选出这个学生表中的男性，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_gender WHERE student_gender = 1;</span><br></pre></td></tr></table></figure><blockquote><p>结论：当数据重复度大，比如 高于 <strong>10%</strong> 的时候，也不需要对这个字段使用索引。</p></blockquote><h4 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4.  避免对经常更新的表创建过多的索引"></a>4.  避免对经常更新的表创建过多的索引</h4><p>第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p><p>第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。</p><h4 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5. 不建议用无序的值作为索引"></a>5. 不建议用无序的值作为索引</h4><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。</p><h4 id="6-删除不再使用或者很少使用的索引"><a href="#6-删除不再使用或者很少使用的索引" class="headerlink" title="6. 删除不再使用或者很少使用的索引"></a>6. 删除不再使用或者很少使用的索引</h4><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p><h4 id="7-不要定义夯余或重复的索引"><a href="#7-不要定义夯余或重复的索引" class="headerlink" title="7. 不要定义夯余或重复的索引"></a>7. 不要定义夯余或重复的索引</h4><p>① 冗余索引 </p><p>举例：建表语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(10))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一 个专门针对 name 列的索引就算是一个 冗余索引 ，维护这个索引只会增加维护的成本，并不会对搜索有 什么好处。</p><p>② 重复索引 </p><p>另一种情况，我们可能会对某个列 重复建立索引 ，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE repeat_index_demo (</span><br><span class="line">col1 INT PRIMARY KEY,</span><br><span class="line">col2 INT,</span><br><span class="line">UNIQUE uk_idx_c1 (col1),</span><br><span class="line">INDEX idx_c1 (col1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就 会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p><h1 id="第09章-性能分析工具的使用"><a href="#第09章-性能分析工具的使用" class="headerlink" title="第09章_性能分析工具的使用"></a>第09章_性能分析工具的使用</h1><p>在数据库调优中，我们的目标是 <code>响应时间更快, 吞吐量更大</code> 。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p><h2 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1. 数据库服务器的优化步骤"></a>1. 数据库服务器的优化步骤</h2><p>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</p><p>整个流程划分成了 <code>观察（Show status）</code> 和 <code>行动（Action）</code> 两个部分。字母 S 的部分代表观察（会使 用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220627162248635.png" alt="image-20220627162248635" style="zoom: 200%;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220627162345815.png" alt="image-20220627162345815" style="zoom:200%;"><p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p><p><strong>详细解释一下这张图：</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220627164046438.png" alt="image-20220627164046438" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220627164114562.png" alt="image-20220627164114562" style="float:left;"><h2 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2. 查看系统性能参数"></a>2. 查看系统性能参数</h2><p>在MySQL中，可以使用 <code>SHOW STATUS</code> 语句查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。</p><p>SHOW STATUS语句语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS LIKE &#x27;参数&#x27;;</span><br></pre></td></tr></table></figure><p>一些常用的性能参数如下：</p><ul><li>Connections：连接MySQL服务器的次数。 </li><li>Uptime：MySQL服务器的上线时间。 </li><li>Slow_queries：慢查询的次数。 </li><li>Innodb_rows_read：Select查询返回的行数 </li><li>Innodb_rows_inserted：执行INSERT操作插入的行数 </li><li>Innodb_rows_updated：执行UPDATE操作更新的 行数 </li><li>Innodb_rows_deleted：执行DELETE操作删除的行数 </li><li>Com_select：查询操作的次数。 </li><li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 </li><li>Com_update：更新操作 的次数。 </li><li>Com_delete：删除操作的次数。</li></ul><p>若查询MySQL服务器的连接次数，则可以执行如下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Connections&#x27;;</span><br></pre></td></tr></table></figure><p>若查询服务器工作时间，则可以执行如下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Uptime&#x27;;</span><br></pre></td></tr></table></figure><p>若查询MySQL服务器的慢查询次数，则可以执行如下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Slow_queries&#x27;;</span><br></pre></td></tr></table></figure><p>慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行<code>表结构优化</code>或者<code>查询语句优化</code>。</p><p>再比如，如下的指令可以查看相关的指令情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Innodb_rows_%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="3-统计SQL的查询成本-last-query-cost"><a href="#3-统计SQL的查询成本-last-query-cost" class="headerlink" title="3. 统计SQL的查询成本: last_query_cost"></a>3. 统计SQL的查询成本: last_query_cost</h2><p>一条SQL查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择<code>成本最小</code>的一个作为最终执行的执行计划。</p><p>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的<code>last_query_cost</code>变量值来得到当前查询的成本。它通常也是我们<code>评价一个查询的执行效率</code>的一个常用指标。这个查询成本对应的是<code>SQL 语句所需要读取的读页的数量</code>。</p><p>我们依然使用第8章的 student_info 表为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student_info` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `student_id` INT NOT NULL ,</span><br><span class="line">    `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    `course_id` INT NOT NULL ,</span><br><span class="line">    `class_id` INT(11) DEFAULT NULL,</span><br><span class="line">    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>如果我们想要查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001;</span><br></pre></td></tr></table></figure><p>运行结果（1 条记录，运行时间为 <strong>0.042s</strong> ）</p><p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;last_query_cost&#x27;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   |   Value  |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Last_query_cost | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br></pre></td></tr></table></figure><p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id BETWEEN 900001 AND 900100;</span><br></pre></td></tr></table></figure><p>运行结果（100 条记录，运行时间为 0.046s ）： </p><p>然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;last_query_cost&#x27;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   |   Value   |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Last_query_cost | 21.134453 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure><p>你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间 基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 <code>页数量（last_query_cost）增加了不少</code> ，但是通过缓冲池的机制，并 <code>没有增加多少查询时间</code> 。 </p><p><strong>使用场景：</strong>它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL查询时一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库 <code>缓冲池</code> 中，那么效率是最高的，否则还需要从 <code>内存</code> 或者 <code>磁盘</code> 中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，<strong>甚至要快于单个页面在内存中的随机读取</strong>。</li></ol><p>所以说，遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><h2 id="4-定位执行慢的-SQL：慢查询日志"><a href="#4-定位执行慢的-SQL：慢查询日志" class="headerlink" title="4. 定位执行慢的 SQL：慢查询日志"></a>4. 定位执行慢的 SQL：慢查询日志</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628173022699.png" alt="image-20220628173022699" style="float:left;"><h3 id="4-1-开启慢查询日志参数"><a href="#4-1-开启慢查询日志参数" class="headerlink" title="4.1 开启慢查询日志参数"></a>4.1 开启慢查询日志参数</h3><p><strong>1. 开启 slow_query_log</strong></p><p>在使用前，我们需要先查下慢查询是否已经开启，使用下面这条命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;%slow_query_log&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628173525966.png" alt="image-20220628173525966" style="float:left;"><p>我们可以看到 <code>slow_query_log=OFF</code>，我们可以把慢查询日志打开，注意设置变量值的时候需要使用 <code>global</code>，否则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure><p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628175226812.png" alt="image-20220628175226812" style="float:left;"><p>你能看到这时慢查询分析已经开启，同时文件保存在 <code>/var/lib/mysql/主机名-slow.log</code> 文件 中。</p><p><strong>2. 修改 long_query_time 阈值</strong></p><p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628175353233.png" alt="image-20220628175353233" style="float:left;"><p>这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并</span><br><span class="line">执行下述语句</span><br><span class="line">mysql &gt; set global long_query_time = 1;</span><br><span class="line">mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time=1;</span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>决定一条语句是否为慢查询，由两个变量决定：min_examined_row_limit和slow_queries</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628175425922.png" alt="image-20220628175425922" style="zoom:80%; float:left;"><p><strong>补充：配置文件中一并设置参数</strong></p><p>如下的方式相较于前面的命令行方式，可以看做是永久设置的方式。</p><p>修改 <code>my.cnf</code> 文件，[mysqld] 下增加或修改参数 <code>long_query_time、slow_query_log</code> 和 <code>slow_query_log_file</code> 后，然后重启 MySQL 服务器。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">ON  # 开启慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">/var/lib/mysql/atguigu-low.log  # 慢查询日志的目录和文件名信息</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">3  # 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">FILE</span></span><br></pre></td></tr></table></figure><p>如果不指定存储路径，慢查询日志默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname_slow.log。</p><h3 id="4-2-查看慢查询数目"><a href="#4-2-查看慢查询数目" class="headerlink" title="4.2 查看慢查询数目"></a>4.2 查看慢查询数目</h3><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="4-3-案例演示"><a href="#4-3-案例演示" class="headerlink" title="4.3 案例演示"></a>4.3 案例演示</h3><p><strong>步骤1. 建表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `stuno` INT NOT NULL ,</span><br><span class="line">    `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    `age` INT(3) DEFAULT NULL,</span><br><span class="line">    `classId` INT(11) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p><strong>步骤2：设置参数 log_bin_trust_function_creators</strong></p><p>创建函数，假如报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure><ul><li>命令开启：允许创建函数设置：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure><p><strong>步骤3：创建函数</strong></p><p>随机产生字符串：（同上一章）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT)</span><br><span class="line">RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">SELECT rand_string(10);</span><br></pre></td></tr></table></figure><p>产生随机数值：（同上一章）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">    RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#测试：</span><br><span class="line">SELECT rand_num(10,100);</span><br></pre></td></tr></table></figure><p><strong>步骤4：创建存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu1( START INT , max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    SET i = i + 1; #赋值</span><br><span class="line">    INSERT INTO student (stuno, NAME ,age ,classId ) VALUES</span><br><span class="line">    ((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>步骤5：调用存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#调用刚刚写好的函数, 4000000条记录,从100001号开始</span><br><span class="line"></span><br><span class="line">CALL insert_stu1(100001,4000000);</span><br></pre></td></tr></table></figure><h3 id="4-4-测试及分析"><a href="#4-4-测试及分析" class="headerlink" title="4.4 测试及分析"></a>4.4 测试及分析</h3><p><strong>1. 测试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student WHERE stuno = 3455655;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  | age  | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 3523633 | 3455655 | oQmLUr |  19  |    39   |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">1 row in set (2.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM student WHERE name = &#x27;oQmLUr&#x27;;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  |  age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 1154002 | 1243200 | OQMlUR | 266  |   28    |</span><br><span class="line">| 1405708 | 1437740 | OQMlUR | 245  |   439   |</span><br><span class="line">| 1748070 | 1680092 | OQMlUR | 240  |   414   |</span><br><span class="line">| 2119892 | 2051914 | oQmLUr | 17   |   32    |</span><br><span class="line">| 2893154 | 2825176 | OQMlUR | 245  |   435   |</span><br><span class="line">| 3523633 | 3455655 | oQmLUr | 19   |   39    |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">6 rows in set (2.39 sec)</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为2.09秒。查询学生姓名为 “oQmLUr”的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面 的小节我们分析一下原因。</p><p><strong>2. 分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;slow_queries&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628195650079.png" alt="image-20220628195650079" style="float:left;"><h3 id="4-5-慢查询日志分析工具：mysqldumpslow"><a href="#4-5-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="4.5 慢查询日志分析工具：mysqldumpslow"></a>4.5 慢查询日志分析工具：mysqldumpslow</h3><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 <code>mysqldumpslow</code> 。</p><p>查看mysqldumpslow的帮助信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">--help</span></span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628195821440.png" alt="image-20220628195821440" style="float:left;"><p>mysqldumpslow 命令的具体参数如下：</p><ul><li>-a: 不将数字抽象成N，字符串抽象成S</li><li>-s: 是表示按照何种方式排序：<ul><li>c: 访问次数 </li><li>l: 锁定时间 </li><li>r: 返回记录 </li><li>t: 查询时间 </li><li>al:平均锁定时间 </li><li>ar:平均返回记录数 </li><li>at:平均查询时间 （默认方式） </li><li>ac:平均查询次数</li></ul></li><li>-t: 即为返回前面多少条的数据；</li><li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li></ul><p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-a -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[root@bogon</span> <span class="string">~]# mysqldumpslow -a -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Reading</span> <span class="string">mysql slow query log from /var/lib/mysql/atguigu01-slow.log</span></span><br><span class="line"><span class="attr">Count</span>: <span class="string">1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student WHERE name = &#x27;S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Count</span>: <span class="string">1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student WHERE stuno = N</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Died</span> <span class="string">at /usr/bin/mysqldumpslow line 162, &lt;&gt; chunk 2.</span></span><br></pre></td></tr></table></figure><p><strong>工作常用参考：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s r -t 10 /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s c -t 10 /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span></span><br></pre></td></tr></table></figure><h3 id="4-6-关闭慢查询日志"><a href="#4-6-关闭慢查询日志" class="headerlink" title="4.6 关闭慢查询日志"></a>4.6 关闭慢查询日志</h3><p>MySQL服务器停止慢查询日志功能有两种方法：</p><p><strong>方式1：永久性方式</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">OFF</span></span><br></pre></td></tr></table></figure><p>或者，把slow_query_log一项注释掉 或 删除</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#slow_query_log =OFF</span></span><br></pre></td></tr></table></figure><p>重启MySQL服务，执行如下语句查询慢日志功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;; #查询慢查询日志所在目录</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;; #查询超时时长</span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><p>使用SET语句来设置。 </p><p>（1）停止MySQL慢查询日志功能，具体SQL语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=off;</span><br></pre></td></tr></table></figure><p>（2）<strong>重启MySQL服务</strong>，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;;</span><br><span class="line">#以及</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="4-7-删除慢查询日志"><a href="#4-7-删除慢查询日志" class="headerlink" title="4.7 删除慢查询日志"></a>4.7 删除慢查询日志</h3><p>使用SHOW语句显示慢查询日志信息，具体SQL语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE `slow_query_log%`;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628203545536.png" alt="image-20220628203545536" style="float:left;"><p>从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下 <code>手动删除慢查询日志文件</code> 即可。</p><p>使用命令 <code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysqladmin</span> <span class="string">-uroot -p flush-logs slow</span></span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p></blockquote><h2 id="5-查看-SQL-执行成本：SHOW-PROFILE"><a href="#5-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="5. 查看 SQL 执行成本：SHOW PROFILE"></a>5. 查看 SQL 执行成本：SHOW PROFILE</h2><p>show profile 在《逻辑架构》章节中讲过，这里作为复习。</p><p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗工具的情况，可用于 sql 调优的测量。<code>默认情况下处于关闭状态</code>，并保存最近15次的运行结果。</p><p>我们可以在会话级别开启这个功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628204922556.png" alt="image-20220628204922556" style="float:left;"><p>通过设置 profiling&#x3D;’ON’ 来开启 show profile:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; set profiling = &#x27;ON&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628205029208.png" alt="image-20220628205029208" style="zoom:80%;float:left"><p>然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show profiles;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628205243769.png" alt="image-20220628205243769" style="zoom:80%;float:left"><p>你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show profile;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628205317257.png" alt="image-20220628205317257" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 2</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628205354230.png" alt="image-20220628205354230" style="float:left;"><p>**show profile的常用查询参数： **</p><p>① ALL：显示所有的开销信息。 </p><p>② BLOCK IO：显示块IO开销。 </p><p>③ CONTEXT SWITCHES：上下文切换开销。 </p><p>④ CPU：显示CPU开销信息。 </p><p>⑤ IPC：显示发送和接收开销信息。</p><p>⑥ MEMORY：显示内存开销信 息。 </p><p>⑦ PAGE FAULTS：显示页面错误开销信息。 </p><p>⑧ SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。 </p><p>⑨ SWAPS：显示交换次数开销信息。</p><p><strong>日常开发需注意的结论：</strong></p><p>① <code>converting HEAP to MyISAM</code>: 查询结果太大，内存不够，数据往磁盘上搬了。 </p><p>② <code>Creating tmp table</code>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。 </p><p>③ <code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！ </p><p>④ <code>locked</code>。 </p><p>如果在show profile诊断结果中<strong>出现了以上4条结果中的任何一条，则sql语句需要优化</strong>。</p><blockquote><p><strong>注意：</strong></p><p>不过SHOW PROFILE命令将被启用，我们可以从 information_schema 中的 profiling 数据表进行查看。</p></blockquote><h2 id="6-分析查询语句：EXPLAIN"><a href="#6-分析查询语句：EXPLAIN" class="headerlink" title="6. 分析查询语句：EXPLAIN"></a>6. 分析查询语句：EXPLAIN</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628210837301.png" alt="image-20220628210837301" style="float:left;"><p><strong>1. 能做什么？</strong></p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p><strong>2. 官网介绍</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a> </p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html</a></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220628211207436.png" alt="image-20220628211207436"></p><p><strong>3. 版本情况</strong></p><ul><li>MySQL 5.6.3以前只能 <code>EXPLAIN SELECT</code> ；MYSQL 5.6.3以后就可以<code> EXPLAIN SELECT</code>，<code>UPDATE</code>， <code>DELETE </code></li><li>在<strong>5.7以前</strong>的版本中，想要显示 <code>partitions</code> 需要使用 <strong>explain partitions</strong> 命令；想要显示 <code>filtered</code> 需要使用 <strong>explain extended</strong> 命令。在<strong>5.7版本后</strong>，默认explain直接显示partitions和 filtered中的信息。</li></ul><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628211351678.png" alt="image-20220628211351678" style="float:left;"><h3 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h3><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT select_options</span><br><span class="line">或者</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure><p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 <code>EXPLAIN</code> ，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628212029574.png" alt="image-20220628212029574" style="float:left;"><p>EXPLAIN 语句输出的各个列的作用如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220628212049096.png" alt="image-20220628212049096"></p><p>在这里把它们都列出来知识为了描述一个轮廓，让大家有一个大致的印象。</p><h3 id="6-3-数据准备"><a href="#6-3-数据准备" class="headerlink" title="6.3 数据准备"></a>6.3 数据准备</h3><p><strong>1. 建表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s2 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p><strong>2. 设置参数 log_bin_trust_function_creators</strong></p><p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure><p><strong>3. 创建函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string1(n INT)</span><br><span class="line">RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>4. 创建存储过程</strong></p><p>创建往s1表中插入数据的存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO s1 VALUES(</span><br><span class="line">        (min_num + i),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        (min_num + 30 * i + 5),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(5),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(10));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建往s2表中插入数据的存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO s2 VALUES(</span><br><span class="line">        (min_num + i),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        (min_num + 30 * i + 5),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(5),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(10));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>5. 调用存储过程</strong></p><p>s1表数据的添加：加入1万条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_s1(10001,10000);</span><br></pre></td></tr></table></figure><p>s2表数据的添加：加入1万条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_s2(10001,10000);</span><br></pre></td></tr></table></figure><h3 id="6-4-EXPLAIN各列作用"><a href="#6-4-EXPLAIN各列作用" class="headerlink" title="6.4 EXPLAIN各列作用"></a>6.4 EXPLAIN各列作用</h3><p>为了让大家有比较好的体验，我们调整了下 <code>EXPLAIN</code> 输出列的顺序。</p><blockquote><p>测试语句可在MySQL&gt;尚硅谷&gt;高级篇&gt;资料&gt;EXPLAIN的使用.sql获取，可使用navicat直接打开</p></blockquote><h4 id="1-table"><a href="#1-table" class="headerlink" title="1. table"></a>1. table</h4><p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220628221143339.png" alt="image-20220628221143339"></p><p>这个查询语句只涉及对s1表的单表查询，所以 <code>EXPLAIN</code> 输出中只有一条记录，其中的table列的值为s1，表明这条记录是用来说明对s1表的单表访问方法的。</p><p>下边我们看一个连接查询的执行计划</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220628221414097.png" alt="image-20220628221414097"></p><p>可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p><h4 id="2-id"><a href="#2-id" class="headerlink" title="2. id"></a>2. id</h4><p>我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比 如下边这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">ON s1.key1 = s2.key1</span><br><span class="line">WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220628221948512.png" alt="image-20220628221948512" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220628222055716.png" alt="image-20220628222055716"></p><p>对于连接查询来说，一个SELECT关键字后边的FROM字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220628222251309.png" alt="image-20220628222251309"></p><p>可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的<code>id</code>都是1。这里需要大家记住的是，<strong>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的</strong>，出现在前边的表表示<code>驱动表</code>，出现在后面的表表示<code>被驱动表</code>。所以从上边的EXPLAIN输出中我们可以看到，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。</p><p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在**包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的id值，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629165122837.png" alt="image-20220629165122837"></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220629170848349.png" alt="image-20220629170848349" style="float:left;"><p><strong>特殊情况1：子查询优化为连接查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。  </span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629165603072.png" alt="image-20220629165603072"></p><p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的<code>id</code>值全部是1，这就表明<code>查询优化器将子查询转换为了连接查询</code>。</p><p><strong>特殊情况2：union去重临时表</strong></p><p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Union去重</span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629165909340.png" alt="image-20220629165909340"></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220629171104375.png" alt="image-20220629171104375" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629171138065.png" alt="image-20220629171138065"></p><p><strong>小结:</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong> </li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong> （类似递归，先执行内层的操作）</li><li>关注点：id号每个号码，表示一趟独立的查询,<code> 一个sql的查询趟数越少越好</code></li></ul><h4 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3. select_type"></a>3. select_type</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220629171611716.png" alt="image-20220629171611716" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629171442624.png" alt="image-20220629171442624"></p><p>具体分析如下：</p><ul><li><p>SIMPLE</p><p>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询<code>select_type</code>的值就是<code>SIMPLE</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629171840300.png" alt="image-20220629171840300"></p><p>​        当然，连接查询也算是 SIMPLE 类型，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629171904912.png" alt="image-20220629171904912"></p><ul><li><p>PRIMARY</p><p>对于包含<code>UNION、UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>的值就是<code>PRIMARY</code>,比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629171929924.png" alt="image-20220629171929924"></p><p>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>的值就是<code>PRIMARY</code>。</p></li><li><p>UNION</p><p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的<code>select_type</code>值就是UNION，可以对比上一个例子的效果。</p></li><li><p>UNION RESULT</p><p>MySQL 选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>, 例子上边有。</p></li><li><p>SUBQUERY</p><p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是<strong>不相关子查询</strong>（<strong>即子查询中没有用到外层查询的表</strong>），并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629172449267.png" alt="image-20220629172449267"></p></li><li><p>DEPENDENT SUBQUERY</p><p><strong>相关子查询</strong>（<strong>即子查询中用到了外层查询的表</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629172525236.png" alt="image-20220629172525236"></p></li><li><p>DEPENDENT UNION</p><p>在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果<strong>各个小查询都依赖于外层查询</strong>的话，那<strong>除了最左边</strong>的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; UNION SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629172555603.png" alt="image-20220629172555603"></p></li><li><p>DERIVED</p><p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED, 说明该子查询是以<strong>物化的方式执行</strong>的。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询时针对将派生表物化之后的表进行查询的。</p><p>（对于包含<code>派生表</code>的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>）</p><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是DERIVED，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629172622893.png" alt="image-20220629172622893"></p></li><li><p>MATERIALIZED</p><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，<br>该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220629172646367.png" alt="image-20220629172646367"></p></li><li><p>UNCACHEABLE SUBQUERY</p><p>不常用，就不多说了。</p></li><li><p>UNCACHEABLE UNION</p><p>不常用，就不多说了。</p></li></ul><h4 id="4-partitions-可略"><a href="#4-partitions-可略" class="headerlink" title="4. partitions (可略)"></a>4. partitions (可略)</h4><ul><li>代表分区表中的命中情况，非分区表，该项为<code>NULL</code>。一般情况下我们的额查询语句的执行计划的<code>partitions</code>列的值为<code>NULL</code>。</li><li><a><a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html">https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html</a></a></li><li>如果想详细了解，可以如下方式测试。创建分区表：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建分区表，</span><br><span class="line">-- 按照id分区，id&lt;100 p0分区，其他p1分区</span><br><span class="line">CREATE TABLE user_partitions (id INT auto_increment,</span><br><span class="line">NAME VARCHAR(12),PRIMARY KEY(id))</span><br><span class="line">PARTITION BY RANGE(id)(</span><br><span class="line">PARTITION p0 VALUES less than(100),</span><br><span class="line">PARTITION p1 VALUES less than MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220629190304966.png" alt="image-20220629190304966" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC SELECT * FROM user_partitions WHERE id&gt;200;</span><br></pre></td></tr></table></figure><p>查询id大于200（200&gt;100，p1分区）的记录，查看执行计划，partitions是p1，符合我们的分区规则</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220629190335371.png" alt="image-20220629190335371" style="float:left;"><h4 id="5-type-☆"><a href="#5-type-☆" class="headerlink" title="5. type ☆"></a>5. type ☆</h4><p>执行计划的一条记录就代表着MySQL对某个表的 <code>执行查询时的访问方法</code> , 又称“访问类型”，其中的 <code>type</code> 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。</p><p>完整的访问方法如下： <code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code> 。</p><blockquote><p><strong><font color="red">访问方越靠前，说明性能越高，越靠后性能越差，就要注意</font></strong></p></blockquote><p>我们详细解释一下：</p><ul><li><p><code>system</code></p><p>当表中<code>只有一条记录</code>并且该表使用的<strong>存储引擎的统计数据是精确</strong>的，比如MyISAM(因为<strong>有专门的空间记录count值</strong>)、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>然后我们看一下查询这个表的执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220630164434315.png" alt="image-20220630164434315" style="float:left;"><p>可以看到<code>type</code>列的值就是<code>system</code>了，</p><blockquote><p>测试，可以把表改成使用InnoDB存储引擎，试试看执行计划的<code>type</code>列是什么。<strong>ALL</strong></p></blockquote></li><li><p><code>const</code></p><p>当我们根据<strong>主键</strong>或者<strong>unique二级索引列</strong>与<strong>常数</strong>进行<strong>等值</strong>匹配时，对单表的访问方法就是<code>const</code>, 比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220630164724548.png" alt="image-20220630164724548" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;#key1为common索引，type = ref</span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 10066;#key2为unique索引，type = const</span><br></pre></td></tr></table></figure></li><li><p><code>eq_ref</code></p><p>在<strong>连接查询时</strong>，如果被<strong>驱动表是通过主键或者唯一二级索引</strong>列<strong>等值匹配</strong>的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）。则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220630164802559.png" alt="image-20220630164802559" style="float:left;"><p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问 方法是 <code>eq_ref</code> ，表明在访问s1表的时候可以 <code>通过主键的等值匹配</code> 来进行访问。</p></li><li><p><code>ref</code></p><p>当通过<strong>普通的二级索引列</strong>与<strong>常量</strong>进行<strong>等值匹配</strong>时来查询某个表，那么对该表的访问方法就<strong>可能</strong>是<code>ref</code>，比方说下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220630164930020.png" alt="image-20220630164930020" style="float:left;"></li><li><p><code>fulltext</code></p><p>全文索引</p></li><li><p><code>ref_or_null</code>：就是ref加了个or key1 i</p><p>当对<strong>普通二级索引</strong>进行<strong>等值匹配</strong>查询，该索引列的值<strong>也可以是</strong><code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key1 IS NULL;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220630175133920.png" alt="image-20220630175133920" style="float:left;"></li><li><p><code>index_merge</code></p><p>一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用<code>Interseation、union、Sort-Union</code>这三种<strong>索引合并</strong>的方式来执行查询，<strong>只能使用or，不能使用and</strong>。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220630175511644.png" alt="image-20220630175511644" style="float:left;"><p>从执行计划的 <code>type</code> 列的值是 <code>index_merge</code> 就可以看出，MySQL 打算使用索引合并的方式来执行 对 s1 表的查询。</p><p>如果是使用and，则type &#x3D; ref，只使用到inx_key1索引</p></li><li><p><code>unique_subquery</code></p><p>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到<code>主键</code>进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220630180123913.png" alt="image-20220630180123913" style="float:left;"></li></ul><ul><li><p><code>index_subquery</code></p><p><code>index_subquery</code> 与 <code>unique_subquery</code> 类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220703214407225.png" alt="image-20220703214407225"></p><ul><li><p><code>range</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220703214633338.png" alt="image-20220703214633338"></p><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220703214657251.png" alt="image-20220703214657251"></p></li><li><p><code>index</code></p><p>当我们可以**使用<code>索引覆盖</code>**，但需要扫描全部的索引记录但<code>不需要回表</code>时，该表的访问方法就是<code>index</code>，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220703214844885.png" alt="image-20220703214844885"></p><p>上述查询中的所有列表中只有key_part2 一个列，而且搜索条件中也只有 key_part3 一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行<code>ref</code>和<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p><blockquote><p>再一次强调，对于使用InnoDB存储引擎的表来说，<strong>二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列</strong>，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p><p><strong><font color="cornflowerblue">覆盖索引不止在type &#x3D; index时才有，只要不用回表就能查到想要的字段，就都叫覆盖索引</font></strong></p><p>eg: select key1 from s1 where key1 &#x3D; ‘a’;</p><p>其中key1是一个二级索引，但是只需要查key1，所以并不需要回表</p></blockquote></li><li><p><code>ALL</code></p><p>最熟悉的全表扫描，就不多说了，直接看例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220703215958374.png" alt="image-20220703215958374"></p></li></ul><p>**小结: **</p><p>**结果值从最好到最坏依次是： **</p><p><font color="cornflowerblue">system &gt; const &gt; eq_ref &gt; ref</font> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <font color="cornflowerblue">range &gt; index &gt; ALL </font></p><p><strong>其中比较重要的几个提取出来（见上图中的粗体）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴 开发手册要求）</strong></p><h4 id="6-possible-keys和key"><a href="#6-possible-keys和key" class="headerlink" title="6. possible_keys和key"></a>6. possible_keys和key</h4><p>在EXPLAIN语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个列执行<code>单表查询时可能用到的索引</code>有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。<code>key</code>列表示<code>实际用到的索引</code>有哪些，如果为NULL，则没有使用索引。比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220703220724964.png" alt="image-20220703220724964"></p><p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1, idx_key3</code>，表示该查询可能使用到<code>idx_key1, idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定采用<code>idx_key3</code>。</p><h4 id="7-key-len-☆"><a href="#7-key-len-☆" class="headerlink" title="7. key_len ☆"></a>7. key_len ☆</h4><p>实际使用到的索引长度 (即：<strong>字节数</strong>)</p><p>帮你检查<code>是否充分的利用了索引</code>，<code>值越大越好</code>，<strong>主要针对于联合索引，有一定的参考意义。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130030692.png" alt="image-20220704130030692"></p><blockquote><p>int 占用 4 个字节</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130138204.png" alt="image-20220704130138204"></p><blockquote><p>key2上有一个唯一性约束，是否为NULL占用一个字节，那么就是5个字节</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130214482.png" alt="image-20220704130214482"></p><blockquote><p>key1 VARCHAR(100) 一个字符占3个字节，100*3，是否为NULL占用一个字节，varchar的长度信息占两个字节。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130442095.png" alt="image-20220704130442095"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130515031.png" alt="image-20220704130515031"></p><blockquote><p>联合索引中可以比较，key_len&#x3D;606的好于key_len&#x3D;303</p></blockquote><p>**练习： **</p><p>key_len的长度计算公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">varchar(10)变长字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)</span><br><span class="line"></span><br><span class="line">varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</span><br></pre></td></tr></table></figure><h4 id="8-ref"><a href="#8-ref" class="headerlink" title="8. ref"></a>8. ref</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704131759630.png" alt="image-20220704131759630" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130837498.png" alt="image-20220704130837498"></p><p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130925426.png" alt="image-20220704130925426"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704130957359.png" alt="image-20220704130957359"></p><h4 id="9-rows-☆"><a href="#9-rows-☆" class="headerlink" title="9. rows ☆"></a>9. rows ☆</h4><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704131050496.png" alt="image-20220704131050496"></p><h4 id="10-filtered"><a href="#10-filtered" class="headerlink" title="10. filtered"></a>10. filtered</h4><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p><p>如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引 的搜索条件外 的其他<strong>搜索条件</strong> 的记录有多少条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704131323242.png" alt="image-20220704131323242"></p><blockquote><p>这里就是满足key1 &gt; ‘z’ 的有266条，然后and满足common_field &#x3D; ‘a’的只有10%</p></blockquote><p>对于单表查询来说，这个filtered的值没有什么意义，我们<code>更关注在连接查询中驱动表对应的执行计划记录的filtered值</code>，它决定了被驱动表要执行的次数 (即: rows * filtered)</p><p>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704131644615.png" alt="image-20220704131644615"></p><p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>作为驱动表，<code>s2</code>当做被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>9688</code>，filtered列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>9688 x 10.00% = 968.8</code>，这说明还要对<strong>被驱动表执行大约<code>968</code>次查询</strong>。</p><h4 id="11-Extra-☆"><a href="#11-Extra-☆" class="headerlink" title="11. Extra ☆"></a>11. Extra ☆</h4><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来<code>更准确的理解MySQL到底将如何执行给定的查询语句</code>。MySQL提供的额外信息有好几十个，我们就不一个一个介绍了，所以我们只挑选比较重要的额外信息介绍给大家。</p><ul><li><p><code>No tables used</code></p><p>当查询语句没有<code>FROM</code>子句时将会提示该额外信息，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704132345383.png" alt="image-20220704132345383"></p></li><li><p><code>Impossible WHERE</code></p><p>当查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704132458978.png" alt="image-20220704132458978"></p></li><li><p><code>Using where</code></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704140148163.png" alt="image-20220704140148163" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704132655342.png" alt="image-20220704132655342"></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704140212813.png" alt="image-20220704140212813" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704133130515.png" alt="image-20220704133130515"></p></li><li><p><code>No matching min/max row</code></p><p>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚合函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = &#x27;abcdefg&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704134324354.png" alt="image-20220704134324354"></p></li><li><p><code>Using index</code></p><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以<strong>使用覆盖索引</strong><code>不会出现回表</code>的情况下，在<code>Extra</code>列将会提示该额外信息 <strong>Using Index</strong>。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704134931220.png" alt="image-20220704134931220"></p></li><li><p><code>Using index condition</code></p><p>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边<strong>索引下推</strong>这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704140344015.png" alt="image-20220704140344015" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704140411033.png" alt="image-20220704140411033" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%b&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704140441702.png" alt="image-20220704140441702"></p></li><li><p><code>Using join buffer (Block Nested Loop)</code></p><p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704140815955.png" alt="image-20220704140815955"></p></li><li><p><code>Not exists</code></p><p>当我们使用左(外)连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列是不允许存储<code>NULL</code>值的，那么在该表的执行计划的Extra列就会提示这个信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704142059555.png" alt="image-20220704142059555"></p></li><li><p><code>Using intersect(...) 、 Using union(...) 和 Using sort_union(...)</code></p><p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</p><p>如果出现<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询;</p><p>如果出现<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704142552890.png" alt="image-20220704142552890"></p></li><li><p><code>Zero limit</code></p><p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LIMIT 0;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704142754394.png" alt="image-20220704142754394"></p></li><li><p><code>Using filesort</code></p><p>有一些情况下对结果集中的记录进行排序是可以使用到索引的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704142901857.png" alt="image-20220704142901857"></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704145143170.png" alt="image-20220704145143170" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704143518857.png" alt="image-20220704143518857"></p><p>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法<code>将使用文件排序的执行方式改为索引进行排序</code>。</p></li><li><p><code>Using temporary</code></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704145924130.png" alt="image-20220704145924130" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704150030005.png" alt="image-20220704150030005"></p><p>再比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704150156416.png" alt="image-20220704150156416"></p><p>执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们<code>最好能使用索引来替代掉使用临时表</code>，比方说下边这个包含<code>GROUP BY</code>子句的查询就不需要使用临时表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704150308189.png" alt="image-20220704150308189"></p><p>从 <code>Extra</code> 的 <code>Using index</code> 的提示里我们可以看出，上述查询只需要扫描 <code>idx_key1</code> 索引就可以搞 定了，不再需要临时表了。</p></li><li><p>其他</p><p>其它特殊情况这里省略。</p></li></ul><h4 id="12-小结"><a href="#12-小结" class="headerlink" title="12. 小结"></a>12. 小结</h4><ul><li>EXPLAIN不考虑各种Cache </li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作 </li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况 </li><li>部分统计信息是估算的，并非精确值</li></ul><h2 id="7-EXPLAIN的进一步使用"><a href="#7-EXPLAIN的进一步使用" class="headerlink" title="7. EXPLAIN的进一步使用"></a>7. EXPLAIN的进一步使用</h2><h3 id="7-1-EXPLAIN四种输出格式"><a href="#7-1-EXPLAIN四种输出格式" class="headerlink" title="7.1 EXPLAIN四种输出格式"></a>7.1 EXPLAIN四种输出格式</h3><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： <code>传统格式</code> ，<code>JSON格式</code> ， <code>TREE格式</code> 以及 <code>可视化输出</code> 。用户可以根据需要选择适用于自己的格式。</p><h4 id="1-传统格式"><a href="#1-传统格式" class="headerlink" title="1. 传统格式"></a>1. 传统格式</h4><p>传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704161702384.png" alt="image-20220704161702384"></p><h4 id="2-JSON格式"><a href="#2-JSON格式" class="headerlink" title="2. JSON格式"></a>2. JSON格式</h4><p>第1种格式中介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行好坏的重要属性 —— <code>成本</code>。而JSON格式是四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p><ul><li>JSON格式：在EXPLAIN单词和真正的查询语句中间加上 <code>FORMAT=JSON</code> 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT=JSON SELECT ....</span><br></pre></td></tr></table></figure><ul><li>EXPLAIN的Column与JSON的对应关系：(来源于MySQL 5.7文档)</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704164236909.png" alt="image-20220704164236909"></p><p>这样我们就可以得到一个json格式的执行计划，里面包含该计划花费的成本。比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2  WHERE s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">EXPLAIN<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query_block&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;select_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1360.07&quot;</span><span class="comment">//查询成本</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nested_loop&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ALL&quot;</span><span class="punctuation">,</span><span class="comment">//type</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key1&quot;</span><span class="comment">//possible_keys</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">9895</span><span class="punctuation">,</span><span class="comment">//rows</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">989</span><span class="punctuation">,</span><span class="comment">//rows * filtered</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.00&quot;</span><span class="punctuation">,</span><span class="comment">//filtered</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;914.80&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;98.95&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1013.75&quot;</span><span class="punctuation">,</span><span class="comment">//此驱动表需要花费的成本 prefix_cost = read_cost + eval_cost</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span><span class="comment">//读取数据量</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//要查询的字段</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attached_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`atguigudb1`.`s1`.`common_field` = &#x27;a&#x27;) and (`atguigudb1`.`s1`.`key1` is not null))&quot;</span><span class="comment">//查询条件</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq_ref&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key_length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;atguigudb1.s1.key1&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">989</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;index_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(cast(`atguigudb1`.`s1`.`key1` as double) = cast(`atguigudb1`.`s2`.`key2` as double))&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;247.38&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;98.95&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1360.08&quot;</span><span class="punctuation">,</span><span class="comment">//驱动表和被驱动表的总成本 具体后面有讲</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="number">1</span> row in set<span class="punctuation">,</span> <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们使用 # 后边跟随注释的形式为大家解释了 <code>EXPLAIN FORMAT=JSON</code> 语句的输出内容，但是大家可能 有疑问 “<code>cost_info</code>“ 里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的 “<code>cost_info</code>“ 部 分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><p><code>read_cost</code> 是由下边这两部分组成的：</p><ul><li>IO 成本</li><li>检测 rows × (1 - filter) 条记录的 CPU 成本</li></ul><blockquote><p>小贴士： rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows 相当于rows_examined_per_scan，filtered名称不变。</p></blockquote></li></ul><ul><li><p><code>eval_cost</code> 是这样计算的：</p><p>检测 rows × filter 条记录的成本。</p></li><li><p><code>prefix_cost</code> 就是单独查询 s1 表的成本，也就是：</p><p><code>read_cost + eval_cost</code></p></li><li><p><code>data_read_per_join</code> 表示在此次查询中需要读取的数据量。</p></li></ul><p>对于 <code>s2</code> 表的 “<code>cost_info</code>“ 部分是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>由于 <code>s2</code> 表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code> 和 <code>eval_cost</code> 是访问多次 <code>s2</code> 表后累加起来的值，大家主要关注里边儿的 <code>prefix_cost</code> 的值代表的是整个连接查询预计的成本，也就是单次查询 <code>s1</code> 表和多次查询 <code>s2</code> 表后的成本的和，也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">247.38 + 98.95 + 1013.75 = 1360.08</span><br></pre></td></tr></table></figure><h4 id="3-TREE格式"><a href="#3-TREE格式" class="headerlink" title="3. TREE格式"></a>3. TREE格式</h4><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 <code>各个部分之间的关系</code> 和 <code>各部分的执行顺序</code> 来描述如何查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=TREE SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2  WHERE s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop inner join  (cost=1360.08 rows=990)</span><br><span class="line">    -&gt; Filter: ((s1.common_field = &#x27;a&#x27;) and (s1.key1 is not null))  (cost=1013.75 rows=990)</span><br><span class="line">        -&gt; Table scan on s1  (cost=1013.75 rows=9895)</span><br><span class="line">    -&gt; Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)</span><br><span class="line"></span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="4-可视化输出"><a href="#4-可视化输出" class="headerlink" title="4. 可视化输出"></a>4. 可视化输出</h4><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。 </p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704174401970.png" alt="image-20220704174401970"></p><p>上图按从左到右的连接顺序显示表。红色框表示 <code>全表扫描</code> ，而绿色框表示使用 <code>索引查找</code> 。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。</p><h3 id="7-2-SHOW-WARNINGS的使用"><a href="#7-2-SHOW-WARNINGS的使用" class="headerlink" title="7.2 SHOW WARNINGS的使用"></a>7.2 SHOW WARNINGS的使用</h3><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704174543663.png" alt="image-20220704174543663"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `atguigudb1`.`s1`.`key1` AS `key1`,`atguigudb1`.`s2`.`key1` AS `key1` from `atguigudb1`.`s1` join `atguigudb1`.`s2` where ((`atguigudb1`.`s1`.`key1` = `atguigudb1`.`s2`.`key1`) and (`atguigudb1`.`s2`.`common_field` is not null))</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>大家可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level、Code、Message</code>。我们最常见的就是Code为1003的信息，当Code值为1003时，<code>Message</code>字段展示的信息**<font color="red">类似于</font><strong>查询优化器将我们的</strong><font color="red">查询语句重写后的语句</font><strong>。比如我们上边的查询本来是一个左(外)连接查询，但是有一个s2.common_field IS NOT NULL的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，</strong>原本的LEFE JOIN已经变成了JOIN**。</p><p>但是大家一定要注意，我们说<code>Message</code>字段展示的信息<strong>类似于</strong>查询优化器将我们的查询语句<code>重写后的语句</code>，<strong>并不是等价于</strong>，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解MySQL将如何执行查询语句的一个参考依据而已。</p><h2 id="8-分析优化器执行计划：trace"><a href="#8-分析优化器执行计划：trace" class="headerlink" title="8. 分析优化器执行计划：trace"></a>8. 分析优化器执行计划：trace</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704175711800.png" alt="image-20220704175711800" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;</span><br><span class="line"></span><br><span class="line">set optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure><p>开启后，可分析如下语句： </p><ul><li>SELECT </li><li>INSERT </li><li>REPLACE</li><li>UPDATE </li><li>DELETE </li><li>EXPLAIN </li><li>SET </li><li>DECLARE </li><li>CASE </li><li>IF </li><li>RETURN </li><li>CALL</li></ul><p>测试：执行如下SQL语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id &lt; 10;</span><br></pre></td></tr></table></figure><p>最后， 查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line"><span class="comment">//第1部分：查询语句</span></span><br><span class="line">QUERY<span class="punctuation">:</span> select * from student where id &lt; <span class="number">10</span></span><br><span class="line"><span class="comment">//第2部分：QUERY字段对应语句的跟踪信息</span></span><br><span class="line">TRACE<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;join_preparation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//预备工作</span></span><br><span class="line">        <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;expanded_query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/* select#1 */ select `student`.`id` AS</span></span><br><span class="line"><span class="string">            `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS</span></span><br><span class="line"><span class="string">            `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* join_preparation */</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;join_optimization&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//进行优化</span></span><br><span class="line">    <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;condition_processing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//条件处理</span></span><br><span class="line">        <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WHERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equality_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;constant_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trivial_condition_removal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* condition_processing */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;substitute_generated_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//替换生成的列</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* substitute_generated_columns */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table_dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//表的依赖关系</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;row_may_be_null&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;map_bit&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;depends_on_map_bits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* table_dependencies */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ref_optimizer_key_uses&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//使用键</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;rows_estimation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//行判断</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;range_analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;table_scan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">3973767</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">408558</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="comment">/* table_scan */</span><span class="punctuation">,</span> <span class="comment">//扫描表</span></span><br><span class="line">            <span class="attr">&quot;potential_range_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//潜在的范围索引</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;id&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span> <span class="comment">/* key_parts */</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* potential_range_indexes */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setup_range_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//设置范围条件</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* setup_range_conditions */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group_index_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;not_group_by_or_distinct&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* group_index_range */</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;skip_scan_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;potential_skip_scan_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;query_references_nonkey_column&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span> <span class="comment">/* potential_skip_scan_indexes */</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="comment">/* skip_scan_range */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzing_range_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//分析范围选项</span></span><br><span class="line">            <span class="attr">&quot;range_scan_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span> <span class="comment">/* ranges */</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rowid_ordered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;using_mrr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index_only&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* range_scan_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzing_roworder_intersect&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;too_few_roworder_scans&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* analyzing_range_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen_range_access_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//选择范围访问摘要</span></span><br><span class="line">            <span class="attr">&quot;range_access_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range_scan&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                <span class="punctuation">]</span> <span class="comment">/* ranges */</span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* range_access_plan */</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* range_analysis */</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* rows_estimation */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;considered_execution_plans&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//考虑执行计划</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plan_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* plan_prefix */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;best_access_path&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//最佳访问路径</span></span><br><span class="line">        <span class="attr">&quot;considered_access_paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;rows_to_scan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;range_details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;used_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* range_details */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;resulting_rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* considered_access_paths */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* best_access_path */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;condition_filtering_pct&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">//行过滤百分比</span></span><br><span class="line">        <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attaching_conditions_to_tables&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//将条件附加到表上</span></span><br><span class="line">        <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached_conditions_computation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* attached_conditions_computation */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached_conditions_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//附加条件概要</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;finalizing_table_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;original_table_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;final_table_condition &quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* finalizing_table_conditions */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;refine_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//精简计划</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* refine_plan */</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* join_optimization */</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;join_execution&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//执行</span></span><br><span class="line">            <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* join_execution */</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。</span></span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE<span class="punctuation">:</span> <span class="number">0</span> <span class="comment">//丢失的超出最大容量的字节</span></span><br><span class="line"><span class="comment">//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在</span></span><br><span class="line">调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。</span><br><span class="line">INSUFFICIENT_PRIVILEGES<span class="punctuation">:</span> <span class="number">0</span> <span class="comment">//缺失权限</span></span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="9-MySQL监控分析视图-sys-schema"><a href="#9-MySQL监控分析视图-sys-schema" class="headerlink" title="9. MySQL监控分析视图-sys schema"></a>9. MySQL监控分析视图-sys schema</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704190726180.png" alt="image-20220704190726180" style="float:left;"><h3 id="9-1-Sys-schema视图摘要"><a href="#9-1-Sys-schema视图摘要" class="headerlink" title="9.1 Sys schema视图摘要"></a>9.1 Sys schema视图摘要</h3><ol><li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。 </li><li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。 </li><li><strong>I&#x2F;o相关</strong>：以io开头，汇总了等待I&#x2F;O、I&#x2F;O使用量情况。 </li><li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况 </li><li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。 </li><li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。 </li><li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。 </li><li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。 </li><li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I&#x2F;O、执行语句统计信息。 </li><li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li></ol><h3 id="9-2-Sys-schema视图使用场景"><a href="#9-2-Sys-schema视图使用场景" class="headerlink" title="9.2 Sys schema视图使用场景"></a>9.2 Sys schema视图使用场景</h3><p>索引情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1. 查询冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">#2. 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">#3. 查询索引的使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line">from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure><p>表相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查询表的访问量</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure><p>语句相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis</span><br><span class="line">order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure><p>IO相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure><p>Innodb 相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704192020603.png" alt="image-20220704192020603" style="float:left;"><h2 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h2><p>查询是数据库中最频繁的操作，提高查询速度可以有效地提高MySQL数据库的性能。通过对查询语句的分析可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句。</p><h1 id="第10章-索引优化与查询优化"><a href="#第10章-索引优化与查询优化" class="headerlink" title="第10章_索引优化与查询优化"></a>第10章_索引优化与查询优化</h1><p>都有哪些维度可以进行数据库调优？简言之：</p><ul><li>索引失效、没有充分利用到索引——建立索引</li><li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化</li><li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li><li>数据过多——分库分表</li></ul><p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p><p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<code>物理查询优化</code>和<code>逻辑查询优化</code>两大块。</p><ul><li>物理查询优化是通过<code>索引</code>和<code>表连接方式</code>等技术来进行优化，这里重点需要掌握索引的使用。</li><li>逻辑查询优化就是通过SQL<code>等价变换</code>提升查询效率，直白一点就是说，换一种查询写法效率可能更高。</li></ul><h2 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h2><p><code>学员表</code> 插 <code>50万</code> 条，<code> 班级表</code> 插 <code>1万</code> 条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE atguigudb2;</span><br><span class="line">USE atguigudb2;</span><br></pre></td></tr></table></figure><p><strong>步骤1：建表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `class` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `className` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">    `address` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">    `monitor` INT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `stuno` INT NOT NULL ,</span><br><span class="line">    `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    `age` INT(3) DEFAULT NULL,</span><br><span class="line">    `classId` INT(11) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">    #CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p><strong>步骤2：设置参数</strong></p><ul><li>命令开启：允许创建函数设置：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure><p><strong>步骤3：创建函数</strong></p><p>保证每条数据都不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#随机产生字符串</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">WHILE i &lt; n DO</span><br><span class="line">SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop function rand_string;</span><br></pre></td></tr></table></figure><p>随机产生班级编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop function rand_num;</span><br></pre></td></tr></table></figure><p><strong>步骤4：创建存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#创建往stu表中插入数据的存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu( START INT , max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO student (stuno, name ,age ,classId ) VALUES</span><br><span class="line">((START+i),rand_string(6),rand_num(1,50),rand_num(1,1000));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop PROCEDURE insert_stu;</span><br></pre></td></tr></table></figure><p>创建往class表中插入数据的存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加随机数据</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `insert_class`( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">INSERT INTO class ( classname,address,monitor ) VALUES</span><br><span class="line">(rand_string(8),rand_string(10),rand_num(1,100000));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop PROCEDURE insert_class;</span><br></pre></td></tr></table></figure><p><strong>步骤5：调用存储过程</strong></p><p>class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加1万条数据</span><br><span class="line">CALL insert_class(10000);</span><br></pre></td></tr></table></figure><p>stu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往stu表添加50万条数据</span><br><span class="line">CALL insert_stu(100000,500000);</span><br></pre></td></tr></table></figure><p><strong>步骤6：删除某表上的索引</strong></p><p>创建存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))</span><br><span class="line">BEGIN</span><br><span class="line">        DECLARE done INT DEFAULT 0;</span><br><span class="line">        DECLARE ct INT DEFAULT 0;</span><br><span class="line">        DECLARE _index VARCHAR(200) DEFAULT &#x27;&#x27;;</span><br><span class="line">        DECLARE _cur CURSOR FOR SELECT index_name FROM</span><br><span class="line">information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND</span><br><span class="line">seq_in_index=1 AND index_name &lt;&gt;&#x27;PRIMARY&#x27; ;</span><br><span class="line">#每个游标必须使用不同的declare continue handler for not found set done=1来控制游标的结束</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;</span><br><span class="line">#若没有数据返回,程序继续,并将变量done设为2</span><br><span class="line">        OPEN _cur;</span><br><span class="line">        FETCH _cur INTO _index;</span><br><span class="line">        WHILE _index&lt;&gt;&#x27;&#x27; DO</span><br><span class="line">            SET @str = CONCAT(&quot;drop index &quot; , _index , &quot; on &quot; , tablename );</span><br><span class="line">            PREPARE sql_str FROM @str ;</span><br><span class="line">            EXECUTE sql_str;</span><br><span class="line">            DEALLOCATE PREPARE sql_str;</span><br><span class="line">            SET _index=&#x27;&#x27;;</span><br><span class="line">            FETCH _cur INTO _index;</span><br><span class="line">        END WHILE;</span><br><span class="line">    CLOSE _cur;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>执行存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);</span><br></pre></td></tr></table></figure><h2 id="2-索引失效案例"><a href="#2-索引失效案例" class="headerlink" title="2. 索引失效案例"></a>2. 索引失效案例</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704202453482.png" alt="image-20220704202453482" style="float:left;"><h3 id="2-1-全值匹配我最爱"><a href="#2-1-全值匹配我最爱" class="headerlink" title="2.1 全值匹配我最爱"></a>2.1 全值匹配我最爱</h3><p>系统中经常出现的sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure><p>建立索引前执行：（关注执行时间）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND name = &#x27;abcd&#x27;;</span><br><span class="line">Empty set, 1 warning (0.28 sec)</span><br></pre></td></tr></table></figure><p><strong>建立索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_age ON student(age);</span><br><span class="line">CREATE INDEX idx_age_classid ON student(age,classId);</span><br><span class="line">CREATE INDEX idx_age_classid_name ON student(age,classId,name);</span><br></pre></td></tr></table></figure><p>建立索引后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND name = &#x27;abcd&#x27;;</span><br><span class="line">Empty set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704204140589.png" alt="image-20220704204140589" style="float:left;"><h3 id="2-2-最佳左前缀法则"><a href="#2-2-最佳左前缀法则" class="headerlink" title="2.2 最佳左前缀法则"></a>2.2 最佳左前缀法则</h3><p>在MySQL建立联合索引时会遵守最佳左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>举例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=1 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure><p>举例3：索引<code>idx_age_classid_name</code>还能否正常使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=4 AND student.age=30 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704211116351.png" alt="image-20220704211116351"></p><p>虽然可以正常使用，但是只有部分被使用到了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=1 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704211254581.png" alt="image-20220704211254581"></p><p>完全没有使用上索引。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。如果查询条件中没有用这些字段中第一个字段时，多列（或联合）索引不会被使用。</p><blockquote><p><strong>拓展：Alibaba《Java开发手册》</strong> </p><p>索引文件具有 B-Tree 的最左前缀匹配特性，<font color="cornflowerblue">如果左边的值未确定，那么无法使用此索引</font>。</p></blockquote><h3 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704212354041.png" alt="image-20220704212354041" style="float:left;"><p>如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704212428607.png" alt="image-20220704212428607"></p><p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前 <code>页面分裂</code> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着： <code>性能损耗</code> ！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的 <code>主键值依次递增</code> ，这样就不会发生这样的性能损耗了。 所以我们建议：让主键具有 <code>AUTO_INCREMENT</code> ，让存储引擎自己为表生成主键，而不是我们手动插入 ， 比如： <code>person_info</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们自定义的主键列 <code>id</code> 拥有 <code>AUTO_INCREMENT</code> 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p><h3 id="2-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#2-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="2.4 计算、函数、类型转换(自动或手动)导致索引失效"></a>2.4 计算、函数、类型转换(自动或手动)导致索引失效</h3><ol><li><p>创建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure></li><li><p>这两条sql哪种写法更好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>第一种：索引优化生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>第二种：索引优化失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220704214905412.png" alt="image-20220704214905412" style="zoom:150%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (3.62 sec)</span><br></pre></td></tr></table></figure><p>type为“ALL”，表示没有使用到索引，查询时间为 3.62 秒，查询效率较之前低很多。</p></li></ol><p><strong>再举例：</strong></p><ul><li><p>student表的字段stuno上设置有索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_sno ON student(stuno);</span><br></pre></td></tr></table></figure></li><li><p>索引优化失效：（假设：student表的字段stuno上设置有索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;</span><br></pre></td></tr></table></figure></li></ul><p>运行结果：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704215159768.png" alt="image-20220704215159768"></p><ul><li><p>索引优化生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;</span><br></pre></td></tr></table></figure></li></ul><p><strong>再举例：</strong></p><ul><li><p>student表的字段name上设置有索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT id, stuno, name FROM student WHERE SUBSTRING(name, 1,3)=&#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704215533871.png" alt="image-20220704215533871"></p></li><li><p>索引优化生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT id, stuno, NAME FROM student WHERE NAME LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704215600507.png" alt="image-20220704215600507"></p></li></ul><h3 id="2-5-类型转换导致索引失效"><a href="#2-5-类型转换导致索引失效" class="headerlink" title="2.5 类型转换导致索引失效"></a>2.5 类型转换导致索引失效</h3><p>下列哪个sql语句可以用到索引。（假设name字段上设置有索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704215658526.png" alt="image-20220704215658526"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704215721216.png" alt="image-20220704215721216"></p><p>name&#x3D;123发生类型转换，索引失效。</p><blockquote><p><strong><font color="red">要注意隐式类型转换，也会使用到函数使索引失效</font></strong></p></blockquote><h3 id="2-6-范围条件右边的列索引失效"><a href="#2-6-范围条件右边的列索引失效" class="headerlink" title="2.6 范围条件右边的列索引失效"></a>2.6 范围条件右边的列索引失效</h3><ol><li>系统经常出现的sql如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student DROP INDEX idx_name;</span><br><span class="line">ALTER TABLE student DROP INDEX idx_age;</span><br><span class="line">ALTER TABLE student DROP INDEX idx_age_classid;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704220123647.png" alt="image-20220704220123647"></p><ol start="2"><li>那么索引 idx_age_classId_name 这个索引还能正常使用么？</li></ol><ul><li>不能，范围右边的列不能使用。比如：(&lt;) (&lt;&#x3D;) (&gt;) (&gt;&#x3D;) 和 between 等</li><li>如果这种sql出现较多，应该建立：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_age_name_classId on student(age,name,classId);</span><br></pre></td></tr></table></figure><ul><li>将范围查询条件放置语句最后：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abc&#x27; AND student.classId&gt;20;</span><br></pre></td></tr></table></figure><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（**<font color="red">创建的联合索引中，务必把范围涉及到的字段写在最后</font>**）</p></blockquote><ol start="3"><li>效果</li></ol><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704223211981.png" alt="image-20220704223211981"></p><h3 id="2-7-不等于-或者-索引失效"><a href="#2-7-不等于-或者-索引失效" class="headerlink" title="2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a>2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效</h3><ul><li>为name字段创建索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure><ul><li>查看索引是否失效</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name &lt;&gt; &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704224552374.png" alt="image-20220704224552374"></p><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name != &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704224916117.png" alt="image-20220704224916117"></p><p>场景举例：用户提出需求，将财务数据，产品利润金额不等于0的都统计出来。</p><blockquote><p><strong>并不是说不等于就一定失效，优化器都是基于成本考虑的</strong></p><p>例如：<font color="red">使用<strong>覆盖索引</strong>时，只查询索引直接能查出的字段，<strong>不需要回表</strong>操作时，是能使用索引的</font></p></blockquote><h3 id="2-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#2-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="2.8 is null可以使用索引，is not null无法使用索引"></a>2.8 is null可以使用索引，is not null无法使用索引</h3><ul><li>IS NULL: 可以触发索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL;</span><br></pre></td></tr></table></figure><ul><li>IS NOT NULL: 无法触发索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220704225333199.png" alt="image-20220704225333199"></p><blockquote><p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p><p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p></blockquote><blockquote><p><strong>并不是说不等于就一定失效，优化器都是基于成本考虑的</strong></p><p>例如：<font color="red">使用<strong>覆盖索引</strong>时，只查询索引直接能查出的字段，<strong>不需要回表</strong>操作时，是能使用索引的</font></p></blockquote><h3 id="2-9-like以通配符-开头索引失效"><a href="#2-9-like以通配符-开头索引失效" class="headerlink" title="2.9 like以通配符%开头索引失效"></a>2.9 like以通配符%开头索引失效</h3><p>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为’%’，索引就不会起作用。只有’%’不在第一个位置，索引才会起作用。</p><ul><li>使用到索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE &#x27;ab%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705131643304.png" alt="image-20220705131643304"></p><ul><li>未使用到索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE &#x27;%ab%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705131717329.png" alt="image-20220705131717329"></p><blockquote><p><strong>拓展：Alibaba《Java开发手册》</strong> </p><p>【强制】页面搜索<font color="cornflowerblue">严禁左模糊或者全模糊</font>，如果需要请走搜索引擎来解决。</p><p><strong>并不是说不等于就一定失效，优化器都是基于成本考虑的</strong></p><p>例如：<font color="red">使用<strong>覆盖索引</strong>时，只查询索引直接能查出的字段，<strong>不需要回表</strong>操作时，是能使用索引的</font></p><p>当使用<strong>覆盖索引</strong>时，即使是会造成索引失效的like ‘%xxx’过滤，优化器也会认为<strong>使用索引成本更小</strong></p></blockquote><h3 id="2-10-OR-前后存在非索引的列，索引失效"><a href="#2-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.10 OR 前后存在非索引的列，索引失效"></a>2.10 OR 前后存在非索引的列，索引失效</h3><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p><p>查询语句使用OR关键字的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705132221045.png" alt="image-20220705132221045"></p><p>因为classId字段上没有索引，所以上述查询语句没有使用索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = &#x27;Abel&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705132239232.png" alt="image-20220705132239232"></p><p>因为age字段和name字段上都有索引，所以查询中使用了索引。你能看到这里使用到了<code>index_merge</code>，简单来说index_merge就是对age和name分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是<code>避免了全表扫描</code>。</p><h3 id="2-12-部分and-后的索引的列，索引失效"><a href="#2-12-部分and-后的索引的列，索引失效" class="headerlink" title="2.12 部分and 后的索引的列，索引失效"></a>2.12 部分and 后的索引的列，索引失效</h3><p>若没有使用使用and连接两个索引，将会只使用and前的索引，而不会使用and之后的索引</p><p>比如第9章 6.4 &gt; 5中的index_merge案例，当使用or时type&#x3D;index_merge，当使用and时，type&#x3D;ref</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; and key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230905164318711.png" alt="image-20230905164318711"></p><p>但是本章使用的测试数据中，使用and时也是index_merge，其extra信息为：Using intersect</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from student where age = 18 and classId = 101;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230905164501122.png" alt="image-20230905164501122"></p><h3 id="2-12-回表超过总数据量的20-会导致索引失效"><a href="#2-12-回表超过总数据量的20-会导致索引失效" class="headerlink" title="2.12 回表超过总数据量的20%会导致索引失效"></a>2.12 回表超过总数据量的20%会导致索引失效</h3><p>当数据量大回表的数据太多时，优化器判断直接加载所有数据的时间更少，则会造成索引失效</p><p>当使用<strong>覆盖索引</strong>时不用回表可以有效解决该问题</p><h3 id="2-13-隐式字符编码转换会造成索引失效"><a href="#2-13-隐式字符编码转换会造成索引失效" class="headerlink" title="2.13 隐式字符编码转换会造成索引失效"></a>2.13 隐式字符编码转换会造成索引失效</h3><p><strong>数据库和表的字符集统一使用utf8mb4</strong></p><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p><p>两张表，一张未utf8，一张为utf8mb4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /*语句Q1*/</span><br></pre></td></tr></table></figure><p>也就是说，实际上这个语句等同于下面这个写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p><p>这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>到这里，你终于明确了，字符集不同只是条件之一，<strong>连接过程中要求在被驱动表的索引字段上加函数操作</strong></p><p><strong>两种解决办法：</strong></p><ul><li>比较常见的优化方法是，把trade_detail表上的tradeid字段的<strong>字符集也改成utf8mb4</strong>，这样就没有字符集转换的问题了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</span><br></pre></td></tr></table></figure><ul><li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大，或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </span><br></pre></td></tr></table></figure><p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看到，这次索引走对了。</p><h3 id="2-14-练习及一般性建议"><a href="#2-14-练习及一般性建议" class="headerlink" title="2.14 练习及一般性建议"></a>2.14 练习及一般性建议</h3><p><strong>练习：</strong>假设：index(a,b,c)</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705145225852.png" alt="image-20220705145225852"></p><p><strong>一般性建议</strong></p><ul><li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引。</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li></ul><p><strong>总之，书写SQL语句时，尽量避免造成索引失效的情况</strong></p><h2 id="3-关联查询优化"><a href="#3-关联查询优化" class="headerlink" title="3. 关联查询优化"></a>3. 关联查询优化</h2><h3 id="3-1-数据准备-1"><a href="#3-1-数据准备-1" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># 分类</span><br><span class="line">CREATE TABLE IF NOT EXISTS `type` (</span><br><span class="line">`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">`card` INT(10) UNSIGNED NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line">#图书</span><br><span class="line">CREATE TABLE IF NOT EXISTS `book` (</span><br><span class="line">`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">`card` INT(10) UNSIGNED NOT NULL,</span><br><span class="line">PRIMARY KEY (`bookid`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#向分类表中添加20条记录</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line"></span><br><span class="line">#向图书表中添加20条记录</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br></pre></td></tr></table></figure><h3 id="3-2-采用左外连接"><a href="#3-2-采用左外连接" class="headerlink" title="3.2 采用左外连接"></a>3.2 采用左外连接</h3><p>下面开始 EXPLAIN 分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705160504018.png" alt="image-20220705160504018"></p><p>结论：type 有All</p><p>添加索引优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y ( card); #【被驱动表】，可以避免全表扫描</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705160935109.png" alt="image-20220705160935109"></p><p>可以看到第二行的 type 变为了 ref，rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有，所以 <code>右边被驱动表是我们的关键点,一定需要建立索引</code> 。</p><blockquote><p><strong><font color="red">当只能添加一个索引时，在被驱动表上添加索引</font></strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `type` ADD INDEX X (card); #【驱动表】，无法避免全表扫描</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705161243838.png" alt="image-20220705161243838"></p><p>接着：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX Y ON book;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705161515545.png" alt="image-20220705161515545"></p><h3 id="3-3-采用内连接"><a href="#3-3-采用内连接" class="headerlink" title="3.3 采用内连接"></a>3.3 采用内连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop index X on type;</span><br><span class="line">drop index Y on book;（如果已经删除了可以不用再执行该操作）</span><br></pre></td></tr></table></figure><p>换成 inner join（MySQL自动选择驱动表）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705161602362.png" alt="image-20220705161602362"></p><p>添加索引优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705161746184.png" alt="image-20220705161746184"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE type ADD INDEX X (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705161843558.png" alt="image-20220705161843558"></p><p>对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的</p><blockquote><p><strong><font color="red">对于内连接，若只有一个表有索引，因为两个表属于同级，那么优化器会选择拥有索引的表作为驱动表</font></strong></p></blockquote><p>接着：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX X ON `type`;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM TYPE INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705161929544.png" alt="image-20220705161929544"></p><p>接着：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `type` ADD INDEX X (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705162009145.png" alt="image-20220705162009145"></p><p>接着：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#向图书表中添加20条记录</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line"></span><br><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON `type`.card = book.card;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705163833445.png" alt="image-20220705163833445"></p><p>图中发现，由于type表数据大于book表数据，MySQL选择将type作为被驱动表。</p><blockquote><p><strong><font color="red">对于内连接：若都有索引，则优化器会选择数据量大的表作为被驱动表，“小表驱动大表”</font></strong></p><p>更准确来讲是<strong>小的结果集驱动大的结果集</strong>，详情看3.4 &gt; 5，不止是根据行数决定，根据sql语句的执行顺序，行数应该是where语句过滤过后的行数，结果集的大小还与要查询的字段数和数据量有关</p></blockquote><h3 id="3-4-join语句原理"><a href="#3-4-join语句原理" class="headerlink" title="3.4 join语句原理"></a>3.4 join语句原理</h3><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p><h4 id="1-驱动表和被驱动表"><a href="#1-驱动表和被驱动表" class="headerlink" title="1. 驱动表和被驱动表"></a>1. 驱动表和被驱动表</h4><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p><ul><li>对于内连接来说：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A JOIN B ON ...</span><br></pre></td></tr></table></figure><p>A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。</p><ul><li>对于外连接来说：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON ...</span><br><span class="line"># 或</span><br><span class="line">SELECT * FROM B RIGHT JOIN A ON ... </span><br></pre></td></tr></table></figure><p>通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。测试如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE a(f1 INT, f2 INT, INDEX(f1)) ENGINE=INNODB;</span><br><span class="line">CREATE TABLE b(f1 INT, f2 INT) ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO a VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);</span><br><span class="line">INSERT INTO b VALUES(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);</span><br><span class="line"></span><br><span class="line">SELECT * FROM b;</span><br><span class="line"></span><br><span class="line"># 测试1</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) WHERE (a.f2=b.f2);</span><br><span class="line"></span><br><span class="line"># 测试2</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) AND (a.f2=b.f2);</span><br></pre></td></tr></table></figure><h4 id="2-Simple-Nested-Loop-Join-简单嵌套循环连接"><a href="#2-Simple-Nested-Loop-Join-简单嵌套循环连接" class="headerlink" title="2. Simple Nested-Loop Join (简单嵌套循环连接)"></a>2. Simple Nested-Loop Join (简单嵌套循环连接)</h4><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result.. 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705165559127.png" alt="image-20220705165559127"></p><p>可以看到这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B&#x3D;10万次。开销统计如下:</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705165646252.png" alt="image-20220705165646252"></p><p>当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p><h4 id="3-Index-Nested-Loop-Join-（索引嵌套循环连接）"><a href="#3-Index-Nested-Loop-Join-（索引嵌套循环连接）" class="headerlink" title="3. Index Nested-Loop Join （索引嵌套循环连接）"></a>3. Index Nested-Loop Join （索引嵌套循环连接）</h4><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内存表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705172315554.png" alt="image-20220705172315554"></p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705172650749.png" alt="image-20220705172650749"></p><p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p><h4 id="4-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#4-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="4. Block Nested-Loop Join（块嵌套循环连接）"></a>4. Block Nested-Loop Join（块嵌套循环连接）</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705173047234.png" alt="image-20220705173047234" style="float:left;"><blockquote><p>注意：</p><p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p><p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p></blockquote><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705174005280.png" alt="image-20220705174005280"></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705174250551.png" alt="image-20220705174250551"></p><p>参数设置：</p><ul><li>block_nested_loop</li></ul><p>通过<code>show variables like &#39;%optimizer_switch%</code> 查看 <code>block_nested_loop</code>状态。默认是开启的。</p><ul><li>join_buffer_size</li></ul><p>驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下<code>join_buffer_size=256k</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%join_buffer%&#x27;;</span><br></pre></td></tr></table></figure><p>join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p><h4 id="5-Join小结"><a href="#5-Join小结" class="headerlink" title="5. Join小结"></a>5. Join小结</h4><p>1、<strong>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</strong></p><p>2、永远用<code>小结果集驱动大结果集</code>（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 * 每行大小）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100; # 推荐</span><br><span class="line">select t1.b,t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100; # 不推荐</span><br></pre></td></tr></table></figure><p>3、为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)</p><p>4、增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）</p><p>5、减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p><h4 id="6-Hash-Join"><a href="#6-Hash-Join" class="headerlink" title="6. Hash Join"></a>6. Hash Join</h4><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li><p>Nested Loop:</p><p>对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p></li><li><p>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列表</code>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p><ul><li>这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 &#x3D; B.COL2），这是由Hash的特点决定的。</li></ul></li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705205050280.png" alt="image-20220705205050280"></p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><ul><li>保证被驱动表的JOIN字段已经创建了索引 </li><li>需要JOIN 的字段，数据类型保持绝对一致。 </li><li>LEFT JOIN 时，选择小表作为驱动表， <code>大表作为被驱动表</code> 。减少外层循环的次数。 </li><li>INNER JOIN 时，MySQL会自动将 <code>小结果集的表选为驱动表</code> 。选择相信MySQL优化策略。 </li><li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数) </li><li><strong>不建议使用子查询</strong>，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。 </li><li>衍生表建不了索引</li></ul><h2 id="4-子查询优化"><a href="#4-子查询优化" class="headerlink" title="4. 子查询优化"></a>4. 子查询优化</h2><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。 <code>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作</code> 。</p><p><strong>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。</strong>原因：</p><p>① 执行子查询时，MySQL需要为内层查询语句的查询结果 <code>建立一个临时表</code> ，然后外层查询语句从临时表 中查询记录。查询完毕后，再 <code>撤销这些临时表</code> 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 <code>不会存在索引</code> ，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</p><p>举例1：查询学生表中是班长的学生信息</p><ul><li>使用子查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建班级表中班长的索引</span><br><span class="line">CREATE INDEX idx_monitor ON class(monitor);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM student stu1</span><br><span class="line">WHERE stu1.`stuno` IN (</span><br><span class="line">SELECT monitor</span><br><span class="line">FROM class c</span><br><span class="line">WHERE monitor IS NOT NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>推荐使用多表查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c</span><br><span class="line">ON stu1.`stuno` = c.`monitor`</span><br><span class="line">WHERE c.`monitor` is NOT NULL;</span><br></pre></td></tr></table></figure><p>举例2：取所有不为班长的同学</p><ul><li>不推荐</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE a.*</span><br><span class="line">FROM student a</span><br><span class="line">WHERE a.stuno NOT IN (</span><br><span class="line">SELECT monitor FROM class b</span><br><span class="line">    WHERE monitor IS NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705210708343.png" alt="image-20220705210708343"></p><ul><li>推荐：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE a.*</span><br><span class="line">FROM student a LEFT OUTER JOIN class b</span><br><span class="line">ON a.stuno = b.monitor</span><br><span class="line">WHERE b.monitor IS NULL;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705210839437.png" alt="image-20220705210839437"></p><blockquote><p>结论：尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p><p><strong>即尽量用连接查询而不用子查询</strong></p></blockquote><h2 id="5-排序优化"><a href="#5-排序优化" class="headerlink" title="5. 排序优化"></a>5. 排序优化</h2><h3 id="5-1-排序优化"><a href="#5-1-排序优化" class="headerlink" title="5.1 排序优化"></a>5.1 排序优化</h3><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p><p><strong>回答：</strong></p><p>在MySQL中，支持两种排序方式，分别是 <code>FileSort</code> 和 <code>Index</code> 排序。</p><ul><li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，<code>效率更高</code>。</li><li>FileSort 排序则一般在 <code>内存中</code> 进行排序，占用<code>CPU较多</code>。如果待排结果较大，会产生临时文件 I&#x2F;O 到磁盘进行排序的情况，效率较低。（也有特殊情况filesort速率优于index）</li></ul><p><strong>优化建议：</strong></p><ol><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code> ，在 ORDER BY 子句 <code>避免使用 FileSort 排序</code> 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。 </li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。 </li><li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li></ol><h3 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2 测试"></a>5.2 测试</h3><p>删除student表和class表中已创建的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 方式1</span><br><span class="line">DROP INDEX idx_monitor ON class;</span><br><span class="line">DROP INDEX idx_cid ON student;</span><br><span class="line">DROP INDEX idx_age ON student;</span><br><span class="line">DROP INDEX idx_name ON student;</span><br><span class="line">DROP INDEX idx_age_name_classId ON student;</span><br><span class="line">DROP INDEX idx_age_classId_name ON student;</span><br><span class="line"></span><br><span class="line"># 方式2</span><br><span class="line">call proc_drop_index(&#x27;atguigudb2&#x27;,&#x27;student&#x27;;)</span><br></pre></td></tr></table></figure><p>以下是否能使用到索引，<code>能否去掉using filesort</code></p><p><strong>过程一：</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705215436102.png" alt="image-20220705215436102"></p><p><strong>过程二： order by 时不limit,索引失效</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705215909350.png" alt="image-20220705215909350"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select SQL_NO_CACHE age,classid from student order by age,classid;</span><br></pre></td></tr></table></figure><blockquote><p>当使用<strong>覆盖索引时，由于不用回表</strong>，所以优化器选择使用索引</p><p><font color="red">回表超过总数据量的20%会导致索引失效</font></p><p>当加上limit过后，数据量变小，所以使用上了索引</p></blockquote><p><strong>过程三：order by 时顺序错误，索引失效</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705220033520.png" alt="image-20220705220033520" style="zoom:80%;float:left"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 失效</span><br><span class="line">2 失效</span><br><span class="line">3 生效</span><br><span class="line">4 生效</span><br><span class="line">5 生效</span><br></pre></td></tr></table></figure><p><strong>过程四：order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705220404802.png" alt="image-20220705220404802" style="zoom:80%;float:left"><blockquote><p>最后一个生效</p><p>结论：ORDER BY 子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p></blockquote><p><strong>过程五：无过滤，不索引</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705221212879.png" alt="image-20220705221212879" style="zoom:80%;float:left"><blockquote><p>索引：student(age,classid,nae)</p><p>1,2都只生效age，key_len&#x3D;5，因为过滤后cpu认为直接回表成本更低</p><p>3不生效，4生效</p><p>最后一条：order by + limit  limit后面比较小  优化器有时候会先执行order by 后where  官方文档8.2.19有</p></blockquote><p><strong>小结</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line"></span><br><span class="line">order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line"></span><br><span class="line">如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line"></span><br><span class="line">不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure><h3 id="5-3-案例实战"><a href="#5-3-案例实战" class="headerlink" title="5.3 案例实战"></a>5.3 案例实战</h3><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。 </p><p>执行案例前先清除student上的索引，只留主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age ON student;</span><br><span class="line">DROP INDEX idx_age_classid_stuno ON student;</span><br><span class="line">DROP INDEX idx_age_classid_name ON student;</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">call proc_drop_index(&#x27;atguigudb2&#x27;,&#x27;student&#x27;);</span><br></pre></td></tr></table></figure><p><strong>场景:查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705222027812.png" alt="image-20220705222027812"></p><p>查询结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| id  | stuno  | name   | age  | classId |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| 826 | 100826 | AggjDn |   30 |     168 |</span><br><span class="line">| 177 | 100177 | fTbCJz |   30 |     513 |</span><br><span class="line">|  34 | 100034 | JerxmT |   30 |     375 |</span><br><span class="line">| 682 | 100682 | jxMpoz |   30 |     516 |</span><br><span class="line">| 410 | 100410 | mkpSts |   30 |     908 |</span><br><span class="line">| 671 | 100671 | mOflNj |   30 |     400 |</span><br><span class="line">| 619 | 100619 | mQsuRa |   30 |     859 |</span><br><span class="line">| 577 | 100577 | TtngUc |   30 |     797 |</span><br><span class="line">| 568 | 100568 | uyiwHU |   30 |     224 |</span><br><span class="line">| 700 | 100700 | vgsxhv |   30 |     709 |</span><br><span class="line">|  38 | 100038 | XNTeSb |   30 |     803 |</span><br><span class="line">|  14 | 100014 | yMmbvY |   30 |      24 |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">12 rows in set, 1 warning (0.14 sec)</span><br></pre></td></tr></table></figure><blockquote><p>结论：type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须的。</p></blockquote><p><strong>方案一: 为了去掉filesort我们可以把索引建成</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建新索引</span><br><span class="line">CREATE INDEX idx_age_name ON student(age,NAME);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705222912521.png" alt="image-20220705222912521"></p><p>这样我们优化掉了 using filesort</p><p>查询结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| id  | stuno  | name   | age  | classId |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| 826 | 100826 | AggjDn |   30 |     168 |</span><br><span class="line">| 177 | 100177 | fTbCJz |   30 |     513 |</span><br><span class="line">|  34 | 100034 | JerxmT |   30 |     375 |</span><br><span class="line">| 682 | 100682 | jxMpoz |   30 |     516 |</span><br><span class="line">| 410 | 100410 | mkpSts |   30 |     908 |</span><br><span class="line">| 671 | 100671 | mOflNj |   30 |     400 |</span><br><span class="line">| 619 | 100619 | mQsuRa |   30 |     859 |</span><br><span class="line">| 577 | 100577 | TtngUc |   30 |     797 |</span><br><span class="line">| 568 | 100568 | uyiwHU |   30 |     224 |</span><br><span class="line">| 700 | 100700 | vgsxhv |   30 |     709 |</span><br><span class="line">|  38 | 100038 | XNTeSb |   30 |     803 |</span><br><span class="line">|  14 | 100014 | yMmbvY |   30 |      24 |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">12 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p><strong>方案二：尽量让where的过滤条件和排序使用上索引</strong></p><p>建一个三个字段的组合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age_name ON student;</span><br><span class="line">CREATE INDEX idx_age_stuno_name ON student (age,stuno,NAME);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705223111883.png" alt="image-20220705223111883"></p><p>我们发现<strong>using filesort依然存在</strong>，所以name并没有用到索引，而且type还是range光看名字其实并不美好。原因是，因为<code>stuno是一个范围过滤</code>，所以索引后面的字段不会在使用索引了 。</p><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| id  | stuno  | name   | age  | classId |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| 826 | 100826 | AggjDn |   30 |     168 |</span><br><span class="line">| 177 | 100177 | fTbCJz |   30 |     513 |</span><br><span class="line">|  34 | 100034 | JerxmT |   30 |     375 |</span><br><span class="line">| 682 | 100682 | jxMpoz |   30 |     516 |</span><br><span class="line">| 410 | 100410 | mkpSts |   30 |     908 |</span><br><span class="line">| 671 | 100671 | mOflNj |   30 |     400 |</span><br><span class="line">| 619 | 100619 | mQsuRa |   30 |     859 |</span><br><span class="line">| 577 | 100577 | TtngUc |   30 |     797 |</span><br><span class="line">| 568 | 100568 | uyiwHU |   30 |     224 |</span><br><span class="line">| 700 | 100700 | vgsxhv |   30 |     709 |</span><br><span class="line">|  38 | 100038 | XNTeSb |   30 |     803 |</span><br><span class="line">|  14 | 100014 | yMmbvY |   30 |      24 |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">12 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>这种方案extra信息中出现了filesort，因为没有用到name字段的部分索引，结果竟然有 filesort的 sql 运行速度， <code>超过了已经优化掉 filesort的 sql</code> ，而且快了很多，几乎一瞬间就出现了结果。</p><p>原因：</p><p>所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几干条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的stuo&lt;101000这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p><blockquote><p>结论：</p><ol><li>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择 idx_age_stuno_name）。但是， <code>随着数据量的变化，选择的索引也会随之变化的 </code>。 </li><li><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过 滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></li></ol></blockquote><p>思考：这里我们使用如下索引，是否可行？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age_stuno_name ON student;</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_age_stuno ON student(age,stuno);</span><br></pre></td></tr></table></figure><p>当然可以。</p><h3 id="5-4-filesort算法：双路排序和单路排序"><a href="#5-4-filesort算法：双路排序和单路排序" class="headerlink" title="5.4 filesort算法：双路排序和单路排序"></a>5.4 filesort算法：双路排序和单路排序</h3><p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p><p><strong>双路排序 （慢）</strong></p><ul><li><code>MySQL 4.1之前是使用双路排序</code> ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 <code>order by列 </code>，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出 </li><li>从磁盘取排序字段，在buffer进行排序，<code>再从磁盘取其他字段</code> 。</li></ul><p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。</p><p><strong>单路排序 （快）</strong></p><p>从磁盘读取查询需要的 <code>所有列</code> ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且<strong>把随机IO变成了顺序IO，但是它会使用更多的空间</strong>， 因为它把每一行都保存在内存中了。</p><p><strong>结论及引申出的问题</strong></p><ul><li>由于单路是后出的，总体而言好过双路 </li><li>但是用单路有问题<ul><li>在sort_buffer中，单路要比多路<code>多占用很多空间</code>，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<code>sort_buffer</code>的容量，导致每次只能取<code>sort_buffer</code>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I&#x2F;O。</li><li>单路本来想省一次I&#x2F;O操作，<code>反而导致了大量的I/O操作</code>，反而得不偿失。</li></ul></li></ul><p><strong>优化策略</strong></p><p><strong>1. 尝试提高 sort_buffer_size</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705224410340.png" alt="image-20220705224410340" style="zoom:80%;float:left"><p><strong>2. 尝试提高 max_length_for_sort_data</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705224505668.png" alt="image-20220705224505668" style="zoom:80%;float:left"><p><strong>3. Order by 时select * 是一个大忌。最好只Query需要的字段。</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705224551104.png" alt="image-20220705224551104" style="float:left;"><h2 id="6-GROUP-BY优化"><a href="#6-GROUP-BY优化" class="headerlink" title="6. GROUP BY优化"></a>6. GROUP BY优化</h2><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。 </li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则 </li><li>当无法使用索引列，增大 <code>max_length_for_sort_data </code>和 <code>sort_buffer_size</code> 参数的设置 </li><li>where效率高于having，能写在where限定的条件就不要写在having中了 </li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。 </li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li></ul><h2 id="7-优化分页查询"><a href="#7-优化分页查询" class="headerlink" title="7. 优化分页查询"></a>7. 优化分页查询</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220705225329130.png" alt="image-20220705225329130" style="float:left;"><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705225625166.png" alt="image-20220705225625166"></p><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220705225654124.png" alt="image-20220705225654124"></p><h2 id="8-优先考虑覆盖索引"><a href="#8-优先考虑覆盖索引" class="headerlink" title="8. 优先考虑覆盖索引"></a>8. 优先考虑覆盖索引</h2><h3 id="8-1-什么是覆盖索引？"><a href="#8-1-什么是覆盖索引？" class="headerlink" title="8.1 什么是覆盖索引？"></a>8.1 什么是覆盖索引？</h3><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是， <code>索引列+主键</code> 包含 <code>SELECT 到 FROM之间查询的列</code> 。</p><p><strong>举例一：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除之前的索引</span><br><span class="line">DROP INDEX idx_age_stuno ON student;</span><br><span class="line">CREATE INDEX idx_age_name ON student(age, NAME);</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE age &lt;&gt; 20;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706124528680.png" alt="image-20220706124528680"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT age from student where age &lt;&gt; 20;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20230907193802681.png" alt="image-20230907193802681"></p><blockquote><p>当使用<strong>覆盖索引</strong>时，即使是会造成索引失效的不等于过滤，优化器也会认为<strong>使用索引成本更小</strong></p></blockquote><p><strong>举例二：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706124612180.png" alt="image-20220706124612180"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_age_name ON student(age, NAME);</span><br><span class="line">EXPLAIN SELECT id,age,NAME FROM student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706125113658.png" alt="image-20220706125113658"></p><blockquote><p>当使用<strong>覆盖索引</strong>时，即使是会造成索引失效的like ‘%xxx’过滤，优化器也会认为<strong>使用索引成本更小</strong></p></blockquote><p>上述都使用到了声明的索引，下面的情况则不然，查询列依然多了classId,结果是未使用到索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT id,age,NAME,classId FROM student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706125351116.png" alt="image-20220706125351116"></p><h3 id="8-2-覆盖索引的利弊"><a href="#8-2-覆盖索引的利弊" class="headerlink" title="8.2 覆盖索引的利弊"></a>8.2 覆盖索引的利弊</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706125943936.png" alt="image-20220706125943936" style="zoom:80%;float:left"><h2 id="9-如何给字符串添加索引"><a href="#9-如何给字符串添加索引" class="headerlink" title="9. 如何给字符串添加索引"></a>9. 如何给字符串添加索引</h2><p>有一张教师表，表定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table teacher(</span><br><span class="line">ID bigint unsigned primary key,</span><br><span class="line">email varchar(64),</span><br><span class="line">...</span><br><span class="line">)engine=innodb;</span><br></pre></td></tr></table></figure><p>讲师要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select col1, col2 from teacher where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure><p>如果email这个字段上没有索引，那么这个语句就只能做 <code>全表扫描</code> 。</p><h3 id="9-1-前缀索引"><a href="#9-1-前缀索引" class="headerlink" title="9.1 前缀索引"></a>9.1 前缀索引</h3><p>MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table teacher add index index1(email);</span><br><span class="line">#或</span><br><span class="line">mysql&gt; alter table teacher add index index2(email(6));</span><br></pre></td></tr></table></figure><p>这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706130901307.png" alt="image-20220706130901307"></p><p>以及</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706130921934.png" alt="image-20220706130921934" style="zoom:70%;"><p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p><ol><li>从index1索引树找到满足索引值是’ <a href="mailto:&#x7a;&#x68;&#x61;&#110;&#103;&#115;&#x73;&#x78;&#x79;&#122;&#x40;&#x78;&#120;&#x78;&#46;&#99;&#111;&#x6d;">&#x7a;&#x68;&#x61;&#110;&#103;&#115;&#x73;&#x78;&#x79;&#122;&#x40;&#x78;&#120;&#x78;&#46;&#99;&#111;&#x6d;</a>’的这条记录，取得ID2的值； </li><li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集； </li><li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email&#x3D;’ <a href="mailto:&#x7a;&#x68;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#121;&#x7a;&#64;&#120;&#120;&#x78;&#x2e;&#x63;&#111;&#109;">&#x7a;&#x68;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#121;&#x7a;&#64;&#120;&#120;&#x78;&#x2e;&#x63;&#111;&#109;</a> ’的 条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p><ol><li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1； </li><li>到主键上查到主键值是ID1的行，判断出email的值不是’ <a href="mailto:&#x7a;&#x68;&#x61;&#x6e;&#x67;&#x73;&#115;&#120;&#x79;&#122;&#64;&#x78;&#x78;&#x78;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#x68;&#x61;&#x6e;&#x67;&#x73;&#115;&#120;&#x79;&#122;&#64;&#x78;&#x78;&#x78;&#x2e;&#99;&#111;&#x6d;</a> ’，这行记录丢弃； </li><li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然 后判断，这次值对了，将这行记录加入结果集； </li><li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li></ol><p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong>前面 已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p><h3 id="9-2-前缀索引对覆盖索引的影响"><a href="#9-2-前缀索引对覆盖索引的影响" class="headerlink" title="9.2 前缀索引对覆盖索引的影响"></a>9.2 前缀索引对覆盖索引的影响</h3><blockquote><p>结论： 使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p></blockquote><h2 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10. 索引下推"></a>10. 索引下推</h2><h3 id="10-1-使用前后对比"><a href="#10-1-使用前后对比" class="headerlink" title="10.1 使用前后对比"></a>10.1 使用前后对比</h3><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706131320477.png" alt="image-20220706131320477" style="zoom:80%;float:left"><h3 id="10-2-ICP的开启-关闭"><a href="#10-2-ICP的开启-关闭" class="headerlink" title="10.2 ICP的开启&#x2F;关闭"></a>10.2 ICP的开启&#x2F;关闭</h3><ul><li>默认情况下启动索引条件下推。可以通过设置系统变量<code>optimizer_switch</code>控制：<code>index_condition_pushdown</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=on&#x27;;</span><br><span class="line"></span><br><span class="line"># 关闭索引下推</span><br><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=off&#x27;;</span><br></pre></td></tr></table></figure><ul><li>当使用索引条件下推是，<code>EXPLAIN</code>语句输出结果中<code>Extra</code>列内容显示为<code>Using index condition</code>。</li></ul><h3 id="10-3-ICP使用案例"><a href="#10-3-ICP使用案例" class="headerlink" title="10.3 ICP使用案例"></a>10.3 ICP使用案例</h3><blockquote><p>这里没有使用覆盖索引，所以根据key_len来判断用%开头的模糊查询索引确实失效了，但是索引下推是在索引失效时或者非索引列的情况下，在<strong>回表前进行一次过滤判断</strong>，<strong>并不代表索引没失效</strong></p></blockquote><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706135436316.png" alt="image-20220706135436316" style="zoom:80%;float:left"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706135506409.png" alt="image-20220706135506409" style="zoom:80%;float:left"><ul><li>主键索引 (简图)</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706135633814.png" alt="image-20220706135633814"></p><p>二级索引zip_last_first (简图，这里省略了数据页等信息)</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706135701187.png" alt="image-20220706135701187"></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706135723203.png" alt="image-20220706135723203" style="zoom:80%;float:left"><h3 id="10-4-开启和关闭ICP性能对比"><a href="#10-4-开启和关闭ICP性能对比" class="headerlink" title="10.4 开启和关闭ICP性能对比"></a>10.4 开启和关闭ICP性能对比</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706135904713.png" alt="image-20220706135904713" style="zoom:80%;float:left"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706140213382.png" alt="image-20220706140213382" style="zoom:80%;float:left"><h3 id="10-5-ICP的使用条件"><a href="#10-5-ICP的使用条件" class="headerlink" title="10.5 ICP的使用条件"></a>10.5 ICP的使用条件</h3><ol><li>如果表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 可以使用ICP。</li><li>ICP可以使用<code>InnDB</code>和<code>MyISAM</code>表，包括分区表<code>InnoDB</code>和<code>MyISAM</code>表</li><li>对于<code>InnoDB</code>表，ICP仅用于<code>二级索引</code>。ICP的目标是减少全行读取次数，从而减少I&#x2F;O操作。</li><li>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I&#x2F;O。</li><li>相关子查询的条件不能使用ICP</li></ol><h2 id="11-普通索引-vs-唯一索引"><a href="#11-普通索引-vs-唯一索引" class="headerlink" title="11. 普通索引 vs 唯一索引"></a>11. 普通索引 vs 唯一索引</h2><p>从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p><p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，假设字段 k 上的值都不重复。</p><p>这个表的建表语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table test(</span><br><span class="line">id int primary key,</span><br><span class="line">k int not null,</span><br><span class="line">name varchar(16),</span><br><span class="line">index (k)</span><br><span class="line">)engine=InnoDB;</span><br></pre></td></tr></table></figure><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)。</p><h3 id="11-1-查询过程"><a href="#11-1-查询过程" class="headerlink" title="11.1 查询过程"></a>11.1 查询过程</h3><p>假设，执行查询的语句是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from test where k=5;</span><br></pre></td></tr></table></figure><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。 </li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。</p><h3 id="11-2-更新过程"><a href="#11-2-更新过程" class="headerlink" title="11.2 更新过程"></a>11.2 更新过程</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下， <code>InooDB会将这些更新操作缓存在change buffer中</code> ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了 <code>访问这个数据页</code> 会触 发merge外，系统有 <code>后台线程会定期</code> merge。在 <code>数据库正常关闭（shutdown）</code> 的过程中，也会执行merge 操作。</p><p>如果能够将更新操作先记录在change buffer， <code>减少读磁盘</code> ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 <code>避免占用内存 </code>，提高内存利用率。</p><p><code>唯一索引的更新就不能使用change buffer</code> ，实际上也只有普通索引可以使用。</p><p>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的？</p><h3 id="11-3-change-buffer的使用场景"><a href="#11-3-change-buffer的使用场景" class="headerlink" title="11.3 change buffer的使用场景"></a>11.3 change buffer的使用场景</h3><ol><li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是 对 更新性能 的影响。所以，建议你 <strong>尽量选择普通索引</strong> 。 </li><li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化 还是很明显的。 </li><li>如果所有的更新后面，都马上 <code>伴随着对这个记录的查询</code> ，那么你应该 <code>关闭change buffer</code> 。而在 其他情况下，change buffer都能提升更新性能。 </li><li>由于<strong>唯一索引用不上change buffer的优化机制</strong>，因此如果业务可以接受，从性能角度出发建议优先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理呢？ <ul><li>首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。 </li><li>然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li></ul></li></ol><blockquote><p>详细请查看《MySQL06实战45讲笔记》 09节</p></blockquote><h2 id="12-其它查询优化策略"><a href="#12-其它查询优化策略" class="headerlink" title="12. 其它查询优化策略"></a>12. 其它查询优化策略</h2><h3 id="12-1-EXISTS-和-IN-的区分"><a href="#12-1-EXISTS-和-IN-的区分" class="headerlink" title="12.1 EXISTS 和 IN 的区分"></a>12.1 EXISTS 和 IN 的区分</h3><p><strong>问题：</strong></p><p>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p><p><strong>回答：</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706141957185.png" alt="image-20220706141957185" style="zoom:80%;float:left"><h3 id="12-2-COUNT-与COUNT-具体字段-效率"><a href="#12-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="12.2 COUNT(*)与COUNT(具体字段)效率"></a>12.2 COUNT(*)与COUNT(具体字段)效率</h3><p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和 SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？</p><p>答：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706142648452.png" alt="image-20220706142648452" style="zoom:80%;float:left"><h3 id="12-3-关于SELECT"><a href="#12-3-关于SELECT" class="headerlink" title="12.3 关于SELECT(*)"></a>12.3 关于SELECT(*)</h3><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因： </p><p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code> 将”*”按序转换成所有列名，这会大大的耗费资源和时间。 </p><p>② 无法使用 <code>覆盖索引</code></p><h3 id="12-4-LIMIT-1-对优化的影响"><a href="#12-4-LIMIT-1-对优化的影响" class="headerlink" title="12.4 LIMIT 1 对优化的影响"></a>12.4 LIMIT 1 对优化的影响</h3><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 <code>LIMIT 1</code> 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p> 如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 <code>LIMIT 1 </code>了。</p><h3 id="12-5-多使用COMMIT"><a href="#12-5-多使用COMMIT" class="headerlink" title="12.5 多使用COMMIT"></a>12.5 多使用COMMIT</h3><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放 的资源而减少。</p><p>COMMIT 所释放的资源： </p><ul><li>回滚段上用于恢复数据的信息 </li><li>被程序语句获得的锁 </li><li>redo &#x2F; undo log buffer 中的空间 </li><li>管理上述 3 种资源中的内部花费</li></ul><h2 id="13-淘宝数据库，主键如何设计的？"><a href="#13-淘宝数据库，主键如何设计的？" class="headerlink" title="13. 淘宝数据库，主键如何设计的？"></a>13. 淘宝数据库，主键如何设计的？</h2><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p><p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。</p><p>大部分人的回答如此自信：用8字节的 BIGINT 做主键，而不要用INT。 <code>错 </code>！</p><p>这样的回答，只站在了数据库这一层，而没有 <code>从业务的角度</code> 思考主键。主键就是一个自增ID吗？站在 2022年的新年档口，用自增做主键，架构设计上可能 <code>连及格都拿不到</code> 。</p><h3 id="13-1-自增ID的问题"><a href="#13-1-自增ID的问题" class="headerlink" title="13.1 自增ID的问题"></a>13.1 自增ID的问题</h3><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p><ol><li><p><strong>可靠性不高</strong></p><p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。 </p></li><li><p>**安全性不高 **</p><p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。 </p></li><li><p><strong>性能差</strong> </p><p>自增ID的性能较差，需要在数据库服务器端生成。 </p></li><li><p><strong>交互多</strong> </p><p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。 </p></li><li><p>**局部唯一性 **</p><p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p></li></ol><h3 id="13-2-业务字段做主键"><a href="#13-2-业务字段做主键" class="headerlink" title="13.2 业务字段做主键"></a>13.2 业务字段做主键</h3><p>为了能够唯一地标识一个会员的信息，需要为 会员信息表 设置一个主键。那么，怎么为这个表设置主 键，才能达到我们理想的目标呢？ 这里我们考虑业务字段做主键。</p><p>表数据如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706151506580.png" alt="image-20220706151506580"></p><p>在这个表里，哪个字段比较合适呢？</p><ul><li><strong>选择卡号（cardno）</strong></li></ul><p>会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来 标识一条会员 记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE demo.membermaster</span><br><span class="line">-&gt; (</span><br><span class="line">-&gt; cardno CHAR(8) PRIMARY KEY, -- 会员卡号为主键</span><br><span class="line">-&gt; membername TEXT,</span><br><span class="line">-&gt; memberphone TEXT,</span><br><span class="line">-&gt; memberpid TEXT,</span><br><span class="line">-&gt; memberaddress TEXT,</span><br><span class="line">-&gt; sex TEXT,</span><br><span class="line">-&gt; birthday DATETIME</span><br><span class="line">-&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure><p>不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会 员一一对应，系统是可以正常运行的。</p><p>但实际情况是， 会员卡号可能存在重复使用 的情况。比如，张三因为工作变动搬离了原来的地址，不再 到商家的门店消费了 （退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让 这个会 员卡空着，就把卡号是“10000001”的会员卡发给了王五。</p><p>从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员 信息，并不会影 响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息， 系统的各个模块，都会获取到修 改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息， 而导致系统内部数据不一致”的情况。因此，从 信息系统层面 上看是没问题的。</p><p>但是从使用 系统的业务层面 来看，就有很大的问题 了，会对商家造成影响。</p><p>比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店 购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706151715106.png" alt="image-20220706151715106"></p><p>接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line">-&gt; FROM demo.trans AS a</span><br><span class="line">-&gt; JOIN demo.membermaster AS b</span><br><span class="line">-&gt; JOIN demo.goodsmaster AS c</span><br><span class="line">-&gt; ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| membername | goodsname | quantity | salesvalue | transdate |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">|     张三   | 书         | 1.000    | 89.00      | 2020-12-01 00:00:00 |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line">-&gt; FROM demo.trans AS a</span><br><span class="line">-&gt; JOIN demo.membermaster AS b</span><br><span class="line">-&gt; JOIN demo.goodsmaster AS c</span><br><span class="line">-&gt; ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| membername | goodsname | quantity | salesvalue | transdate |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| 王五        | 书        | 1.000    | 89.00      | 2020-12-01 00:00:00 |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万 不能把会员卡号当做主键。</p><ul><li><strong>选择会员电话 或 身份证号</strong></li></ul><p>会员电话可以做主键吗？不行的。在实际操作中，手机号也存在 <code>被运营商收回</code> ，重新发给别人用的情况。</p><p>那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可 问题是，身份证号属于 <code>个人隐私</code> ，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很 多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和 电话都为空的原因。</p><p><strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</strong></p><blockquote><p>经验： </p><p>刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p></blockquote><h3 id="13-3-淘宝的主键设计"><a href="#13-3-淘宝的主键设计" class="headerlink" title="13.3 淘宝的主键设计"></a>13.3 淘宝的主键设计</h3><p>在淘宝的电商业务中，订单服务是一个核心业务。请问， <strong>订单表的主键</strong> 淘宝是如何设计的呢？是自增ID 吗？</p><p>打开淘宝，看一下订单信息：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706161436920.png" alt="image-20220706161436920"></p><p>从上图可以发现，订单号不是自增ID！我们详细看下上述4个订单号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1550672064762308113</span><br><span class="line">1481195847180308113</span><br><span class="line">1431156171142308113</span><br><span class="line">1431146631521308113</span><br></pre></td></tr></table></figure><p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的前面14位部分是单调递增的。</p><p>大胆猜测，淘宝的订单ID设计应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单ID = 时间 + 去重字段 + 用户ID后6位尾号</span><br></pre></td></tr></table></figure><p>这样的设计能做到全局唯一，且对分布式系统查询及其友好。</p><h3 id="13-4-推荐的主键设计"><a href="#13-4-推荐的主键设计" class="headerlink" title="13.4 推荐的主键设计"></a>13.4 推荐的主键设计</h3><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p><p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。</p><p>这里推荐最简单的一种主键设计：UUID。</p><p><strong>UUID的特点：</strong></p><p>全局唯一，占用36字节，数据无序，插入性能差。</p><p><strong>认识UUID：</strong></p><ul><li>为什么UUID是全局唯一的？ </li><li>为什么UUID占用36个字节？ </li><li>为什么UUID是无序的？</li></ul><p>MySQL数据库的UUID组成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）</span><br></pre></td></tr></table></figure><p>我们以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706162131362.png" alt="image-20220706162131362"></p><p><code>为什么UUID是全局唯一的？</code></p><p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降 低到1&#x2F;100ns。</p><p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p><p><code>为什么UUID占用36个字节？</code></p><p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p><p><code>为什么UUID是随机无序的呢？</code></p><p>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p><p><strong>改造UUID</strong></p><p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p><p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行转化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706162657448.png" alt="image-20220706162657448"></p><p><strong>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了</strong>。全局唯一 + 单调递增，这不就是我们想要的主键！</p><p><strong>有序UUID性能测试</strong></p><p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？</p><p>我们来做一个测试，插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706162947613.png" alt="image-20220706162947613" style="zoom:67%;"><p>从上图可以看到插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在 <code>业务端就可以生成</code> 。还可以进一步减少SQL的交互次数。</p><p>另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p><blockquote><p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局唯一的实现。 </p><p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。</p></blockquote><p><strong>如果不是MySQL8.0 肿么办？</strong></p><p>手动赋值字段做主键！</p><p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p><p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p><p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值 作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p><p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解 决了各门店添加会员时会员编号冲突的问题。</p><h1 id="第11章-数据库的设计规范"><a href="#第11章-数据库的设计规范" class="headerlink" title="第11章_数据库的设计规范"></a>第11章_数据库的设计规范</h1><h2 id="1-为什么需要数据库设计"><a href="#1-为什么需要数据库设计" class="headerlink" title="1. 为什么需要数据库设计"></a>1. 为什么需要数据库设计</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706164201695.png" alt="image-20220706164201695" style="zoom:80%;float:left"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706164359539.png" alt="image-20220706164359539" style="zoom:80%;float:left"><h2 id="2-范-式"><a href="#2-范-式" class="headerlink" title="2. 范 式"></a>2. 范 式</h2><h3 id="2-1-范式简介"><a href="#2-1-范式简介" class="headerlink" title="2.1 范式简介"></a>2.1 范式简介</h3><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结 构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h3 id="2-2-范式都包括哪些"><a href="#2-2-范式都包括哪些" class="headerlink" title="2.2 范式都包括哪些"></a>2.2 范式都包括哪些</h3><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p><p>数据库的范式设计越高阶，夯余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范的要求称为第二范式（2NF），其余范式以此类推。</p><p>一般来说，在关系型数据库设计中，最高也就遵循到<code>BCNF</code>, 普遍还是<code>3NF</code>。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是<code>反规范化</code>。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706165020939.png" alt="image-20220706165020939"></p><h3 id="2-3-键和相关属性的概念"><a href="#2-3-键和相关属性的概念" class="headerlink" title="2.3 键和相关属性的概念"></a>2.3 键和相关属性的概念</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220706165231022.png" alt="image-20220706165231022" style="float:left;"><p><strong>举例:</strong></p><p>这里有两个表：</p><p><code>球员表(player)</code> ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号 </p><p><code>球队表(team) </code>：球队编号 | 主教练 | 球队所在地</p><ul><li>超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的<strong>任意组合</strong>，比如（球员编号） （球员编号，姓名）（身份证号，年龄）等。 </li><li>候选键 ：就是<strong>最小的超键</strong>，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 </li><li>主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 </li><li>外键 ：球员表中的球队编号。 </li><li>主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名） （年龄）（球队编号）都是非主属性。</li></ul><h3 id="2-4-第一范式-1st-NF"><a href="#2-4-第一范式-1st-NF" class="headerlink" title="2.4 第一范式(1st NF)"></a>2.4 第一范式(1st NF)</h3><p>第一范式主要确保数据库中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单元。</p><p>我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p><p><strong>举例1：</strong></p><p>假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706171057270.png" alt="image-20220706171057270"></p><p>该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的 emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706171130851.png" alt="image-20220706171130851"></p><p><strong>举例2：</strong></p><p>user 表的设计不符合第一范式</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706171225292.png" alt="image-20220706171225292"></p><p>其中，user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的 要求。将user_info拆分后如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706171242455.png" alt="image-20220706171242455"></p><p><strong>举例3：</strong></p><p>属性的原子性是 <code>主观的</code> 。例如，Employees关系中雇员姓名应当使用1个（fullname）、2个（firstname 和lastname）还是3个（firstname、middlename和lastname）属性表示呢？答案取决于应用程序。如果应 用程序需要分别处理雇员的姓名部分（如：用于搜索目的），则有必要把它们分开。否则，不需要。</p><p>表1：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706171442919.png" alt="image-20220706171442919"></p><p>表2：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220706171456873.png" alt="image-20220706171456873"></p><h3 id="2-5-第二范式-2nd-NF"><a href="#2-5-第二范式-2nd-NF" class="headerlink" title="2.5 第二范式(2nd NF)"></a>2.5 第二范式(2nd NF)</h3><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以扩展替换为候选键）。</p><blockquote><p><font color="red">解决部分依赖</font></p></blockquote><p><strong>举例1：</strong></p><p><code>成绩表</code> （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课 程号也不能决定成绩，所以“（学号，课程号）→成绩”就是 <code>完全依赖关系</code> 。</p><p><strong>举例2：</strong></p><p><code>比赛表 player_game</code> ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这 里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure><p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line"></span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure><p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p><ol><li><code>数据冗余</code> ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。 </li><li><code>插入异常</code> ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。 </li><li><code>删除异常</code> ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删 除掉。 </li><li><code>更新异常</code> ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调 整，否则就会出现一场比赛时间不同的情况。</li></ol><p>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707122639894.png" alt="image-20220707122639894"></p><p>这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。</p><blockquote><p>1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p></blockquote><p><strong>举例3：</strong></p><p>定义了一个名为 Orders 的关系，表示订单和订单行的信息：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707123038469.png" alt="image-20220707123038469"></p><p>违反了第二范式，因为有非主键属性仅依赖于候选键（或主键）的一部分。例如，可以仅通过orderid找 到订单的 orderdate，以及 customerid 和 companyname，而没有必要再去使用productid。</p><p>修改：</p><p>Orders表和OrderDetails表如下，此时符合第二范式。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707123104009.png" alt="image-20220707123104009"></p><blockquote><p>小结：第二范式（2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p></blockquote><h3 id="2-6-第三范式-3rd-NF"><a href="#2-6-第三范式-3rd-NF" class="headerlink" title="2.6 第三范式(3rd NF)"></a>2.6 第三范式(3rd NF)</h3><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A-&gt;B-&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能由依赖关系，必须<code>相互独立</code>。</p><p>这里的主键可以扩展为候选键。</p><blockquote><p><font color="red">解决传递依赖</font></p></blockquote><p><strong>举例1：</strong></p><p><code>部门信息表</code> ：每个部门有部门编号（dept_id）、部门名称、部门简介等信息。</p><p><code>员工信息表 </code>：每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介 等与部门有关的信息再加入员工信息表中。</p><p>如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p><p><strong>举例2：</strong></p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707124011654.png" alt="image-20220707124011654"></p><p>商品类别名称依赖于商品类别编号，不符合第三范式。</p><p>修改：</p><p>表1：符合第三范式的 <code>商品类别表</code> 的设计</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707124040899.png" alt="image-20220707124040899"></p><p>表2：符合第三范式的 <code>商品表</code> 的设计</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707124058174.png" alt="image-20220707124058174"></p><p>商品表goods通过商品类别id字段（category_id）与商品类别表goods_category进行关联。</p><p><strong>举例3：</strong></p><p><code>球员player表</code> ：球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出来，如下图所示:</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707124136228.png" alt="image-20220707124136228"></p><p>你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依 赖于球员编号，因此不符合 3NF 的要求。</p><p>如果要达到 3NF 的要求，需要把数据表拆成下面这样：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707124152312.png" alt="image-20220707124152312"></p><p><strong>举例4：</strong></p><p>修改第二范式中的举例3。</p><p>此时的Orders关系包含 orderid、orderdate、customerid 和 companyname 属性，主键定义为 orderid。 customerid 和companyname均依赖于主键——orderid。例如，你需要通过orderid主键来查找代表订单中 客户的customerid，同样，你需要通过 orderid 主键查找订单中客户的公司名称（companyname）。然 而， customerid和companyname也是互相依靠的。为满足第三范式，可以改写如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707124212114.png" alt="image-20220707124212114"></p><blockquote><p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于 整个键，并且除了键别无他物”。</p></blockquote><h3 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707124343085.png" alt="image-20220707124343085" style="zoom:80%;float:left"><h2 id="3-反范式化"><a href="#3-反范式化" class="headerlink" title="3. 反范式化"></a>3. 反范式化</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707124741675.png" alt="image-20220707124741675" style="zoom:80%;float:left"><p><strong>规范化 vs 性能</strong></p><blockquote><ol><li>为满足某种商业目标 , 数据库性能比规范化数据库更重要 </li><li>在数据规范化的同时 , 要综合考虑数据库的性能 </li><li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间 </li><li>通过在给定的表中插入计算列，以方便查询</li></ol></blockquote><h3 id="3-2-应用举例"><a href="#3-2-应用举例" class="headerlink" title="3.2 应用举例"></a>3.2 应用举例</h3><p><strong>举例1：</strong></p><p>员工的信息存储在 <code>employees 表</code> 中，部门信息存储在 <code>departments 表</code> 中。通过 employees 表中的 department_id字段与 departments 表建立关联关系。如果要查询一个员工所在部门的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,department_name</span><br><span class="line">from employees e join departments d</span><br><span class="line">on e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><p>如果经常需要进行这个操作，连接查询就会浪费很多时间。可以在 employees 表中增加一个冗余字段 department_name，这样就不用每次都进行连接操作了。</p><p><strong>举例2：</strong></p><p>反范式化的 <code>goods商品信息表</code> 设计如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707125118808.png" alt="image-20220707125118808"></p><p><strong>举例3：</strong></p><p>我们有 2 个表，分别是 <code>商品流水表（atguigu.trans ）</code>和 <code>商品信息表 （atguigu.goodsinfo）</code> 。商品流水表里有 400 万条流水记录，商品信息表里有 2000 条商品记录。</p><p>商品流水表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707125401029.png" alt="image-20220707125401029"></p><p>商品信息表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707125447317.png" alt="image-20220707125447317"></p><p>新的商品流水表如下所示：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707125500378.png" alt="image-20220707125500378"></p><p><strong>举例4：</strong></p><p><code>课程评论表 class_comment</code> ，对应的字段名称及含义如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707125531172.png" alt="image-20220707125531172"></p><p><code>学生表 student</code> ，对应的字段名称及含义如下：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707125545891.png" alt="image-20220707125545891" style="zoom:80%;"><p>在实际应用中，我们在显示课程评论的时候，通常会显示这个学生的昵称，而不是学生 ID，因此当我们 想要查询某个课程的前 1000 条评论时，需要关联 class_comment 和 student这两张表来进行查询。</p><p><strong>实验数据：模拟两张百万量级的数据表</strong></p><p>为了更好地进行 SQL 优化实验，我们需要给学生表和课程评论表随机模拟出百万量级的数据。我们可以 通过存储过程来实现模拟数据。</p><p><strong>反范式优化实验对比</strong></p><p>如果我们想要查询课程 ID 为 10001 的前 1000 条评论，需要写成下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT p.comment_text, p.comment_time, stu.stu_name</span><br><span class="line">FROM class_comment AS p LEFT JOIN student AS stu</span><br><span class="line">ON p.stu_id = stu.stu_id</span><br><span class="line">WHERE p.class_id = 10001</span><br><span class="line">ORDER BY p.comment_id DESC</span><br><span class="line">LIMIT 1000;</span><br></pre></td></tr></table></figure><p>运行结果（1000 条数据行）：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707125642908.png" alt="image-20220707125642908" style="zoom:80%;"><p>运行时长为 0.395 秒，对于网站的响应来说，这已经很慢了，用户体验会非常差。</p><p>如果我们想要提升查询的效率，可以允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段， 在 class_comment 数据表的基础上增加 stu_name 字段，就得到了 class_comment2 数据表。</p><p>这样一来，只需单表查询就可以得到数据集结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT comment_text, comment_time, stu_name</span><br><span class="line">FROM class_comment2</span><br><span class="line">WHERE class_id = 10001</span><br><span class="line">ORDER BY class_id DESC LIMIT 1000;</span><br></pre></td></tr></table></figure><p>运行结果（1000 条数据）：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707125718469.png" alt="image-20220707125718469" style="zoom:80%;"><p>优化之后只需要扫描一次聚集索引即可，运行时间为 0.039 秒，查询时间是之前的 1&#x2F;10。 你能看到， 在数据量大的情况下，查询效率会有显著的提升。</p><h3 id="3-3-反范式的新问题"><a href="#3-3-反范式的新问题" class="headerlink" title="3.3 反范式的新问题"></a>3.3 反范式的新问题</h3><ul><li>存储 <code>空间变大了 </code></li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 <code>数据不一致 </code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 <code>消耗系统资源 </code></li><li>在 <code>数据量小</code> 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h3 id="3-4-反范式的适用场景"><a href="#3-4-反范式的适用场景" class="headerlink" title="3.4 反范式的适用场景"></a>3.4 反范式的适用场景</h3><p>当冗余信息有价值或者能 <code>大幅度提高查询效率</code> 的时候，我们才会采取反范式的优化。</p><h4 id="1-增加冗余字段的建议"><a href="#1-增加冗余字段的建议" class="headerlink" title="1. 增加冗余字段的建议"></a>1. 增加冗余字段的建议</h4><p>增加冗余字段一定要符合如下两个条件。只要满足这两个条件，才可以考虑增加夯余字段。</p><p>1）这个冗余字段<code>不需要经常进行修改</code>。</p><p>2）这个冗余字段<code>查询的时候不可或缺</code>。</p><h4 id="2-历史快照、历史数据的需要"><a href="#2-历史快照、历史数据的需要" class="headerlink" title="2. 历史快照、历史数据的需要"></a>2. 历史快照、历史数据的需要</h4><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的 <code>订单收货信息</code> 都属于 <code>历史快照</code> ，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在 <code>数据仓库</code> 的设计中，因为数据仓库通常<code>存储历史数据</code> ，对增删改的实时性要求不 强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><p>我简单总结下数据仓库和数据库在使用上的区别：</p><ol><li>数据库设计的目的在于<code>捕捉数据</code>，而数据仓库设计的目的在于<code>分析数据</code>。</li><li>数据库对数据的<code>增删改实时性</code>要求强，需要存储在线的用户数据，而数据仓库存储的一般是<code>历史数据</code>。</li><li>数据库设计需要<code>尽量避免冗余</code>，但为了提高查询效率也允许一定的<code>冗余度</code>，而数据仓库在设计上更偏向采用反范式设计，</li></ol><h2 id="4-BCNF-巴斯范式"><a href="#4-BCNF-巴斯范式" class="headerlink" title="4. BCNF(巴斯范式)"></a>4. BCNF(巴斯范式)</h2><p>人们在3NF的基础上进行了改进，提出了巴斯范式（BCNF），页脚巴斯 - 科德范式（Boyce - Codd Normal Form）。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是<code>修正的第三范式</code>，或<code>扩充的第三范式</code>，BCNF不被称为第四范式。</p><p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。</p><p>一般来说，一个数据库设符合3NF或者BCNF就可以了。</p><p><strong>1. 案例</strong></p><p>我们分析如下表的范式情况：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707131428597.png" alt="image-20220707131428597" style="zoom:80%;"><p>在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。</p><p>仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个 属性。这样，我们就可以找到数据表的候选键。</p><p><code>候选键 </code>：是（管理员，物品名）和（仓库名，物品名），然后我们从候选键中选择一个作为主键 ，比 如（仓库名，物品名）。</p><p><code>主属性</code> ：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。</p><p><code>非主属性</code> ：数量这个属性。</p><p><strong>2. 是否符合三范式</strong></p><p>如何判断一张表的范式呢？我们需要根据范式的等级，从低到高来进行判断。</p><p>首先，数据表每个属性都是原子性的，符合 1NF 的要求；</p><p>其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品 名）决定数量。因此，数据表符合 2NF 的要求；</p><p>最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。</p><p><strong>3. 存在的问题</strong></p><p>既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？我们来看下面的情况：</p><ol><li>增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现插入异常；</li><li>如果仓库更换了管理员，我们就可能会修改数据表中的多条记录 ；</li><li>如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。</li></ol><p>你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。</p><p><strong>4. 问题解决</strong></p><p>首先我们需要确认造成异常的原因：主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系， 这样就有可能导致上面的异常情况。因此引入BCNF，<strong>它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p><ul><li>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于 BCNF。</li></ul><p>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：</p><p><code>仓库表</code> ：（仓库名，管理员）</p><p><code>库存表 </code>：（仓库名，物品名，数量）</p><p>这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。</p><p>再举例：</p><p>有一个 <code>学生导师表</code> ，其中包含字段：学生ID，专业，导师，专业GPA，这其中学生ID和专业是联合主键。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707132038425.png" alt="image-20220707132038425"></p><p>这个表的设计满足三范式，但是这里存在另一个依赖关系，“专业”依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。</p><p>所以这个表的部分主键Major依赖于非主键属性Advisor，那么我们可以进行以下的调整，拆分成2个表：</p><p>学生导师表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707132344634.png" alt="image-20220707132344634"></p><p>导师表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707132355841.png" alt="image-20220707132355841"></p><h2 id="5-第四范式"><a href="#5-第四范式" class="headerlink" title="5. 第四范式"></a>5. 第四范式</h2><p>多值依赖的概念：</p><ul><li><code>多值依赖</code>即属性之间的一对多关系，记为K—&gt;—&gt;A。</li><li><code>函数依赖</code>事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li><li><code>平凡的多值依赖</code>：全集U&#x3D;K+A，一个K可以对应于多个A，即K—&gt;—&gt;A。此时整个表就是一组一对多关系。</li><li><code>非平凡的多值依赖</code>：全集U&#x3D;K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B相互独立，即K—&gt;—&gt;A，K—&gt;—&gt;B。整个表有多组一对多关系，且有：”一”部分是相同的属性集合，“多”部分是相互独立的属性集合。</li></ul><p>第四范式即在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）。</p><p><strong>举例1：</strong>职工表(职工编号，职工孩子姓名，职工选修课程)。</p><p>在这个表中，同一个职工可能会有多个职工孩子姓名。同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。</p><p>如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如： <code>职工表一</code>(职工编 号，职工孩子姓名)， <code>职工表二</code>(职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四范式。</p><p><strong>举例2：</strong></p><p>比如我们建立课程、教师、教材的模型。我们规定，每门课程有对应的一组教师，每门课程也有对应的一组教材，一门课程使用的教材和教师没有关系。我们建立的关系表如下：</p><p>课程ID，教师ID，教材ID；这三列作为联合主键。</p><p>为了表述方便，我们用Name代替ID，这样更容易看懂：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707133830721.png" alt="image-20220707133830721"></p><p>这个表除了主键，就没有其他字段了，所以肯定满足BC范式，但是却存在 <code>多值依赖</code> 导致的异常。</p><p>假如我们下学期想采用一本新的英版高数教材，但是还没确定具体哪个老师来教，那么我们就无法在这 个表中维护Course高数和Book英版高数教材的的关系。</p><p>解决办法是我们把这个多值依赖的表拆解成2个表，分别建立关系。这是我们拆分后的表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707134028730.png" alt="image-20220707134028730"></p><p>以及</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707134220820.png" alt="image-20220707134220820"></p><h2 id="6-第五范式、域键范式"><a href="#6-第五范式、域键范式" class="headerlink" title="6. 第五范式、域键范式"></a>6. 第五范式、域键范式</h2><p>除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。</p><p>在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。<strong>如果关系模式R中的每一个连 接依赖均由R的候选键所隐含</strong>，则称此关系模式符合第五范式。</p><p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由 <code>语义直接导出</code> ，而是在 <code>关系连接运算</code> 时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p><p>第五范式处理的是 <code>无损连接问题</code> ，这个范式基本 <code>没有实际意义</code> ，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个 <code>终极范式</code> ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。</p><h2 id="7-实战案例"><a href="#7-实战案例" class="headerlink" title="7. 实战案例"></a>7. 实战案例</h2><p>商超进货系统中的<code>进货单表</code>进行剖析：</p><p>进货单表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707134636225.png" alt="image-20220707134636225"></p><p>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大，效率极低。如何改造？</p><blockquote><p>在实际工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见。往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CPU使用率飙升的情况，甚至会导致整个项目失败。</p></blockquote><h3 id="7-1-迭代1次：考虑1NF"><a href="#7-1-迭代1次：考虑1NF" class="headerlink" title="7.1 迭代1次：考虑1NF"></a>7.1 迭代1次：考虑1NF</h3><p>第一范式要求：<strong>所有的字段都是基本数据类型，不可进行拆分</strong>。这里需要确认，所有的列中，每个字段只包含一种数据。</p><p>这张表里，我们把“property”这一字段，拆分成”specification (规格)” 和 “unit (单位)”，这两个字段如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707154400580.png" alt="image-20220707154400580"></p><h3 id="7-2-迭代2次：考虑2NF"><a href="#7-2-迭代2次：考虑2NF" class="headerlink" title="7.2 迭代2次：考虑2NF"></a>7.2 迭代2次：考虑2NF</h3><p>第二范式要求，在满足第一范式的基础上，<strong>还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。</p><p>第1步，就是要确定这个表的主键。通过观察发现，字段“listnumber（单号）”+”barcode（条码）”可以唯一标识每一条记录，可以作为主键。</p><p>第2步，确定好了主键以后，判断哪些字段完全依赖主键，哪些字段只依赖于主键的一部分。把只依赖于主键一部分的字段拆出去，形成新的数据表。</p><p>首先，进货单明细表里面的”goodsname(名称)””specification(规格)””unit(单位)”这些信息是商品的属性，只依赖于”batcode(条码)”，不完全依赖主键，可以拆分出去。我们把这3个字段加上它们所依赖的字段”barcode(条码)”，拆分形成新的数据表”商品信息表”。</p><p>这样一来，原来的数据表就被拆分成了两个表。</p><p>商品信息表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707163807205.png" alt="image-20220707163807205" style="float:left;"><p>进货单表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707163828614.png" alt="image-20220707163828614" style="float:left;"><p>此外，字段”supplierid(供应商编号)””suppliername(供应商名称)””stock(仓库)“只依赖于”listnumber(单号)”，不完全依赖于主键，所以，我们可以把”supplierid””suppliername””stock”这3个字段拆出去，再加上它们依赖的字段”listnumber(单号)”，就形成了一个新的表”进货单头表”。剩下的字段，会组成新的表，我们叫它”进货单明细表”。</p><p>原来的数据表就拆分成了3个表。</p><p>进货单头表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707164128704.png" alt="image-20220707164128704"></p><p>进货单明细表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707164146216.png" alt="image-20220707164146216"></p><p>商品信息表：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707164227845.png" alt="image-20220707164227845"></p><p>现在，我们再来分析一下拆分后的3个表，保证这3个表都满足第二范式的要求。</p><p>第3步，在“商品信息表”中，字段“barcode”是有<code>可能存在重复</code>的，比如，用户门店可能有散装称重商品和自产商品，会存在条码共用的情况。所以，所有的字段都不能唯一标识表里的记录。这个时候，我们必须给这个表加上一个主键，比如说是<code>自增字段&quot;itemnumber&quot;</code>。</p><h3 id="7-3-迭代3次：考虑3NF"><a href="#7-3-迭代3次：考虑3NF" class="headerlink" title="7.3 迭代3次：考虑3NF"></a>7.3 迭代3次：考虑3NF</h3><p>我们的进货单头表，还有数据冗余的可能。因为”suppliername”依赖”supplierid”，那么就可以按照第三范式的原则进行拆分了。我们就进一步拆分进货单头表，把它拆解陈供货商表和进货单头表。</p><p>供货商表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707165011050.png" alt="image-20220707165011050" style="float:left;"><p>进货单头表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707165038108.png" alt="image-20220707165038108" style="float:left;"><p>这2个表都满足第三范式的要求了。</p><h3 id="7-4-反范式化：业务优先的原则"><a href="#7-4-反范式化：业务优先的原则" class="headerlink" title="7.4 反范式化：业务优先的原则"></a>7.4 反范式化：业务优先的原则</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707165459547.png" alt="image-20220707165459547" style="zoom:80%;float:left"><p>因此，最后我们可以把进货单表拆分成下面的4个表：</p><p>供货商表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707165011050.png" alt="image-20220707165011050" style="float:left;"><p>进货单头表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707165038108.png" alt="image-20220707165038108" style="float:left;"><p>进货单明细表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707164146216.png" alt="image-20220707164146216" style="zoom:80%;float:left"><p>商品信息表：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707164227845.png" alt="image-20220707164227845" style="zoom:80%;float:left"><p>这样一来，我们就避免了冗余数据，而且还能够满足业务的需求，这样的数据库设计，才是合格的设计。</p><h2 id="8-ER模型"><a href="#8-ER模型" class="headerlink" title="8. ER模型"></a>8. ER模型</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707170027637.png" alt="image-20220707170027637" style="zoom:80%;float:left"><h3 id="8-1-ER模型包括哪些要素？"><a href="#8-1-ER模型包括哪些要素？" class="headerlink" title="8.1 ER模型包括哪些要素？"></a>8.1 ER模型包括哪些要素？</h3><p><strong>ER 模型中有三个要素，分别是实体、属性和关系。</strong></p><p><code>实体</code> ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 <code>矩形</code> 来表 示。实体分为两类，分别是 <code>强实体</code> 和 <code>弱实体</code> 。强实体是指不依赖于其他实体的实体；弱实体是指对另 一个实体有很强的依赖关系的实体。</p><p><code>属性</code> ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 <code>椭圆形</code> 来表示。</p><p><code>关系</code> ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模 型中用 <code>菱形</code> 来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h3 id="8-2-关系的类型"><a href="#8-2-关系的类型" class="headerlink" title="8.2 关系的类型"></a>8.2 关系的类型</h3><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p><p><code>一对一</code> ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p><p><code>一对多</code> ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学 生则对应一个班级，班级对学生就是一对多的关系。</p><p><code>多对多</code> ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之 间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购 商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这 就是多对多的关系。</p><h3 id="8-3-建模分析"><a href="#8-3-建模分析" class="headerlink" title="8.3 建模分析"></a>8.3 建模分析</h3><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设 计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键 了。开发应用项目的实质，其实就是 建模 。</p><p>我们设计的案例是 电商业务 ，由于电商业务太过庞大且复杂，所以我们做了业务简化，比如针对 SKU（StockKeepingUnit，库存量单位）和SPU（Standard Product Unit，标准化产品单元）的含义上，我 们直接使用了SKU，并没有提及SPU的概念。本次电商业务设计总共有8个实体，如下所示。</p><ul><li>地址实体 </li><li>用户实体 </li><li>购物车实体 </li><li>评论实体 </li><li>商品实体 </li><li>商品分类实体 </li><li>订单实体 </li><li>订单详情实体</li></ul><p>其中， 用户 和 商品分类 是强实体，因为它们不需要依赖其他任何实体。而其他属于弱实体，因为它们 虽然都可以独立存在，但是它们都依赖用户这个实体，因此都是弱实体。知道了这些要素，我们就可以 给电商业务创建 ER 模型了，如图：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707170608782.png" alt="image-20220707170608782"></p><p>在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情示一对1的关系，商品和 订单是多对多的关系。 这个 ER 模型，包括了 8个实体之间的 8种关系。</p><p>（1）用户可以在电商平台添加多个地址； </p><p>（2）用户只能拥有一个购物车； </p><p>（3）用户可以生成多个订单； </p><p>（4）用户可以发表多条评论； </p><p>（5）一件商品可以有多条评论； </p><p>（6）每一个商品分类包含多种商品；</p><p>（7）一个订单可以包含多个商品，一个商品可以在多个订单里。 </p><p>（8）订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品</p><h3 id="8-4-ER-模型的细化"><a href="#8-4-ER-模型的细化" class="headerlink" title="8.4 ER 模型的细化"></a>8.4 ER 模型的细化</h3><p>有了这个 ER 模型，我们就可以从整体上 理解 电商的业务了。刚刚的 ER 模型展示了电商业务的框架， 但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之 间的关系，还不能对应到具体的表，以及表与表之间的关联。我们需要把 属性加上 ，用 椭圆 来表示， 这样我们得到的 ER 模型就更加完整了。</p><p>因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的具体业务流程，然后把 它们综合到一起，形成一个完整的 ER 模型。这样可以帮助我们理清数据库的设计思路。</p><p>接下来，我们再分析一下各个实体都有哪些属性，如下所示。</p><p>（1） <code>地址实体</code> 包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。 </p><p>（2） <code>用户实体</code> 包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。</p><p>（3） <code>购物车实体</code> 包括购物车编号、用户编号、商品编号、商品数量、图片文件url。</p><p>（4） <code>订单实体</code> 包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单 时间。 </p><p>（5） <code>订单详情实体</code> 包括订单详情编号、订单编号、商品名称、商品编号、商品数量。 </p><p>（6） <code>商品实体</code> 包括商品编号、价格、商品名称、分类编号、是否销售，规格、颜色。 </p><p>（7） <code>评论实体</code> 包括评论id、评论内容、评论时间、用户编号、商品编号 </p><p>（8） <code>商品分类实体</code> 包括类别编号、类别名称、父类别编号</p><p>这样细分之后，我们就可以重新设计电商业务了，ER 模型如图：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707171022246.png" alt="image-20220707171022246"></p><h3 id="8-5-ER-模型图转换成数据表"><a href="#8-5-ER-模型图转换成数据表" class="headerlink" title="8.5 ER 模型图转换成数据表"></a>8.5 ER 模型图转换成数据表</h3><p>通过绘制 ER 模型，我们已经理清了业务逻辑，现在，我们就要进行非常重要的一步了：把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：</p><p>（1）一个 <code>实体</code> 通常转换成一个 <code>数据表</code> ； </p><p>（2）一个 <code>多对多的关系</code> ，通常也转换成一个 <code>数据表</code> ； </p><p>（3）一个 <code>1 对 1</code> ，或者 <code>1 对多</code> 的关系，往往通过表的 <code>外键</code> 来表达，而不是设计一个新的数据表； </p><p>（4） <code>属性</code> 转换成表的 <code>字段</code> 。</p><p>下面结合前面的ER模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从 而把抽象出来的数据模型，落实到具体的数据库设计当中。</p><h4 id="1-一个实体转换成一个数据库"><a href="#1-一个实体转换成一个数据库" class="headerlink" title="1. 一个实体转换成一个数据库"></a>1. 一个实体转换成一个数据库</h4><p><strong>先来看一下强实体转换成数据表:</strong></p><p><code>用户实体</code>转换成用户表(user_info)的代码如下所示。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707171335255.png" alt="image-20220707171335255" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707171412363.png" alt="image-20220707171412363" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707171915637.png" alt="image-20220707171915637" style="float:left;"><p><strong>下面我们再把弱实体转换成数据表：</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172033399.png" alt="image-20220707172033399" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172052236.png" alt="image-20220707172052236" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172143793.png" alt="image-20220707172143793" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172217772.png" alt="image-20220707172217772" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172236606.png" alt="image-20220707172236606" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172259143.png" alt="image-20220707172259143" style="float:left;"><h4 id="2-一个多对多的关系转换成一个数据表"><a href="#2-一个多对多的关系转换成一个数据表" class="headerlink" title="2. 一个多对多的关系转换成一个数据表"></a>2. 一个多对多的关系转换成一个数据表</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172350226.png" alt="image-20220707172350226" style="float:left;"><h4 id="3-通过外键来表达1对多的关系"><a href="#3-通过外键来表达1对多的关系" class="headerlink" title="3. 通过外键来表达1对多的关系"></a>3. 通过外键来表达1对多的关系</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172609833.png" alt="image-20220707172609833" style="float:left;"><h4 id="4-把属性转换成表的字段"><a href="#4-把属性转换成表的字段" class="headerlink" title="4. 把属性转换成表的字段"></a>4. 把属性转换成表的字段</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707172819174.png" alt="image-20220707172819174" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707172918017.png" alt="image-20220707172918017"></p><h2 id="9-数据表的设计原则"><a href="#9-数据表的设计原则" class="headerlink" title="9. 数据表的设计原则"></a>9. 数据表的设计原则</h2><p>综合以上内容，总结出数据表设计的一般原则：”三少一多”</p><p><strong>1. 数据表的个数越少越好</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707173028203.png" alt="image-20220707173028203" style="float:left;"><p><strong>2. 数据表中的字段个数越少越好</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707173402491.png" alt="image-20220707173402491" style="float:left;"><p><strong>3. 数据表中联合主键的字段个数越少越好</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707173522971.png" alt="image-20220707173522971" style="float:left;"><p><strong>4. 使用主键和外键越多越好</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707173557568.png" alt="image-20220707173557568" style="float:left;"><h2 id="10-数据库对象编写建议"><a href="#10-数据库对象编写建议" class="headerlink" title="10. 数据库对象编写建议"></a>10. 数据库对象编写建议</h2><h3 id="10-1-关于库"><a href="#10-1-关于库" class="headerlink" title="10.1 关于库"></a>10.1 关于库</h3><ol><li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头。 </li><li>【强制】库名中英文 <code>一律小写</code> ，不同单词采用 <code>下划线</code> 分割。须见名知意。 </li><li>【强制】库的名称格式：业务系统名称_子系统名。</li><li>【强制】库名禁止使用关键字（如type,order等）。</li><li>【强制】创建数据库时必须 <code>显式指定字符集</code> ，并且字符集只能是<strong>utf8或者utf8mb4</strong>。 创建数据库SQL举例：CREATE DATABASE crm_fund <strong>DEFAULT CHARACTER SET ‘utf8’</strong> ; </li><li>【建议】对于程序连接数据库账号，遵循 权限最小原则 使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 <code>原则上不准有drop权限</code> 。 </li><li>【建议】临时库以 <code>tmp_</code> 为前缀，并以日期为后缀； 备份库以 <code>bak_</code> 为前缀，并以日期为后缀。</li></ol><h3 id="10-2-关于表、列"><a href="#10-2-关于表、列" class="headerlink" title="10.2 关于表、列"></a>10.2 关于表、列</h3><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议 以 <code>英文字母开头 </code>。 </p></li><li><p>【强制】 <code>表名、列名一律小写</code> ，不同单词采用下划线分割。须见名知意。 </p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 <code>统一前缀</code> 。比如：crm_fund_item </p></li><li><p>【强制】创建表时必须 <code>显式指定字符集</code> 为utf8或utf8mb4。 </p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。 </p></li><li><p>【强制】创建表时必须 <code>显式指定表存储引擎</code> 类型。如无特殊需求，一律为InnoDB。 </p></li><li><p>【强制】建表必须有comment。 </p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 <code>缩写</code> 。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。 </p></li><li><p>【强制】布尔值类型的字段命名为 <code>is_描述</code> 。如member表上表示是否为enabled的会员的字段命 名为 is_enabled。 </p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随 机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。 </p></li><li><p>【建议】建表时关于主键： <code>表必须有主键</code></p><p> (1)强制要求主键为id，类型为int或bigint，且为 auto_increment 建议使用unsigned无符号型。</p><p> (2)标识表里每一行主体的字段不要设为主键，建议 设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机 插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。 </p></li><li><p>【建议】核心表（如用户表）必须有行数据的 <code>创建时间字段</code> （create_time）和 <code>最后更新时间字段</code>（update_time），便于查问题。 </p></li><li><p>【建议】表中所有字段尽量都是 <code>NOT NULL</code> 属性，业务可以根据需要定义 <code>DEFAULT值</code> 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。 </p></li><li><p>【建议】所有存储相同数据的 <code>列名和列类型必须一致</code> （一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。 </p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以 <code>tmp_</code> 开头。 备份表用于备份或抓取源表快照，名称以 <code>bak_ </code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">    `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">    `user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">    `username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">    `email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">    `nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">    `birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">    `sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">    `short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">    `user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">    `user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">    `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">    CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">    `user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">    通过，4为还未提交审核&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">    KEY `idx_username`(`username`),</span><br><span class="line">    KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息</span><br></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。</li></ol><p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。</p><p>可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p><h3 id="10-3-关于索引"><a href="#10-3-关于索引" class="headerlink" title="10.3 关于索引"></a>10.3 关于索引</h3><ol><li>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值<code> 禁止被更新</code>。 </li><li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 <code>BTREE</code> 。 </li><li>【建议】主键的名称以 <code>pk_</code> 开头，唯一键以 <code>uni</code>_ 或 <code>uk_</code> 开头，普通索引以 <code>idx_</code> 开头，一律使用小写格式，以字段的名称或缩写作为后缀。 </li><li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。 </li><li>【建议】单个表上的索引个数 <code>不能超过6个</code> 。 </li><li>【建议】在建立索引时，多考虑建立 <code>联合索引</code> ，并把区分度最高的字段放在最前面。 </li><li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。 </li><li>【建议】建表或加索引时，保证表里互相不存在<code> 冗余索引</code> 。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</li></ol><h3 id="10-4-SQL编写"><a href="#10-4-SQL编写" class="headerlink" title="10.4 SQL编写"></a>10.4 SQL编写</h3><ol><li>【强制】程序端SELECT语句必须指定<code>具体字段名称</code>，禁止写成 *。 </li><li>【建议】程序端insert语句<code>指定具体字段名称</code>，不要写成INSERT INTO t1 VALUES(…)。 </li><li>【建议】除静态表或小表（100行以内），DML语句<code>必须有WHERE条件，且使用索引查找</code>。 </li><li>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。 </li><li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内。 </li><li>【建议】线上环境，多表 JOIN 不要超过5个表。 </li><li>【建议】<strong>减少使用ORDER BY</strong>，和业务沟通能不排序就不排序，或将排序放到程序端去做。<strong>ORDER BY、GROUP BY、DISTINCT</strong> 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。 </li><li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢。 </li><li>【建议】<strong>对单表的多次alter操作必须合并为一次</strong> 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生 <code>表锁</code> ，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。 </li><li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </li><li>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。 </li><li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li></ol><h2 id="11-PowerDesigner的使用"><a href="#11-PowerDesigner的使用" class="headerlink" title="11. PowerDesigner的使用"></a>11. PowerDesigner的使用</h2><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 <code>数据流程图</code> 、 <code>概念数据模型</code> 、 <code>物理数据模型</code> ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设 计提供的一套完整的集成化企业级建模解决方案。</p><h3 id="11-1-开始界面"><a href="#11-1-开始界面" class="headerlink" title="11.1 开始界面"></a>11.1 开始界面</h3><p>当前使用的PowerDesigner版本是16.5的。打开软件即是此页面，可选择Create Model,也可以选择Do Not Show page Again,自行在打开软件后创建也可以！完全看个人的喜好，在此我在后面的学习中不在显示此页面。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175250944.png" alt="image-20220707175250944" style="zoom:80%;float:left"><p>“Create Model”的作用类似于普通的一个文件，该文件可以单独存放也可以归类存放。</p><p> “Create Project”的作用类似于文件夹，负责把有关联关系的文件集中归类存放。</p><h3 id="11-2-概念数据模型"><a href="#11-2-概念数据模型" class="headerlink" title="11.2 概念数据模型"></a>11.2 概念数据模型</h3><p>常用的模型有4种，分别是 <code>概念模型(CDM Conceptual Data Model)</code> ， <code>物理模型（PDM,Physical Data Model）</code> ， <code>面向对象的模型（OOM Objcet Oriented Model）</code> 和 <code>业务模型（BPM Business Process Model）</code> ，我们先创建概念数据模型。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175350250.png" alt="image-20220707175350250" style="float:left;"><p>点击上面的ok，即可出现下图左边的概念模型1，可以自定义概念模型的名字，在概念模型中使用最多的 就是如图所示的Entity(实体),Relationship(关系)</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175604026.png" alt="image-20220707175604026" style="float:left;"><p><strong>Entity实体</strong></p><p>选中右边框中Entity这个功能，即可出现下面这个方框，需要注意的是书写name的时候，code自行补全，name可以是英文的也可以是中文的，但是code必须是英文的。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175653689.png" alt="image-20220707175653689" style="float:left;"><p><strong>填充实体字段</strong></p><p>General中的name和code填好后，就可以点击Attributes（属性）来设置name（名字），code(在数据库中 的字段名)，Data Type(数据类型) ，length(数据类型的长度)</p><ul><li>Name: 实体名字一般为中文，如论坛用户 </li><li>Code: 实体代号，一般用英文，如XXXUser </li><li>Comment:注释，对此实体详细说明 </li><li>Code属性：代号，一般用英文UID DataType </li><li>Domain域，表示属性取值范围如可以创建10个字符的地址域 </li><li>M:Mandatory强制属性，表示该属性必填。不能为空 </li><li>P:Primary Identifer是否是主标识符，表示实体唯一标识符 </li><li>D:Displayed显示出来，默认全部勾选</li></ul><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175805226.png" alt="image-20220707175805226" style="float:left;"><p>在此上图说明name和code的起名方法</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175827417.png" alt="image-20220707175827417" style="float:left;"><p><strong>设置主标识符</strong></p><p>如果不希望系统自动生成标识符而是手动设置的话，那么切换到Identifiers选项卡，添加一行Identifier， 然后单击左上角的“属性”按钮，然后弹出的标识属性设置对话框中单击“添加行”按钮，选择该标识中使用的属性。例如将学号设置为学生实体的标识。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175858031.png" alt="image-20220707175858031" style="float:left;"><p><strong>放大模型</strong></p><p>创建好概念数据模型如图所示，但是创建好的字体很小，读者可以按着ctrl键同时滑动鼠标的可滑动按钮 即可放大缩写字体，同时也可以看到主标识符有一个*号的标志，同时也显示出来了，name,Data type和 length这些可见的属性</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175925155.png" alt="image-20220707175925155" style="float:left;"><p><strong>实体关系</strong></p><p>同理创建一个班级的实体（需要特别注意的是，点击完右边功能的按钮后需要点击鼠标指针状态的按钮 或者右击鼠标即可，不然很容易乱操作，这点注意一下就可以了），然后使用Relationship（关系）这个 按钮可以连接学生和班级之间的关系，发生一对多（班级对学生）或者多对一（学生对班级）的关系。 </p><p>如图所示</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707175954634.png" alt="image-20220707175954634" style="float:left;"><p>需要注意的是点击Relationship这个按钮，就把班级和学生联系起来了，就是一条线，然后双击这条线进 行编辑，在General这块起name和code</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180021612.png" alt="image-20220707180021612" style="float:left;"><p>上面的name和code起好后就可以在Cardinalities这块查看班级和学生的关系，可以看到班级的一端是一 条线，学生的一端是三条，代表班级对学生是一对多的关系即one对many的关系，点击应用，然后确定 即可</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180044291.png" alt="image-20220707180044291" style="float:left;"><p>一对多和多对一练习完还有多对多的练习，如下图操作所示，老师实体和上面介绍的一样，自己将 name，data type等等修改成自己需要的即可，满足项目开发需求即可。（comment是解释说明，自己可以写相关的介绍和说明）</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180113532.png" alt="image-20220707180113532" style="float:left;"><p>多对多需要注意的是自己可以手动点击按钮将关系调整称为多对多的关系many对many的关系，然后点击应用和确定即可</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180159184.png" alt="image-20220707180159184" style="float:left;"><p>综上即可完成最简单的学生，班级，教师这种概念数据模型的设计，需要考虑数据的类型和主标识码， 是否为空。关系是一对一还是一对多还是多对多的关系，自己需要先规划好再设计，然后就ok了。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707180254510.png" alt="image-20220707180254510"></p><h3 id="11-3-物理数据模型"><a href="#11-3-物理数据模型" class="headerlink" title="11.3 物理数据模型"></a>11.3 物理数据模型</h3><p>上面是概念数据模型，下面介绍一下物理数据模型，以后 经常使用 的就是物理数据模型。打开 PowerDesigner，然后点击File–&gt;New Model然后选择如下图所示的物理数据模型，物理数据模型的名字自己起，然后选择自己所使用的数据库即可。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180327712.png" alt="image-20220707180327712" style="float:left;"><p>创建好主页面如图所示，但是右边的按钮和概念模型略有差别，物理模型最常用的三个是 <code>table(表)</code> ， <code>view(视图)</code>， <code>reference(关系) </code>；</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180418090.png" alt="image-20220707180418090" style="float:left;"><p>鼠标先点击右边table这个按钮然后在新建的物理模型点一下，即可新建一个表，然后双击新建如下图所示，在General的name和code填上自己需要的，点击应用即可），如下图：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180449212.png" alt="image-20220707180449212" style="float:left;"><p>然后点击Columns,如下图设置，非常简单，需要注意的就是P（primary主键） , F （foreign key外键） , M（mandatory强制性的，代表不可为空） 这三个。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180537251.png" alt="image-20220707180537251" style="float:left;"><p>在此设置学号的自增（MYSQL里面的自增是这个AUTO_INCREMENT），班级编号同理，不多赘述！</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180556645.png" alt="image-20220707180556645" style="float:left;"><p>在下面的这个点上对号即可，就设置好了自增</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180619440.png" alt="image-20220707180619440" style="float:left;"><p>全部完成后如下图所示。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180643107.png" alt="image-20220707180643107" style="float:left;"><p>班级物理模型同理如下图所示创建即可</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180723698.png" alt="image-20220707180723698" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180744600.png" alt="image-20220707180744600" style="float:left;"><p>完成后如下图所示</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180806150.png" alt="image-20220707180806150" style="float:left;"><p>上面的设置好如上图所示，然后下面是关键的地方，点击右边按钮Reference这个按钮，因为是班级对学 生是一对多的，所以鼠标从学生拉到班级如下图所示，学生表将发生变化，学生表里面增加了一行，这 行是班级表的主键作为学生表的外键，将班级表和学生表联系起来。（仔细观察即可看到区别。）</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707180828164.png" alt="image-20220707180828164" style="float:left;"><p>做完上面的操作，就可以双击中间的一条线，显示如下图，修改name和code即可</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707183743297.png" alt="image-20220707183743297" style="float:left;"><p>但是需要注意的是，修改完毕后显示的结果却如下图所示，并没有办法直接像概念模型那样，修改过后 显示在中间的那条线上面，自己明白即可。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707193816176.png" alt="image-20220707193816176" style="float:left;"><p>学习了多对一或者一对多的关系，接下来学习多对对的关系，同理自己建好老师表，这里不在叙述，记得老师编号自增，建好如下图所示</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707193932694.png" alt="image-20220707193932694" style="float:left;"><p>下面是多对多关系的关键，由于物理模型多对多的关系需要一个中间表来连接，如下图，只设置一个字 段，主键，自增</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707193957629.png" alt="image-20220707193957629" style="float:left;"><p>点击应用，然后设置Columns，只添加一个字段</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707194048843.png" alt="image-20220707194048843" style="float:left;"><p>这是设置字段递增，前面已经叙述过好几次</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707194111885.png" alt="image-20220707194111885" style="float:left;"><p>设置好后如下图所示，需要注意的是有箭头的一方是一，无箭头的一方是多，即一对多的多对一的关系 需要搞清楚，学生也可以有很多老师，老师也可以有很多学生，所以学生和老师都可以是主体；</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707194138137.png" alt="image-20220707194138137" style="float:left;"><p>可以看到添加关系以后学生和教师的关系表前后发生的变化</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707194158936.png" alt="image-20220707194158936" style="float:left;"><h3 id="11-4-概念模型转为物理模型"><a href="#11-4-概念模型转为物理模型" class="headerlink" title="11.4 概念模型转为物理模型"></a>11.4 概念模型转为物理模型</h3><p>1：如下图所示先打开概念模型图，然后点击Tool,如下图所示</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194228064.png" alt="image-20220707194228064"></p><p>点开的页面如下所示，name和code已经从概念模型1改成物理模型1了</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194248236.png" alt="image-20220707194248236"></p><p>完成后如下图所示，将自行打开修改的物理模型，需要注意的是这些表的数据类型已经自行改变了，而 且中间表出现两个主键，即双主键</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194308595.png" alt="image-20220707194308595"></p><h3 id="11-5-物理模型转为概念模型"><a href="#11-5-物理模型转为概念模型" class="headerlink" title="11.5 物理模型转为概念模型"></a>11.5 物理模型转为概念模型</h3><p>上面介绍了概念模型转物理模型，下面介绍一下物理模型转概念模型（如下图点击操作即可）</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194405358.png" alt="image-20220707194405358"></p><p>然后出现如下图所示界面，然后将物理修改为概念 ，点击应用确认即可</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194419360.png" alt="image-20220707194419360"></p><p>点击确认后将自行打开如下图所示的页面，自己观察有何变化，如果转换为oracle的，数据类型会发生变 化，比如Varchar2等等）；</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194433407.png" alt="image-20220707194433407"></p><h3 id="11-6-物理模型导出SQL语句"><a href="#11-6-物理模型导出SQL语句" class="headerlink" title="11.6 物理模型导出SQL语句"></a>11.6 物理模型导出SQL语句</h3><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194544714.png" alt="image-20220707194544714"></p><p>打开之后如图所示，修改好存在sql语句的位置和生成文件的名称即可</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194557554.png" alt="image-20220707194557554"></p><p>在Selection中选择需要导出的表，然后点击应用和确认即可</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194637242.png" alt="image-20220707194637242"></p><p>完成以后出现如下图所示，可以点击Edit或者close按钮</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707194727849.png" alt="image-20220707194727849"></p><p>自此，就完成了导出sql语句，就可以到自己指定的位置查看导出的sql语句了；PowerDesigner在以后在 项目开发过程中用来做需求分析和数据库的设计非常的方便和快捷。</p><h1 id="第12章-数据库其它调优策略"><a href="#第12章-数据库其它调优策略" class="headerlink" title="第12章_数据库其它调优策略"></a>第12章_数据库其它调优策略</h1><h2 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a>1. 数据库调优的措施</h2><h3 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a>1.1 调优的目标</h3><ul><li>尽可能节省系统资源 ，以便系统可以提供更大负荷的服务。（吞吐量更大） </li><li>合理的结构设计和参数调整，以提高用户操作响应的速度 。（响应速度更快） </li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h3 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a>1.2 如何定位调优问题</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707200915836.png" alt="image-20220707200915836" style="float:left;"><p>如何确定呢？一般情况下，有如下几种方式：</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707201133424.png" alt="image-20220707201133424" style="float:left;"><h3 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a>1.3 调优的维度和步骤</h3><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构 等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。通过如下的步骤我们进行梳理：</p><h4 id="第1步：选择适合的-DBMS"><a href="#第1步：选择适合的-DBMS" class="headerlink" title="第1步：选择适合的 DBMS"></a>第1步：选择适合的 DBMS</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707201443229.png" alt="image-20220707201443229" style="float:left;"><h4 id="第2步：优化表设计"><a href="#第2步：优化表设计" class="headerlink" title="第2步：优化表设计"></a>第2步：优化表设计</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707201617799.png" alt="image-20220707201617799" style="float:left;"><h4 id="第3步：优化逻辑查询"><a href="#第3步：优化逻辑查询" class="headerlink" title="第3步：优化逻辑查询"></a>第3步：优化逻辑查询</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707202059972.png" alt="image-20220707202059972" style="float:left;"><h4 id="第4步：优化物理查询"><a href="#第4步：优化物理查询" class="headerlink" title="第4步：优化物理查询"></a>第4步：优化物理查询</h4><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对 各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中，我们需要掌握的重点是对索引的创建和使用。</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707202156660.png" alt="image-20220707202156660" style="float:left;"><h4 id="第5步：使用-Redis-或-Memcached-作为缓存"><a href="#第5步：使用-Redis-或-Memcached-作为缓存" class="headerlink" title="第5步：使用 Redis 或 Memcached 作为缓存"></a>第5步：使用 Redis 或 Memcached 作为缓存</h4><p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p><p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用 户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放 到内存中，就会大幅提升查询的效率。</p><p>键值存储数据库可以帮我们解决这个问题。</p><p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707202436467.png" alt="image-20220707202436467" style="float:left;"><h4 id="第6步：库级优化"><a href="#第6步：库级优化" class="headerlink" title="第6步：库级优化"></a>第6步：库级优化</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707202555506.png" alt="image-20220707202555506" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707202732911.png" alt="image-20220707202732911" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707203538155.png" alt="image-20220707203538155" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707203607993.png" alt="image-20220707203607993" style="float:left;"><blockquote><p>但需要注意的是，分拆在提升数据库性能的同时，也会增加维护和使用成本。</p></blockquote><h2 id="2-优化MySQL服务器"><a href="#2-优化MySQL服务器" class="headerlink" title="2. 优化MySQL服务器"></a>2. 优化MySQL服务器</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707203818987.png" alt="image-20220707203818987" style="float:left;"><h3 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a>2.1 优化服务器硬件</h3><p>服务器的硬件性能直接决定着MySQL数据库的性能。硬件的性能瓶颈直接决定MySQL数据库的运行速度 和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。 </p><p>（1） <code>配置较大的内存</code> 。足够大的显存是提高MySQL数据库性能的方法之一。内存的速度比磁盘I&#x2F;O快得多，可以通过增加系统的<code>缓冲区容量</code>使数据在内存中停留的时间更长，以<code>减少磁盘I/O</code>。</p><p>（2） <code>配置高速磁盘系统 </code>，以减少读盘的等待时间，提高响应速度。磁盘的I&#x2F;O能力，也就是它的寻道能力，目前的SCSI高速旋转的是7200转&#x2F;分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站pv (page view) 在150w，这样的一般的配置就无法满足这样的需求了。现在SSD盛行，在SSD上随机访问和顺序访问性能差不多，使用SSD可以减少随机IO带来的性能损耗。</p><p>（3） <code>合理分布磁盘I/O</code>，把磁盘I&#x2F;O分散在多个设备，以减少资源竞争，提高冰箱操作能力。</p><p>（4） <code>配置多处理器</code>, MySQL是多线程的数据库，多处理器可同时执行多个线程。</p><h3 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a><strong>2.2 优化MySQL的参数</strong></h3><p>通过优化MySQL的参数可以提高资源利用率，从而达到提高MySQL服务器性能的目的。</p><p>MySQL服务的配置参数都在<strong>my.cnf</strong>或者<strong>my.ini</strong>文件的[mysqld]组中。配置完参数以后，需要重新启动MySQL服务才会生效。</p><p>下面对几个对性能影响比较大的参数进行详细介绍。</p><ul><li><p><strong>innodb_buffer_pool_size</strong> ：<code>缓冲区大小</code>，这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的 <code>表和索引的最大缓存</code> 。它不仅仅缓存 <code>索引数据</code> ，还会缓存 <code>表的数据</code>。这个值越大，查询的速度就会越 快。但是这个值太大会影响操作系统的性能。</p></li><li><p><strong>key_buffer_size</strong> ：表示 <code>索引缓冲区的大小</code> 。索引缓冲区是所有的 <code>线程共享</code> 。增加索引缓冲区可 以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存 的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 <code>4GB 左右 的服务器该参数可设置为 256M 或 384M</code> 。</p></li><li><p><strong>table_cache</strong> ：表示 <code>同时打开的表的个数</code> 。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。<code>默认为2402，调到512-1024最佳</code>。这个值不是越大越好，因为同时打开的表 太多会影响操作系统的性能。</p></li><li><p><strong>query_cache_size</strong> ：表示 <code>查询缓冲区的大小</code> 。可以通过在MySQL控制台观察，如果 Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size 的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很 多。<code>MySQL8.0之后失效</code>。该参数需要和query_cache_type配合使用。</p><ul><li><strong>query_cache_type</strong> 的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不 会导致MySQL释放query_cache_size所配置的缓存区内存。<ul><li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE ，如SELECT SQL_NO_CACHE * FROM tbl_name。</li><li>当query_cache_type&#x3D;2时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓 存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的 查询操作的情况。</li></ul></li></ul></li><li><p><strong>sort_buffer_size</strong> ：表示每个 <code>需要进行排序的线程分配的缓冲区的大小</code> 。增加这个参数的值可以 提高 <code>ORDER BY</code> 或 <code>GROUP BY</code> 操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB 左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。</p></li><li><p><strong>join_buffer_size &#x3D; 8M</strong> ：表示 <code>联合查询操作所能使用的缓冲区大小 </code>，和sort_buffer_size一样， 该参数对应的分配内存也是每个连接独享。</p></li><li><p><strong>read_buffer_size</strong> ：表示 <code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code> 。当线 程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参 数的值。默认为64K，可以设置为4M。</p></li><li><p><strong>innodb_flush_log_at_trx_commit</strong> ：表示 <code>何时将缓冲区的数据写入日志文件</code> ，并且将日志文件 写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值 为1。</p><ul><li>值为 <code>0</code> 时，表示 <code>每秒1次</code> 的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的 commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导 致上一秒钟所有事务数据的丢失。</li><li>值为 <code>1</code> 时，表示 <code>每次提交事务时</code> 将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是<code>最安全</code>的，但也是<code>最慢</code>的一种方式。因为每次事务提交或事务外的指令都需要把日志写入 （flush）硬盘。</li><li>值为 <code>2</code> 时，表示 <code>每次提交事务时</code> 将数据写入日志文件， <code>每隔1秒</code> 将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数 据才可能丢失。</li></ul></li><li><p><strong>innodb_log_buffer_size</strong> ：这是 InnoDB 存储引擎的 <code>事务日志所使用的缓冲区</code> 。为了提高性能， 也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条 件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</p></li><li><p><strong>max_connections</strong> ：表示 <code>允许连接到MySQL数据库的最大数量</code> ，默认值是 <code>151</code> 。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接 数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的 服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 <code>不是越大越好</code> ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</p><ul><li><strong>back_log</strong> ：用于 <code>控制MySQL监听TCP端口时设置的积压请求栈大小</code> 。如果MySql的连接数达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默 认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512 的整数，但最大不超过900。</li></ul><p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><ul><li><p><strong>thread_cache_size</strong> ： <code>线程池缓存线程数量的大小 </code>，当客户端断开连接后将当前线程缓存起来， 当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为 120。</p><p>可以通过如下几个MySQL状态值来适当调整线程池的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;Thread%&#x27;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached | 2 |</span><br><span class="line">| Threads_connected | 1 |</span><br><span class="line">| Threads_created | 3 |</span><br><span class="line">| Threads_running | 2 |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>当 Threads_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可 适当增加 thread_cache_size 的大小。</p></li></ul></li><li><p><strong>wait_timeout</strong> ：指定 <code>一个请求的最大连接时间</code> ，对于4GB左右内存的服务器可以设置为5-10。</p></li><li><p><strong>interactive_timeout</strong> ：表示服务器在关闭连接前等待行动的秒数。</p></li></ul><p>这里给出一份my.cnf的参考配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port = 3306 </span><br><span class="line">serverid = 1 </span><br><span class="line">socket = /tmp/mysql.sock </span><br><span class="line">skip-locking #避免MySQL的外部锁定，减少出错几率增强稳定性。 </span><br><span class="line">skip-name-resolve #禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ </span><br><span class="line">back_log = 384</span><br><span class="line">key_buffer_size = 256M </span><br><span class="line">max_allowed_packet = 4M </span><br><span class="line">thread_stack = 256K</span><br><span class="line">table_cache = 128K </span><br><span class="line">sort_buffer_size = 6M </span><br><span class="line">read_buffer_size = 4M</span><br><span class="line">read_rnd_buffer_size=16M </span><br><span class="line">join_buffer_size = 8M </span><br><span class="line">myisam_sort_buffer_size =64M </span><br><span class="line">table_cache = 512 </span><br><span class="line">thread_cache_size = 64 </span><br><span class="line">query_cache_size = 64M</span><br><span class="line">tmp_table_size = 256M </span><br><span class="line">max_connections = 768 </span><br><span class="line">max_connect_errors = 10000000</span><br><span class="line">wait_timeout = 10 </span><br><span class="line">thread_concurrency = 8 #该参数取值为服务器逻辑CPU数量*2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8</span><br><span class="line">skip-networking #开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ </span><br><span class="line">table_cache=1024</span><br><span class="line">innodb_additional_mem_pool_size=4M #默认为2M </span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=2M #默认为1M </span><br><span class="line">innodb_thread_concurrency=8 #你的服务器CPU有几个就设置为几。建议用默认一般为8 </span><br><span class="line">tmp_table_size=64M #默认为16M，调到64-256最挂</span><br><span class="line">thread_cache_size=120 </span><br><span class="line">query_cache_size=32M</span><br></pre></td></tr></table></figure><p>很多情况还需要具体情况具体分析！</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707210351452.png" alt="image-20220707210351452" style="float:left;"><p><strong>(1) 调整系统参数 InnoDB_flush_log_at_trx_commit</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707210447501.png" alt="image-20220707210447501" style="float:left;"><p><strong>(2)  调整系统参数 InnoDB_buffer_pool_size</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707210555848.png" alt="image-20220707210555848" style="float:left;"><p><strong>(3) 调整系统参数 InnoDB_buffer_pool_instances</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707210720394.png" alt="image-20220707210720394" style="float:left;"><h2 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a>3. 优化数据库结构</h2><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707211709553.png" alt="image-20220707211709553" style="float:left;"><h3 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a>3.1 拆分表：冷热数据分离</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707211802756.png" alt="image-20220707211802756" style="float:left;"><p><strong>举例1：</strong> <code>会员members表</code> 存储会员登录认证信息，该表中有很多字段，如id、姓名、密码、地址、电 话、个人描述字段。其中地址、电话、个人描述等字段并不常用，可以将这些不常用的字段分解出另一 个表。将这个表取名叫members_detail，表中有member_id、address、telephone、description等字段。 这样就把会员表分成了两个表，分别为 <code>members表</code> 和 <code>members_detail表</code> 。</p><p>创建这两个表的SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE members (</span><br><span class="line">    id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    username varchar(50) DEFAULT NULL,</span><br><span class="line">    password varchar(50) DEFAULT NULL,</span><br><span class="line">    last_login_time datetime DEFAULT NULL,</span><br><span class="line">    last_login_ip varchar(100) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY(Id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE members_detail (</span><br><span class="line">    Member_id int(11) NOT NULL DEFAULT 0,</span><br><span class="line">    address varchar(255) DEFAULT NULL,</span><br><span class="line">    telephone varchar(255) DEFAULT NULL,</span><br><span class="line">    description text</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果需要查询会员的基本信息或详细信息，那么可以用会员的id来查询。如果需要将会员的基本信息和 详细信息同时显示，那么可以将members表和members_detail表进行联合查询，查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM members LEFT JOIN members_detail on members.id =</span><br><span class="line">members_detail.member_id;</span><br></pre></td></tr></table></figure><p>通过这种分解可以提高表的查询效率。对于字段很多且有些字段使用不频繁的表，可以通过这种分解的方式来优化数据库的性能。</p><h3 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a>3.2 增加中间表</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707212800544.png" alt="image-20220707212800544" style="float:left;"><p>举例1： 学生信息表 和 班级表 的SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `class` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`className` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">`address` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">`monitor` INT NULL ,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stuno` INT NOT NULL ,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`age` INT(3) DEFAULT NULL,</span><br><span class="line">`classId` INT(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>现在有一个模块需要经常查询带有学生名称（name）、学生所在班级名称（className）、学生班级班 长（monitor）的学生信息。根据这种情况可以创建一个 temp_student 表。temp_student表中存储学生名称（stu_name）、学生所在班级名称（className）和学生班级班长（monitor）信息。创建表的语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `temp_student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stu_name` INT NOT NULL ,</span><br><span class="line">`className` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`monitor` INT(3) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>接下来，从学生信息表和班级表中查询相关信息存储到临时表中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into temp_student(stu_name,className,monitor)</span><br><span class="line">            select s.name,c.className,c.monitor</span><br><span class="line">            from student as s,class as c</span><br><span class="line">            where s.classId = c.id</span><br></pre></td></tr></table></figure><p>以后，可以直接从temp_student表中查询学生名称、班级名称和班级班长，而不用每次都进行联合查 询。这样可以提高数据库的查询速度。</p><blockquote><p>如果用户信息修改了，是不是会导致temp_vip中的<code>数据不一致</code>的问题呢？如何同步数据呢？<br>方式1：清空数据-&gt;重新添加数据<br>方式2：使用视图</p></blockquote><h3 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a>3.3 增加冗余字段</h3><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。 但是，合理地加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表与表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而 且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p><p>这部分内容在《第11章_数据库的设计规范》章节中 反范式化小节 中具体展开讲解了。这里省略。</p><h3 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a>3.4 优化数据类型</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707213524137.png" alt="image-20220707213524137" style="float:left;"><p><strong>情况1：对整数类型数据进行优化。</strong></p><p>遇到整数类型的字段可以用 <code>INT</code> 型 。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数 据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以 的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于 <code>非负型</code> 的数据（如自增ID、整型IP）来说，要优先使用无符号整型 <code>UNSIGNED</code> 来存储。因为无符号 相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多 出一倍的存储空间。</p><p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</strong></p><p>跟文本类型数据相比，大整数往往占用<code>更少的存储空间</code> ，因此，在存取和比对的时候，可以占用更少的 内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地 址转换成整型数据。</p><p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707214640374.png" alt="image-20220707214640374" style="float:left;"><p><strong>情况4：避免使用ENUM类型</strong></p><p>修改ENUM值需要使用ALTER语句。</p><p>ENUM类型的ORDER BY 操作效率低，需要额外操作。使用TINYINT来代替ENUM类型。</p><p><strong>情况5：使用TIMESTAMP存储时间</strong></p><p>TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01_19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。</p><p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p><ol><li>非精准浮点： float, double</li><li>精准浮点：decimal</li></ol><p>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</p><p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充 分发挥资源的效率，使系统达到最优。</strong></p><h3 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a>3.5 优化插入记录的速度</h3><p>插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为MyISAM引擎和InnoDB引擎来讲。</p><p><strong>1. MyISAM引擎的表：</strong></p><p><strong>① 禁用索引</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707215305640.png" alt="image-20220707215305640" style="float:left;"><p><strong>② 禁用唯一性检查</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707215356893.png" alt="image-20220707215356893" style="float:left;"><p><strong>③ 使用批量插入</strong></p><p>插入多条记录时，可以使用一条INSERT语句插入一条数据，也可以使用一条INSERT语句插入多条数据。插入一条记录的INSERT语句情形如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into student values(1,&#x27;zhangsan&#x27;,18,1);</span><br><span class="line">insert into student values(2,&#x27;lisi&#x27;,17,1);</span><br><span class="line">insert into student values(3,&#x27;wangwu&#x27;,17,1);</span><br><span class="line">insert into student values(4,&#x27;zhaoliu&#x27;,19,1);</span><br></pre></td></tr></table></figure><p>使用一条INSERT语句插入多条记录的情形如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into student values</span><br><span class="line">(1,&#x27;zhangsan&#x27;,18,1),</span><br><span class="line">(2,&#x27;lisi&#x27;,17,1),</span><br><span class="line">(3,&#x27;wangwu&#x27;,17,1),</span><br><span class="line">(4,&#x27;zhaoliu&#x27;,19,1);</span><br></pre></td></tr></table></figure><p>第2种情形的插入速度要比第1种情形快。</p><p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p><p>当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句块。</p><p><strong>2. InnoDB引擎的表：</strong></p><p><strong>① 禁用唯一性检查</strong></p><p>插入数据之前执行<code>set unique_checks=0</code>来禁止对唯一索引的检查，数据导入完成之后再运行<code>set unique_check=1</code>。这个和MyISAM引擎的使用方法一样。</p><p><strong>② 禁用外键检查</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707220034534.png" alt="image-20220707220034534" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set foreign_key_checks=0;</span><br><span class="line">set foreign_key_checks=1;</span><br></pre></td></tr></table></figure><p><strong>③ 禁止自动提交</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707220131891.png" alt="image-20220707220131891" style="float:left;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line">set autocommit=1;</span><br></pre></td></tr></table></figure><h3 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a>3.6 使用非空约束</h3><p><strong>在设计字段的时候，如果业务允许，建议尽量使用非空约束</strong>。这样做的好处是：</p><p>①进行比较和计算时，省去要对NULL值的字段判断是否为空的开销，提高存储效率。<br>②非空字段也容易创建索引。因为索引NULL列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间（每个字段1个bit)。</p><h3 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a>3.7 分析表、检查表与优化表</h3><p>MySQL提供了分析表、检查表和优化表的语句。<code>分析表</code>主要是<strong>分析关键字的分布</strong>，<code>检查表</code>主要是<strong>检查表是否存在错误</strong>，<code>优化表</code>主要是<strong>消除删除或者更新造成的空间浪费</strong>。</p><h4 id="1-分析表"><a href="#1-分析表" class="headerlink" title="1. 分析表"></a>1. 分析表</h4><p>MySQL中提供了ANALYZE TABLE语句分析表，ANALYZE TABLE语句的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…</span><br></pre></td></tr></table></figure><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。 可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用 <code>ANALYZE TABLE</code> 分析表的过程中，数据库系统会自动对表加一个 <code>只读锁</code> 。在分析期间，只能读取 表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到 <code>cardinality（某一列的基数）</code> 的值，该值统计了表中某一键所在的列不重复 的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。也就是索引列的cardinality的值与表中数据的总条数差距越大，即使查询的时候使用了该索引作为查询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality可以通过 SHOW INDEX FROM 表名查看。</p><blockquote><p><strong>选择基数大（散列度&#x2F;区分度高的列作为索引）</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE user;</span><br><span class="line">+--------------+---------+----------+---------+</span><br><span class="line">| Table        | Op      | Msg_type |Msg_text |</span><br><span class="line">+--------------+---------+----------+---------+</span><br><span class="line">| atguigu.user | analyze | status   | Ok      |</span><br><span class="line">+--------------+----------+---------+---------+</span><br></pre></td></tr></table></figure><p>上面结果显示的信息说明如下：</p><ul><li>Table: 表示分析的表的名称。</li><li>Op: 表示执行的操作。analyze表示进行分析操作。</li><li>Msg_type: 表示信息类型，其值通常是状态 (status) 、信息 (info) 、注意 (note) 、警告 (warning) 和 错误 (error) 之一。</li><li>Msg_text: 显示信息。</li></ul><h4 id="2-检查表"><a href="#2-检查表" class="headerlink" title="2. 检查表"></a>2. 检查表</h4><p>MySQL中可以使用 <code>CHECK TABLE</code> 语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表 是否存在错误。CHECK TABLE语句在执行过程中也会给表加上 <code>只读锁</code> 。</p><p>对于MyISAM类型的表，CHECK TABLE语句还会更新关键字统计数据。而且，CHECK TABLE也可以检查视 图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure><p>其中，tbl_name是表名；option参数有5个取值，分别是QUICK、FAST、MEDIUM、EXTENDED和 CHANGED。各个选项的意义分别是：</p><ul><li>QUICK ：不扫描行，不检查错误的连接。 </li><li>FAST ：只检查没有被正确关闭的表。 </li><li>CHANGED ：只检查上次检查后被更改的表和没有被正确关闭的表。 </li><li>MEDIUM ：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。 </li><li>EXTENDED ：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但 是花的时间较长。</li></ul><p><strong>option只对MyISAM类型的表有效，对InnoDB类型的表无效</strong>。比如：</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707221707254.png" alt="image-20220707221707254"></p><p>该语句对于检查的表可能会产生多行信息。最后一行有一个状态的 Msg_type 值，Msg_text 通常为 OK。 如果得到的不是 OK，通常要对其进行修复；是 OK 说明表已经是最新的了。表已经是最新的，意味着存 储引擎对这张表不必进行检查。</p><h4 id="3-优化表"><a href="#3-优化表" class="headerlink" title="3. 优化表"></a>3. 优化表</h4><p><strong>方式1：OPTIMIZE TABLE</strong></p><p>MySQL中使用 <code>OPTIMIZE TABLE</code> 语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的 <code>VARCHAR</code> 、 <code>BLOB</code> 或 <code>TEXT</code> 类型的字段。一个表使用了这些字段的数据类型，若已经 <code>删除</code> 了表的一大部 分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多 <code>更新</code> ，则 应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的 <code>碎片</code> 。</p><p>OPTIMIZE TABLE 语句<strong>对InnoDB和MyISAM类型的表都有效</strong>。该语句在执行过程中也会给表加上 <code>只读锁</code> 。</p><p>OPTILMIZE TABLE语句的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><p>LOCAL | NO_WRITE_TO_BINLOG关键字的意义和分析表相同，都是指定不写入二进制日志。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707221901664.png" alt="image-20220707221901664"></p><p>执行完毕，Msg_text显示</p><blockquote><p>‘numysql.SYS_APP_USER’, ‘optimize’, ‘note’, ‘Table does not support optimize, doing recreate + analyze instead’</p></blockquote><p>原因是我服务器上的MySQL是InnoDB存储引擎。</p><p>到底优化了没有呢？看官网！</p><p><a>MySQL :: MySQL 8.0 Reference Manual :: 13.7.3.4 OPTIMIZE TABLE Statement](<a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html">https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html</a>)</a></p><blockquote><p>看过官网后发现，InnoDB优化表的模样就是上面那样，与MyISAM的具体区别如下：</p></blockquote><p><code>在MyISAM</code>中，是先分析这张表，然后会整理相关的MySQL datafile，之后回收未使用的空间；<code>在InnoDB中</code>，回收空间是简单通过Alter table进行整理空间。在优化期间，MySQL会创建一个临时表，优化完成之后会删除原始表，然后会将临时表rename成为原始表。</p><blockquote><p>说明： 在多数的设置中，根本不需要运行OPTIMIZE TABLE。即使对可变长度的行进行了大量的更新，也不需要经常运行，<code> 每周一次</code> 或 <code>每月一次</code> 即可，并且只需要对 <code>特定的表</code> 运行。</p></blockquote><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707222156765.png" alt="image-20220707222156765" style="float:left;"><p><strong>方式二：使用mysqlcheck命令</strong></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707222305302.png" alt="image-20220707222305302" style="float:left;"><h4 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h4><p>上述这些方法都是有利有弊的。比如：</p><ul><li>修改数据类型，节省存储空间的同时，你要考虑到数据不能超过取值范围； </li><li>增加冗余字段的时候，不要忘了确保数据一致性； </li><li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li></ul><p>因此，你一定要结合实际的业务需求进行权衡。</p><h2 id="4-大表优化"><a href="#4-大表优化" class="headerlink" title="4. 大表优化"></a>4. 大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><h3 id="4-1-限定查询的范围"><a href="#4-1-限定查询的范围" class="headerlink" title="4.1 限定查询的范围"></a>4.1 限定查询的范围</h3><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p><h3 id="4-2-读-写分离"><a href="#4-2-读-写分离" class="headerlink" title="4.2 读&#x2F;写分离"></a>4.2 读&#x2F;写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><ul><li>一主一从模式：</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707222606097.png" alt="image-20220707222606097"></p><ul><li>双主双从模式：</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707222623485.png" alt="image-20220707222623485"></p><h3 id="4-3-垂直拆分"><a href="#4-3-垂直拆分" class="headerlink" title="4.3 垂直拆分"></a>4.3 垂直拆分</h3><p>当数据量级达到 <code>千万级</code> 以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上， 减少对单一数据库服务器的访问压力。</p><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707222648112.png" alt="image-20220707222648112"></p><ul><li>如果数据库的数据表过多，可以采用<code>垂直分库</code>的方式，将关联的数据库部署在同一个数据库上。</li><li>如果数据库中的列过多，可以采用<code>垂直分表</code>的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放在同一张表里。</li></ul><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707222910740.png" alt="image-20220707222910740"></p><p><code>垂直拆分的优点</code>： 可以使得列数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。 </p><p><code>垂直拆分的缺点</code>： 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p><h3 id="4-4-水平拆分"><a href="#4-4-水平拆分" class="headerlink" title="4.4 水平拆分"></a>4.4 水平拆分</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707222954304.png" alt="image-20220707222954304" style="float:left;"><p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20220707222739120.png" alt="image-20220707222739120"></p><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707223024163.png" alt="image-20220707223024163" style="float:left;"><p>下面补充一下数据库分片的两种常见方案：</p><ul><li><strong>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。 </li><li><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong>我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h2 id="5-其它调优策略"><a href="#5-其它调优策略" class="headerlink" title="5. 其它调优策略"></a>5. 其它调优策略</h2><h3 id="5-1-服务器语句超时处理"><a href="#5-1-服务器语句超时处理" class="headerlink" title="5.1 服务器语句超时处理"></a>5.1 服务器语句超时处理</h3><p>在MySQL 8.0中可以设置 服务器语句超时的限制 ，单位可以达到 毫秒级别 。当中断的执行语句超过设置的 毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报给客户端。</p><p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。默认情况下， MAX_EXECUTION_TIME的值为0，代表没有时间限制。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL MAX_EXECUTION_TIME=2000;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION MAX_EXECUTION_TIME=2000; #指定该会话中SELECT语句的超时时间</span><br></pre></td></tr></table></figure><h3 id="5-2-创建全局通用表空间"><a href="#5-2-创建全局通用表空间" class="headerlink" title="5.2 创建全局通用表空间"></a>5.2 创建全局通用表空间</h3><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707223246684.png" alt="image-20220707223246684" style="float:left;"><img src="https://www.hahhome.top/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/../../image/MySQL(3)索引和调优篇.assets/image-20220707223349879.png" alt="image-20220707223349879" style="float:left;"><h3 id="5-3-MySQL-8-0新特性：隐藏索引对调优的帮助"><a href="#5-3-MySQL-8-0新特性：隐藏索引对调优的帮助" class="headerlink" title="5.3 MySQL 8.0新特性：隐藏索引对调优的帮助"></a>5.3 MySQL 8.0新特性：隐藏索引对调优的帮助</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(2)架构篇</title>
      <link href="/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/"/>
      <url>/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h1><blockquote><p>学习课程：B站搜尚硅谷MySQL康师傅</p><p>author：hah</p></blockquote><h2 id="Linux下MySQL的安装与使用"><a href="#Linux下MySQL的安装与使用" class="headerlink" title="Linux下MySQL的安装与使用"></a>Linux下MySQL的安装与使用</h2><blockquote><p>具体看尚硅谷笔记高级篇《第01章 Linux下MySQL的安装与使用》</p></blockquote><h3 id="Linux版MySQL的安装和卸载"><a href="#Linux版MySQL的安装和卸载" class="headerlink" title="Linux版MySQL的安装和卸载"></a>Linux版MySQL的安装和卸载</h3><blockquote><p>具体看尚硅谷笔记高级篇《第01章 Linux下MySQL的安装与使用》</p></blockquote><p>有需要还可以设置密码的安全设置</p><h3 id="字符集的相关操作"><a href="#字符集的相关操作" class="headerlink" title="字符集的相关操作"></a>字符集的相关操作</h3><ul><li><p>修改MySQL5.7字符集</p><ul><li><p>在MySQL 8.0版本之前，默认字符集为 latin1 ，utf8字符集指向的是 utf8mb3 。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL8.0开始，数据库的默认编码将改为 utf8mb4 ，从而避免上述乱码的问题。</p></li><li><pre><code class="mysql"># 操作1：查看默认使用的字符集show variables like &#39;character%&#39;;# 或者show variables like &#39;%char%&#39;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  # 修改：</span><br><span class="line">  vim /etc/my.cnf</span><br><span class="line">  # 加上</span><br><span class="line">  character_set_server=utf8</span><br><span class="line">  # 重启</span><br><span class="line">  systemctl restart mysqld</span><br></pre></td></tr></table></figure></code></pre></li><li><p>MySQL5.7版本中，以前创建的库，创建的表字符集还是latin1。</p></li><li><p>并且，在以前的库新创建的表也是latin1。</p></li><li><p><font color="red">因为创建表的字符集默认是和数据库一致的</font></p></li></ul></li><li><p>各级别的字符集</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li><li><font color="red">若未设置字符集，则会默认采用它上一层的字符集级别</font></li></ul></li></ul><p><strong>字符集与比较规则</strong></p><p><strong>utf8</strong> <strong>与</strong> <strong>utf8mb4</strong></p><p>utf8 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而字符集表示一个字符所用的最大字节长度，在某些方面会影响系统的存储和性能，所以设计MySQL的设计者偷偷的定义了两个概念：</p><ul><li>utf8mb3 ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。</li><li>utf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。</li></ul><p>一般情况下使用utf8mb3 即可，若要存储emoji表情等，则需要使用utf8mb4 </p><p><strong>比较规则</strong></p><p>上表中，MySQL版本一共支持41种字符集，其中的 Default collation 列表示这种字符集中一种默认的比较规则，里面包含着该比较规则主要作用于哪种语言，比如 utf8_polish_ci 表示以波兰语的规则比较， utf8_spanish_ci 是以西班牙语的规则比较， utf8_general_ci 是一种通用的比较规则。</p><p><strong>常用操作示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#查看GBK字符集的比较规则</span><br><span class="line">SHOW COLLATION LIKE &#x27;gbk%&#x27;;</span><br><span class="line">#查看UTF-8字符集的比较规则</span><br><span class="line">SHOW COLLATION LIKE &#x27;utf8%&#x27;;</span><br><span class="line"></span><br><span class="line">#查看服务器的字符集和比较规则</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%_server&#x27;;</span><br><span class="line">#查看数据库的字符集和比较规则</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%_database&#x27;;</span><br><span class="line">#查看具体数据库的字符集</span><br><span class="line">SHOW CREATE DATABASE dbtest1;</span><br><span class="line">#修改具体数据库的字符集</span><br><span class="line">ALTER DATABASE dbtest1 DEFAULT CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_general_ci&#x27;;</span><br><span class="line"></span><br><span class="line">#查看表的字符集</span><br><span class="line">show create table employees;</span><br><span class="line">#查看表的比较规则</span><br><span class="line">show table status from atguigudb like &#x27;employees&#x27;;</span><br><span class="line">#修改表的字符集和比较规则</span><br><span class="line">ALTER TABLE emp1 DEFAULT CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_general_ci&#x27;;</span><br></pre></td></tr></table></figure><p><strong>请求到响应过程中字符集的变化</strong></p><p>。。。</p><h3 id="SQL大小写规范"><a href="#SQL大小写规范" class="headerlink" title="SQL大小写规范"></a>SQL大小写规范</h3><p>Windows和Linux平台区别</p><p>在 SQL 中，关键字和函数名是不用区分字母大小写的，比如 SELECT、WHERE、ORDER、GROUP BY 等关键字，以及 ABS、MOD、ROUND、MAX 等函数名。不过在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，你可能会遇到不同的大小写问题。 <strong>windows系统默认大小写不敏感 ，但是 linux系统是大小写敏感的</strong> 。</p><p>通过如下命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%lower_case_table_names%&#x27;;</span><br></pre></td></tr></table></figure><p>lower_case_table_names参数值的设置：</p><ul><li>默认为0，大小写敏感 。</li><li>设置1，大小写不敏感。创建的表，数据库都是以小写形式存放在磁盘上，对于sql语句都是转换为小写对表和数据库进行查找。</li><li>设置2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行。</li></ul><p>两个平台上SQL大小写的区别具体来说:</p><blockquote><p>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：</p><p>1、<font color="red">数据库名、表名、表的别名、变量名是严格区分大小写的；</font></p><p>2、关键字、函数名称在 SQL 中不区分大小写；</p><p>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</p><p><strong>MySQL在Windows的环境下全部不区分大小写</strong></p></blockquote><p><strong>Linux</strong>下大小写规则设置</p><p>当想设置为大小写不敏感时，要在 my.cnf 这个配置文件 [mysqld] 中加入lower_case_table_names&#x3D;1 ，然后重启服务器。</p><ul><li>但是要在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则将找不到数据库名。</li><li>SHOW VARIABLES LIKE ‘%lower_case_table_names%’此参数适用于MySQL5.7。在MySQL 8下禁止在重新启动 MySQL 服务时将</li></ul><p>lower_case_table_names 设置成不同于初始化 MySQL 服务时设置的lower_case_table_names 值。如果非要将MySQL8设置为大小写不敏感，具体步骤为：</p><ul><li>1、停止MySQL服务</li><li>2、删除数据目录，即删除 &#x2F;var&#x2F;lib&#x2F;mysql 目录</li><li>3、在MySQL配置文件（ &#x2F;etc&#x2F;my.cnf ）中添加 lower_case_table_names&#x3D;1</li><li>4、启动MySQL服务</li></ul><p><strong>SQL</strong>编写建议</p><p>如果你的变量名命名规范没有统一，就可能产生错误。这里有一个有关命名规范的建议：</p><ul><li>\1. 关键字和函数名称全部大写；</li><li>\2. 数据库名、表名、表别名、字段名、字段别名等全部小写；</li><li>\3. SQL 语句必须以分号结尾。</li></ul><p>数据库名、表名和字段名在 Linux MySQL 环境下是区分大小写的，因此建议你统一这些字段的命名规则，比如全部采用小写的方式。</p><p>虽然关键字和函数名称在 SQL 中不区分大小写，也就是如果小写的话同样可以执行。但是同时将关键词和函数名称全部大写，以便于区分数据库名、表名、字段名。</p><h2 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h2><blockquote><p>具体看尚硅谷笔记高级篇《第02章_MySQL的数据目录》</p></blockquote><h3 id="MySQL8的主要目录结构"><a href="#MySQL8的主要目录结构" class="headerlink" title="MySQL8的主要目录结构"></a>MySQL8的主要目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure><p><strong>1.1</strong> <strong>数据库文件的存放路径</strong> </p><p>mysql下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;datadir&#x27;; # /var/lib/mysql/</span><br></pre></td></tr></table></figure><p><strong>1.2</strong> <strong>相关命令目录</strong></p><p><strong>相关命令目录：&#x2F;usr&#x2F;bin 和&#x2F;usr&#x2F;sbin。</strong></p><p><strong>1.3</strong> <strong>配置文件目录</strong></p><p><strong>配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如my.cnf）</strong></p><h3 id="数据库和表在文件系统中的表示"><a href="#数据库和表在文件系统中的表示" class="headerlink" title="数据库和表在文件系统中的表示"></a>数据库和表在文件系统中的表示</h3><p><strong>数据库在文件系统中的表示</strong></p><p>看一下我的计算机上的数据目录下的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/mysql</span><br><span class="line">ll</span><br></pre></td></tr></table></figure><h4 id="InnoDB存储引擎模式"><a href="#InnoDB存储引擎模式" class="headerlink" title="InnoDB存储引擎模式"></a>InnoDB存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p><p>为了保存表结构，<code>InnoDB</code>在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p><p>先进入某个数据库文件，执行ll，可以看到如下结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MySQL5</span></span><br><span class="line">-rw-r-----. 1 mysql mysql 61 8月 18 11:32 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql 8716 8月 18 11:32 departments.frm#表结构</span><br><span class="line">-rw-r-----. 1 mysql mysql 147456 8月 18 11:32 departments.ibd#表数据</span><br><span class="line">-rw-r-----. 1 mysql mysql 8982 8月 18 11:32 employees.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 180224 8月 18 11:32 employees.ibd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MySQL8</span></span><br><span class="line">-rw-r-----. 1 mysql mysql 163840 7月 29 23:10 departments.ibd</span><br><span class="line">-rw-r-----. 1 mysql mysql 196608 7月 29 23:10 employees.ibd</span><br></pre></td></tr></table></figure><p>可以发现mysql8中只有ibd文件</p><ul><li><p>db.opt文件放到具体的表.ibd文件中了</p></li><li><p>.frm和.ibd文件合并</p></li><li><p>可以使用以下命令查看ibd文件：</p><ul><li><pre><code class="shell">ibd2sdi --dump-file=xxx.txt xxx.ibd<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**2.** **表中数据和索引**</span><br><span class="line"></span><br><span class="line">**① 系统表空间（system tablespace）**</span><br><span class="line"></span><br><span class="line">默认情况下，InnoDB会在数据目录下创建一个名为`ibdata1`、大小为`12M`的`自拓展`文件，这个文件就是对应的`系统表空间`在文件系统上的表示。在**MySQL5.5.7~5.6.6之间会将表数据存储在系统表空间**</span><br><span class="line"></span><br><span class="line">**② 独立表空间(file-per-table tablespace)** </span><br><span class="line"></span><br><span class="line">**在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中**，而是为`每一个表建立一个独立表空间`，也就是说我们创建了多少个表，就有多少个独立表空间。使用`独立表空间`来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>表名.ibd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; &lt;font color=&#x27;red&#x27;&gt;MySQL8.0中不再单独提供`表名.frm`，而是合并在`表名.ibd`文件中。&lt;/font&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**③ 系统表空间与独立表空间的设置**</span><br><span class="line"></span><br><span class="line">我们可以自己指定使用`系统表空间`还是`独立表空间`来存储数据，这个功能由启动参数`innodb_file_per_table`控制</span><br><span class="line"></span><br><span class="line">```ini</span><br><span class="line">[server] </span><br><span class="line">innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></pre></td></tr></table></figure><p><strong>④ 其他类型的表空间</strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><h4 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a>MyISAM存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p><p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sdi</span><br><span class="line">test.MYD 存储数据 (MYData) #.MYD和.MYI两个一起也就是8.0 InnoDB中的.ibd文件</span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<font color="cornflowerblue"><code>数据和索引是分开存放</code></font>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sdi</span><br><span class="line">test.MYD 存储数据 (MYData) </span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>举例： 数据库a ， 表b 。</p><p>1、如果表b采用 <strong>InnoDB</strong> ，data\a中会产生1个或者2个文件：</p><ul><li><strong>b.frm</strong> ：描述表结构文件，字段长度等</li><li>如果采用 <strong>系统表空间</strong> 模式的，数据信息和索引信息都存储在 <strong>ibdata1</strong> 中</li><li>如果采用 <strong>独立表空间</strong> 存储模式，data\a中还会产生 <strong>b.ibd</strong> 文件（存储数据信息和索引信息）</li></ul><p>此外：</p><p>① MySQL5.7 中会在data&#x2F;a的目录下生成 <strong>db.opt</strong> 文件用于保存数据库的相关配置。比如：字符集、比较</p><p>规则。而MySQL8.0不再提供db.opt文件。</p><p>② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。</p><p>2、如果表b采用 <strong>MyISAM</strong> ，data\a中会产生3个文件：</p><ul><li><p>MySQL5.7 中： <strong>b.frm</strong> ：描述表结构文件，字段长度等。</p><p>MySQL8.0 中 <strong>b.xxx.sdi</strong> ：描述表结构文件，字段长度等</p></li><li><p><strong>b.MYD</strong> (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式)</p></li><li><p><strong>b.MYI</strong> (MYIndex)：存放索引信息文件</p></li></ul><p></p><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><h3 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a>1. 逻辑架构剖析</h3><h4 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1.1 服务器处理客户端请求"></a>1.1 服务器处理客户端请求</h4><p>首先MySQL是典型的C&#x2F;S架构，即<code>Clinet/Server 架构</code>，服务端程序使用的<code>mysqld</code>。</p><p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果是：<font color="red"><strong>客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）</strong>。</font></p><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为 例展示：</p><p><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20230816163801104.png" alt="image-20230816163801104"></p><p>下面具体展开如下：</p><p><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E.png" alt="MySQL服务器端的逻辑架构说明"></p><p>接下来分别对上图的五层架构进行说明：</p><h4 id="1-2-Connectors"><a href="#1-2-Connectors" class="headerlink" title="1.2 Connectors"></a>1.2 Connectors</h4><p>Connectors, 指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server <code>建立TCP连接</code>，之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native C API、JDBC、PHP等各语言MySQL Connecotr,或者通过ODBC。但<strong>通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互</strong></p><p><strong>接下来的MySQL Server结构可以分为如下三层：</strong></p><h4 id="1-3-第一层：连接层"><a href="#1-3-第一层：连接层" class="headerlink" title="1.3 第一层：连接层"></a>1.3 第一层：连接层</h4><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p><ul><li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li><li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li></ul><p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>所以<strong>连接管理</strong>的职责是负责认证、管理连接、获取权限信息。</p><h4 id="1-4-第二层：服务层"><a href="#1-4-第二层：服务层" class="headerlink" title="1.4 第二层：服务层"></a>1.4 第二层：服务层</h4><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成<code>缓存的查询</code>，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><p>在该层，服务器会<code>解析查询</code>并创建相应的内部<code>解析树</code>，并对其完成相应的<code>优化</code>：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p>如果是SELECT语句，服务器还会<code>查询内部的缓存</code>。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><ul><li><p>SQL Interface: SQL接口</p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口</li></ul></li><li><p>Parser: 解析器</p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错 误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字 典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还 会对SQl查询进行语法上的优化，进行查询重写。</li></ul></li><li><p>Optimizer: 查询优化器</p><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 执行计划 。</li><li>这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连 接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将 查询结果返回给用户。</li><li>它使用“ 选取-投影-连接 ”策略进行查询。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过 滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 连接 起来生成最终查询结果。</p></li><li><p>Caches &amp; Buffers： 查询缓存组件</p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结 果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在 不同客户端之间共享 。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</li></ul></li></ul><h4 id="1-5-第三层：引擎层"><a href="#1-5-第三层：引擎层" class="headerlink" title="1.5 第三层：引擎层"></a>1.5 第三层：引擎层</h4><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。</p><p>MySQL 8.0.25默认支持的存储引擎如下：</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615140556893.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615140556893.png" alt="image-20220615140556893"></a></p><h4 id="1-6-存储层"><a href="#1-6-存储层" class="headerlink" title="1.6 存储层"></a>1.6 存储层</h4><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统 上，以<code>文件</code>的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p><h4 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h4><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615140710351.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615140710351.png" alt="image-20220615140710351"></a></p><p>简化为三层结构：</p><ol><li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li><li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li><li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li></ol><h3 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2. SQL执行流程"></a>2. SQL执行流程</h3><h4 id="2-1-MySQL中的SQL执行流程"><a href="#2-1-MySQL中的SQL执行流程" class="headerlink" title="2.1 MySQL中的SQL执行流程"></a>2.1 MySQL中的SQL执行流程</h4><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615141934531.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615141934531.png" alt="image-20220615141934531"></a></p><p><strong>MySQL的查询流程：</strong></p><h5 id="1-查询缓存"><a href="#1-查询缓存" class="headerlink" title="1) 查询缓存"></a>1) 查询缓存</h5><ul><li><strong>(1) 查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没 有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。5.7中默认关闭</li></ul><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。<code>之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中</code>。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key,那么这个value就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。<code>执行完成后，执行结果会被存入查询缓存中</code>。所以，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>大多数情况查缓存就是个鸡肋，为什么呢？</strong></p><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL中的<br>查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询 操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同<strong>（例如：空格、注释、大小写）</strong>，都会导致缓存不会命<br>中。因此MySQL的<code>查询缓存命中率不高</code>。</p><blockquote><p>即需要sql语句完全一致才能命中缓存，有一点点区别都不行</p></blockquote><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如mysql、information_schema、performance_schema数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数<code>NOW</code>,每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p><blockquote><p>比如调用某些函数例如NOW()时使那么每次都查询语句都将不一样</p></blockquote><p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p><blockquote><p>当表中数据发生增删改时，可能会出现缓存失效</p></blockquote><p><strong>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁。</strong></p><p><strong>什么时候建议使用查询缓存呢？</strong></p><p>一般建议大家在静态表里使用查询缓存，什么叫<code>静态表</code>呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表，这张表上的查询才适合使用查询缓存。好在MySQL也提供了这种“<code>按需使用</code>”的方式。你可以将 my.cnf 参数 query_cache_type 设置成 DEMAND，代表当 sql 语句中有 SQL_CACHE关键字时才缓存。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># query_cache_type 有3个值。 0代表关闭查询缓存OFF，1代表开启ON，2代表(DEMAND)</span><br><span class="line">query_cache_type=2</span><br></pre></td></tr></table></figure><p>若设置为query_cache_type&#x3D;2：</p><p>这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以供SQL_CACHE显示指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQl_CACHE * FROM test WHERE ID=5;</span><br></pre></td></tr></table></figure><p>SQl_NO_CACHE为不使用</p><p>查看当前 mysql 实例是否开启缓存机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># MySQL5.7中：</span><br><span class="line">show global variables like &quot;%query_cache_type%&quot;;</span><br></pre></td></tr></table></figure><p>监控查询缓存的命中率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;%Qcache%&#x27;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615144537260.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615144537260.png" alt="image-20220615144537260"></a></p><blockquote><p>运行结果解析：</p><p><code>Qcache_free_blocks</code>: 表示查询缓存中海油多少剩余的blocks，如果该值显示较大，则说明查询缓存中的<code>内部碎片</code>过多了，可能在一定的时间进行整理。</p><p><code>Qcache_free_memory</code>: 查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，DBA可以根据实际情况做出调整。</p><p><code>Qcache_hits</code>: 表示有 <code>多少次命中缓存</code>。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</p><p><code>Qcache_inserts</code>: 表示<code>多少次未命中然后插入</code>，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这也正常。</p><p><code>Qcache_lowmem_prunes</code>: 该参数记录有<code>多少条查询因为内存不足而被移除</code>出查询缓存。通过这个值，用户可以适当的调整缓存大小。</p><p><code>Qcache_not_cached</code>: 表示因为query_cache_type的设置而没有被缓存的查询数量。</p><p><code>Qcache_queries_in_cache</code>: 当前缓存中<code>缓存的查询数量</code>。</p><p><code>Qcache_total_blocks</code>: 当前缓存的block数量。</p></blockquote><h5 id="2-解析器"><a href="#2-解析器" class="headerlink" title="2) 解析器"></a>2) 解析器</h5><ul><li><strong>(2) 解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</li></ul><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615142301226.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615142301226.png" alt="image-20220615142301226"></a></p><p><strong>如果没有命中查询缓存，就要开始真正执行语句了</strong>。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。SQL语句的分析分为词法分析与语法分析。</p><p>分析器先做“ <code>词法分析</code> ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“ <code>语法分析</code> ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 <code>满足 MySQL 语法</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select department_id,job_id, avg(salary) from employees group by department_id;</span><br></pre></td></tr></table></figure><p>例如上一句，如果你的语法不对，将会放回错误提醒，</p><p>如果SQL语句正确，则会生成一个这样的语法树：</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615162031427.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615162031427.png" alt="image-20220615162031427"></a></p><p>下图是SQL分词分析的过程步骤:</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615163338495.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615163338495.png" alt="image-20220615163338495"></a></p><p>至此解析器的工作任务也基本圆满了。</p><h5 id="3-优化器"><a href="#3-优化器" class="headerlink" title="3) 优化器"></a>3) 优化器</h5><ul><li><p><strong>(3) 优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据 <code>全表检索</code> ，还是根据 <code>索引检索</code> 等。</p><p>经过解释器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。<strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划</strong>。</p><p>比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><p>举例：如下语句是执行两个表的 join：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test1 join test2 using(ID)</span><br><span class="line">where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方案1：可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27;的记录的 ID 值，再根据 ID 值关联到表 test2，再判</span><br><span class="line">断 test2 里面 name的值是否等于 &#x27;mysql高级课程&#x27;。</span><br><span class="line"></span><br><span class="line">方案2：可以先从表 test2 里面取出 name=&#x27;mysql高级课程&#x27; 的记录的 ID 值，再根据 ID 值关联到 test1，</span><br><span class="line">再判断 test1 里面 name的值是否等于 zhangwei。</span><br><span class="line"></span><br><span class="line">这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化</span><br><span class="line">器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</span><br><span class="line">如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</span><br></pre></td></tr></table></figure><p>在查询优化器中，可以分为 <code>逻辑查询</code> 优化阶段和 <code>物理查询</code> 优化阶段。</p><p>逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行<code>等价变换</code>，对查询进行<code>重写</code>，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p><p>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地<code>使用索引</code>，提升查询效率。</p><h5 id="4-执行器"><a href="#4-执行器" class="headerlink" title="4) 执行器"></a>4) 执行器</h5><ul><li><strong>(4) 执行器</strong>：</li></ul><p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段 。</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615162613806.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615162613806.png" alt="image-20220615162613806"></a></p><p>在执行之前需要判断该用户是否 <code>具备权限</code> 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id=1;</span><br></pre></td></tr></table></figure><p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；</span><br><span class="line">调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</span><br><span class="line">执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p><p>SQL 语句在 MySQL 中的流程是： <code>SQL语句</code>→<code>查询缓存</code>→<code>解析器</code>→<code>优化器</code>→<code>执行器</code> 。</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615164722975.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615164722975.png" alt="image-20220615164722975"></a></p><h4 id="2-2-验证MySQL中SQL执行流程"><a href="#2-2-验证MySQL中SQL执行流程" class="headerlink" title="2.2 验证MySQL中SQL执行流程"></a>2.2 验证MySQL中SQL执行流程</h4><h5 id="1-MySQL8-0中"><a href="#1-MySQL8-0中" class="headerlink" title="1) MySQL8.0中"></a>1) MySQL8.0中</h5><ol><li>确认profiling是否开启</li></ol><p>了解查询语句底层执行的过程：<code>select @profiling</code> 或者 <code>show variables like &#39;%profiling&#39;</code> 查看是否开启计划。开启它可以让MySQL收集在SQL</p><p>执行时所使用的资源情况，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">mysql&gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure><p>profiling&#x3D;0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure><ol start="2"><li>多次执行相同SQL查询</li></ol><p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employees;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看profiles</li></ol><p>查看当前会话所产生的所有 profiles：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles; # 显示最近的几次查询</span><br></pre></td></tr></table></figure><ol start="4"><li>查看profile</li></ol><p>显示执行计划，查看程序的执行步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615172149919.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615172149919.png" alt="image-20220615172149919"></a></p><p>当然你也可以查询指定的 Query ID，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 7;</span><br></pre></td></tr></table></figure><p>查询 SQL 的执行时间结果和上面是一样的。</p><p>此外，还可以查询更丰富的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 6;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615172409967.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615172409967.png" alt="image-20220615172409967"></a></p><p>继续：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 7;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615172438338.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615172438338.png" alt="image-20220615172438338"></a></p><p>1、除了查看cpu、io阻塞等参数情况，还可以查询下列参数的利用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Syntax:</span><br><span class="line">SHOW PROFILE [type [, type] ... ]</span><br><span class="line">[FOR QUERY n]</span><br><span class="line">[LIMIT row_count [OFFSET offset]]</span><br><span class="line"></span><br><span class="line">type: &#123;</span><br><span class="line">| ALL -- 显示所有参数的开销信息</span><br><span class="line">| BLOCK IO -- 显示IO的相关开销</span><br><span class="line">| CONTEXT SWITCHES -- 上下文切换相关开销</span><br><span class="line">| CPU -- 显示CPU相关开销信息</span><br><span class="line">| IPC -- 显示发送和接收相关开销信息</span><br><span class="line">| MEMORY -- 显示内存相关开销信息</span><br><span class="line">| PAGE FAULTS -- 显示页面错误相关开销信息</span><br><span class="line">| SOURCE -- 显示和Source_function,Source_file,Source_line 相关的开销信息</span><br><span class="line">| SWAPS -- 显示交换次数相关的开销信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、发现两次查询当前情况都一致，说明没有缓存。</p><p><code>在 8.0 版本之后，MySQL 不再支持缓存的查询</code>。一旦数据表有更新，缓存都将清空，因此只有数据表是静态的时候，或者数据表很少发生变化时，使用缓存查询才有价值，否则如果数据表经常更新，反而增加了 SQL 的查询时间。</p><h5 id="2-MySQL5-7中"><a href="#2-MySQL5-7中" class="headerlink" title="2) MySQL5.7中"></a>2) MySQL5.7中</h5><p>上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用 缓存吗？这里我们需要 显式开启查询缓存模式 。在MySQL5.7中如下设置：</p><ol><li>配置文件中开启查询缓存</li></ol><p>在 &#x2F;etc&#x2F;my.cnf 中新增一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure><ol start="2"><li>重启mysql服务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><ol start="3"><li>开启查询执行计划</li></ol><p>由于重启过服务，需要重新执行如下指令，开启profiling。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure><ol start="4"><li>执行语句两次：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from locations;</span><br></pre></td></tr></table></figure><ol start="5"><li>查看profiles</li></ol><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615173727345.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615173727345.png" alt="image-20220615173727345"></a></p><ol start="6"><li>查看profile</li></ol><p>显示执行计划，查看程序的执行步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 1;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615173803835.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615173803835.png" alt="image-20220615173803835"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 2;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615173822079.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615173822079.png" alt="image-20220615173822079"></a></p><p>结论不言而喻。执行编号2时，比执行编号1时少了很多信息，从截图中可以看出查询语句直接从缓存中 获取数据。</p><h4 id="2-3-SQL语法顺序"><a href="#2-3-SQL语法顺序" class="headerlink" title="2.3 SQL语法顺序"></a>2.3 SQL语法顺序</h4><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同 而动态调整执行顺序。</p><p><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20230816223305552.png" alt="image-20230816223305552"></p><h3 id="3-数据库缓冲池（buffer-pool）"><a href="#3-数据库缓冲池（buffer-pool）" class="headerlink" title="3. 数据库缓冲池（buffer pool）"></a>3. 数据库缓冲池（buffer pool）</h3><p><code>InnoDB</code> 存储引擎是<strong>以页为单位</strong>来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I&#x2F;O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code> ，<strong>在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。</strong></p><p>这样做的好处是可以让磁盘活动最小化，从而 <code>减少与磁盘直接进行 I/O 的时间 </code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><blockquote><p>MySQL数据页的大小默认是16KB，操作系统的默认大小是4KB</p></blockquote><h4 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a>3.1 缓冲池 vs 查询缓存</h4><p>缓冲池和查询缓存是一个东西吗？不是。</p><h5 id="1-缓冲池（Buffer-Pool）"><a href="#1-缓冲池（Buffer-Pool）" class="headerlink" title="1) 缓冲池（Buffer Pool）"></a>1) 缓冲池（Buffer Pool）</h5><p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。</p><p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615175309751.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615175309751.png" alt="image-20220615175309751"></a></p><p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>缓存池的重要性：</strong></p><p>InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会<code>把完整的页的数据全部加载到内存</code>中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其<code>缓存</code>起来，这样将来有请求再次访问该页面时，就可以<code>省去磁盘IO</code>的开销了。</p><p><strong>缓存原则：</strong></p><p>“ <code>位置 * 频次</code> ”这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p><p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载 </code>。</p><p><strong>缓冲池的预读特性:</strong></p><p>缓冲池的作用就是提升 I&#x2F;O 效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，<code>大概率还会使用它周围的一些数据</code>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘 I&#x2F;O 操作。</p><h5 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2) 查询缓存"></a>2) 查询缓存</h5><p>那么什么是查询缓存呢？</p><p>查询缓存是提前把 查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表 发生变化，查询缓存就会失效，因此命中率低。</p><h4 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a>3.2 缓冲池如何读取数据</h4><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p>缓存在数据库中的结构和作用如下图所示：</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615193131719.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615193131719.png" alt="image-20220615193131719"></a></p><p><strong>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</strong></p><p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会<code>以一定的频率刷新</code>到磁盘中。注意<strong>并不是每次发生更新操作，都会立即进行磁盘回写</strong>。缓冲池会采用一种叫做 <code>checkpoint 的机制</code> 将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p><p>比如，当<code>缓冲池不够用</code>时，需要释放掉一些不常用的页，此时就可以<code>强行采用checkpoint的方式</code>，将不常用的脏页回写到磁盘上，然后再从缓存池中将这些页释放掉。这里的脏页 (dirty page) 指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p><h4 id="3-3-查看-设置缓冲池的大小"><a href="#3-3-查看-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a>3.3 查看&#x2F;设置缓冲池的大小</h4><p>如果你使用的是 MySQL MyISAM 存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为<code>key_buffer_size</code>，你可以用它进行查看。</p><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大小。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615214847480.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615214847480.png" alt="image-20220615214847480"></a></p><p>你能看到此时 InnoDB 的缓冲池大小只有 134217728&#x2F;1024&#x2F;1024&#x3D;128MB。我们可以修改缓冲池大小，比如改为256MB，方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_buffer_pool_size = 268435456;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure><h4 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a>3.4 多个Buffer Pool实例</h4><p>Buffer Poolz本质是InnoDB向操作系统申请的一块<code>连续的内存空间</code>，在多线程环境下，方问Buffer Pool中的数据都需要<code>加锁</code>处理。在Buffer Pool特别大而且<strong>多线程并发访问特别高</strong>的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们<code>拆分成若干个小的Buffer Pool</code>,每个BufferPool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。<strong>所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</strong></p><p>我们可以在服务器启动的时候通过设置innodb_buffer_pool_instances的值来修改Buffer Pool3实例的个数，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure><p>这样就表明我们要创建2个 <code>Buffer Pool</code> 实例。</p><p>我们看下如何查看缓冲池的个数，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_instances&#x27;;</span><br></pre></td></tr></table></figure><p><strong>默认情况下缓冲池的个数为1</strong></p><p>那每个 <code>Buffer Pool</code> 实例实际占多少内存空间呢？其实使用这个公式算出来的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure><p>也就是总共的大小除以实例的个数，结果就是每个 <code>Buffer Pool</code> 实例占用的大小。</p><p>不过也不是说 Buffer Pool 实例创建的越多越好，分别<code>管理各个 Buffer Pool 也是需要性能开销</code>的，InnDB规定：<strong>当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的</strong>，InnoDB会默认把innodb_buffer_pool_instances的值修改为1。而我们鼓励在 Buffer Pool 大于等于 1G 的时候设置多个 Buffer Pool 实例。</p><h4 id="3-5-引申问题"><a href="#3-5-引申问题" class="headerlink" title="3.5 引申问题"></a>3.5 引申问题</h4><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p><p><strong>黑盒下的更新数据流程</strong></p><p>当我们查询数据的时候，会先去 Buffer Pool 中查询。如果 Buffer Pool 中不存在，存储引擎会先将数据从磁盘加载到 Buffer Pool 中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于 Buffer Pool，同样会先数据加载进来，然后修改内存的数据。被修改的数据会在之后统一刷入磁盘。</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615222455867.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615222455867.png" alt="image-20220615222455867"></a></p><p>我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</p><p>答案：<strong>Redo Log</strong> &amp; <strong>Undo Log</strong></p><h2 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h2><ul><li>为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为MySQL server的功能，</li><li>把真实存取数据的功能划分为<code>存储引擎</code>的功能。所以在<code>MySQL server</code>完成了查询优化后，只需按照生成的<code>执行计划</code>调用底层存储引擎提供的API,获取到数据后返回给客户端就好了。</li><li>MySQL中提到了存储引擎的概念。简而言之，<code>存储引擎就是指表的类型</code>。其实存储引擎以前叫做**<code>表处理器</code>**，后来改名为<code>存储引擎</code>，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</li></ul><h3 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a>1. 查看存储引擎</h3><ul><li>查看mysql提供什么存储引擎</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615223831995.png" alt="image-20220615223831995"></p><blockquote><p>只有InnoDB支持事务、分布式事务（XA）、savepoints</p></blockquote><h3 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a>2. 设置系统默认的存储引擎</h3><ul><li>查看默认的存储引擎</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br><span class="line">#或</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615224249491.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220615224249491.png" alt="image-20220615224249491"></a></p><ul><li>修改默认的存储引擎</li></ul><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>或者修改 my.cnf 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default-storage-engine=MyISAM</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure><h3 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a>3. 设置表的存储引擎</h3><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是 说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h4 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a>3.1 创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">建表语句;</span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><h4 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a>3.2 修改表的存储引擎</h4><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><p>比如我们修改一下 engine_demo_table 表的存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE engine_demo_table ENGINE = InnoDB;</span><br></pre></td></tr></table></figure><p>这时我们再查看一下 engine_demo_table 的表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE engine_demo_table\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Table: engine_demo_table</span><br><span class="line">Create Table: CREATE TABLE `engine_demo_table` (</span><br><span class="line">`i` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a>4. 引擎介绍</h3><h4 id="4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><ul><li><p>MySQL从3.23.34a开始就包含InnoDB存储引擎。 <code>大于等于5.5之后，默认采用InnoDB引擎</code> 。</p></li><li><p>InnoDB是MySQL的 <code>默认事务型引擎</code> ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p></li><li><p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 </p></li><li><p><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></p></li><li><p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲）</p><ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li><p>InnoDB是 <code>为处理巨大数据量的最大性能设计</code> 。</p><ul><li><p>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。</p><p>比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</p></li></ul></li><li><p>对比MyISAM的存储引擎， <code>InnoDB写的处理效率差一些</code> ，并且会占用更多的磁盘空间以保存数据和索引。</p></li><li><p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， <code>对内存要求较高</code> ，而且内存大小对性能有决定性的影响。</p></li><li><p><code>支持行锁、事务、外键</code></p></li></ul><h4 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a>4.2 MyISAM 引擎：主要的非事务处理存储引擎</h4><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code> ，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复 </code>。</li><li><code>5.5之前默认的存储引擎</code></li><li>对事务完整性没有要求或者以<code>SELECT、INSERT</code>为主的应用，优势是访问的<code>速度快</code></li><li><strong>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</strong> 数据文件结构：（在《第02章_MySQL数据目录》章节已讲）<ul><li>表名.frm(8.0后.sdi) 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><h4 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a>4.3 Archive 引擎：用于数据存档</h4><ul><li><code>archive</code>是<code>归档</code>的意思，仅仅支持<code>插入</code>和<code>查询</code>两种功能（行插入后不能被修改）。</li><li>在MySQL5.5以后<code>支持索引</code>功能</li><li>拥有很好的压缩机制，使用<code>zlib压缩库</code>，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</li><li>创建ARCHIVE表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为<code>.ARZ</code>。</li><li>根据英文的测试结论来看，同样数据量下，<code>Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</code></li><li>ARCHIVE:存储引擎采用了<code>行级锁</code>。该ARCHIVE引擎支持<code>AUTO_INCREMENT</code>列属性。AUTO_INCREMENT列可以具有唯一索引或非唯一索引。尝试在任何其他列上创建索引会导致错误。</li><li>Archive表<code>适合日志和数据采集（档案）</code>类应用；<strong>适合存储大量的独立的作为历史记录的数据</strong>。拥有<code>很高的插入 速度</code>，但是对查询的支持较差。</li><li><strong>下表展示了ARCHIVE存储号引擎功能</strong></li></ul><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616124743732.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616124743732.png" alt="image-20220616124743732"></a></p><h4 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4><ul><li>Blackhole引擎没有实现任何存储机制，它会<code>丢弃所有插入的数据</code>，不做任何保存。</li><li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到目志。但这种应用方式会碰到很多问题，<strong>因此并不推荐。</strong></li></ul><h4 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><ul><li>CSV引擎可以将<code>普通的CSV文件作为MySQL的表来处理</code>，但不支持索引。</li><li>CSV引擎可以作为一种<code>数据交换的机制</code>，非常有用。</li><li>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者exceli读取。</li><li>对于数据的快速导入、导出是有明显优势的。</li></ul><p>创建CSV表时，服务器会创建一个纯文本数据文件，其名称以表名开头并带有<code>.CSV</code>扩展名。当你将数据存储到表中时，存储引擎将其以逗号分隔值格式保存到数据文件中。</p><p>使用案例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL) ENGINE = CSV;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line">mysql&gt; INSERT INTO test VALUES(1,&#x27;record one&#x27;),(2,&#x27;record two&#x27;);</span><br><span class="line">Query OK, 2 rows affected (0.05 sec)</span><br><span class="line">Records: 2 Duplicates: 0 Warnings: 0</span><br><span class="line">mysql&gt; SELECT * FROM test;</span><br><span class="line">+---+------------+</span><br><span class="line">| i |      c     |</span><br><span class="line">+---+------------+</span><br><span class="line">| 1 | record one |</span><br><span class="line">| 2 | record two |</span><br><span class="line">+---+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>创建CSV表还会创建相应的元文件 ，用于 存储表的状态 和 表中存在的行数 。此文件的名称与表的名称相 同，后缀为 CSM 。如图所示</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616125342599.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616125342599.png" alt="image-20220616125342599"></a></p><p>如果检查 test.CSV 通过执行上述语句创建的数据库目录中的文件，其内容使用Notepad++打开如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;1&quot;,&quot;record one&quot;</span><br><span class="line">&quot;2&quot;,&quot;record two&quot;</span><br></pre></td></tr></table></figure><p>这种格式可以被 Microsoft Excel 等电子表格应用程序读取，甚至写入。使用Microsoft Excel打开如图所示</p><p><a href="https://github.com/codinglin/StudyNotes/blob/main/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616125448555.png"><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616125448555.png" alt="image-20220616125448555"></a></p><h4 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a>4.6 Memory 引擎：置于内存的表</h4><p><strong>概述：</strong></p><p>Memory采用的逻辑介质是<code>内存 ，响应速度很快</code> ，但是当mysqld守护进程崩溃的时候<code>数据会丢失</code> 。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</p><p><strong>主要特征：</strong></p><ul><li><p>Memory同时 <code>支持哈希（HASH）索引</code> 和 <code>B+树索引</code> 。</p><ul><li>哈希索引相等的比较快，但是对于范围的比较慢很多。</li><li><code>默认使用哈希(HASH)索引</code>，其速度要比使用B型树(BTREE)索引快。</li><li>如果希望使用B树索引，可以在创建索引时选择使用。</li></ul></li><li><p>Memory表至少比MyISAM表要<code>快一个数量级</code> 。</p></li><li><p>MEMORY <code>表的大小是受到限制</code> 的。表的大小主要取决于两个参数，分别是 <code>max_rows</code> 和 <code>max_heap_table_size</code> 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默 认为16MB，可以按需要进行扩大。</p></li><li><p>数据文件与索引文件分开存储。</p><ul><li>每个基于MEMORY存储引擎的表实际对应一个磁盘文件，该文件的文件名与表名相同，类型为<code>frm类型</code>，该文件中只存储表的结构，而其<code>数据文件都是存储在内存中的</code>。</li><li>这样有利于数据的快速处理，提供整个表的处理效率。</li></ul></li><li><p>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</p></li></ul><p><strong>使用Memory存储引擎的场景：</strong></p><ol><li><code>目标数据比较小</code> ，而且非常<code>频繁的进行访问</code> ，在内存中存放数据，如果太大的数据会造成<code>内存溢出</code> 。可以通过参数<code> max_heap_table_size</code> 控制Memory表的大小，限制Memory表的最大的大小。</li><li>如果<code>数据是临时的</code> ，而且<code>必须立即可用</code>得到，那么就可以放在内存中。</li><li>存储在Memory表中的数据如果突然间<code>丢失的话也没有太大的关系</code> 。</li></ol><h4 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a>4.7 Federated 引擎：访问远程表</h4><ul><li>Federated引擎是访问其他MySQL服务器的一个 <code>代理</code> ，尽管该引擎看起来提供了一种很好的 <code>跨服务 器的灵活性</code> ，但也经常带来问题，因此 <code>默认是禁用的</code> 。</li></ul><h4 id="4-8-Merge引擎：管理多个MyISAM表构成的表集合"><a href="#4-8-Merge引擎：管理多个MyISAM表构成的表集合" class="headerlink" title="4.8 Merge引擎：管理多个MyISAM表构成的表集合"></a>4.8 Merge引擎：管理多个MyISAM表构成的表集合</h4><h4 id="4-9-NDB引擎：MySQL集群专用存储引擎"><a href="#4-9-NDB引擎：MySQL集群专用存储引擎" class="headerlink" title="4.9 NDB引擎：MySQL集群专用存储引擎"></a>4.9 NDB引擎：MySQL集群专用存储引擎</h4><p>也叫做 NDB Cluster 存储引擎，主要用于 <code>MySQL Cluster 分布式集群</code> 环境，类似于 Oracle 的 RAC 集 群。</p><h4 id="4-10-引擎对比"><a href="#4-10-引擎对比" class="headerlink" title="4.10 引擎对比"></a>4.10 引擎对比</h4><p>MySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。</p><p><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616125928861.png" alt="image-20220616125928861">]</p><p><img src="https://www.hahhome.top/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/../../image/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87.assets/image-20220616125945304.png" alt="image-20220616125945304">]</p><p>其实这些东西大家没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功能。</p><p>其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其中 InnoDB 是 MySQL 默认的存储引擎。</p><h3 id="5-MyISAM和InnoDB对比汇总"><a href="#5-MyISAM和InnoDB对比汇总" class="headerlink" title="5. MyISAM和InnoDB对比汇总"></a>5. MyISAM和InnoDB对比汇总</h3><p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？</p><p>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p><ul><li><strong>首先对于InnoDB存储引擎</strong>，提供了良好的事务管理、崩溃修复能力和并发控制。因为InnoDB存储引擎<code>支持事务</code>，所以对于要求事务完整性的场合需要选择InnoDB,比如数据操作除了插入和查询以外还包，含有很多更新、删除操作，像财务系统等对数据准确性要求较高的系统。缺点是其<code>读写效率稍差</code>，<code>占用的数据空间相对比较大</code>。</li><li><strong>其次对于MyISAM存储引擎</strong>，如果是<code>小型应用</code>，系统以<code>读操作和插入操作为主</code>，只有很少的更新、删除操作，并且对事务的要求没有那么高，则可以选择这个存储引擎，且有先天的<code>count(*)优势</code>。MyISAM存储引擎的优势在于<code>占用空间小</code>，<code>处理速度快</code>；缺点是<code>不支持事务</code>的完整性和并发性。</li></ul><p>这两种引擎各有特点，当然你也可以在MySQL中，针对不同的数据表，可以选择不同的存储引擎。</p><table><thead><tr><th align="left">对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td align="left">外键</td><td>不支持</td><td>支持</td></tr><tr><td align="left">事务</td><td>不支持</td><td>支持</td></tr><tr><td align="left">行表锁</td><td>表锁，及时操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td align="left">缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="left">自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td align="left">关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td align="left">默认安装</td><td>Y</td><td>Y</td></tr><tr><td align="left">默认使用</td><td>N</td><td>Y</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(1)基础篇</title>
      <link href="/blog/MySQL(1)%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/blog/MySQL(1)%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="SQL通用语法及分类"><a href="#SQL通用语法及分类" class="headerlink" title="SQL通用语法及分类"></a>SQL通用语法及分类</h2><p><strong>通用语法：</strong></p><p>在学习具体的SQL语句之前，先来了解一下SQL语言的通用语法。</p><ul><li><p>1). SQL语句可以单行或多行书写，以分号结尾。</p></li><li><p>2). SQL语句可以使用空格&#x2F;缩进来增强语句的可读性。</p></li><li><p>3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p></li><li><p>4). 注释：</p><ul><li><p>单行注释：– 注释内容 或 # 注释内容</p></li><li><p>多行注释：&#x2F;* 注释内容 *&#x2F;</p></li></ul></li></ul><p><strong>分类：</strong></p><ul><li>DDL（Data DefinitionLanguage）: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML（Data ManipulationLanguage）: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL（Data Query Language ）: 数据查询语言，用来查询数据库中表的记录</li><li>DCL（Data Control Language）: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><h2 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>查询所有数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p>查询当前数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure><p>创建数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</span><br></pre></td></tr></table></figure><p>删除数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] 数据库名;</span><br></pre></td></tr></table></figure><p>使用数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>查询当前数据库所有表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>查询表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`DESC 表名;`</span><br></pre></td></tr></table></figure><p>查询指定表的建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型 [COMMENT 字段1注释],</span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释],</span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释],</span><br><span class="line">...</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure><p><strong>最后一个字段后面没有逗号</strong></p><p><strong>修改表结构：</strong></p><p>添加字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：`ALTER TABLE emp ADD nickname varchar(20) COMMENT &#x27;昵称&#x27;;`</span><br></pre></td></tr></table></figure><p>修改数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);`</span><br></pre></td></tr></table></figure><p>修改字段名和字段类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];`</span><br></pre></td></tr></table></figure><p>例：将emp表的nickname字段修改为username，类型为varchar(30)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#x27;昵称&#x27;;</span><br></pre></td></tr></table></figure><p>删除字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure><p>修改表名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名</span><br></pre></td></tr></table></figure><p>删除表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure><p>删除表，并重新创建该表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure><h2 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h2><ul><li>简单查询</li><li>自连接</li><li>内连接</li><li>外连接</li><li>子查询</li></ul><h2 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>指定字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure><p>全部字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure><p>批量添加数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);`</span><br><span class="line">`INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);`</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h3 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h3><p>修改数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE emp SET name = &#x27;Jack&#x27; WHERE id = 1;</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [ WHERE 条件 ];</span><br></pre></td></tr></table></figure><blockquote><p>删除表，并重新创建该表：（类似于删除数据）<br><code>TRUNCATE TABLE 表名;</code></p></blockquote><h2 id="DCL（数据控制语言）"><a href="#DCL（数据控制语言）" class="headerlink" title="DCL（数据控制语言）"></a>DCL（数据控制语言）</h2><p><strong>登录MySQL服务器</strong></p><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure><ul><li><code>DatabaseName参数</code>指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li><li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li></ul><h3 id="增删改用户"><a href="#增删改用户" class="headerlink" title="增删改用户"></a>增删改用户</h3><p><strong>创建用户</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER 用户名 [IDENTIFIED BY &#x27;密码&#x27;][,用户名 [IDENTIFIED BY &#x27;密码&#x27;]];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER zhang3 IDENTIFIED BY &#x27;123123&#x27;; # 默认host是 %</span><br><span class="line">CREATE USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p><strong>修改用户</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user SET USER=&#x27;li4&#x27; WHERE USER=&#x27;wang5&#x27;; </span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>删除用户</strong></p><p><strong>方式1：使用DROP方式删除（推荐）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER user[,user]…;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP USER li4 ; # 默认删除host为%的用户</span><br><span class="line">DROP USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p><strong>方式2：使用DELETE方式删除（不推荐，有残留信息）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><blockquote><p>注意：不推荐通过 DELETE FROM USER u WHERE USER&#x3D;’li4’ 进行删除，系统会有残留信息保留。而<strong>drop user命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表的相应记录都消失了。</strong></p></blockquote><p><strong>设置当前用户密码</strong></p><p><strong>1.</strong> <strong>使用ALTER USER命令来修改当前用户密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER USER() IDENTIFIED BY &#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用SET语句来修改当前用户密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><p><strong>1.6</strong> <strong>修改其它用户密码</strong> </p><p><strong>1.</strong> <strong>使用ALTER语句来修改普通用户的密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER user [IDENTIFIED BY &#x27;新密码&#x27;] </span><br><span class="line">[,user[IDENTIFIED BY &#x27;新密码&#x27;]]…;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用SET命令来修改普通用户的密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p><strong>2.1权限列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show privileges;</span><br></pre></td></tr></table></figure><ul><li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li><li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li><li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li><li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li><li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li><li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li><li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li><li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li></ul><p><strong>2.2</strong> <strong>授予权限的原则</strong></p><p>权限控制主要是出于安全因素，因此需要遵循以下几个<code>经验原则</code>：</p><p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p><p>2、创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</p><p>3、为每个用户<code>设置满足密码复杂度的密码</code>。 </p><p>4、<code>定期清理不需要的用户</code>，回收权限或者删除用户。</p><p><strong>2.3</strong> <strong>授予权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</span><br></pre></td></tr></table></figure><ul><li>该权限如果发现没有该用户，则会直接新建一个用户。</li><li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;</span><br></pre></td></tr></table></figure><ul><li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO joe@&#x27;%&#x27; IDENTIFIED BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p><strong>2.4</strong> <strong>查看权限</strong></p><ul><li>查看当前用户权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS; </span><br><span class="line"># 或 </span><br><span class="line">SHOW GRANTS FOR CURRENT_USER; </span><br><span class="line"># 或 </span><br><span class="line">SHOW GRANTS FOR CURRENT_USER();</span><br></pre></td></tr></table></figure><ul><li>查看某用户的全局权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;主机地址&#x27;;</span><br></pre></td></tr></table></figure><p><strong>2.5</strong> <strong>收回权限</strong></p><p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p><ul><li>收回权限命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#收回全库全表的所有权限 </span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM joe@&#x27;%&#x27;; </span><br><span class="line">#收回mysql库下的所有表的插删改查权限 </span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</span><br></pre></td></tr></table></figure><ul><li>注意：<code>须用户重新登录后才能生效</code></li></ul><h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><p><strong>3.1</strong> <strong>创建角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]...</span><br></pre></td></tr></table></figure><p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%</code>，<code>role_name不可省略</code>，不可为空。</p><p><strong>3.2</strong> <strong>给角色赋予权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br></pre></td></tr></table></figure><p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PRIVILEGES\G</span><br></pre></td></tr></table></figure><p><strong>3.3</strong> <strong>查看角色的权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;role_name&#x27;;</span><br></pre></td></tr></table></figure><p>只要你创建了一个角色，系统就会自动给你一个“<code>USAGE</code>”权限，意思是<code>连接登录数据库的权限</code>。</p><p><strong>3.4</strong> <strong>回收角色的权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE privileges ON tablename FROM &#x27;rolename&#x27;;</span><br></pre></td></tr></table></figure><p><strong>3.5</strong> <strong>删除角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP ROLE role [,role2]...</span><br></pre></td></tr></table></figure><p>注意，<code>如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</code>。</p><p><strong>3.6</strong> <strong>给用户赋予角色</strong></p><p>角色创建并授权后，要赋给用户并处于<code>激活状态</code>才能发挥作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT role [,role2,...] TO user [,user2,...];</span><br></pre></td></tr></table></figure><p>查询当前已激活的角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURRENT_ROLE();</span><br></pre></td></tr></table></figure><p><strong>3.7</strong> <strong>激活角色</strong></p><p><strong>方式1：使用set default role 命令激活角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL activate_all_roles_on_login=ON;</span><br></pre></td></tr></table></figure><p>这条 SQL 语句的意思是，对<code>所有角色永久激活</code>。</p><p><strong>3.8</strong> <strong>撤销用户的角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE role FROM user;</span><br></pre></td></tr></table></figure><p><strong>3.9</strong> <strong>设置强制角色(mandatory role)</strong></p><p>方式1：服务启动前设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">mandatory_roles</span>=<span class="string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span></span><br></pre></td></tr></table></figure><p>方式2：运行时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后仍然有效</span><br><span class="line">SET GLOBAL mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后失效</span><br></pre></td></tr></table></figure><h2 id="其它非表数据库对象"><a href="#其它非表数据库对象" class="headerlink" title="其它非表数据库对象"></a>其它非表数据库对象</h2><h3 id="视图VIEW"><a href="#视图VIEW" class="headerlink" title="视图VIEW"></a>视图VIEW</h3><h4 id="视图的理解"><a href="#视图的理解" class="headerlink" title="视图的理解"></a>视图的理解</h4><p>视图的理解</p><ul><li>视图，可以看做是一个虚拟似表，本身是不存储数据的。<ul><li>视图的本质，就可以看做是存储起来的SE工ECT语句</li></ul></li><li>视图中SELECT语句中涉及到的表，称为基表</li><li>针对视图做DML操作，会影响到对应的基表中的数据。反之亦然。</li><li>视图本身的删除，不会导致基表中数据的删除。</li><li>视图的应用场景：针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图。</li><li>视图的优点：简化查询；控制数据的访问权限。</li></ul><h4 id="视图的优缺点"><a href="#视图的优缺点" class="headerlink" title="视图的优缺点"></a>视图的优缺点</h4><p><strong>优点</strong></p><p><strong>1.</strong> <strong>操作简单</strong></p><p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p><p><strong>2.</strong> <strong>减少数据冗余</strong></p><p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p><p><strong>3.</strong> <strong>数据安全</strong></p><p>MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，<strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。</p><p><strong>4.</strong> <strong>适应灵活多变的需求</strong> </p><p>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p><p><strong>5.</strong> <strong>能够分解复杂的查询逻辑</strong> </p><p>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p><p><strong>缺点</strong></p><p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><ul><li><strong>在</strong> <strong>CREATE VIEW</strong> <strong>语句中嵌入子查询</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] </span><br><span class="line">VIEW 视图名称 [(字段列表)]</span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED|LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><ul><li>精简版</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW 视图名称 </span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure><ul><li><strong>创建单表视图</strong></li></ul><p>举例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, last_name, salary</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 80;</span><br></pre></td></tr></table></figure><p>查询视图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROMsalvu80;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW emp_year_salary (ename,year_salary)</span><br><span class="line">AS </span><br><span class="line">SELECT ename,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM t_employee;</span><br></pre></td></tr></table></figure><blockquote><p>说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。</p><p>说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p></blockquote><ul><li><strong>创建多表联合视图</strong></li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empview </span><br><span class="line">AS </span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW emp_dept</span><br><span class="line">AS </span><br><span class="line">SELECT ename,dname</span><br><span class="line">FROM t_employee LEFT JOIN t_department</span><br><span class="line">ON t_employee.did = t_department.did;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEWdept_sum_vu</span><br><span class="line">(name, minsal, maxsal, avgsal)</span><br><span class="line">AS </span><br><span class="line">SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)</span><br><span class="line">FROM employees e, departments d</span><br><span class="line">WHERE e.department_id = d.department_id </span><br><span class="line">GROUP BY  d.department_name;</span><br></pre></td></tr></table></figure><ul><li><strong>利用视图对数据进行格式化</strong></li></ul><p>我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br></pre></td></tr></table></figure><ul><li><strong>基于视图创建视图</strong></li></ul><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p><p>举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW emp_dept_ysalary</span><br><span class="line">AS </span><br><span class="line">SELECT emp_dept.ename,dname,year_salary</span><br><span class="line">FROM emp_dept INNER JOIN emp_year_salary</span><br><span class="line">ON emp_dept.ename = emp_year_salary.ename;</span><br></pre></td></tr></table></figure><h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><p>语法1：查看数据库的表对象、视图对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>语法2：查看视图的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC/ DESCRIBE 视图名称;</span><br></pre></td></tr></table></figure><p>语法3：查看视图的属性信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line">SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G</span><br></pre></td></tr></table></figure><p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p><p>语法4：查看视图的详细定义信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure><h4 id="更新视图的数据"><a href="#更新视图的数据" class="headerlink" title="更新视图的数据"></a>更新视图的数据</h4><ul><li><strong>一般情况</strong></li></ul><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><p>举例：UPDATE操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename   | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789098765 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE emp_tel SET tel = &#x27;13789091234&#x27; WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename  | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename   | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例：DELETE操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename  | tel           |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM emp_tel  WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>不可更新的视图</strong></p></li><li><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<code>一对一</code>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li><p>在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作；</p></li><li><p>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</p></li><li><p>在定义视图的SELECT语句中使用了<code>JOIN联合查询</code>，视图将不支持INSERT和DELETE操作；</p></li><li><p>在定义视图的SELECT语句后的字段列表中使用了<code>数学表达式</code>或<code>子查询</code>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</p></li><li><p>在定义视图的SELECT语句后的字段列表中使用<code>DISTINCT</code>、<code>聚合函数</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>等，视图将不支持INSERT、UPDATE、DELETE；</p></li><li><p>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</p></li><li><p>视图定义基于一个<code>不可更新视图</code>；</p></li><li><p>常量视图。</p></li></ul></li><li><p><font color="red">即：基表和视图的字段不存在一一对应的关系时，都不可以执行添加、更新和删除等操作</font></p></li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE OR REPLACE VIEW emp_dept</span><br><span class="line">    -&gt; (ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">    -&gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname</span><br><span class="line">    -&gt; FROM t_employee INNER JOIN t_department</span><br><span class="line">    -&gt; ON t_employee.did = t_department.did ;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">    -&gt; VALUES(&#x27;张三&#x27;,15000,&#x27;1995-01-08&#x27;,&#x27;18201587896&#x27;,</span><br><span class="line">    -&gt; &#x27;zs@atguigu.com&#x27;,&#x27;2022-02-14&#x27;,&#x27;新部门&#x27;);</span><br><span class="line">    </span><br><span class="line">#ERROR 1393 (HY000): Can not modify more than one base table through a join view &#x27;atguigu_chapter9.emp_dept&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了<strong>JOIN联合查询</strong>，视图将不支持更新操作。</p><blockquote><p>虽然可以更新视图数据，但总的来说，视图作为<code>虚拟表</code>，主要用于<code>方便查询</code>，不建议更新视图的数据。<strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p></blockquote><h4 id="修改、删除视图"><a href="#修改、删除视图" class="headerlink" title="修改、删除视图"></a>修改、删除视图</h4><p><strong>修改视图</strong></p><p>方式1：使用CREATE <strong>OR REPLACE</strong> VIEW 子句<strong>修改视图</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW empvu80</span><br><span class="line">(id_number, name, sal, department_id)</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, first_name || &#x27; &#x27; || last_name, salary, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br></pre></td></tr></table></figure><blockquote><p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p></blockquote><p>方式2：ALTER VIEW</p><p>修改视图的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER VIEW 视图名称 </span><br><span class="line">AS</span><br><span class="line">新的查询语句</span><br></pre></td></tr></table></figure><p><strong>删除视图</strong></p><ul><li><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p></li><li><p>删除视图的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;</span><br></pre></td></tr></table></figure></li><li><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW empvu80;</span><br></pre></td></tr></table></figure></li><li><p>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。</p><ul><li>分为全局变量（GLOBAL）、</li><li>会话变量（SESSION）。</li></ul><p>1). 查看系统变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量</span><br><span class="line">SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#x27;......&#x27;; -- 可以通过LIKE模糊匹配方式查找变量</span><br><span class="line">SELECT @@[SESSION | GLOBAL].系统变量名; -- 查看指定变量的值</span><br></pre></td></tr></table></figure><p>2). 设置系统变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;</span><br><span class="line">SET @@[SESSION | GLOBAL].系统变量名 = 值  ;</span><br></pre></td></tr></table></figure><blockquote><p>注意:</p><p>如果没有指定SESSION&#x2F;GLOBAL，默认是SESSION，会话变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。</span><br></pre></td></tr></table></figure><p>A. 全局变量(GLOBAL): 全局变量针对于所有的会话。</p><p>B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p></blockquote><p><strong>演示示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 查看系统变量</span><br><span class="line">show session variables ;</span><br><span class="line"></span><br><span class="line">show session variables like &#x27;auto%&#x27;;</span><br><span class="line">show global variables like &#x27;auto%&#x27;;</span><br><span class="line"></span><br><span class="line">select @@global.autocommit;</span><br><span class="line">select @@session.autocommit;</span><br><span class="line"></span><br><span class="line">-- 设置系统变量</span><br><span class="line">set session autocommit = 1;</span><br><span class="line"></span><br><span class="line">set global autocommit = 0;</span><br><span class="line"></span><br><span class="line">select @@global.autocommit;</span><br></pre></td></tr></table></figure><h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。</p><p>1). 赋值</p><p>方式一:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @var_name = expr [, @var_name = expr] ... ;</span><br><span class="line">SET @var_name := expr [, @var_name := expr] ... ;</span><br></pre></td></tr></table></figure><p>赋值时，可以使用 &#x3D; ，也可以使用 :&#x3D; （推荐）。</p><p>方式二:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @var_name := expr [, @var_name := expr] ... ;</span><br><span class="line">SELECT 字段名 INTO @var_name FROM 表名;</span><br></pre></td></tr></table></figure><p>2). 使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @var_name;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p></blockquote><p><strong>演示示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 赋值</span><br><span class="line">set @myname = &#x27;itcast&#x27;;</span><br><span class="line">set @myage := 10;</span><br><span class="line">set @mygender := &#x27;男&#x27;,@myhobby := &#x27;java&#x27;;</span><br><span class="line"></span><br><span class="line">select @mycolor := &#x27;red&#x27;;</span><br><span class="line">select count(*) into @mycount from tb_user;</span><br><span class="line"></span><br><span class="line">-- 使用</span><br><span class="line">select @myname,@myage,@mygender,@myhobby;</span><br><span class="line">select @mycolor , @mycount;</span><br><span class="line">select @abc;</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块。</p><p>1). 声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 变量名 变量类型 [DEFAULT ... ] ;</span><br></pre></td></tr></table></figure><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><p>2). 赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 变量名 = 值 ;</span><br><span class="line">SET 变量名 := 值 ;</span><br><span class="line">SELECT 字段名 INTO 变量名 FROM 表名 ... ;</span><br></pre></td></tr></table></figure><p><strong>演示示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 声明局部变量 - declare</span><br><span class="line">-- 赋值</span><br><span class="line">create procedure p2()</span><br><span class="line">begin</span><br><span class="line">    declare stu_count int default 0;</span><br><span class="line">    </span><br><span class="line">    select count(*) into stu_count from student;</span><br><span class="line">    select stu_count;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p2();</span><br></pre></td></tr></table></figure><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>上面的局部变量等只能接收标量，</p><p>而游标可以接收多个数据的值</p><p>游标（CURSOR）是用来存储<strong>查询结果集</strong>的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><ul><li><p>声明游标</p><ul><li><pre><code class="mysql">DECLARE 游标名称 CURSOR FOR 查询语句 ;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 打开游标</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    OPEN 游标名称 ;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>获取游标记录</p><ul><li><pre><code class="mysql">FETCH 游标名称 INTO 变量 [, 变量 ] ;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关闭游标</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    CLOSE 游标名称 ;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>案例</strong></p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- 逻辑:</span><br><span class="line">-- A. 声明游标, 存储查询结果集</span><br><span class="line">-- B. 准备: 创建表结构</span><br><span class="line">-- C. 开启游标</span><br><span class="line">-- D. 获取游标中的记录</span><br><span class="line">-- E. 插入数据到新表中</span><br><span class="line">-- F. 关闭游标</span><br><span class="line"></span><br><span class="line">create procedure p11(in uage int)</span><br><span class="line">begin</span><br><span class="line">    declare uname varchar(100);</span><br><span class="line">    declare upro varchar(100);</span><br><span class="line">    declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;</span><br><span class="line">    </span><br><span class="line">    drop table if exists tb_user_pro;</span><br><span class="line">    create table if not exists tb_user_pro(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(100),</span><br><span class="line">        profession varchar(100)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    open u_cursor;</span><br><span class="line">        while true do</span><br><span class="line">            fetch u_cursor into uname,upro;</span><br><span class="line">            insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">        end while;</span><br><span class="line">    close u_cursor;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p11(30);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行</span><br><span class="line">但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构</span><br><span class="line">中的数据。</span><br></pre></td></tr></table></figure><p>上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。</p><p>要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决</p><h4 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h4><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;</span><br></pre></td></tr></table></figure><blockquote><ul><li>handler_action 的取值：</li><li>CONTINUE: 继续执行当前程序</li><li>EXIT: 终止执行当前程序</li><li>condition_value 的取值：</li><li>SQLSTATE sqlstate_value: 状态码，如 02000</li><li>SQLWARNING: 所有以01开头的SQLSTATE代码的简写</li><li>NOT FOUND: 所有以02开头的SQLSTATE代码的简写</li><li>SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</li><li>statement的取值：</li><li>为具体操作的时候执行这个条件处理程序</li><li>eg：close u_cursor（关闭某个游标时）</li></ul></blockquote><p> <strong>案例</strong></p><p>我们继续来完成在上一小节提出的这个需求，并解决其中的问题。</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>A. 通过 <strong>SQLSTATE</strong> 指定<strong>具体的</strong>状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 逻辑:</span><br><span class="line">-- A. 声明游标, 存储查询结果集</span><br><span class="line">-- B. 准备: 创建表结构</span><br><span class="line">-- C. 开启游标</span><br><span class="line">-- D. 获取游标中的记录</span><br><span class="line">-- E. 插入数据到新表中</span><br><span class="line">-- F. 关闭游标</span><br><span class="line">create procedure p11(in uage int)</span><br><span class="line">begin</span><br><span class="line">    declare uname varchar(100);</span><br><span class="line">    declare upro varchar(100);</span><br><span class="line">    declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;</span><br><span class="line">    </span><br><span class="line">    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出</span><br><span class="line">    declare exit handler for SQLSTATE &#x27;02000&#x27; close u_cursor;</span><br><span class="line">    </span><br><span class="line">    drop table if exists tb_user_pro;</span><br><span class="line">    create table if not exists tb_user_pro(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(100),</span><br><span class="line">        profession varchar(100)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    open u_cursor;</span><br><span class="line">        while true do</span><br><span class="line">            fetch u_cursor into uname,upro;</span><br><span class="line">            insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">        end while;</span><br><span class="line">    close u_cursor;#自动执行条件处理程序</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p11(30);</span><br></pre></td></tr></table></figure><p>B. 通过SQLSTATE的代码简写方式 NOT FOUND</p><p>02 开头的状态码，代码简写为 NOT FOUND</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">create procedure p12(in uage int)</span><br><span class="line">begin</span><br><span class="line">    declare uname varchar(100);</span><br><span class="line">    declare upro varchar(100);</span><br><span class="line">    declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;</span><br><span class="line">    </span><br><span class="line">    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出</span><br><span class="line">    declare exit handler for not found close u_cursor;#  NOT FOUND</span><br><span class="line">    </span><br><span class="line">    drop table if exists tb_user_pro;</span><br><span class="line">    create table if not exists tb_user_pro(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(100),</span><br><span class="line">        profession varchar(100)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    open u_cursor;</span><br><span class="line">        while true do</span><br><span class="line">            fetch u_cursor into uname,upro;</span><br><span class="line">            insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">        end while;</span><br><span class="line">    close u_cursor;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p12(30);</span><br></pre></td></tr></table></figure><h3 id="存储过程PROCEDURE"><a href="#存储过程PROCEDURE" class="headerlink" title="存储过程PROCEDURE"></a>存储过程PROCEDURE</h3><h4 id="理解和优缺点"><a href="#理解和优缺点" class="headerlink" title="理解和优缺点"></a>理解和优缺点</h4><p><strong>含义</strong>：存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过 预先编译 的 SQL 语句的封装。</p><p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p><p><strong>好处</strong>：</p><p>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力</p><p>2、减少操作过程中的失误，提高效率</p><p>3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） </p><p>4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</p><p><strong>和视图、函数的对比</strong>：</p><p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 虚拟表 ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是 没有返回值 的。</p><ul><li><strong>优点</strong><ul><li><strong>存储过程可以一次编译多次使用</strong></li><li><strong>可以减少开发工作量</strong></li><li><strong>存储过程的安全性强。</strong></li><li><strong>可以减少网络传输量</strong></li><li><strong>良好的封装性</strong></li></ul></li><li><strong>缺点</strong><ul><li><strong>可移植性差。</strong></li><li><strong>调试困难。</strong></li><li><strong>存储过程的版本管理很困难。</strong></li><li><strong>它不适合高并发的场景</strong></li></ul></li></ul><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li><p><font color="cornflowerblue">创建</font></p><ul><li><pre><code class="mysql">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN    存储过程体END<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</span><br><span class="line"></span><br><span class="line">  - IN ：当前参数为输入参数，也就是表示入参；</span><br><span class="line">    - 存储过程只是读取这个参数的值。如果没有定义参数种类， &lt;font color=&#x27;cornflowerblue&#x27;&gt;默认就是 IN &lt;/font&gt;，表示输入参数。</span><br><span class="line">  - OUT ：当前参数为输出参数，也就是表示出参；</span><br><span class="line">    - 执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</span><br><span class="line">  - INOUT ：当前参数既可以为输入参数，也可以为输出参数。</span><br><span class="line"></span><br><span class="line">- **注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。**</span><br><span class="line"></span><br><span class="line">- &gt; characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;```mysql</span><br><span class="line">  &gt;LANGUAGE SQL</span><br><span class="line">  &gt;| [NOT] DETERMINISTIC</span><br><span class="line">  &gt;| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">  &gt;| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line">  &gt;| COMMENT &#x27;string</span><br></pre></td></tr></table></figure>&gt;&gt;- `LANGUAGE SQL` ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。&gt;- `[NOT] DETERMINISTIC `：指明存储过程执行的结果是否确定。&gt;  - DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。&gt;  - NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。&gt;  - 如果没有指定任意一个值，默认为NOT DETERMINISTIC。&gt;- `&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; `：指明子程序使用SQL语句的限制。&gt;  - CONTAINS SQL：表示子程序包含SQL语句，但不包含读或写数据的语句。&gt;  - NO SQL：表示子程序中不包含SQL语句&gt;  - READS SQL DATA：表示子程序中包含读数据的语句。&gt;  - MODIFIES SQL DATA：表示子程序中包含写数据的语句。&gt;  - 默认情况下，系统会指定为CONTAINS SQL&gt;- `SQL SECURITY &#123; DEFINER | INVOKER &#125; `：指明谁有权限来执行。&gt;  - `DEFINER` ：表示只有定义者自己才能够执行。&gt;  - `INVOKER` 表示权限的调用者可以执行&gt;  - 如果没有设置相关的值，则MySQL默认指定值为DEFINER。&gt;- `COMMENT &#39;string&#39;` ：表示注释信息。</code></pre></li><li><p>举例</p><ul><li><pre><code class="mysql">create procedure p1()begin    declare student_count int    select count(*) into student_count from student;        select student_count;end;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  # 命令行中：</span><br><span class="line">  DELIMITER $</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE select_all_data()</span><br><span class="line">  BEGIN</span><br><span class="line">  SELECT * FROM emps;</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  DELIMITER ;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p><font color="cornflowerblue">调用</font></p><ul><li><pre><code class="mysql">CALL 存储过程名(实参列表)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 1、调用in模式的参数：</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    CALL sp1(&#x27;值&#x27;);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>2、调用out模式的参数：</p><ul><li><pre><code class="mysql">SET @name;CALL sp1(@name);SELECT @name;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 3、调用inout模式的参数：</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    SET @name=值;</span><br><span class="line">    CALL sp1(@name);</span><br><span class="line">    SELECT @name;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><pre><code class="mysql"># 举例：DELIMITER //CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)BEGIN    SELECT COUNT(*) INTO num FROM fruitsWHERE s_id = sid;END //DELIMITER ;# 调用存储过程：mysql&gt; CALL CountProc (101, @num);Query OK, 1 row affected (0.00 sec)# 查看返回结果：mysql&gt; SELECT @num;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- &lt;font color=&#x27;cornflowerblue&#x27;&gt;查看&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">  - **使用SHOW CREATE语句查看存储过程和函数的创建信息**</span><br><span class="line"></span><br><span class="line">    - ```mysql</span><br><span class="line">      SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名（未指定数据库默认为本数据库）</span><br><span class="line">      </span><br><span class="line">      # 举例：</span><br><span class="line">      SHOW CREATE PROCEDURE test_db.CountProc \G</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>2.</strong> <strong>使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></p><ul><li><pre><code class="mysql">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#39;pattern&#39;] \G<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **3.** **从information_schema.Routines表中查看存储过程和函数的信息**</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    SELECT * FROM information_schema.Routines</span><br><span class="line">    WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];</span><br><span class="line">    </span><br><span class="line">    # 举例：</span><br><span class="line">    SELECT * FROM information_schema.Routines</span><br><span class="line">    WHERE ROUTINE_NAME=&#x27;count_by_id&#x27; AND ROUTINE_TYPE = &#x27;FUNCTION&#x27; \G</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p><font color="cornflowerblue">修改</font></p><ul><li><p>修改存储过程或函数，<strong>不能修改存储过程体</strong>或函数功能，<strong>只是修改相关特性</strong>。使用ALTER语句实现。</p></li><li><pre><code class="mysql">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...]# 举例：ALTER PROCEDURE CountProcMODIFIES SQL DATASQL SECURITY INVOKER ;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- &lt;font color=&#x27;cornflowerblue&#x27;&gt;删除&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="存储函数FUNCTION"><a href="#存储函数FUNCTION" class="headerlink" title="存储函数FUNCTION"></a>存储函数FUNCTION</h3><p>存储函数是有返回值的存储过程，存储函数的参数<strong>只能是IN类型的</strong>。具体语法如下：</p><p>学过的函数：LENGTH、SUBSTR、CONCAT等</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...)</span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">函数体 #函数体中肯定有 RETURN 语句</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li>FUNCTION中参数只能是IN类型的。</li><li>RETURNS type 语句表示函数返回数据的类型；<ul><li>RETURNS子句只能对FUNCTION做指定，对函数而言这是 强制 的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。</li></ul></li><li>characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</li><li>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</li></ul><p><strong>调用存储函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数名(实参列表)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create function fun1([IN] n int)</span><br><span class="line">returns int </span><br><span class="line">deterministic</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    while n&gt;0 do</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end while;</span><br><span class="line">    return total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">select fun1(50);</span><br></pre></td></tr></table></figure><h3 id="控制过程"><a href="#控制过程" class="headerlink" title="控制过程"></a>控制过程</h3><h4 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h4><p>if 用于做条件判断，具体的语法结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF 条件1 THEN</span><br><span class="line">.....</span><br><span class="line">ELSEIF 条件2 THEN -- 可选</span><br><span class="line">.....</span><br><span class="line">ELSE  -- 可选</span><br><span class="line">.....</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p><p><strong>案例</strong></p><p>根据定义的分数score变量，判定当前分数对应的分数等级。</p><ul><li>score &gt;&#x3D; 85分，等级为优秀。</li><li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create procedure p3(in score int, out result varchar(10))</span><br><span class="line">begin</span><br><span class="line">    </span><br><span class="line">    if score &gt;= 85 then</span><br><span class="line">    set result := &#x27;优秀&#x27;;</span><br><span class="line">    elseif score &gt;= 60 then</span><br><span class="line">    set result := &#x27;及格&#x27;;</span><br><span class="line">    else</span><br><span class="line">    set result := &#x27;不及格&#x27;;</span><br><span class="line">    end if;</span><br><span class="line">    </span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p3(18, @result);</span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure><h4 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h4><p>case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：</p><p>语法1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list</span><br><span class="line">CASE case_value</span><br><span class="line">    WHEN when_value1 THEN statement_list1</span><br><span class="line">    [ WHEN when_value2 THEN statement_list2] ...</span><br><span class="line">    [ ELSE statement_list ]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><p>语法2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list</span><br><span class="line">CASE</span><br><span class="line">    WHEN search_condition1 THEN statement_list1</span><br><span class="line">    [WHEN search_condition2 THEN statement_list2] ...</span><br><span class="line">    [ELSE statement_list]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p>根据传入的月份，判定月份所属的季节（要求采用case结构）。</p><ul><li>1-3月份，为第一季度</li><li>4-6月份，为第二季度</li><li>7-9月份，为第三季度</li><li>10-12月份，为第四季度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">create procedure p6(in month int)</span><br><span class="line">begin</span><br><span class="line">    declare result varchar(10);</span><br><span class="line">    case</span><br><span class="line">        when month &gt;= 1 and month &lt;= 3 then</span><br><span class="line">        set result := &#x27;第一季度&#x27;;</span><br><span class="line">        when month &gt;= 4 and month &lt;= 6 then</span><br><span class="line">        set result := &#x27;第二季度&#x27;;</span><br><span class="line">        when month &gt;= 7 and month &lt;= 9 then</span><br><span class="line">        set result := &#x27;第三季度&#x27;;</span><br><span class="line">        when month &gt;= 10 and month &lt;= 12 then</span><br><span class="line">        set result := &#x27;第四季度&#x27;;</span><br><span class="line">        else</span><br><span class="line">        set result := &#x27;非法参数&#x27;;</span><br><span class="line">    end case ;</span><br><span class="line">    </span><br><span class="line">    select concat(&#x27;您输入的月份为: &#x27;,month, &#x27;, 所属的季度为: &#x27;,result);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p6(16);</span><br></pre></td></tr></table></figure><h4 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h4><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><br><span class="line">WHILE 条件 DO</span><br><span class="line">    SQL逻辑...</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure><p> <strong>案例</strong></p><p>计算从1累加到n的值，n为传入的参数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</span><br><span class="line">create procedure p7(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    </span><br><span class="line">    while n&gt;0 do</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end while;</span><br><span class="line">    </span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p7(100);</span><br></pre></td></tr></table></figure><h4 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h4><p>repeat是有条件的循环控制语句, 当<strong>满足until声明的条件的时候，则退出循环</strong> 。具体语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line">    SQL逻辑...</span><br><span class="line">    UNTIL 条件</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure><p> <strong>案例</strong></p><p>计算从1累加到n的值，n为传入的参数值。(使用repeat实现)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</span><br><span class="line">create procedure p8(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    </span><br><span class="line">    repeat</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">        until n &lt;= 0</span><br><span class="line">    end repeat;</span><br><span class="line">    </span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p8(10);</span><br><span class="line">call p8(100);</span><br></pre></td></tr></table></figure><h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</p><p>LOOP可以配合一下两个语句使用：</p><ul><li>LEAVE ：配合循环使用，退出循环。</li><li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">SQL逻辑...</span><br><span class="line">END LOOP [end_label];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LEAVE label; -- 退出指定标记的循环体</span><br><span class="line">ITERATE label; -- 直接进入下一次循环</span><br></pre></td></tr></table></figure><p>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</p><p><strong>案例一</strong></p><p>计算从1累加到n的值，n为传入的参数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span><br><span class="line">create procedure p9(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    </span><br><span class="line">    sum:loop</span><br><span class="line">    </span><br><span class="line">        if n&lt;=0 then</span><br><span class="line">        leave sum;</span><br><span class="line">        end if;</span><br><span class="line">        </span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end loop sum;</span><br><span class="line">    </span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p9(100);</span><br></pre></td></tr></table></figure><p> <strong>案例二</strong></p><p>计算从1到n之间的偶数累加的值，n为传入的参数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span><br><span class="line">-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xx</span><br><span class="line">create procedure p10(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    </span><br><span class="line">    sum:loop</span><br><span class="line">        if n&lt;=0 then</span><br><span class="line">        leave sum;</span><br><span class="line">        end if;</span><br><span class="line">        </span><br><span class="line">        if n%2 = 1 then</span><br><span class="line">            set n := n - 1;</span><br><span class="line">            iterate sum;</span><br><span class="line">        end if;</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end loop sum;</span><br><span class="line">    </span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用：</span><br><span class="line">call p10(100);</span><br></pre></td></tr></table></figure><h3 id="触发器TRIGGER"><a href="#触发器TRIGGER" class="headerlink" title="触发器TRIGGER"></a>触发器TRIGGER</h3><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。</p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><p>触发器类型：</p><ul><li>INSERT 型触发器 <ul><li>NEW 表示将要或者已经新增的数据</li></ul></li><li>UPDATE 型触发器 <ul><li>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</li></ul></li><li>DELETE 型触发器 <ul><li>OLD 表示将要或者已经删除的数据</li></ul></li></ul><p><strong>语法</strong></p><p>1). 创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br><span class="line">BEFORE/AFTER INSERT/UPDATE/DELETE</span><br><span class="line">ON tbl_name FOR EACH ROW -- 行级触发器</span><br><span class="line">BEGIN</span><br><span class="line">trigger_stmt ;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>2). 查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS ;</span><br></pre></td></tr></table></figure><p>3). 删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加,</p><p>修改 , 删除 ;</p><p>表结构准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 准备工作 : 日志表 user_logs</span><br><span class="line">create table user_logs(</span><br><span class="line">    id int(11) not null auto_increment,</span><br><span class="line">    operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;,</span><br><span class="line">    operate_time datetime not null comment &#x27;操作时间&#x27;,</span><br><span class="line">    operate_id int(11) not null comment &#x27;操作的ID&#x27;,</span><br><span class="line">    operate_params varchar(500) comment &#x27;操作参数&#x27;,</span><br><span class="line">    primary key(`id`)</span><br><span class="line">)engine=innodb default charset=utf8;</span><br></pre></td></tr></table></figure><p>A. 插入数据触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create trigger tb_user_insert_trigger</span><br><span class="line">after insert on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">    VALUES</span><br><span class="line">    (null, &#x27;insert&#x27;, now(), new.id, concat(&#x27;插入的数据内容为:</span><br><span class="line">    id=&#x27;,new.id,&#x27;,name=&#x27;,new.name, &#x27;, phone=&#x27;, NEW.phone, &#x27;, email=&#x27;, NEW.email, &#x27;,</span><br><span class="line">    profession=&#x27;, NEW.profession));</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">show triggers ;</span><br><span class="line">-- 插入数据到tb_user</span><br><span class="line">insert into tb_user(id, name, phone, email, profession, age, gender, status,createtime) VALUES (26,&#x27;三皇子&#x27;,&#x27;18809091212&#x27;,&#x27;erhuangzi@163.com&#x27;,&#x27;软件工程&#x27;,23,&#x27;1&#x27;,&#x27;1&#x27;,now());</span><br></pre></td></tr></table></figure><p> 测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性</p><p>B. 修改数据触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create trigger tb_user_update_trigger</span><br><span class="line">after update on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">    VALUES</span><br><span class="line">    (null, &#x27;update&#x27;, now(), new.id,</span><br><span class="line">    concat(&#x27;更新之前的数据: id=&#x27;,old.id,&#x27;,name=&#x27;,old.name, &#x27;, phone=&#x27;,</span><br><span class="line">    old.phone, &#x27;, email=&#x27;, old.email, &#x27;, profession=&#x27;, old.profession,</span><br><span class="line">    &#x27; | 更新之后的数据: id=&#x27;,new.id,&#x27;,name=&#x27;,new.name, &#x27;, phone=&#x27;,</span><br><span class="line">    NEW.phone, &#x27;, email=&#x27;, NEW.email, &#x27;, profession=&#x27;, NEW.profession));</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">show triggers ;</span><br><span class="line"></span><br><span class="line">-- 更新</span><br><span class="line">update tb_user set profession = &#x27;会计&#x27; where id = 23;</span><br><span class="line">update tb_user set profession = &#x27;会计&#x27; where id &lt;= 5;</span><br></pre></td></tr></table></figure><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><p>C. 删除数据触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create trigger tb_user_delete_trigger</span><br><span class="line">after delete on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">    VALUES</span><br><span class="line">    (null, &#x27;delete&#x27;, now(), old.id,</span><br><span class="line">    concat(&#x27;删除之前的数据: id=&#x27;,old.id,&#x27;,name=&#x27;,old.name, &#x27;, phone=&#x27;,</span><br><span class="line">    old.phone, &#x27;, email=&#x27;, old.email, &#x27;, profession=&#x27;, old.profession));</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">show triggers ;</span><br><span class="line"></span><br><span class="line">-- 删除数据</span><br><span class="line">delete from tb_user where id = 26;</span><br></pre></td></tr></table></figure><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><h2 id="MySQL8-0新特性"><a href="#MySQL8-0新特性" class="headerlink" title="MySQL8.0新特性"></a>MySQL8.0新特性</h2><h3 id="新特性1：窗口函数"><a href="#新特性1：窗口函数" class="headerlink" title="新特性1：窗口函数"></a>新特性1：窗口函数</h3><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，</p><p>不同的是，<strong>分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</strong></p><p><font color="red">即：窗口函数是在每行新增一个字段，用于显示窗口函数的计算值，并将同一个组的数据放在一起，但是并不合并</font></p><p><font color="cornflowerblue">强化、代替GROUP BY</font></p><p>窗口函数的分类：</p><p><img src="https://www.hahhome.top/blog/MySQL(1)%E5%9F%BA%E7%A1%80%E7%AF%87/../../image/MySQL(1)%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20211012162944536.png" alt="image-20211012162944536"></p><p>具体使用案例看尚硅谷基础篇笔记 《MySQL8.0新特性》篇</p><h3 id="新特性2：公用表达式"><a href="#新特性2：公用表达式" class="headerlink" title="新特性2：公用表达式"></a>新特性2：公用表达式</h3><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p><p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code> 2 种。</p><p><font color="cornflowerblue">强化、代替子查询</font></p><p>具体使用案例看尚硅谷基础篇笔记 《MySQL8.0新特性》篇</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx高级篇扩容与高效</title>
      <link href="/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/"/>
      <url>/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx高级-第一部分：扩容"><a href="#Nginx高级-第一部分：扩容" class="headerlink" title="Nginx高级 第一部分：扩容"></a>Nginx高级 第一部分：扩容</h1><p>通过扩容提升整体吞吐量</p><h2 id="1-单机垂直扩容：硬件资源增加"><a href="#1-单机垂直扩容：硬件资源增加" class="headerlink" title="1.单机垂直扩容：硬件资源增加"></a>1.单机垂直扩容：硬件资源增加</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">云服务资源增加</span><br><span class="line">整机：IBM、浪潮、DELL、HP等</span><br><span class="line">CPU/主板：更新到主流</span><br><span class="line">网卡：10G/40G网卡</span><br><span class="line">磁盘：SAS(SCSI) HDD（机械）、HHD（混合）、SATA SSD、PCI-e SSD、 MVMe SSD</span><br><span class="line">SSD</span><br><span class="line">多副本机制</span><br><span class="line">系统盘/热点数据/数据库存储</span><br><span class="line">HDD</span><br><span class="line">冷数据存储</span><br></pre></td></tr></table></figure><h2 id="2-水平扩展：集群化"><a href="#2-水平扩展：集群化" class="headerlink" title="2.水平扩展：集群化"></a>2.水平扩展：集群化</h2><h2 id="基本调优"><a href="#基本调优" class="headerlink" title="基本调优"></a>基本调优</h2><h3 id="会话管理-修改负载均衡策略"><a href="#会话管理-修改负载均衡策略" class="headerlink" title="会话管理-修改负载均衡策略"></a>会话管理-修改负载均衡策略</h3><h4 id="Nginx高级负载均衡"><a href="#Nginx高级负载均衡" class="headerlink" title="Nginx高级负载均衡"></a>Nginx高级负载均衡</h4><p><strong>ip_hash</strong></p><ul><li>会导致流量倾斜，ip集中</li><li>若后端服务器宕机，对应ip的服务将无法提供</li><li>应用场景：中小型项目快速扩容时，不想修改代码，只需增加几台服务器使用ip_hash就可临时实现</li></ul><p><strong>hash    $cookie_jsessionid;</strong></p><ul><li>根据cookie中的jsessionid的不同转发到对应的服务器</li></ul><p><strong>hash    $request_uri;</strong> </p><ul><li>根据uri的不同转发到对应的服务器</li></ul><p><strong>使用lua逻辑定向分发</strong></p><p><strong>Redis + SpringSession</strong></p><ul><li>要修改代码</li><li>所有前端服务器的请求打在redis服务器上，redis受不了</li></ul><p>ip_hash示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> httpds &#123;</span><br><span class="line">ip_hash;<span class="comment">#设置负载均衡策略为ip_hash</span></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.44.102</span> ;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.44.103</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="section">server</span> &#123;</span><br><span class="line">     <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">     <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">     <span class="section">location</span> / &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://httpds;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># root   html;</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="section">location</span> ~*/(css|img|js) &#123;</span><br><span class="line">  </span><br><span class="line">     <span class="attribute">root</span>   /usr/local/nginx/html;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="使用sticky模块完成对Nginx的负载均衡"><a href="#使用sticky模块完成对Nginx的负载均衡" class="headerlink" title="使用sticky模块完成对Nginx的负载均衡"></a>使用sticky模块完成对Nginx的负载均衡</h4><p><strong>使用参考</strong></p><p><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#sticky">http://nginx.org/en/docs/http/ngx_http_upstream_module.html#sticky</a></p><p>tengine中有session_sticky模块我们通过第三方的方式安装在开源版本中</p><p>sticky是第三方模块，需要重新编译Nginx,他可以对Nginx这种静态文件服务器使用基于cookie的负载均衡</p><p><strong>1.下载模块</strong></p><p><strong>项目官网</strong></p><p><a href="https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/src/master/">https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/src/master/</a></p><p>另外一个版本</p><p><a href="https://github.com/bymaximus/nginx-sticky-module-ng">https://github.com/bymaximus/nginx-sticky-module-ng</a></p><p><strong>下载</strong></p><p><a href="https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/get/1.2.6.zip">https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/get/1.2.6.zip</a></p><p><strong>2.上传解压</strong></p><p><strong>3.重新编译Nginx</strong></p><p><strong>进到源码目录重新编译</strong></p><p><font color="cornflowerblue">configure时记得加上自己原本有的后缀</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nginx-1.21.6#根据自己的实际目录</span><br><span class="line">./configure --prefix=/usr/local/nginx --add-module=/root/nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d</span><br></pre></td></tr></table></figure><p><strong>执行make</strong></p><p><strong>make时如遇报错修改源码</strong></p><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230624154939957.png" alt="image-20230624154939957"></p><p>打开sticky文件夹中 <code>ngx_http_sticky_misc.c</code>文件</p><p>在12行添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/sha.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/md5.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>若缺少依赖<code>openssl-devel</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum intall -y openssl-devel</span><br></pre></td></tr></table></figure><p><strong>备份之前的程序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old</span><br></pre></td></tr></table></figure><p><strong>把编译好的Nginx程序替换到原来的目录里</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure><p><strong>升级检测</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure><p>检查程序中是否包含新模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure><p>配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> httpget &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">sticky</span> name=route expires=<span class="number">6h</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.44.102</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.44.103</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求头中的cookie中带有key为route的数据，重复请求该值不变，route是由sticky模块下发的值</p><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230624160320269.png" alt="image-20230624160320269"></p><h3 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h3><p>不是keepalived没有d</p><p><strong>KeepAlive：保持长连接，避免过多的http连接的建立</strong>，在http协议header中可以看到当前KeepAlive的连接状态</p><p><strong>可使用测试工具charles</strong>，也可以直接使用浏览器开发者模式，不过可能因为缓存原因刷新失败</p><p>类似于wireshark，一个抓包工具</p><p><strong>下载地址</strong></p><p><a href="https://www.charlesproxy.com/assets/release/4.6.2/charles-proxy-4.6.2-win64.msi?k=fc1457e312">https://www.charlesproxy.com/assets/release/4.6.2/charles-proxy-4.6.2-win64.msi?k=fc1457e312</a></p><p><strong>官网</strong></p><p><a href="https://www.charlesproxy.com/">https://www.charlesproxy.com</a></p><h4 id="什么时候用和不用？"><a href="#什么时候用和不用？" class="headerlink" title="什么时候用和不用？"></a>什么时候用和不用？</h4><p><strong>用？</strong></p><p>明显的预知用户会在当前连接上有下一步操作</p><p>复用连接，有效减少握手次数，尤其是https建立一次连接开销会更大</p><p><strong>不用？</strong></p><p>访问内联资源一般用缓存，不需要keepalive</p><p>长时间的tcp连接容易导致系统资源无效占用</p><h4 id="对客户端使用keepalive"><a href="#对客户端使用keepalive" class="headerlink" title="&#x3D;&#x3D;对客户端使用keepalive&#x3D;&#x3D;"></a>&#x3D;&#x3D;<font color="red">对客户端使用keepalive</font>&#x3D;&#x3D;</h4><p>客户端一般是浏览器</p><p><font color="cornflowerblue">配置位置：http</font></p><ul><li><strong>keepalive_timeout</strong></li></ul><p>nginx.conf配置文件中修改keepalive_timeout，默认是65（s），修改成0即为关闭</p><p>用于设置Nginx服务器与客户端保持连接的超时时间</p><p>用于踢出不活动连接</p><p>keepalive_timeout &#x3D; 0 即关闭</p><p>可以设置两个参数，   keepalive_timeout  65 65;</p><p>第二个参数用于配置http1.0版本，1.1不需要</p><ul><li><strong>keepalive_disable</strong></li></ul><p>不对某些浏览器建立长连接</p><p>默认msie6</p><ul><li><strong>keepalive_time</strong></li></ul><p>限制keepalive保持连接的最大时间，超过之后 强制失效</p><p>默认是1h</p><p>1.19.10新功能</p><ul><li><strong>keepalive_request</strong></li></ul><p>默认1000，1000已经够用</p><p>一个tcp复用中 可以并发接收的请求个数</p><ul><li><strong>send_timeout</strong></li></ul><p>两次向客户端写操作之间的间隔 如果大于这个时间则关闭连接 默认60s</p><p>send_timeout 10;  10秒</p><p>send_timeout 10 10; 同时下发一个header 告诉浏览器</p><p><strong>此处有坑</strong>，注意耗时的同步操作有可能会丢弃用户连接</p><p>该设置表示Nginx服务器与客户端连接后，某次会话中服务器等待客户端响应超过10s，就会自动关闭连接。</p><p>配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span> <span class="number">65</span>; <span class="comment">#超过这个时间 没有活动，会让keepalive失效 ，第二个参数用于配置http1.0版本，1.1不需要</span></span><br><span class="line">    <span class="attribute">keepalive_time</span> <span class="number">1h</span>; <span class="comment"># 一个tcp连接总时长，超过之后 强制失效</span></span><br><span class="line">  </span><br><span class="line">    <span class="attribute">send_timeout</span> <span class="number">60</span>;<span class="comment"># 默认60s  此处有坑！！ 系统中 若有耗时操作，超过 send_timeout 强制断开连接。 注意：准备过程中，不是传输过程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_requests</span> <span class="number">1000</span>;  <span class="comment">#一个tcp复用中 可以并发接收的请求个数</span></span><br></pre></td></tr></table></figure><h4 id="对上游服务器使用keepalive"><a href="#对上游服务器使用keepalive" class="headerlink" title="&#x3D;&#x3D;对上游服务器使用keepalive&#x3D;&#x3D;"></a>&#x3D;&#x3D;<font color="red">对上游服务器使用keepalive</font>&#x3D;&#x3D;</h4><p>上游服务器就是后端服务器</p><p>首先需要配置使用http1.1协议。以便建立更高效的传输，默认使用http1.0，在http1.0中需要配置header才能</p><p>在Upstream中所配置的上游服务器默认都是用短连接，即每次请求都会在完成之后断开</p><p><strong>upstream中配置</strong></p><p>配置</p><ul><li><strong>keepalive 100;</strong></li></ul><p>向上游服务器的保留连接数</p><ul><li><strong>keepalive_timeout  65</strong></li></ul><p>连接保留时间</p><ul><li><strong>keepalive_requests 1000</strong></li></ul><p>一个tcp复用中 可以并发接收的请求个数</p><p><strong>server中的location配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="comment">#配置http版本号</span></span><br><span class="line"><span class="comment">#因为nginx默认使用http1.0协议，需要在request中增加”Connection： keep-alive“ header才能够支持，而HTTP1.1默认支持。</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;<span class="comment">#清除close信息</span></span><br></pre></td></tr></table></figure><p><font color="cornflowerblue">由于nginx默认为 http 1.0 ，不支持服务端长连接，请求头会携带 connection： close ，所以需要指定http版本为 http 1.1，同时设置connection： “”</font></p><p>配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#定义集群</span></span><br><span class="line">   <span class="section">upstream</span> cluster &#123;</span><br><span class="line"><span class="attribute">keepalive</span> <span class="number">100</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"><span class="attribute">keepalive_requests</span> <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.111.101:80</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.111.102:80</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line">       <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">       <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">       <span class="section">location</span> / &#123;</span><br><span class="line">           <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">           <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">#反向代理到集群，配置负载均衡</span></span><br><span class="line">           <span class="attribute">proxy_pass</span> http://cluster;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="KeepAlive配置总结"><a href="#KeepAlive配置总结" class="headerlink" title="KeepAlive配置总结"></a>KeepAlive配置总结</h4><p>一般情况下：</p><ul><li>对客户端使用keepAlive全部配上，使用默认值</li><li>对上游服务器使用keepAlive全部配上，使用默认值</li></ul><h4 id="KeepAlive压测：AB安装使用"><a href="#KeepAlive压测：AB安装使用" class="headerlink" title="KeepAlive压测：AB安装使用"></a>KeepAlive压测：AB安装使用</h4><p>apache benchmark：一款压力测试插件，直接通过yum安装即可</p><p>yum install httpd-tools</p><p>参数说明：</p><ul><li><strong>-n  即requests，用于指定压力测试总共的执行次数。</strong></li><li><strong>-c  即concurrency，用于指定的并发数。</strong></li><li>-t  即timelimit，等待响应的最大时间(单位：秒)。</li><li>-b  即windowsize，TCP发送&#x2F;接收的缓冲大小(单位：字节)。</li><li>-p  即postfile，发送POST请求时需要上传的文件，此外还必须设置-T参数。</li><li>-u  即putfile，发送PUT请求时需要上传的文件，此外还必须设置-T参数。</li><li>-T  即content-type，用于设置Content-Type请求头信息，例如：application&#x2F;x-www-form-urlencoded，默认值为text&#x2F;plain。</li><li>-v  即verbosity，指定打印帮助信息的冗余级别。</li><li>-w  以HTML表格形式打印结果。</li><li>-i  使用HEAD请求代替GET请求。</li><li>-x  插入字符串作为table标签的属性。</li><li>-y  插入字符串作为tr标签的属性。</li><li>-z  插入字符串作为td标签的属性。</li><li>-C  添加cookie信息，例如：”Apache&#x3D;1234”(可以重复该参数选项以添加多个)。</li><li>-H  添加任意的请求头，例如：”Accept-Encoding: gzip”，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)。</li><li>-A  添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开。</li><li>-P  添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开。</li><li>-X  指定使用的和端口号，例如:”126.10.10.3:88”。</li><li>-V  打印版本号并退出。</li><li>-k  使用HTTP的KeepAlive特性。</li><li>-d  不显示百分比。</li><li>-S  不显示预估和警告信息。</li><li>-g  输出结果信息到gnuplot格式的文件中。</li><li>-e  输出结果信息到CSV格式的文件中。</li><li>-r  指定接收到错误信息时不退出程序。</li><li>-h  显示用法信息，其实就是ab -help。</li></ul><p>压测语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 100000 c 30 http://192.168.111.102/</span><br></pre></td></tr></table></figure><p><strong>直连nginx</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.21.6</span><br><span class="line">Server Hostname:        192.168.44.102</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        16 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      30</span><br><span class="line">Time taken for tests:   13.035 seconds</span><br><span class="line">Complete requests:      100000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      25700000 bytes</span><br><span class="line">HTML transferred:       1600000 bytes</span><br><span class="line">Requests per second:    7671.48 [#/sec] (mean)</span><br><span class="line">Time per request:       3.911 [ms] (mean)</span><br><span class="line">Time per request:       0.130 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1925.36 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.4      0      12</span><br><span class="line">Processing:     1    3   1.0      3      14</span><br><span class="line">Waiting:        0    3   0.9      3      14</span><br><span class="line">Total:          2    4   0.9      4      14</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%      4</span><br><span class="line">  66%      4</span><br><span class="line">  75%      4</span><br><span class="line">  80%      4</span><br><span class="line">  90%      5</span><br><span class="line">  95%      5</span><br><span class="line">  98%      6</span><br><span class="line">  99%      7</span><br><span class="line"> 100%     14 (longest request)</span><br></pre></td></tr></table></figure><p><strong>反向代理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.21.6</span><br><span class="line">Server Hostname:        192.168.44.101</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        16 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      30</span><br><span class="line">Time taken for tests:   25.968 seconds</span><br><span class="line">Complete requests:      100000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      25700000 bytes</span><br><span class="line">HTML transferred:       1600000 bytes</span><br><span class="line">Requests per second:    3850.85 [#/sec] (mean)</span><br><span class="line">Time per request:       7.790 [ms] (mean)</span><br><span class="line">Time per request:       0.260 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          966.47 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.2      0      13</span><br><span class="line">Processing:     3    8   1.4      7      22</span><br><span class="line">Waiting:        1    7   1.4      7      22</span><br><span class="line">Total:          3    8   1.4      7      22</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%      7</span><br><span class="line">  66%      8</span><br><span class="line">  75%      8</span><br><span class="line">  80%      8</span><br><span class="line">  90%      9</span><br><span class="line">  95%     10</span><br><span class="line">  98%     12</span><br><span class="line">  99%     13</span><br><span class="line"> 100%     22 (longest request)</span><br></pre></td></tr></table></figure><p><strong>直连Tomcat</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.21.6</span><br><span class="line">Server Hostname:        192.168.44.105</span><br><span class="line">Server Port:            8080</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        7834 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      30</span><br><span class="line">Time taken for tests:   31.033 seconds</span><br><span class="line">Complete requests:      100000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      804300000 bytes</span><br><span class="line">HTML transferred:       783400000 bytes</span><br><span class="line">Requests per second:    3222.38 [#/sec] (mean)</span><br><span class="line">Time per request:       9.310 [ms] (mean)</span><br><span class="line">Time per request:       0.310 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          25310.16 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.3      0      15</span><br><span class="line">Processing:     0    9   7.8      7     209</span><br><span class="line">Waiting:        0    9   7.2      7     209</span><br><span class="line">Total:          0    9   7.8      7     209</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%      7</span><br><span class="line">  66%      9</span><br><span class="line">  75%     11</span><br><span class="line">  80%     13</span><br><span class="line">  90%     18</span><br><span class="line">  95%     22</span><br><span class="line">  98%     27</span><br><span class="line">  99%     36</span><br><span class="line"> 100%    209 (longest request)</span><br></pre></td></tr></table></figure><p><strong>nginx反向代理Tomcat + keepalive</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.21.6</span><br><span class="line">Server Hostname:        192.168.44.101</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        7834 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      30</span><br><span class="line">Time taken for tests:   23.379 seconds</span><br><span class="line">Complete requests:      100000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      806500000 bytes</span><br><span class="line">HTML transferred:       783400000 bytes</span><br><span class="line">Requests per second:    4277.41 [#/sec] (mean)</span><br><span class="line">Time per request:       7.014 [ms] (mean)</span><br><span class="line">Time per request:       0.234 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          33688.77 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.2      0       9</span><br><span class="line">Processing:     1    7   4.2      6     143</span><br><span class="line">Waiting:        1    7   4.2      6     143</span><br><span class="line">Total:          1    7   4.2      6     143</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%      6</span><br><span class="line">  66%      7</span><br><span class="line">  75%      7</span><br><span class="line">  80%      7</span><br><span class="line">  90%      8</span><br><span class="line">  95%     10</span><br><span class="line">  98%     13</span><br><span class="line">  99%     16</span><br><span class="line"> 100%    143 (longest request)</span><br></pre></td></tr></table></figure><p><strong>nginx反向代理Tomcat</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.21.6</span><br><span class="line">Server Hostname:        192.168.44.101</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        7834 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      30</span><br><span class="line">Time taken for tests:   33.814 seconds</span><br><span class="line">Complete requests:      100000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      806500000 bytes</span><br><span class="line">HTML transferred:       783400000 bytes</span><br><span class="line">Requests per second:    2957.32 [#/sec] (mean)</span><br><span class="line">Time per request:       10.144 [ms] (mean)</span><br><span class="line">Time per request:       0.338 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          23291.74 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.2      0       9</span><br><span class="line">Processing:     1   10   5.5      9     229</span><br><span class="line">Waiting:        1   10   5.5      9     229</span><br><span class="line">Total:          1   10   5.5      9     229</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%      9</span><br><span class="line">  66%     10</span><br><span class="line">  75%     11</span><br><span class="line">  80%     11</span><br><span class="line">  90%     13</span><br><span class="line">  95%     14</span><br><span class="line">  98%     17</span><br><span class="line">  99%     19</span><br><span class="line"> 100%    229 (longest request)</span><br></pre></td></tr></table></figure><h3 id="UpStream-反向代理上游集群-工作流程"><a href="#UpStream-反向代理上游集群-工作流程" class="headerlink" title="UpStream(反向代理上游集群)工作流程"></a>UpStream(反向代理上游集群)工作流程</h3><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230624174235190.png" alt="image-20230624174235190"></p><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230624174246944.png" alt="image-20230624174246944"></p><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230624174400920.png" alt="image-20230624174400920"></p><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230624174406412.png" alt="image-20230624174406412"></p><p>proxy_pass 向上游服务器请求数据共有6个阶段</p><ul><li>初始化</li><li>与上游服务器建立连接</li><li>向上游服务器发送请求</li><li>处理响应头</li><li>处理响应体</li><li>结束</li></ul><h4 id="对客户端的限制配置"><a href="#对客户端的限制配置" class="headerlink" title="&#x3D;&#x3D;对客户端的限制配置&#x3D;&#x3D;"></a>&#x3D;&#x3D;<font color="red">对客户端的限制配置</font>&#x3D;&#x3D;</h4><p>可配置位置</p><ul><li><p><font color="cornflowerblue">http</font></p></li><li><p><font color="cornflowerblue">server</font></p></li><li><p><font color="cornflowerblue"><strong>location</strong></font></p></li><li><p><strong>client_body_buffer_size</strong></p></li></ul><p>对客户端请求中的body缓冲区大小</p><p>默认32位系统8k 64位16k</p><p>如果请求体大于配置，则写入临时文件</p><ul><li><strong>client_header_buffer_size</strong></li></ul><p>设置读取客户端请求体的缓冲区大小。 如果请求体大于缓冲区，则将整个请求体或仅将其部分写入临时文件。 默认32位8K。 64位平台16K。  </p><ul><li><strong>client_max_body_size 1000M;</strong></li></ul><p>默认1m，如果一个请求的大小超过配置的值，会返回413 (request Entity Too Large)错误给客户端</p><p>将size设置为0将禁用对客户端请求正文大小的检查。  </p><ul><li><strong>client_body_timeout</strong></li></ul><p>指定客户端与服务端建立连接后发送 request body 的超时时间。如果客户端在指定时间内没有发送任何内容，Nginx 返回 HTTP 408（Request Timed Out）</p><ul><li><strong>client_header_timeout</strong></li></ul><p>客户端向服务端发送一个完整的 request header 的超时时间。如果客户端在指定时间内没有发送一个完整的 request header，Nginx 返回 HTTP 408（Request Timed Out）。</p><ul><li><strong>client_body_temp_path</strong> <em>path</em><code> [</code><em>level1</em><code> [</code><em>level2</em><code> [</code><em>level3</em>&#96;]]]</li></ul><p>在磁盘上客户端的body临时缓冲区位置</p><p><strong>client_body_in_file_only on;</strong></p><p>把body写入磁盘文件，请求结束也不会删除</p><ul><li><strong>client_body_in_single_buffer</strong></li></ul><p>尽量缓冲body的时候在内存中使用连续单一缓冲区，在二次开发时使用<code>$request_body</code>读取数据时性能会有所提高</p><ul><li><strong>client_header_buffer_size</strong></li></ul><p>设置读取客户端请求头的缓冲区大小</p><p>如果一个请求行或者一个请求头字段不能放入这个缓冲区，那么就会使用large_client_header_buffers</p><ul><li><strong>large_client_header_buffers</strong></li></ul><p>默认8k</p><h4 id="header和连接配置"><a href="#header和连接配置" class="headerlink" title="&#x3D;&#x3D;header和连接配置&#x3D;&#x3D;"></a>&#x3D;&#x3D;<font color="red">header和连接配置</font>&#x3D;&#x3D;</h4><p><font color="cornflowerblue">配置位置：推荐location</font></p><ul><li><strong>add_header | proxy_set_header</strong></li></ul><p>设置header</p><ul><li><strong>proxy_connect_timeout</strong></li></ul><p>与上游服务器连接超时时间、快速失败</p><ul><li><strong>proxy_send_timeout</strong></li></ul><p>定义nginx向后端服务发送请求的间隔时间(不是耗时)。默认60秒，超过这个时间会关闭连接</p><ul><li><strong>proxy_read_timeout</strong></li></ul><p>后端服务给nginx响应的时间，规定时间内后端服务没有给nginx响应，连接会被关闭，nginx返回504 Gateway Time-out。默认60秒</p><h4 id="缓冲区配置"><a href="#缓冲区配置" class="headerlink" title="&#x3D;&#x3D;缓冲区配置&#x3D;&#x3D;"></a>&#x3D;&#x3D;<font color="red">缓冲区配置</font>&#x3D;&#x3D;</h4><p><font color="cornflowerblue">配置位置：推荐location</font></p><ul><li><strong>proxy_requset_buffering</strong></li></ul><p>是否完全读到请求体之后再向上游服务器发送请求</p><ul><li><strong>proxy_buffering</strong></li></ul><p>是否缓冲上游服务器数据</p><ul><li><strong>proxy_buffers 32 64k;</strong></li></ul><p>缓冲区大小 32个 64k大小内存缓冲块</p><ul><li><strong>proxy_buffer_size</strong></li></ul><p>header缓冲区大小</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_requset_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">32</span> <span class="number">128k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">8k</span>;</span><br><span class="line"><span class="attribute">proxy_max_temp_file_size</span> <span class="number">1024m</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>proxy_temp_file_write_size 8k</strong></li></ul><p>当启用从代理服务器到临时文件的响应的缓冲时，一次限制写入临时文件的数据的大小。 默认情况下，大小由proxy_buffer_size和proxy_buffers指令设置的两个缓冲区限制。 临时文件的最大大小由proxy_max_temp_file_size指令设置。  </p><ul><li><strong>proxy_max_temp_file_size 1024m;</strong></li></ul><p>临时文件最大值</p><ul><li><strong>proxy_temp_path</strong></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_temp_path /spool/nginx/proxy_temp 1 2;</span><br></pre></td></tr></table></figure></blockquote><p>a temporary file might look like this:</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/spool/nginx/proxy_temp/7/45/00000123457</span><br></pre></td></tr></table></figure></blockquote><h4 id="UpStream配置总结"><a href="#UpStream配置总结" class="headerlink" title="UpStream配置总结"></a>UpStream配置总结</h4><p>自己的阿里云服务器配置示例：</p><p>需要配置下列一项才能完成登录等post请求，否侧会返回500<br>            proxy_set_header Host $host;</p><p>注释掉的都可以配一配，参考的别人的</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">#反向代理到集群，配置负载均衡</span></span><br><span class="line">          <span class="attribute">proxy_pass</span> http://47.115.207.49:8099/;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">#proxy_redirect off;</span></span><br><span class="line">          <span class="comment">#proxy_set_header X-Real-IP $remote_addr;</span></span><br><span class="line">          <span class="comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;           </span></span><br><span class="line">          <span class="comment">#proxy_set_header Cookie $http_cookie;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">#proxy_send_timeout 1300;</span></span><br><span class="line">          <span class="comment">#proxy_read_timeout 1300;</span></span><br><span class="line">          <span class="comment">#proxy_buffer_size 64k;</span></span><br><span class="line">          <span class="comment">#proxy_buffers 8 64k;</span></span><br><span class="line">          <span class="comment">#proxy_busy_buffers_size 128k;</span></span><br><span class="line">          <span class="comment">#proxy_temp_file_write_size 64k;</span></span><br><span class="line">          <span class="comment">#client_max_body_size 10m;</span></span><br><span class="line">          <span class="comment">#client_body_buffer_size 128k;</span></span><br><span class="line">          <span class="comment">#proxy_connect_timeout 1300;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">#root   /www/www;</span></span><br><span class="line">          <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="获取客户端真实IP"><a href="#获取客户端真实IP" class="headerlink" title="获取客户端真实IP"></a>获取客户端真实IP</h4><p>用到header设置：proxy_set_header</p><p><strong>X-Real-IP</strong></p><p>额外模块，不推荐使用</p><p><strong>X-Forwarded-For</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header X-Forwarded-For $remote_addr;</span><br></pre></td></tr></table></figure><p>$remote_addr：前置ip地址，这里是获取nginx服务器的前置ip，那就是客户端ip</p><p>若有两层nginx服务器，一种方法是转发第一层nginx发过来的remote_addr，另一种方法是不覆盖再加一个header记录第二层nginx的remote_addr</p><h3 id="Gzip"><a href="#Gzip" class="headerlink" title="Gzip"></a>Gzip</h3><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230627140313937.png" alt="image-20230627140313937"></p><p>适合静态资源，但是</p><p><strong>二进制资源</strong>：例如图片&#x2F;mp3这样的二进制文件,不必压缩；因为压缩率比较小, 比如100-&gt;80字节,而且压缩也是耗费CPU资源的.</p><h4 id="Gzip动态压缩配置"><a href="#Gzip动态压缩配置" class="headerlink" title="Gzip动态压缩配置"></a>Gzip动态压缩配置</h4><p>作用域 <code>http, server, location</code></p><ul><li><strong>gzip on;</strong></li></ul><p>开关，默认关闭</p><ul><li><strong>gzip_buffers 32 4k|16 8k</strong></li></ul><p>缓冲区大小</p><p>32位cpu推荐选 32 4k</p><p>64位cpu推荐选 16 8k</p><ul><li><strong>gzip_comp_level 1；</strong></li></ul><p>压缩等级 1-9，数字越大压缩比越高</p><p>推荐1-6</p><ul><li><strong>gzip_http_version 1.1;</strong></li></ul><p>使用gzip的最小版本</p><ul><li><strong>gzip_min_length</strong></li></ul><p>设置将被gzip压缩的响应的最小长度。 长度仅由“Content-Length”响应报头字段确定。</p><p>大于这个设置长度才会压缩数据，否则不压缩</p><p>一般1k~5K</p><ul><li><strong>gzip_proxied 多选</strong></li></ul><p>off 为不做限制</p><p>作为反向代理时，针对上游服务器返回的头信息进行压缩</p><p>expired - 启用压缩，如果header头中包含 “Expires” 头信息<br>no-cache - 启用压缩，如果header头中包含 “Cache-Control:no-cache” 头信息<br>no-store - 启用压缩，如果header头中包含 “Cache-Control:no-store” 头信息<br>private - 启用压缩，如果header头中包含 “Cache-Control:private” 头信息<br>no_last_modified - 启用压缩,如果header头中不包含 “Last-Modified” 头信息<br>no_etag - 启用压缩 ,如果header头中不包含 “ETag” 头信息<br>auth - 启用压缩 , 如果header头中包含 “Authorization” 头信息<br>any - 无条件启用压缩</p><ul><li><strong>gzip_vary on;</strong></li></ul><p>增加一个header，适配老的浏览器 <code>Vary: Accept-Encoding</code></p><ul><li><strong>gzip_types</strong></li></ul><p>哪些mime类型的文件进行压缩</p><ul><li><strong>gzip_disable</strong></li></ul><p>禁止某些浏览器使用gzip</p><p>会使用正则表达式，<font color="red">一般不推荐配置文件使用正则表达式，会额外消耗服务器的性能</font></p><p><strong>完整实例</strong></p><p><font color="cornflowerblue">加载location或者server中</font></p><p><font color="cornflowerblue">使用Gzip动态压缩会导致sendFile功能无法使用，于是使用静态压缩来解决这个问题，静态压缩只用给nginx加装module即可，配置加一行gzip_static on; 前提：服务器硬盘指定静态资源的位置，已经有压缩好的文件.gz</font></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">256</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span> any;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;</span><br><span class="line"><span class="attribute">gzip_types</span></span><br><span class="line">  text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">  text/javascript application/javascript application/x-javascript</span><br><span class="line">  text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">  text/css text/plain text/x-component</span><br><span class="line">  font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">  image/x-icon;</span><br><span class="line"><span class="comment">#gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;#正则会消耗服务器性能，不推荐配置</span></span><br></pre></td></tr></table></figure><p>未配置gzip的响应报文</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span></span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>nginx/1.21.6</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 18 May 2022 17:42:35 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html;charset=utf-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>7832</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=65</span><br></pre></td></tr></table></figure><p>配置gzip的响应报文</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span></span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>nginx/1.21.6</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 18 May 2022 17:42:35 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html;charset=utf-8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=65</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br></pre></td></tr></table></figure><h4 id="Gzip静态压缩"><a href="#Gzip静态压缩" class="headerlink" title="Gzip静态压缩"></a>Gzip静态压缩</h4><p><strong>http_gzip_static_module</strong></p><p><font color="cornflowerblue">前提：服务器硬盘指定静态资源的位置，已经有压缩好的文件.gz</font></p><p>需要重新编译nginx</p><p><font color="cornflowerblue">configure时记得加上自己原本有的后缀</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gzip_static_module</span><br></pre></td></tr></table></figure><p>编译后make和复制启动命令，具体参考使用sticky模块完成对Nginx的负载均衡部分</p><p>配置：在动态压缩的基础上加上gzip_static on;</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><p><strong>ngx_http_gunzip_module</strong></p><p>不常用</p><p>作用：将压缩包发送给客户端前，帮助先解压再给客户端</p><p>帮助不支持gzip的客户端解压本地文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gunzip_module</span><br></pre></td></tr></table></figure><p>配置：在前面的配置基础上加上gunzip on;并修改为gzip_static always;</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gunzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_static</span> always;</span><br></pre></td></tr></table></figure><h3 id="Brotli（Br）"><a href="#Brotli（Br）" class="headerlink" title="Brotli（Br）"></a>Brotli（Br）</h3><p>Brotli为比Gzip压缩比更高的压缩方式，需要加载新的nginx模块才能实现</p><p>可以和Gzip共存，若客户端不支持Brotli则使用Gzip</p><p><strong>安装模块</strong></p><ul><li><p>官网</p><ul><li><p><code>https://github.com/google/ngx_brotli</code></p></li><li><p><code>https://codeload.github.com/google/brotli/tar.gz/refs/tags/v1.0.9</code></p></li></ul></li><li><p>下载 两个项目</p></li><li><p>解压缩</p></li><li><p>将brotli-1.0.9目录下的所有东西移动到ngx_brotli-1.0.0rc&#x2F;deps&#x2F;brotli&#x2F;下</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/brotli-1.0.9/</span><br><span class="line">mv ./* /root/ngx_brotli-1.0.0rc/deps/brotli/</span><br></pre></td></tr></table></figure><p>模块化编译</p><p><font color="cornflowerblue">configure时记得加上自己原本有的后缀</font></p><p>–add-dynamic-module：动态编译，临时存在于nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-compat --add-dynamic-module=/root/ngx_brotli-1.0.0rc</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--add-dynamic-module=brotli目录</span><br></pre></td></tr></table></figure><ul><li>make</li><li>将objs中的<code>ngx_http_brotli_filter_module.so</code> <code>ngx_http_brotli_static_module.so</code>拷贝到<code>/usr/local/nginx/modules/</code></li><li>备份然后复制nginx主程序</li></ul><p><strong>配置文件中添加</strong></p><p>在最外层加，例如配置文件最前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load_module &quot;/usr/local/nginx/modules/ngx_http_brotli_filter_module.so&quot;;</span><br><span class="line">load_module &quot;/usr/local/nginx/modules/ngx_http_brotli_static_module.so&quot;;</span><br></pre></td></tr></table></figure><p><font color="cornflowerblue">location或server加（和Gzip一起）</font></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">brotli</span> <span class="literal">on</span>;</span><br><span class="line">   <span class="attribute">brotli_static</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">brotli_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">brotli_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line"><span class="attribute">brotli_min_length</span> <span class="number">20</span>;</span><br><span class="line"><span class="attribute">brotli_types</span> text/plain text/css text/javascript application/javascript text/xml application/xml application/xml+rss application/json image/jpeg image/gif image/png;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><p>默认http协议是没有br的，即http请求头中没有带br的请求方式，需要使用curl自己指定header</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#x27;Accept-Encoding: br&#x27; -I http://192.168.111.100</span><br></pre></td></tr></table></figure><h3 id="反向代理中的容错机制"><a href="#反向代理中的容错机制" class="headerlink" title="反向代理中的容错机制"></a>反向代理中的容错机制</h3><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/</a></p><p><a href="http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_bind">http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_bind</a></p><p><strong>proxy_timeout</strong> </p><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p><strong>proxy_next_upstream</strong></p><p>作用：</p><p>当后端服务器返回指定的错误时，将请求传递到其他服务器。</p><p><code>error</code>与服务器建立连接，向其传递请求或读取响应头时发生错误;</p><p><code>timeout</code>在与服务器建立连接，向其传递请求或读取响应头时发生超时;</p><p><code>invalid_header</code>服务器返回空的或无效的响应;</p><p><code>http_500</code>服务器返回代码为500的响应;</p><p><code>http_502</code>服务器返回代码为502的响应;</p><p><code>http_503</code>服务器返回代码为503的响应;</p><p><code>http_504</code>服务器返回代码504的响应;</p><p><code>http_403</code>服务器返回代码为403的响应;</p><p><code>http_404</code>服务器返回代码为404的响应;</p><p><code>http_429</code>服务器返回代码为429的响应;</p><p>不了解这个机制，在日常开发web服务的时候，就可能会踩坑。</p><p>比如有这么一个场景：一个用于导入数据的web页面，上传一个excel，通过读取、处理excel，向数据库中插入数据，处理时间较长（如1分钟），且为同步操作（即处理完成后才返回结果）。暂且不论这种方式的好坏，若nginx配置的响应等待时间（proxy_read_timeout）为30秒，就会触发超时重试，将请求又打到另一台。如果处理中没有考虑到重复数据的场景，就会发生数据多次重复插入！（当然，这种场景，内网可以通过机器名访问该服务器进行操作，就可以绕过nginx了，不过外网就没办法了。）</p><h2 id="并发调优"><a href="#并发调优" class="headerlink" title="并发调优"></a>并发调优</h2><h3 id="Concat合并客户端请求"><a href="#Concat合并客户端请求" class="headerlink" title="Concat合并客户端请求"></a>Concat合并客户端请求</h3><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230627143528769.png" alt="image-20230627143528769"></p><p>将文本类的请求合并起来成一个请求（需要修改代码），再发给客户端，<font color="cornflowerblue">能够减少并发请求，让并发量变小</font>提高能处理的并发数</p><p>虽然多个类似于css文件会额外消耗服务器性能，但为了便于管理，也会分开来</p><p>Concat模块</p><p>Tengine</p><p>Nginx官方介绍</p><p><a href="https://www.nginx.com/resources/wiki/modules/concat/">https://www.nginx.com/resources/wiki/modules/concat/</a></p><p>git地址</p><p><a href="https://github.com/alibaba/nginx-http-concat">https://github.com/alibaba/nginx-http-concat</a></p><ul><li>安装</li></ul><p>下载源码到&#x2F;root目录</p><p>解压</p><p>nginx重新编译</p><p><font color="cornflowerblue">configure时记得加上自己原本有的后缀</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure .... --add-module=/root/nginx-http-concat-master/</span><br></pre></td></tr></table></figure><ul><li>make</li><li>备份复制nginx主程序</li><li>配置</li></ul><p>例如css引用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;??font.css,bg.css&quot;</span><span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件：server或location</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">concat</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">concat_max_files</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h3 id="资源静态化"><a href="#资源静态化" class="headerlink" title="资源静态化"></a>资源静态化</h3><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230627151618632.png" alt="image-20230627151618632"></p><p><strong>高并发下：把资源做为静态资源放到Nginx。</strong></p><ul><li>类似于商品列表和详情页这种<font color="cornflowerblue">并发量高，但总体页面变化不大的页面</font>，</li><li>可以使用资源静态化的方式将请求的页面生成一个静态页面存储起来，每次直接返回静态页面即可</li><li>优点：商品列表和详情页的并发量高，可以跳过服务器计算和连接数据库读取数据的过程，直接返回静态页面，<font color="cornflowerblue">降低延迟度和并发量</font></li><li>静态页面存储在nginx，或者使用openresty技术（内置模板引擎，落地磁盘）直接跳过nginx连接DB生成静态页面</li><li>再使用异步请求的方式更新页面中变化的动态数据</li><li>nginx服务器需要用到<strong>rsync</strong>进行资源同步</li></ul><p><strong>例如一个item.html，可分为三个部分：</strong></p><ul><li><p>1.实际内容</p></li><li><p>2.固定公用-&gt;抽取 静态（<font color="cornflowerblue">例如header和footer，是common的</font>）</p><ul><li><p>前端-&gt;节约服务器端的计算资源消耗请求数</p></li><li><p>后端-&gt;使用SSI合并服务端文件（下一节讲），类似使用模板引擎（例如thymeleaf）</p></li></ul></li><li><p>3.关联的内容-&gt;引用 动态资源</p></li></ul><p>•高并发系统资源静态化方案</p><p>•一致性问题</p><p>•合并文件输出</p><p>•集群文件同步</p><p>生成静态页面自己去学</p><h3 id="SSI合并nginx服务器端文件"><a href="#SSI合并nginx服务器端文件" class="headerlink" title="SSI合并nginx服务器端文件"></a>SSI合并nginx服务器端文件</h3><p><font color="cornflowerblue">类似使用模板引擎（例如thymeleaf）</font></p><p>不推荐过于复杂使用ssi，否则高消耗服务器性能，专业的事交给模板引擎来做</p><p>服务端文件是nginx的文件，例如动静分离的静态文件html等等</p><p>官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_ssi_module.html">http://nginx.org/en/docs/http/ngx_http_ssi_module.html</a></p><h4 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h4><ul><li><strong>ssi on|off</strong></li></ul><p>开启关闭ssi</p><ul><li><strong>ssi_last_modified on|off</strong></li></ul><p>是否保留lastmodified</p><p>默认off，每次输出的都是新文件</p><ul><li><strong>ssi_min_file_chunk size</strong></li></ul><p>向磁盘存储并使用sendfile发送，文件大小最小值</p><p>默认1k，当大于1k时存储再磁盘上并用sendfile发送</p><ul><li><strong>ssi_silent_errors on|off</strong></li></ul><p>不显示逻辑语法错误</p><p>默认off，当类似于<!--# include1 file="footer.html" -->的语法错误，将直接返回不友好提示</p><p>on：语法错误时不提示，但是类似找不到文件，也会返回404错误提示</p><ul><li><strong>ssi_types</strong></li></ul><p>默认text&#x2F;html，只支持解析html的ssi功能</p><p>如果需要其他mime类型 需要设置</p><ul><li><strong>ssi_value_length length</strong></li></ul><p>限制脚本参数最大长度</p><p>要配置一般开启就行</p><p>配置在server或者location中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssi</span> <span class="literal">on</span></span><br><span class="line">ssi_silent_errors <span class="literal">on</span></span><br></pre></td></tr></table></figure><h4 id="SSI命令配置"><a href="#SSI命令配置" class="headerlink" title="SSI命令配置"></a>SSI命令配置</h4><p>配置在配置文件配置ssi_types(例如html)中</p><ul><li><strong>include file</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# include file=&quot;footer.html&quot; --&gt;</span><br></pre></td></tr></table></figure><p>静态文件直接引用</p><ul><li><strong>block</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# block name=&quot;one&quot; --&gt;</span><br><span class="line">stub</span><br><span class="line">&lt;!--# endblock --&gt;</span><br></pre></td></tr></table></figure><p>可以声明一个ssi的命令块，里面可以包裹其他命令</p><ul><li><p><strong>config</strong></p><ul><li><p>1、errmsg:</p><p>配置文件配置ssi_silent_errors off时，即会返回不友好的语法错误提示</p><p>用于修改提示信息的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an error occurred while processing the directive]</span><br></pre></td></tr></table></figure><p>在模板中配置报错情况</p></li><li><p>2、timefmt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%A, %d-%b-%Y %H:%M:%S %Z&quot;</span><br></pre></td></tr></table></figure><p>日期格式化</p></li></ul></li><li><p><strong>echo</strong></p><p>直接输出变量</p><ul><li>var变量名称</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# echo var=&quot;name” default=&quot;no” --&gt;</span><br></pre></td></tr></table></figure><ul><li><p>encoding 是否使用特殊编码格式</p></li><li><p>default 变量没有值的时候使用默认值</p></li></ul></li><li><p><strong>if</strong></p></li></ul><p>逻辑判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# if expr=&quot;...&quot; --&gt;</span><br><span class="line">...</span><br><span class="line">&lt;!--# elif expr=&quot;...&quot; --&gt;</span><br><span class="line">...</span><br><span class="line">&lt;!--# else --&gt;</span><br><span class="line">...</span><br><span class="line">&lt;!--# endif --&gt;</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">变量存在性检查：</span><br><span class="line">&lt;!--# if expr=&quot;$name&quot; --&gt;</span><br><span class="line">变量与文本的比较：</span><br><span class="line">&lt;!--# if expr=&quot;$name = text&quot; --&gt;</span><br><span class="line">&lt;!--# if expr=&quot;$name != text&quot; --&gt;</span><br><span class="line">变量与正则表达式的比较：</span><br><span class="line">&lt;!--# if expr=&quot;$name = /text/&quot; --&gt;</span><br><span class="line">&lt;!--# if expr=&quot;$name != /text/&quot; --&gt;</span><br><span class="line">如果 a 包含变量， 它们的值被替换。 正则表达式可以包含位置捕获和命名捕获 以后可以通过变量使用，例如：text</span><br><span class="line">&lt;!--# if expr=&quot;$name = /(.+)@(?P&lt;domain&gt;.+)/&quot; --&gt;</span><br><span class="line">    &lt;!--# echo var=&quot;1&quot; --&gt;</span><br><span class="line">    &lt;!--# echo var=&quot;domain&quot; --&gt;</span><br><span class="line">&lt;!--# endif --&gt;</span><br></pre></td></tr></table></figure><p><font color="cornflowerblue">正则不推荐使用，会高消耗服务器性能</font></p><ul><li><strong>include virtual</strong></li></ul><p>可以指向location，而不一定是具体文件</p><p>指定包含的请求，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# include virtual=&quot;/remote/body.php?argument=value&quot; --&gt;</span><br></pre></td></tr></table></figure><p>如果需要顺序处理，则应使用该参数。<code>wait</code></p><ul><li><strong>include wait</strong></li></ul><p>如果需要顺序处理，则应使用该参数。<code>wait</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# include virtual=&quot;/remote/body.php?argument=value&quot; wait=&quot;yes&quot; --&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>include stub</strong></li></ul><p>一个非标准参数，用于命名其块 如果包含的请求导致空，则将输出内容 正文，或者在请求处理过程中发生错误，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# block name=&quot;one&quot; --&gt;&amp;nbsp;&lt;!--# endblock --&gt;</span><br><span class="line">&lt;!--# include virtual=&quot;/remote/body.php?argument=value&quot; stub=&quot;one&quot; --&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>include set</strong></li></ul><p>指示写入成功结果的非标准参数 对指定变量的请求处理， 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# include virtual=&quot;/remote/body.php?argument=value&quot; set=&quot;one&quot; --&gt;</span><br></pre></td></tr></table></figure><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230627184302481.png" alt="image-20230627184302481"></p><p><a href="https://www.samba.org/ftp/rsync/rsync.html">https://www.samba.org/ftp/rsync/rsync.html</a></p><p>remote synchronize是一个远程数据同步工具，可通过 LAN&#x2F;WAN 快速同步多台主机之间的文件。也可以使用 rsync 同步本地硬盘中的不同目录。<br>rsync 是用于替代 rcp 的一个工具，rsync 使用所谓的 rsync算法 进行数据同步，这种算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。</p><p>rsync 基于inotify 开发</p><p>Rsync有三种模式：</p><ul><li>本地模式（类似于cp命令）</li><li>远程模式（类似于scp命令）</li><li>守护进程（socket进程：是rsync的重要功能）</li></ul><h4 id="rsync手动拉取同步源文件"><a href="#rsync手动拉取同步源文件" class="headerlink" title="rsync手动拉取同步源文件"></a>rsync手动拉取同步源文件</h4><p><strong>安装</strong></p><p>两端安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y rsync</span><br></pre></td></tr></table></figure><p><strong>源服务器修改配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rsyncd.conf</span><br></pre></td></tr></table></figure><p>内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ftp]</span><br><span class="line">       <span class="attribute">path</span> = /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p><strong>源服务器启动rsync</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync--daemon</span><br></pre></td></tr></table></figure><p><strong>目标服务器查看源文件夹</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync --list-only 192.168.111.100::ftp/</span><br></pre></td></tr></table></figure><p>ftp&#x2F;为源服务器配置文件配置的[ftp]</p><p><strong>目标服务器手动拉取同步文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz 192.168.111.100::ftp/ /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p>同步到自己的&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html目录下</p><p><font color="cornflowerblue">现在只能增量同步</font>，若要删除源服务器没有的文件，需要加上参数实现完全同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--delete</span><br></pre></td></tr></table></figure><h4 id="增加安全认证及免密"><a href="#增加安全认证及免密" class="headerlink" title="增加安全认证及免密"></a>增加安全认证及免密</h4><p><strong>源服务器增加密码文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;sgg:111&quot; &gt;&gt; /etc/rsyncd.pwd</span><br><span class="line"></span><br><span class="line">chmod 600 /etc/rsyncd.pwd</span><br></pre></td></tr></table></figure><p><strong>源服务器修改配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rsyncd.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auth users = sgg</span><br><span class="line">secrets file = /etc/rsyncd.pwd</span><br><span class="line"></span><br><span class="line">[ftp]</span><br><span class="line">       path = /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p><strong>源服务器重启rsync</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep rsync</span><br><span class="line">kill -9 进程号</span><br><span class="line">rsync --daemon</span><br></pre></td></tr></table></figure><p><strong>目标服务器输入密码登录查看</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync --list-only sgg@192.168.111.100::ftp/</span><br></pre></td></tr></table></figure><p><strong>目标服务器创建client密码文件</strong><strong>实现免密</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;111&quot; &gt;&gt; /etc/rsyncd.pwd.client</span><br><span class="line">chmod 600 /etc/rsyncd.pwd.client</span><br><span class="line"></span><br><span class="line">rsync --list-only --password-file=/etc/rsyncd.pwd.client sgg@192.168.111.100::ftp/</span><br><span class="line"></span><br><span class="line">rsync -avz --password-file=/etc/rsyncd.pwd.client sgg@192.168.111.100::ftp/ /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p>此时在客户端已经可以配合脚本实现定时同步了</p><p><font color="cornflowerblue">现在只能增量同步</font>，若要删除源服务器没有的文件，需要加上参数实现完全同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--delete</span><br></pre></td></tr></table></figure><h4 id="源服务器推送文件"><a href="#源服务器推送文件" class="headerlink" title="源服务器推送文件"></a>源服务器推送文件</h4><p><strong>目标服务器增加密码文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;sgg:111&quot; &gt;&gt; /etc/rsyncd.pwd</span><br><span class="line">chmod 600 /etc/rsyncd.pwd</span><br></pre></td></tr></table></figure><p><strong>目标服务器修改配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rsyncd.conf</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auth</span> users = sgg</span><br><span class="line">secrets file = /etc/rsyncd.pwd</span><br><span class="line">read only = <span class="literal">no</span><span class="comment">#关闭只读，让别人可以写进来</span></span><br><span class="line"></span><br><span class="line">[ftp]</span><br><span class="line">       path = /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p><strong>目标服务器启动rsync</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync --daemon</span><br></pre></td></tr></table></figure><p><strong>源服务器创建client密码文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;111&quot; &gt;&gt; /etc/rsyncd.pwd.client</span><br><span class="line">chmod 600 /etc/rsyncd.pwd.client</span><br></pre></td></tr></table></figure><p><strong>源服务器推送给目标服务器</strong></p><p>与拉取比只是交换了目录和目标ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --password-file=/etc/rsyncd.pwd.client /usr/local/nginx/html/ sgg@192.168.111.101::ftp/ </span><br></pre></td></tr></table></figure><p>注意发送目录&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;最后要加‘&#x2F;‘，否则发送的是文件夹，不是文件夹下的东西</p><p><font color="cornflowerblue">现在只能增量同步</font>，若要删除源服务器没有的文件，需要加上参数实现完全同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--delete</span><br></pre></td></tr></table></figure><h4 id="inotify监控自动推送"><a href="#inotify监控自动推送" class="headerlink" title="inotify监控自动推送"></a>inotify监控自动推送</h4><p><strong>源服务器推送端安装inotify</strong></p><p>依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y automake</span><br></pre></td></tr></table></figure><p>下载上传tar包：</p><p>我的是inotify-tools-3.14.tar.gz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf inotify-tools-3.14.tar.gz</span><br></pre></td></tr></table></figure><p>configure</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd inotify-tools-3.14/</span><br><span class="line">./configure --prefix=/usr/local/inotify</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><strong>源服务器监控目录</strong></p><p>监控源服务器的&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;目录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/inotify/bin/<span class="attribute">inotifywait</span> -mrq --timefmt <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span> --format <span class="string">&#x27;%T %w%f %e&#x27;</span> -e close_write,modify,delete,create,attrib,move //usr/local/nginx/html/</span><br></pre></td></tr></table></figure><p><strong>更改目标服务器配置文件</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">uid</span> = root<span class="comment">#设置user</span></span><br><span class="line">gid = root<span class="comment">#设置用户组</span></span><br><span class="line">auth users = sgg</span><br><span class="line">secrets file = /etc/rsyncd.pwd</span><br><span class="line">read only = <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">[ftp]</span><br><span class="line">       path = /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p><strong>保证源和目标服务器rsync服务已启动且读取了最新配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep rsync</span><br><span class="line">kill -9 进程号</span><br><span class="line">rsync --daemon</span><br></pre></td></tr></table></figure><p><strong>源服务器编写简单自动化脚本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/bin</span><br><span class="line">vim autoRsync.sh</span><br></pre></td></tr></table></figure><p>内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">/usr/local/inotify/bin/inotifywait -mrq --timefmt &#x27;%d/%m/%y %H:%M&#x27; --format &#x27;%T %w%f %e&#x27; -e close_write,modify,delete,create,attrib,move //usr/local/nginx/html/ | while read file</span><br><span class="line">do</span><br><span class="line">       </span><br><span class="line">        rsync -az --delete --password-file=/etc/rsyncd.pwd.client /usr/local/nginx/html/ sgg@192.168.111.101::ftp/</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>源服务器修改文件权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 autoRsync.sh</span><br><span class="line">chmod 777 /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p><strong>启动脚本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoRsync.sh</span><br></pre></td></tr></table></figure><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p><strong>rsync 常用选项</strong></p><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">包含-rtplgoD</td></tr><tr><td align="left">-r</td><td align="left">同步目录时要加上，类似cp时的-r选项</td></tr><tr><td align="left">-v</td><td align="left">同步时显示一些信息，让我们知道同步的过程</td></tr><tr><td align="left">-l</td><td align="left">保留软连接</td></tr><tr><td align="left">-L</td><td align="left">加上该选项后，同步软链接时会把源文件给同步</td></tr><tr><td align="left">-p</td><td align="left">保持文件的权限属性</td></tr><tr><td align="left">-o</td><td align="left">保持文件的属主</td></tr><tr><td align="left">-g</td><td align="left">保持文件的属组</td></tr><tr><td align="left">-D</td><td align="left">保持设备文件信息</td></tr><tr><td align="left">-t</td><td align="left">保持文件的时间属性</td></tr><tr><td align="left">–delete</td><td align="left">删除DEST中SRC没有的文件</td></tr><tr><td align="left">–exclude</td><td align="left">过滤指定文件，如–exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步</td></tr><tr><td align="left">-P</td><td align="left">显示同步过程，比如速率，比-v更加详细</td></tr><tr><td align="left">-u</td><td align="left">加上该选项后，如果DEST中的文件比SRC新，则不同步</td></tr><tr><td align="left">-z</td><td align="left">传输时压缩</td></tr></tbody></table><p><strong>inotify常用参数</strong></p><table><thead><tr><th>参数</th><th>说明</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>–recursive</td><td>#递归查询目录</td></tr><tr><td>-q</td><td>–quiet</td><td>#打印很少的信息，仅仅打印监控事件信息</td></tr><tr><td>-m</td><td>–monitor</td><td>#始终保持事件监听状态</td></tr><tr><td>–excludei</td><td></td><td>#排除文件或目录时，不区分大小写</td></tr><tr><td>–timefmt</td><td></td><td>#指定事件输出格式</td></tr><tr><td>–format</td><td></td><td>#打印使用指定的输出类似格式字符串</td></tr><tr><td>-e</td><td>–event[ -e|–event … ]accessmodifyattribcloseopenmove_tomove createdeleteumount</td><td>#通过此参数可以指定要监控的事件 #文件或目录被读取#文件或目录的内容被修改#文件或目录属性被改变#文件或目录封闭，无论读&#x2F;写模式#文件或目录被打开#文件或目录被移动至另外一个目录#文件或目录被移动另一个目录或从另一个目录移动至当前目录#文件或目录被创建在当前目录#文件或目录被删除#文件系统被卸载</td></tr></tbody></table><h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230628204302590.png" alt="image-20230628204302590"></p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p><strong>什么时候可以用缓存？</strong></p><ol><li>不常改变的内容</li><li>过期时间</li><li>针对post&#x2F;get请求都可以</li><li>存储位置</li><li>磁盘使用空间限制</li></ol><p>观察京东缓存及加载速度</p><ul><li>deskcache</li></ul><p>字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，<strong>不会请求服务器</strong>一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况</p><ul><li>memorycache</li></ul><p>是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，<strong>不会请求服务器</strong>但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache</p><p><strong>Age</strong></p><p>是CDN添加的属性表示在CDN中缓存了多少秒</p><p><strong>via</strong></p><p>用来标识CDN缓存经历了哪些服务器，缓存是否命中，使用的协议</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p><strong>cache-control</strong></p><p>http1.1的规范，使用max-age表示文件可以在浏览器中缓存的时间以秒为单位</p><table><thead><tr><th align="left">标记</th><th>类型</th><th>功能</th></tr></thead><tbody><tr><td align="left">public</td><td>响应头</td><td>响应的数据可以被缓存，客户端和代理层都可以缓存</td></tr><tr><td align="left">private</td><td>响应头</td><td>可私有缓存，客户端可以缓存，代理层不能缓存（CDN，proxy_pass）</td></tr><tr><td align="left">no-cache</td><td>请求头</td><td>可以使用本地缓存，但是必须发送请求到服务器回源验证</td></tr><tr><td align="left">no-store</td><td>请求和响应</td><td>应禁用缓存</td></tr><tr><td align="left">max-age</td><td>请求和响应</td><td>文件可以在浏览器中缓存的时间以秒为单位</td></tr><tr><td align="left">s-maxage</td><td>请求和响应</td><td>用户代理层缓存，CDN下发，当客户端数据过期时会重新校验</td></tr><tr><td align="left">max-stale</td><td>请求和响应</td><td>缓存最大使用时间，如果缓存过期，但还在这个时间范围内则可以使用缓存数据</td></tr><tr><td align="left">min-fresh</td><td>请求和响应</td><td>缓存最小使用时间，</td></tr><tr><td align="left">must-revalidate</td><td>请求和响应</td><td>当缓存过期后，必须回源重新请求资源。比no-cache更严格。因为HTTP 规范是允许客户端在某些特殊情况下直接使用过期缓存的，比如校验请求发送失败的时候。那么带有must-revalidate的缓存必须校验，其他条件全部失效。</td></tr><tr><td align="left">proxy-revalidate</td><td>请求和响应</td><td>和must-revalidate类似，只对CDN这种代理服务器有效，客户端遇到此头，需要回源验证</td></tr><tr><td align="left">stale-while-revalidate</td><td>响应</td><td>表示在指定时间内可以先使用本地缓存，后台进行异步校验</td></tr><tr><td align="left">stale-if-error</td><td>响应</td><td>在指定时间内，重新验证时返回状态码为5XX的时候，可以用本地缓存</td></tr><tr><td align="left">only-if-cached</td><td>响应</td><td>那么只使用缓存内容，如果没有缓存 则504 getway timeout</td></tr></tbody></table><p>在浏览器和服务器端验证文件是否过期的时候，浏览器在二次请求的时候会携带IF-Modified-Since属性</p><p><strong>Expires</strong></p><p>设置强制缓存过期时间</p><p><strong>配置</strong></p><p><font color="cornflowerblue">location中</font></p><p><strong>使用expires配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expires 30s;   #缓存30秒</span><br><span class="line">expires 30m;  #缓存30分钟   </span><br><span class="line">expires 2h;     #缓存2小时</span><br><span class="line">expires 30d;    #缓存30天</span><br></pre></td></tr></table></figure><p><strong>使用cache-control</strong></p><p>优先级高于expires</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header cache-control &quot;max-age:300&quot;;#单位s</span><br></pre></td></tr></table></figure><p><font color="cornflowerblue">浏览器缓存很取决于浏览器的策略，一般只会在新标签页的首次访问才会使用强制缓存</font></p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p><strong>last-modified</strong></p><p><strong>etag</strong></p><p>http1.1支持</p><p>在HTTP协议中If-Modified-Since和If-None-Match分别对应Last-Modified和ETag</p><p>Entity Tag 的缩写，中文译过来就是实体标签的意思.</p><p>HTTP中并没有指定如何生成ETag，哈希是比较理想的选择。</p><p>在计算Etag的时候，会产生CPU的耗费，所以也可以用时间戳，但这样直接使用Last-Modified即可。</p><p>ETag 用来校验用户请求的资源是否有变化，作用和lastmodified很像，区别是lastmodified精确到秒，ETag可以用hash算法来生成更精确的比对内容。</p><p><strong>当用户首次请求资源的时候返回给用户数据和200状态码并生成ETag，再次请求的时候服务器比对ETag，没有发生变化的话返回304</strong></p><p>Cache-Control直接是通过不请求来实现，而ETag是会发请求的，只不过服务器根据请求的东西的内容有无变化来判断是否返回请求的资源</p><p><strong>配置</strong></p><p>Http1.1自带协商缓存，一般浏览器默认开启</p><p><strong>禁用协商缓存：</strong></p><p>server或location</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etag off;</span><br><span class="line">if_modified_since off;</span><br><span class="line">或</span><br><span class="line">etag off;</span><br><span class="line">add_header Last-Modified &quot;&quot;;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p><strong>cache-control | expires 强制缓存</strong></p><ul><li>浏览器缓存很取决于浏览器的策略，一般只会在新标签页的首次访问才会使用强制缓存</li></ul></li><li><p><strong>etag | lastmodify  协商缓存</strong></p><ul><li>发送请求header中携带Last-Modified，若未修改服务器会返回304 Not Modified</li></ul></li><li><p><strong>强制缓存和协商缓存可配合使用</strong></p><ul><li>首次访问使用强制缓存，用户手动刷新将会发送请求，若服务器判断未修改，则返回304</li></ul></li><li><p><strong>last-modified 会与ssi的冲突</strong></p></li><li><p><strong>浏览器缓存原则</strong></p><ul><li><p>多级集群负载时last-modified必须<strong>保持一致</strong></p></li><li><p>还有一些场景下我们希望禁用浏览器缓存。比如轮训api上报数据数据</p></li><li><p>浏览器缓存很难彻底禁用，大家的做法是加版本号，随机数等方法。</p></li><li><p>只缓存200响应头的数据，像3XX这类跳转的页面不需要缓存。</p></li><li><p>对于js，css这类可以缓存很久的数据，可以通过加版本号的方式更新内容</p></li><li><p>不需要强一致性的数据，可以缓存几秒</p></li><li><p>异步加载的接口数据，可以使用ETag来校验。</p></li><li><p>在服务器添加Server头，有利于排查错误</p></li><li><p>分为手机APP和Client以及是否遵循http协议</p></li><li><p>在没有联网的状态下可以展示数据</p></li><li><p>流量消耗过多</p></li><li><p><strong>提前下发</strong>  避免秒杀时同时下发数据造成流量短时间暴增</p></li><li><p><strong>兜底数据</strong> 在服务器崩溃和网络不可用的时候展示</p></li><li><p>临时缓存  退出即清理</p></li><li><p>固定缓存  展示框架这种，可能很长时间不会更新，可用随客户端下发</p><ul><li><strong>首页</strong>有的时候可以看做是框架，首页经常变化应该禁用缓存，以保证加载的资源都是最新的</li></ul></li><li><p>父子连接 页面跳转时有一部分内容不需要重新加载，可用从父菜单带过来</p></li><li><p>预加载     某些逻辑可用判定用户接下来的操作，那么可用异步加载那些资源</p></li><li><p>漂亮的加载过程 异步加载 先展示框架，然后异步加载内容，避免主线程阻塞</p></li></ul></li></ul><h3 id="GEOip"><a href="#GEOip" class="headerlink" title="GEOip"></a>GEOip</h3><p>根据用户的ip获取用户所在地</p><p><strong>1 下载数据库</strong></p><p>官网需注册登录,下载数据库</p><p>maxmind.com</p><p>数据库有country版和city版是免费的，商业版更精确需要收费</p><p><strong>2 安装依赖</strong></p><p>官方git<a href="https://github.com/maxmind/libmaxminddb">https://github.com/maxmind/libmaxminddb</a></p><p>下载后执行编译安装之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo /usr/local/lib  &gt;&gt; /etc/ld.so.conf.d/local.conf </span><br><span class="line">$ ldconfig</span><br></pre></td></tr></table></figure><p><strong>Nginx模块</strong></p><p><a href="https://github.com/leev/ngx_http_geoip2_module">https://github.com/leev/ngx_http_geoip2_module</a></p><p>更完整的配置可参考官方文档</p><p><a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html#geoip_proxy">http://nginx.org/en/docs/http/ngx_http_geoip_module.html#geoip_proxy</a></p><p>编译安装，不再讲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=......--with.......... --add-module=/root/ngx_http_geoip2_module</span><br></pre></td></tr></table></figure><p><strong>Nginx配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#http添加</span></span><br><span class="line"><span class="attribute">geoip2</span> /root/GeoLite2-ASN_20220524/GeoLite2-ASN.mmdb &#123;</span><br><span class="line">    $<span class="attribute">geoip2_country_code</span> country iso_code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#location添加</span></span><br><span class="line"><span class="attribute">add_header</span> country <span class="variable">$geoip2_country_code</span>;</span><br></pre></td></tr></table></figure><h3 id="正向代理配置"><a href="#正向代理配置" class="headerlink" title="正向代理配置"></a>正向代理配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server中配置google提供的DNS服务器进行解析</span></span><br><span class="line"><span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#location中</span></span><br><span class="line"><span class="attribute">proxy_pass</span> <span class="variable">$scheme</span>://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure><p>还需要在浏览器中设置代理服务器的信息，设置过后就可以正常代理访问http请求了</p><p>若要能访问https请求，还需要添加下面的模块（一般不会使用nginx作为正向代理服务器）</p><p><strong>代理https请求</strong></p><p>需要第三方模块</p><p><a href="https://github.com/chobits/ngx_http_proxy_connect_module">https://github.com/chobits/ngx_http_proxy_connect_module</a></p><p>下载后对nginx进行重新编译</p><p><strong>配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>                         <span class="number">3128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dns resolver used by forward proxying</span></span><br><span class="line">    <span class="attribute">resolver</span>                       <span class="number">8.8.8.8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># forward proxy for CONNECT request</span></span><br><span class="line">    proxy_connect;</span><br><span class="line">    <span class="attribute">proxy_connect_allow</span>            <span class="number">443</span> <span class="number">563</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_connect_timeout</span>  <span class="number">10s</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_read_timeout</span>     <span class="number">10s</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_send_timeout</span>     <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># forward proxy for non-CONNECT request</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://<span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反向代理proxy缓存"><a href="#反向代理proxy缓存" class="headerlink" title="反向代理proxy缓存"></a>反向代理proxy缓存</h3><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230628204302590.png" alt="image-20230628204302590"></p><p>将资源缓存在nginx服务器</p><p>自己的理解：<font color="cornflowerblue">与动静分离类似</font>，只不过动静分离在静态资源文件夹更新数据，而反向代理缓存则是设定的时间过期过后可以重新向tomcat发送请求拉取数据，<font color="cornflowerblue">并且缓存会缓存发起请求时的动态数据</font></p><p>官网解释</p><p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache</a></p><h4 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#http模块：</span></span><br><span class="line"><span class="attribute">proxy_cache_path</span> /ngx_tmp levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=test_cache:<span class="number">100m</span> inactive=<span class="number">1d</span> max_size=<span class="number">10g</span>;</span><br><span class="line"><span class="comment">#缓存存储目录：/ngx_tmp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#location模块：</span></span><br><span class="line"><span class="attribute">add_header</span>  Nginx-Cache <span class="string">&quot;<span class="variable">$upstream_cache_status</span>&quot;</span>;</span><br><span class="line"><span class="attribute">proxy_cache</span> test_cache;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">1h</span>;<span class="comment">#缓存过期时间</span></span><br></pre></td></tr></table></figure><h4 id="缓存清理"><a href="#缓存清理" class="headerlink" title="缓存清理"></a>缓存清理</h4><p><strong>purger</strong></p><p>手动清理缓存，需要第三方模块支持</p><p><a href="https://github.com/FRiCKLE/ngx_cache_purge">https://github.com/FRiCKLE/ngx_cache_purge</a></p><p>下载解压后使用–add-module重新编译nginx</p><p><strong>最小配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">#新增location</span></span><br><span class="line"><span class="section">location</span> <span class="regexp">~ /purge(/.*)</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attribute">proxy_cache_purge</span>  test_cache  <span class="variable">$1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">#proxy缓存配置的location中：</span></span><br><span class="line">      <span class="attribute">proxy_cache_key</span> <span class="variable">$uri</span>;<span class="comment">#自定义cachekey</span></span><br></pre></td></tr></table></figure><p>其中，proxy_cache_key为设置的key，purger会根据设置的key删除指定的缓存</p><p>目前只根据uri为key删除缓存</p><p><strong>示例：</strong></p><p>以及访问了192.168.111.100&#x2F;test.html，此时nginx缓存该页面，该页面的key为test.html，</p><p><strong>若要清除该缓存，则浏览器访问：192.168.111.100&#x2F;purge&#x2F;test.html</strong></p><p>配置以主机名+uri+参数作为key：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">#新增location</span></span><br><span class="line"><span class="section">location</span> <span class="regexp">~ /purge(/.*)</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="attribute">proxy_cache_purge</span>  test_cache  <span class="variable">$host</span><span class="variable">$1</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">#proxy缓存配置的location中：</span></span><br><span class="line">      <span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;<span class="comment">#自定义cachekey</span></span><br></pre></td></tr></table></figure><p>proxy_cache_key和proxy_cache_purge要对应修改</p><h4 id="断点续传缓存range"><a href="#断点续传缓存range" class="headerlink" title="断点续传缓存range"></a>断点续传缓存range</h4><p>当有完整的content-length之后即可断点续传</p><p>在反向代理服务器中需向后传递header</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header Range $http_range;</span><br></pre></td></tr></table></figure><p>proxy_cache_key中增加range</p><p>根据header中的Range获取对应的partial-content，会返回206</p><h4 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h4><ul><li><strong>proxy_cache_key</strong></li></ul><p>默认<code>$scheme$proxy_host$request_uri</code></p><p>缓存的key</p><ul><li><strong>proxy_cache_revalidate</strong></li></ul><p>过期后可以和协商缓存类似，如果缓存过期了，向上游服务器发送“If-Modified-Since” and “If-None-Match来验证是否改变，如果没有就不需要重新下载资源了</p><ul><li><strong>proxy_cache_valid</strong></li></ul><p>可以针对不容http状态码设置缓存过期时间</p><p>不设置状态码会默认200, 301, 302</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid 200 302 10m;</span><br><span class="line">proxy_cache_valid 301      1h;</span><br><span class="line">proxy_cache_valid any      1m;</span><br></pre></td></tr></table></figure><p>any指其他任意状态码</p><ul><li><strong>proxy_cache_use_stale</strong></li></ul><p>默认off</p><p>在什么时候可以使用过期缓存</p><p>可选<code>error</code> | <code>timeout</code> | <code>invalid_header</code> | <code>updating</code> | <code>http_500</code> | <code>http_502</code> | <code>http_503</code> | <code>http_504</code> | <code>http_403</code> | <code>http_404</code> | <code>http_429</code> | <code>off</code></p><ul><li><strong>proxy_cache_background_update</strong></li></ul><p>默认off</p><p>运行开启子请求更新过期的内容。同时会把过期的内容返回给客户端</p><ul><li><strong>proxy_no_cache</strong>  <strong>proxy_cache_bypass</strong></li></ul><p>指定什么时候不使用缓存而直接请求上游服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_no_cache $cookie_nocache $arg_nocache$arg_comment;</span><br><span class="line">proxy_no_cache $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure><p>如果这些变量如果存在的话不为空或者不等于0，则不使用缓存</p><ul><li><strong>proxy_cache_convert_head</strong></li></ul><p>默认 on</p><p>是否把head请求转换成get请求后再发送给上游服务器 以便缓存body里的内容</p><p>如果关闭 需要在 <code>cache key</code> 中添加 $request_method 以便区分缓存内容</p><ul><li><strong>proxy_cache_lock</strong></li></ul><p>默认off</p><p>缓存更新锁</p><ul><li><strong>proxy_cache_lock_age</strong></li></ul><p>默认5s</p><p>缓存锁超时时间</p><ul><li><strong>proxy_cache_max_range_offset</strong></li></ul><p>range最大值，超过之后不做缓存，默认情况下 不需要对单文件较大的资源做缓存</p><ul><li><strong>proxy_cache_methods</strong></li></ul><p>默认 head get</p><ul><li><strong>proxy_cache_min_uses</strong></li></ul><p>默认1</p><p>被请求多少次之后才做缓存</p><ul><li><strong>proxy_cache_path</strong></li></ul><p>path 指定存储目录</p><p>以cache_key取md5值</p><ul><li><strong>levels&#x3D;1:2</strong></li></ul><p>目录层级数及目录名称位数</p><p>取mdb5后几位</p><p>TMPFS</p><ul><li><strong>use_temp_path</strong></li></ul><p>默认创建缓存文件时，先向缓冲区创建临时文件，再移动到缓存目录</p><p>是否使用缓冲区</p><ul><li><strong>inactive</strong></li></ul><p>指定时间内未被访问过的缓存将被删除</p><h1 id="第二部分-高效"><a href="#第二部分-高效" class="headerlink" title="第二部分 高效"></a>第二部分 高效</h1><h2 id="Nginx内存缓存"><a href="#Nginx内存缓存" class="headerlink" title="Nginx内存缓存"></a>Nginx内存缓存</h2><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230628204302590.png" alt="image-20230628204302590"></p><p><strong>适用场景</strong>：内存高速，但是内存较小，一般应用为静态文件元数据（索引）信息缓存、热点数据缓存</p><p><strong>strace追踪内核</strong></p><p>追踪内核查看sendfile执行过程</p><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y strace</span><br></pre></td></tr></table></figure><p>追踪：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line">strace -p 进程号#nginx第一个worker的进程号</span><br></pre></td></tr></table></figure><p>sendfile执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">epoll_wait(8, [&#123;EPOLLIN, &#123;u32=1904243152, u64=140709327827408&#125;&#125;, &#123;EPOLLIN, &#123;u32=1904242704, u64=140709327826960&#125;&#125;], 512, 25215) = 2</span><br><span class="line">recvfrom(10, &quot;GET / HTTP/1.1\r\nHost: 192.168.44&quot;..., 1024, 0, NULL, NULL) = 475</span><br><span class="line">stat(&quot;/usr/local/nginx//html/index.html&quot;, &#123;st_mode=S_IFREG|0644, st_size=1429, ...&#125;) = 0</span><br><span class="line">open(&quot;/usr/local/nginx//html/index.html&quot;, O_RDONLY|O_NONBLOCK) = 11</span><br><span class="line">fstat(11, &#123;st_mode=S_IFREG|0644, st_size=1429, ...&#125;) = 0</span><br><span class="line">writev(10, [&#123;iov_base=&quot;HTTP/1.1 200 OK\r\nServer: nginx/1&quot;..., iov_len=263&#125;], 1) = 263</span><br><span class="line">sendfile(10, 11, [0] =&gt; [1429], 1429)   = 1429</span><br><span class="line">write(4, &quot;192.168.44.1 - - [27/May/2022:14&quot;..., 193) = 193</span><br><span class="line">close(11) </span><br></pre></td></tr></table></figure><p>使用sendfile，上面执行过程将不会具体读取文件内容，<font color="cornflowerblue">sendfile是使用内存的</font></p><p><strong>open_file_cache配置</strong></p><p>这里是缓存在内存中的，<strong>用于加速sendfile</strong></p><p>配置在server下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">open_file_cache</span> max=<span class="number">500</span> inactive=<span class="number">60s</span>;</span><br><span class="line"><span class="attribute">open_file_cache_min_uses</span> <span class="number">1</span>; </span><br><span class="line"><span class="attribute">open_file_cache_valid</span> <span class="number">60s</span>; </span><br><span class="line"><span class="attribute">open_file_cache_errors</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><p><strong>max</strong>缓存最大数量，超过数量后会使用LRU淘汰</p><p><strong>inactive</strong> 指定时间内未被访问过的缓存将被删除</p><p><strong>pen_file_cache_min_uses</strong></p><p>被访问到多少次后会开始缓存</p><p><strong>open_file_cache_valid</strong></p><p>间隔多长时间去检查文件是否有变化</p><p><strong>open_file_cache_errors</strong></p><p>对错误信息是否缓存</p><h2 id="Nginx外置缓存缓存"><a href="#Nginx外置缓存缓存" class="headerlink" title="Nginx外置缓存缓存"></a>Nginx外置缓存缓存</h2><p>通过网络使用其他机器的内存</p><p><a href="http://nginx.org/en/docs/http/ngx_http_memcached_module.html">http://nginx.org/en/docs/http/ngx_http_memcached_module.html</a></p><h3 id="error-page"><a href="#error-page" class="headerlink" title="error_page"></a>error_page</h3><p>指定状态码，默认指向location</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">302</span> http://www.atguigu.com;<span class="comment">#若404则返回302重定向到http://www.atguigu.com</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">200</span> /<span class="number">401</span>.html<span class="comment">#若2404则返回200然后跳转到401页面</span></span><br></pre></td></tr></table></figure><p><font color="cornflowerblue"><code>=</code>后面不能有空格</font></p><h3 id="匿名location"><a href="#匿名location" class="headerlink" title="匿名location"></a>匿名location</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> =@<span class="number">666</span>;</span><br><span class="line"><span class="section">location</span> @<span class="number">666</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> content-type <span class="string">&quot;text/html&quot;</span>;<span class="comment">#若加了content-type，浏览器就知道怎么处理文本，不加则不显示</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;hi world!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若未指定content-type，返回的返回的数据不会被展示，状态码为<strong>886</strong>，代表浏览器不知道怎么处理数据，会下载返回的数据到本机</p><p>此配置代表：若404，则跳转到自定义页面&#x2F;666&#x2F;index.html，状态码为200，网页内容为hi world!</p><h3 id="nginx-memcached"><a href="#nginx-memcached" class="headerlink" title="nginx + memcached"></a>nginx + memcached</h3><p><img src="https://www.hahhome.top/blog/Nginx%E9%AB%98%E7%BA%A7%E8%AF%BE%E7%A8%8B%E6%89%A9%E5%AE%B9%E4%B8%8E%E9%AB%98%E6%95%88/../../image/nginxadvanced.assets/image-20230629175942043.png" alt="image-20230629175942043"></p><p><strong>作用：将 <code>uri+args</code> 作为key存储在内存当中，当用户请求对应的uri时，从内存中找到后直接返回给用户，若未找到，则反向代理到上游服务器，然后将数据添加到内存中再返回给用户。</strong></p><p><code>memcached：内存缓存</code></p><p><strong>memcached安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install memcached</span><br></pre></td></tr></table></figure><p>默认配置文件在</p><p><code>/etc/sysconfig/memcached</code></p><p>查看状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start memcached</span><br><span class="line">memcached-tool 127.0.0.1:11211  stats</span><br></pre></td></tr></table></figure><p><strong>安装telnet</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install telnet</span><br></pre></td></tr></table></figure><p>向内存写东西</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211</span><br><span class="line">set [key] 0 0 3#0 0 x： x个字节</span><br><span class="line">123</span><br><span class="line">get [key]</span><br></pre></td></tr></table></figure><p>为下面nginx实验写入数据准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set /? 0 0 5</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p><strong>nginx配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">upstream</span> backend &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.44.104:8080</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">   <span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">set</span>    <span class="variable">$memcached_key</span> <span class="string">&quot;<span class="variable">$uri</span>?<span class="variable">$args</span>&quot;</span>;<span class="comment">#uri+args作为key</span></span><br><span class="line">       <span class="attribute">memcached_pass</span> <span class="number">127.0.0.1:11211</span>;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">add_header</span> X-Cache-Satus HIT;</span><br><span class="line">       <span class="attribute">add_header</span> Content-Type <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>; <span class="comment"># 强制响应数据格式为html</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># root   html;#内存中没有内容则发出请求请求数据添加到内存，不需要返回页面了</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">error_page</span> <span class="number">404</span> =<span class="variable">@fallback</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> <span class="variable">@fallback</span> &#123;</span><br><span class="line">       <span class="attribute">proxy_set_header</span> memcached_key <span class="variable">$memcached_key</span>;</span><br><span class="line">       <span class="attribute">proxy_pass</span> http://192.168.44.104:8080;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>uri+args</code> 作为key存储在内存当中，当用户请求对应的uri时，从内存中找到后直接返回给用户，若未找到，则反向代理到上游服务器，然后将数据添加到内存中再返回给用户。</p><p>这里我们是去前面手动写入第一次访问的数据12345，真实场景中需要后端tomcat服务器来写入</p><h3 id="nginx-redis"><a href="#nginx-redis" class="headerlink" title="nginx + redis"></a>nginx + redis</h3><p><font color="cornflowerblue">nginx连接redis或者mysql用于直接从nginx获取redis、mysql中的数据，简化从tomcat让tomcat连接数据库再传值回来，数据库中的值的写入由tomcat完成，nginx只需要读取就好</font><br>以上功能主要由后面讲的openresty处实现，这里主要讲外置缓存</p><p><strong>redis快速安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install -y redis</span><br></pre></td></tr></table></figure><p>也可以自己下载后规范安装：<a href="https://codeload.github.com/redis/redis/tar.gz/refs/tags/7.0.0">https://codeload.github.com/redis/redis/tar.gz/refs/tags/7.0.0</a></p><p><strong>redis2-nginx-module</strong> </p><p>redis2-nginx-module是一个支持 Redis 2.0 协议的 Nginx upstream 模块，它可以让 Nginx 以非阻塞方式直接防问远方的 Redis 服务，同时支持 TCP 协议和 Unix Domain Socket 模式，并且可以启用强大的 Redis 连接池功能。</p><p><a href="https://www.nginx.com/resources/wiki/modules/redis2/">https://www.nginx.com/resources/wiki/modules/redis2/</a></p><p><a href="https://github.com/openresty/redis2-nginx-module">https://github.com/openresty/redis2-nginx-module</a></p><p>上传后解压，重新编译nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nginx-1.21.6</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-http_gzip_static_module --add-module=/root/nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d --add-module=/root/redis2-nginx-module-0.15</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">cd objs</span><br><span class="line">mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old</span><br><span class="line">cp nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure><p><strong>启动redis</strong></p><p>规范安装示例，快速安装应该已经自动启动和配置好了redis-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在根目录下创建一个目录/myredis，并将/opt/redis-7.0.10/redis.conf文件复制到myredis目录下，保留原文件</span><br><span class="line">/myredis/redis.conf配置文件的修改：</span><br><span class="line">​1.将daemonize no 改为 daemonize yes</span><br><span class="line">​2.protected-mode yes 改为protected-mode no</span><br><span class="line">​3.注释掉bind 127.0.0.1 -::1</span><br><span class="line">​4.requirepass设置密码</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-server /myredis/redis.conf</span><br><span class="line">redis-cli</span><br><span class="line">auth [password]</span><br><span class="line">ping#若弹出pong则为连接客户端成功</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p><strong>test</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /foo &#123;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> auth <span class="number">123123</span>;<span class="comment">#自己的redis密码</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">set</span> <span class="variable">$value</span> <span class="string">&#x27;first&#x27;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> set one <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_pass</span> <span class="number">127.0.0.1:6379</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>浏览器访问192.168.111.100&#x2F;foo可以向redis中写值，根据配置，写的键值对为<code>one:fire</code></p><p><strong>get</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /get &#123;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_pass</span> <span class="number">127.0.0.1:6379</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> auth <span class="number">123123</span>;<span class="comment">#自己的redis密码</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">#set_unescape_uri $key $arg_key;  # this requires ngx_set_misc</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> get <span class="variable">$arg_key</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 192.168.111.100&#x2F;get?key&#x3D;one可获得one的值</p><p><strong>set</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET /set?key=one&amp;val=first%20value</span></span><br><span class="line"></span><br><span class="line"><span class="section">location</span> = /set &#123;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_pass</span> <span class="number">127.0.0.1:6379</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> auth <span class="number">123123</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="attribute">set_unescape_uri</span> <span class="variable">$key</span> <span class="variable">$arg_key</span>;  <span class="comment"># this requires ngx_set_misc</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">set_unescape_uri</span> <span class="variable">$val</span> <span class="variable">$arg_val</span>;  <span class="comment"># this requires ngx_set_misc</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> set <span class="variable">$key</span> <span class="variable">$val</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>pipeline</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="attribute">set</span> <span class="variable">$value</span> <span class="string">&#x27;first&#x27;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">redis2_query</span> set one <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">redis2_query</span> get one;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">redis2_query</span> set one two;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">redis2_query</span> get one;</span><br><span class="line"></span><br><span class="line"><span class="attribute">redis2_query</span> del key1;</span><br></pre></td></tr></table></figure><p><strong>list</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   redis2_query lpush key1 C;</span><br><span class="line"></span><br><span class="line">   redis2_query lpush key1 B;</span><br><span class="line"></span><br><span class="line">   redis2_query lpush key1 A;</span><br><span class="line"></span><br><span class="line">redis2_query lrange key1 <span class="number">0</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><strong>集群</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> redis_cluster &#123;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.199.161:6379</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.199.161:6379</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> = /redis &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">redis2_next_upstream</span> <span class="literal">error</span> timeout invalid_response;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">redis2_query</span> get foo;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">redis2_pass</span> redis_cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream模块为nginx反向代理mysql"><a href="#Stream模块为nginx反向代理mysql" class="headerlink" title="Stream模块为nginx反向代理mysql"></a>Stream模块为nginx反向代理mysql</h2><p><font color="red">配置文件中和http同级，是提供tcp服务的配置</font></p><p><a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html">http://nginx.org/en/docs/stream/ngx_stream_core_module.html</a></p><p>重新编译nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure ...... --with-stream </span><br><span class="line">make</span><br><span class="line">mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old</span><br><span class="line">cp objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure><p>额外开两台mysql服务器，一主一从，</p><p>配置nginx服务器stream tcp服务，和http同级</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> mysql &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.111.101:3306</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.111.102:3306</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">3306</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  mysql;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p><strong>QPS限制</strong></p><p>官方文档</p><p><a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html">http://nginx.org/en/docs/http/ngx_http_limit_req_module.html</a></p><p>测试工具</p><p><a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a></p><p>配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#http中</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=test:<span class="number">10m</span> rate=1r/s;</span><br><span class="line"><span class="comment">#zone=test：与location中zone对应</span></span><br><span class="line"><span class="comment">#rate=15r/s：限流，15qps每秒，每秒只接收15个请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#location中</span></span><br><span class="line"><span class="attribute">limit_req</span> zone=test<span class="comment">#每秒处理500个请求</span></span><br><span class="line"></span><br><span class="line">limit_req zone=test burst=<span class="number">5</span>;<span class="comment">#采用漏斗算法，允许平均每秒不超过1个请求，突发不超过5个请求。5个请求满后，后续请求全部排队，若排队超时则失败</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">limit_req</span> zone=test burst=<span class="number">5</span> nodelay;<span class="comment">#如果不希望在限制请求时延迟过多的请求，则应使用参数nodelay，不会再有排队的请求，桶外请求全部快速失败</span></span><br></pre></td></tr></table></figure><p><strong>带宽限制</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#location中：</span></span><br><span class="line"><span class="attribute">limit_rate_after</span> <span class="number">1m</span>;<span class="comment">#设置刚开始的带宽</span></span><br><span class="line"><span class="attribute">limit_rate</span> <span class="number">1k</span>;<span class="comment">#设置带宽</span></span><br></pre></td></tr></table></figure><p><strong>并发数限制</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#http中</span></span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=test2:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#location中：</span></span><br><span class="line"><span class="attribute">limit_conn</span> test2 <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li><strong>ngx_http_log_module</strong></li></ul><p><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">http://nginx.org/en/docs/http/ngx_http_log_module.html</a></p><p>默认日志目录：</p><p>正常访问日志：nignx&#x2F;logs&#x2F;access.log</p><p>错误日志：nignx&#x2F;logs&#x2F;error.log</p><p>linux可使用<code>tail -f /usr/local/nginx/logs/access.log</code>实时追踪日志文件</p><ul><li><strong>ngx_http_empty_gif_module</strong></li></ul><p><a href="http://nginx.org/en/docs/http/ngx_http_empty_gif_module.html">http://nginx.org/en/docs/http/ngx_http_empty_gif_module.html</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /_.gif &#123;</span><br><span class="line">    empty_gif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有1个像素的gif，肉眼看不出，用于收集用户的行为信息</p><h3 id="access-log配置"><a href="#access-log配置" class="headerlink" title="access.log配置"></a>access.log配置</h3><p><strong>自定义日志格式</strong></p><p>| 语法: | <code>log_format name [escape=default|json|none] string ...;</code> |<br>| :—- | ——————————————————– |<br>| 默认: | <code>log_format combined &quot;...&quot;;</code>                             |</p><p>示例：http中：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：log_format name [escape=default|json|none] string ...;</span></span><br><span class="line"><span class="attribute">log_format</span> logtest <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &#x27;</span></span><br><span class="line">                       <span class="string">&#x27;&quot;<span class="variable">$request</span>&quot; <span class="variable">$status</span> <span class="variable">$bytes_sent</span> &#x27;</span></span><br><span class="line">                       <span class="string">&#x27;&quot;<span class="variable">$http_referer</span>&quot; &quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$gzip_ratio</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>日志内容格式定义为json示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> ngxlog json <span class="string">&#x27;&#123;&quot;timestamp&quot;:&quot;<span class="variable">$time_iso8601</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;source&quot;:&quot;<span class="variable">$server_addr</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;hostname&quot;:&quot;<span class="variable">$hostname</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;remote_user&quot;:&quot;<span class="variable">$remote_user</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;ip&quot;:&quot;<span class="variable">$http_x_forwarded_for</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;client&quot;:&quot;<span class="variable">$remote_addr</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;request_method&quot;:&quot;<span class="variable">$request_method</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;scheme&quot;:&quot;<span class="variable">$scheme</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;domain&quot;:&quot;<span class="variable">$server_name</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;referer&quot;:&quot;<span class="variable">$http_referer</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;request&quot;:&quot;<span class="variable">$request_uri</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;requesturl&quot;:&quot;<span class="variable">$request</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;args&quot;:&quot;<span class="variable">$args</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;size&quot;:<span class="variable">$body_bytes_sent</span>,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;status&quot;: <span class="variable">$status</span>,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;responsetime&quot;:<span class="variable">$request_time</span>,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;upstreamtime&quot;:&quot;<span class="variable">$upstream_response_time</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;upstreamaddr&quot;:&quot;<span class="variable">$upstream_addr</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;http_user_agent&quot;:&quot;<span class="variable">$http_user_agent</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;http_cookie&quot;:&quot;<span class="variable">$http_cookie</span>&quot;,&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;https&quot;:&quot;<span class="variable">$https</span>&quot;&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>自定义日志位置和其他设置</strong></p><table><thead><tr><th align="left">语法:</th><th><code>access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];</code>            <code>access_log off;</code></th></tr></thead><tbody><tr><td align="left">default:</td><td><code>access_log logs/access.log combined;</code></td></tr></tbody></table><p>示例：http中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">access_log</span> /ngx_logs/nginx-access.log [logtest] [buffer=<span class="number">32k</span>] [gzip=<span class="number">6</span>] [flush=<span class="number">2m</span>];</span><br><span class="line"><span class="comment">#logtest：日志format，可使用log_format配置的名字来引用</span></span><br><span class="line"><span class="comment">#buffer=32k：缓冲大小32k，32k后才写入文件方括号表示可选</span></span><br><span class="line"><span class="comment">#flush=2m：若两份钟还没打到缓冲区大小，强制写入文件方括号表示可选</span></span><br><span class="line"><span class="comment">#gzip=6：将记录的日志信息进行压缩，压缩等级1-9方括号表示可选</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">open_log_file_cache</span> max=N [inactive=time] [min_uses=N] [valid=time];</span><br><span class="line"><span class="comment">#将日志文件缓存到内存中，减小磁盘的io，最多缓存max=N个日志文件</span></span><br></pre></td></tr></table></figure><p>查看使用gzip的压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 设置的或默认日志文件目录</span><br><span class="line">cp access.log access.gz</span><br><span class="line">gzip -d access.gz</span><br></pre></td></tr></table></figure><h3 id="errorlog和日志分割"><a href="#errorlog和日志分割" class="headerlink" title="errorlog和日志分割"></a>errorlog和日志分割</h3><p><strong>errorlog</strong></p><p><a href="http://nginx.org/en/docs/ngx_core_module.html#error_log">http://nginx.org/en/docs/ngx_core_module.html#error_log</a></p><table><thead><tr><th align="left">语法：</th><th><code>error_log file [level];</code></th></tr></thead><tbody><tr><td align="left"><strong>默认：</strong></td><td><strong><code>error_log logs/error.log error;</code></strong></td></tr></tbody></table><p>第二个参数决定日志记录的级别，可以是下列参数之一：debug，info，notice，warn，error，crit，alert，emerg【等级弱-&gt;强】</p><p><strong>日志分割</strong></p><p>1.脚本</p><p>2.Logrotate（CentOS自带）</p><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><h3 id="upstream被动式重试机制"><a href="#upstream被动式重试机制" class="headerlink" title="upstream被动式重试机制"></a>upstream被动式重试机制</h3><p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream</a></p><p>对upstream服务器中所有服务器的限制</p><p><strong>proxy_next_upstream</strong></p><p>设置当连接upstream服务器集群中的某个服务器第一次失败时，指定在哪些情况下将请求传递到下一个服务器</p><p>| 语法:    | <code>proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;</code> |<br>| :——- | ———————————————————— |<br>| Default: | <code>proxy_next_upstream error timeout;</code>                         |<br>| Context: | <code>http</code>, <code>server</code>, <code>location</code>                                 |</p><p><strong>proxy_next_upstream_timeout</strong></p><p>设置重试的超时时间，超时后不再重试，给用户返回错误，默认为0，即不做限制</p><table><thead><tr><th align="left">语法:</th><th><code>proxy_next_upstream_timeout time;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>proxy_next_upstream_timeout 0;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>**proxy_next_upstream_tries **</p><p>设置重试的最大次数，若超过重试次数，也不再重试，默认为0，即不做限制（proxy_next_upstream_timeout时间内允许proxy_next_upstream_tries次重试，包括第一次）</p><table><thead><tr><th align="left">语法:</th><th><code>proxy_next_upstream_tries number;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>proxy_next_upstream_tries 0;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout;</span><br><span class="line"><span class="attribute">proxy_next_upstream_timeout</span> <span class="number">15s</span>;</span><br><span class="line"><span class="attribute">proxy_next_upstream_tries</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>upstream参数</strong></p><p>对upstream中某单一服务器的限制</p><ul><li><strong>max_fails</strong></li></ul><p>最大失败次数</p><p>0为标记一直可用，不检查健康状态</p><ul><li><strong>fail_timeout</strong></li></ul><p>失败时间</p><p>当fail_timeout时间内失败了max_fails次，标记服务不可用</p><p>fail_timeout时间后会再次激活次服务</p><p>示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> httpget &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.111.101:8080</span> max_fails=<span class="number">5</span> fail_timeout=<span class="number">10s</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.111.102:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主动健康检查"><a href="#主动健康检查" class="headerlink" title="主动健康检查"></a>主动健康检查</h3><p>tengine版</p><p><a href="https://github.com/yaoweibin/nginx_upstream_check_module">https://github.com/yaoweibin/nginx_upstream_check_module</a></p><p>nginx商业版</p><p><a href="http://nginx.org/en/docs/http/ngx_http_upstream_hc_module.html">http://nginx.org/en/docs/http/ngx_http_upstream_hc_module.html</a></p><p>补丁包是1.20.1+，和原来的nginx版本不适配，所以重新装一个nginx</p><p><strong>1 下载nginx-1.20.2和nginx_upstream_check_module-0.3.0.tar.gz</strong></p><p>下载后解压</p><p><strong>2 复制check_1.20.1+.patch</strong></p><p>tengine版网页打开，选择check_1.20.1+.patch，复制到linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root</span><br><span class="line">vim path#复制到这里</span><br></pre></td></tr></table></figure><p><strong>3 执行patch修改nginx源码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.20.2</span><br><span class="line">yum install -y patch</span><br><span class="line">patch -p1 &lt; /root/path</span><br></pre></td></tr></table></figure><p><strong>4 编译新的nginx</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx20 --add-module=/root/nginx_upstream_check_module-0.3.0</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><strong>5 配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">upstream</span> backend &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.111.101:8080</span>;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.111.102:8080</span>;</span><br><span class="line">       <span class="attribute">check</span> interval=<span class="number">3000</span> rise=<span class="number">2</span> fall=<span class="number">5</span> timeout=<span class="number">1000</span> type=http;</span><br><span class="line">           <span class="attribute">check_http_send</span> <span class="string">&quot;HEAD / HTTP/1.0\r\n\r\n&quot;</span>;</span><br><span class="line">           <span class="attribute">check_http_expect_alive</span> http_2xx http_3xx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /status &#123;</span><br><span class="line">            check_status;</span><br><span class="line">            <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">     <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">         <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6 启动nginx1.20并访问</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx20/sbin/nginx -c /usr/local/nginx20/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>浏览器访问：192.168.111.100&#x2F;status</p><h2 id="Lua基础语法"><a href="#Lua基础语法" class="headerlink" title="Lua基础语法"></a>Lua基础语法</h2><p>用于 nginx二次开发+Openresty</p><p>Lua 是由巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组于1993年开发的一种轻量、小巧的脚本语言，用标准 C 语言编写，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p>官网：<a href="http://www.lua.org/">http://www.lua.org/</a></p><p><strong>IDE</strong></p><p>EmmyLua插件</p><p><a href="https://github.com/EmmyLua/IntelliJ-EmmyLua">https://github.com/EmmyLua/IntelliJ-EmmyLua</a></p><p><a href="https://emmylua.github.io/zh_CN/">https://emmylua.github.io/zh_CN/</a></p><p><strong>LDT 基于eclipse</strong></p><p><a href="https://www.eclipse.org/ldt/">https://www.eclipse.org/ldt/</a></p><p><strong>Lua基础语法</strong></p><p><strong>hello world</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>保留关键字</strong></p><p><code>and</code>       <code>break</code>     <code>do   </code> <code>else</code>      <code>elseif</code>      <code>end</code>       <code>false</code>    <code> for</code>       <code>function  if</code>      <code>in</code>        <code>local</code>     <code>nil</code>      <code>not</code>      <code>or</code>      <code>repeat</code>    <code>return</code>    <code>then</code>     <code> true</code>      <code>until</code>    <code> while</code></p><p><strong>注释</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 两个减号是行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 这是块注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 这是块注释.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> --]]</span></span><br></pre></td></tr></table></figure><p><strong>变量</strong></p><p><strong>数字类型</strong></p><p>Lua的数字只有double型，64bits</p><p>你可以以如下的方式表示数字</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">3.1416</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">314.16e-2</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0.31416E1</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0x56</span></span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><p>可以用单引号，也可以用双引号</p><p>也可以使用转义字符‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\’ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\” （单引号)等等</p><p>下面的四种方式定义了完全相同的字符串（其中的两个中括号可以用于定义有换行的字符串）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#x27;alo\n123&quot;&#x27;</span><br><span class="line"></span><br><span class="line">a = &quot;alo\n123\&quot;&quot;</span><br><span class="line"></span><br><span class="line">a = &#x27;\97lo\10\04923&quot;&#x27;</span><br><span class="line"></span><br><span class="line">a = [[alo</span><br><span class="line"></span><br><span class="line">123&quot;]]</span><br></pre></td></tr></table></figure><p><strong>空值</strong></p><p>C语言中的NULL在Lua中是nil，比如你访问一个没有声明过的变量，就是nil</p><p><strong>布尔类型</strong></p><p>只有nil和false是 false</p><p>数字0，‘’空字符串（’\0’）都是true</p><p><strong>作用域</strong></p><p>lua中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。</p><p>变量前加local关键字的是局部变量。</p><p><strong>控制语句</strong></p><p><strong>while循环</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">max</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="built_in">max</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">i = i +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>if-else</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> age = <span class="number">140</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> sex = <span class="string">&#x27;Male&#x27;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> age == <span class="number">40</span> <span class="keyword">and</span> sex ==<span class="string">&quot;Male&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 男人四十一枝花 &quot;</span>)</span><br><span class="line">  <span class="keyword">elseif</span> age &gt; <span class="number">60</span> <span class="keyword">and</span> sex ~=<span class="string">&quot;Female&quot;</span> <span class="keyword">then</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;old man!!&quot;</span>)</span><br><span class="line">  <span class="keyword">elseif</span> age &lt; <span class="number">20</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;too young, too simple!\n&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Your age is &quot;</span>..age)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>for循环</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">100</span>, <span class="number">1</span>, <span class="number">-2</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">sum = sum + i</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>函数</strong></p><ol><li></li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPower</span><span class="params">(x,y)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>      y+x</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">power2 = myPower(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"> <span class="built_in">print</span>(power2)</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>     <span class="comment">-- anonymous function</span></span><br><span class="line"></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">c1 = newCounter()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1())</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name, age,bGay = <span class="string">&quot;yiming&quot;</span>, <span class="number">37</span>, <span class="literal">false</span>, <span class="string">&quot;yimingl@hotmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name,age,bGay)</span><br></pre></td></tr></table></figure> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMyGirl</span><span class="params">(name)</span></span></span><br><span class="line">  <span class="keyword">return</span> name == <span class="string">&#x27;xiao6&#x27;</span> , name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> bol,name = isMyGirl(<span class="string">&#x27;xiao6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name,bol)</span><br></pre></td></tr></table></figure><p><strong>Table</strong></p><p>key，value的键值对 类似 map</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">dog = &#123;name=<span class="string">&#x27;111&#x27;</span>,age=<span class="number">18</span>,height=<span class="number">165.5</span>&#125;</span><br><span class="line"></span><br><span class="line">dog.age=<span class="number">35</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.name,dog.age,dog.height)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">arr = &#123;<span class="string">&quot;string&quot;</span>, <span class="number">100</span>, <span class="string">&quot;dog&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;wangwang!&quot;</span>) <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">end</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">4</span>]())</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;<span class="string">&quot;string&quot;</span>, <span class="number">100</span>, <span class="string">&quot;dog&quot;</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;wangwang!&quot;</span>) <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">end</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(arr) <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(k, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">person = &#123;name=<span class="string">&#x27;旺财&#x27;</span>,age = <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">person.eat</span><span class="params">(food)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(person.name ..<span class="string">&quot; eating &quot;</span>..food)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">person.eat(<span class="string">&quot;骨头&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Openresty-Nginx-Lua"><a href="#Openresty-Nginx-Lua" class="headerlink" title="Openresty Nginx + Lua"></a>Openresty Nginx + Lua</h2><p>Nginx是一个主进程配合多个工作进程的工作模式，每个进程由单个线程来处理多个连接。</p><p>在生产环境中，我们往往会把cpu内核直接绑定到工作进程上，从而提升性能。</p><h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><p><strong>预编译安装</strong></p><p>以CentOS举例 其他系统参照：<a href="http://openresty.org/cn/linux-packages.html">http://openresty.org/cn/linux-packages.html</a></p><p>你可以在你的 CentOS 系统中添加 openresty 仓库，这样就可以便于未来安装或更新我们的软件包（通过 yum update 命令）。运行下面的命令就可以添加我们的仓库：</p><p>      yum install yum-utils</p><p>      yum-config-manager –add-repo <a href="https://openresty.org/package/centos/openresty.repo">https://openresty.org/package/centos/openresty.repo</a></p><p>然后就可以像下面这样安装软件包，比如 openresty：</p><p>   yum install openresty</p><p>如果你想安装命令行工具 resty，那么可以像下面这样安装 openresty-resty 包：</p><p>      sudo yum install openresty-resty</p><p><strong>源码编译安装</strong></p><p><strong>下载</strong></p><p><a href="http://openresty.org/cn/download.html">http://openresty.org/cn/download.html</a></p><p>最小版本基于nginx1.21</p><p>然后在进入 <code>openresty-VERSION/ </code>目录, 然后输入以下命令配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/openresty</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>默认, <code>--prefix=/usr/local/openresty</code> 程序会被安装到<code>/usr/local/openresty</code>目录。</p><p>依赖 <code>gcc openssl-devel pcre-devel zlib-devel</code></p><p>安装：<code>yum install gcc openssl-devel pcre-devel zlib-devel postgresql-devel</code></p><p>您可以指定各种选项，比如</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/openresty \</span><br><span class="line"></span><br><span class="line">            --with-luajit \</span><br><span class="line"></span><br><span class="line">            --without-http_redis2_module \</span><br><span class="line"></span><br><span class="line">            --with-http_iconv_module \</span><br><span class="line"></span><br><span class="line">            --with-http_postgres_module</span><br></pre></td></tr></table></figure><p>试着使用 <code>./configure --help</code> 查看更多的选项。</p><p><code>make &amp;&amp; make install</code></p><p><strong>启动</strong></p><p><code>Service openresty start</code></p><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/openresty/nginx/sbin</span><br><span class="line">./nginx -c /usr/local/openresty/nginx/conf/nginx.conf#启动前修改配置文件端口号以防和原nginx冲突</span><br></pre></td></tr></table></figure><p><strong>停止</strong></p><p><code>Service openresty stop</code></p><p><strong>检查配置文件是否正确</strong></p><p><code>Nginx -t</code></p><p> 重新加载配置文件</p><p><code>Service openresty reload</code></p><p><strong>查看已安装模块和版本号</strong></p><p><code>Nginx -V</code></p><p><strong>测试lua脚本</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Nginx.conf 中写入</span></span><br><span class="line"><span class="section">location</span> /lua &#123;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">default_type</span> text/html;</span><br><span class="line">     <span class="attribute">content_by_lua</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">        ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)</span></span><br><span class="line"><span class="string">      &#x27;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不在配置文件写lua，引入lua文件：nginx目录下的lua&#x2F;hello.lua</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">content_by_lua_file</span> lua/hello.lua;</span><br></pre></td></tr></table></figure><h3 id="lua-nginx-module"><a href="#lua-nginx-module" class="headerlink" title="lua-nginx-module"></a>lua-nginx-module</h3><h4 id="引入lua环境"><a href="#引入lua环境" class="headerlink" title="引入lua环境"></a>引入lua环境</h4><p><strong>创建配置文件lua.conf（没必要采用引入方式，直接在nginx配置文件中写location &#x2F;lua 即可）</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">   <span class="section">location</span> /lua &#123;</span><br><span class="line">        <span class="attribute">default_type</span> text/html;</span><br><span class="line">        <span class="attribute">content_by_lua_file</span> lua/hello.lua;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在Nginx.conf下引入lua配置</strong></p><p><code>include       lua.conf;</code></p><p><strong>创建外部lua脚本</strong></p><p><code>nginx目录下的lua/hello.lua</code></p><p>内容：</p><p><code>ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)</code></p><p><strong>代码热部署</strong></p><p>关闭缓存，开启热部署，不用每次都重启openresty nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_code_cache off;</span><br></pre></td></tr></table></figure><h4 id="用lua代码获取各值"><a href="#用lua代码获取各值" class="headerlink" title="用lua代码获取各值"></a>用lua代码获取各值</h4><p><strong>获取Nginx uri中的单一变量</strong></p> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /nginx_var &#123;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">default_type</span> text/html;</span><br><span class="line">      <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">      ngx.say(ngx.var.arg_a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取Nginx uri中的所有变量</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()  </span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(uri_args) <span class="keyword">do</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span>  </span><br><span class="line">        ngx.say(k, <span class="string">&quot; : &quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">&quot;, &quot;</span>), <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        ngx.say(k, <span class="string">&quot;: &quot;</span>, v, <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>在处理http请求时还可以使用</strong></p><ul><li>set_by_lua</li></ul><p>修改nginx变量</p><ul><li>rewrite_by_lua</li></ul><p>修改uri</p><ul><li>access_by_lua</li></ul><p>访问控制</p><ul><li>header_filter_by_lua</li></ul><p>修改响应头</p><ul><li>boy_filter_by_lua</li></ul><p>修改响应体</p><ul><li>log_by_lua</li></ul><p>日志</p><p><strong>获取Nginx请求头信息</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> headers = ngx.req.get_headers()                         </span><br><span class="line"></span><br><span class="line">ngx.say(<span class="string">&quot;Host : &quot;</span>, headers[<span class="string">&quot;Host&quot;</span>], <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line">ngx.say(<span class="string">&quot;user-agent : &quot;</span>, headers[<span class="string">&quot;user-agent&quot;</span>], <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line">ngx.say(<span class="string">&quot;user-agent : &quot;</span>, headers.user_agent, <span class="string">&quot;&lt;br/&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(headers) <span class="keyword">do</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span>  </span><br><span class="line"></span><br><span class="line">        ngx.say(k, <span class="string">&quot; : &quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line"></span><br><span class="line">        ngx.say(k, <span class="string">&quot; : &quot;</span>, v, <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure><p><strong>获取post请求参数</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.read_body()  </span><br><span class="line"></span><br><span class="line">ngx.say(<span class="string">&quot;post args begin&quot;</span>, <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> post_args = ngx.req.get_post_args()  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(post_args) <span class="keyword">do</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span>  </span><br><span class="line"></span><br><span class="line">        ngx.say(k, <span class="string">&quot; : &quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">&quot;, &quot;</span>), <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line"></span><br><span class="line">        ngx.say(k, <span class="string">&quot;: &quot;</span>, v, <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>http协议版本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&quot;ngx.req.http_version : &quot;</span>, ngx.req.http_version(), <span class="string">&quot;&lt;br/&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>请求方法</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&quot;ngx.req.get_method : &quot;</span>, ngx.req.get_method(), <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br></pre></td></tr></table></figure><p><strong>原始的请求头内容</strong>  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&quot;ngx.req.raw_header : &quot;</span>,  ngx.req.raw_header(), <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br></pre></td></tr></table></figure><p><strong>body内容体</strong>  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&quot;ngx.req.get_body_data() : &quot;</span>, ngx.req.get_body_data(), <span class="string">&quot;&lt;br/&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h3><h4 id="Nginx全局内存缓存"><a href="#Nginx全局内存缓存" class="headerlink" title="Nginx全局内存缓存"></a>Nginx全局内存缓存</h4><p>nginx配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lua_shared_dict</span> shared_data <span class="number">1m</span>;<span class="comment">#http中</span></span><br></pre></td></tr></table></figure><p>lua文件代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> shared_data = ngx.shared.shared_data  </span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> i = shared_data:get(<span class="string">&quot;i&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">then</span>  </span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    shared_data:set(<span class="string">&quot;i&quot;</span>, i)  </span><br><span class="line"></span><br><span class="line">    ngx.say(<span class="string">&quot;lazy set i &quot;</span>, i, <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">i = shared_data:incr(<span class="string">&quot;i&quot;</span>, <span class="number">1</span>)  </span><br><span class="line"></span><br><span class="line">ngx.say(<span class="string">&quot;i=&quot;</span>, i, <span class="string">&quot;&lt;br/&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="lua-resty-lrucache"><a href="#lua-resty-lrucache" class="headerlink" title="lua-resty-lrucache"></a>lua-resty-lrucache</h4><p>Lua 实现的一个简单的 LRU 缓存，适合在 Lua 空间里直接缓存较为复杂的 Lua 数据结构：它相比 ngx_lua 共享内存字典可以省去较昂贵的序列化操作，相比 memcached 这样的外部服务又能省去较昂贵的 socket 操作</p><p><a href="https://github.com/openresty/lua-resty-lrucache">https://github.com/openresty/lua-resty-lrucache</a></p><p>新建文件cache.lua</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/openresty/lualib</span><br><span class="line">mkdir my</span><br><span class="line">cd my</span><br><span class="line">vim cache.lua#内容写下面lua文件代码</span><br></pre></td></tr></table></figure><p>lua文件代码：自定义函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">lrucache = <span class="built_in">require</span> <span class="string">&quot;resty.lrucache&quot;</span></span><br><span class="line"></span><br><span class="line">c, err = lrucache.new(<span class="number">200</span>)  <span class="comment">-- allow up to 200 items in the cache</span></span><br><span class="line">ngx.say(<span class="string">&quot;count=init&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> c <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;failed to create the cache: &quot;</span> .. (err <span class="keyword">or</span> <span class="string">&quot;unknown&quot;</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.go</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">count = c:get(<span class="string">&quot;count&quot;</span>)</span><br><span class="line"></span><br><span class="line">c:set(<span class="string">&quot;count&quot;</span>,<span class="number">100</span>)</span><br><span class="line">ngx.say(<span class="string">&quot;count=&quot;</span>, count, <span class="string">&quot; --&lt;br/&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> count <span class="keyword">then</span>  </span><br><span class="line"></span><br><span class="line">    c:set(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ngx.say(<span class="string">&quot;lazy set count &quot;</span>, c:get(<span class="string">&quot;count&quot;</span>), <span class="string">&quot;&lt;br/&gt;&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">c:set(<span class="string">&quot;count&quot;</span>,count+<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">ngx.say(<span class="string">&quot;count=&quot;</span>, count, <span class="string">&quot;&lt;br/&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><p>nginx配置文件引用lua文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释掉http中的代码热部署，否则lua文件中每次都会new一个新对象</span></span><br><span class="line"><span class="comment">#lua_code_cache off;</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> shared_data <span class="number">1m</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /lua &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">#content_by_lua_file lua/hello.lua;#需注释，否则与lua_block冲突</span></span><br><span class="line">        </span><br><span class="line">    <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">    require(&quot;my/cache&quot;).go()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lua-resty-redis访问redis"><a href="#lua-resty-redis访问redis" class="headerlink" title="lua-resty-redis访问redis"></a>lua-resty-redis访问redis</h3><p><font color="cornflowerblue">nginx连接redis或者mysql用于直接从nginx获取redis、mysql中的数据，简化从tomcat让tomcat连接数据库再传值回来，数据库中的值的写入由tomcat完成，nginx只需要读取就好</font></p><p><a href="https://github.com/openresty/lua-resty-redis">https://github.com/openresty/lua-resty-redis</a></p><p>除了lua-resty-redis可以连接redis，也可以用前面讲的redis2-nginx-module</p><p><strong>常用方法</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> res, err = red:get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> res, err = red:lrange(<span class="string">&quot;nokey&quot;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ngx.say(<span class="string">&quot;res:&quot;</span>,cjson.encode(res))</span><br></pre></td></tr></table></figure><p><strong>创建连接</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red, err = redis:new()</span><br><span class="line"></span><br><span class="line">ok, err = red:connect(host, port, options_table?)</span><br></pre></td></tr></table></figure><p><strong>timeout</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red:set_timeout(<span class="built_in">time</span>)</span><br></pre></td></tr></table></figure><p><strong>keepalive</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red:set_keepalive(max_idle_timeout, pool_size)</span><br></pre></td></tr></table></figure><p><strong>close</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok, err = red:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p><strong>pipeline</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red:init_pipeline()</span><br><span class="line"></span><br><span class="line">results, err = red:commit_pipeline()</span><br></pre></td></tr></table></figure><p><strong>认证</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">local</span> res, err = red:auth(<span class="string">&quot;foobared&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">       ngx.say(<span class="string">&quot;failed to authenticate: &quot;</span>, err)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>nginx配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content_by_lua_file lua/redis.lua</span><br></pre></td></tr></table></figure><p><strong>redis.lua</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line">            <span class="keyword">local</span> red = redis:new()</span><br><span class="line"></span><br><span class="line">            red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>) <span class="comment">-- 1 sec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;failed to connect: &quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">red:auth(<span class="string">&quot;123123&quot;</span>) <span class="comment">--redis有密码需要输入密码，没密码删除此行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--业务代码，根据实际情况修改</span></span><br><span class="line">            ok, err = red:set(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;an animal&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;failed to set dog: &quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            ngx.say(<span class="string">&quot;set result: &quot;</span>, ok)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">local</span> res, err = red:get(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;failed to get dog: &quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> res == ngx.null <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;dog not found.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ngx.say(<span class="string">&quot;dog: &quot;</span>, res)</span><br></pre></td></tr></table></figure><p><strong>redis-cluster支持</strong></p><p><a href="https://github.com/steve0511/resty-redis-cluster">https://github.com/steve0511/resty-redis-cluster</a></p><h3 id="redis2-nginx-module"><a href="#redis2-nginx-module" class="headerlink" title="redis2-nginx-module"></a>redis2-nginx-module</h3><p>redis2-nginx-module是一个支持 Redis 2.0 协议的 Nginx upstream 模块，它可以让 Nginx 以非阻塞方式直接防问远方的 Redis 服务，同时支持 TCP 协议和 Unix Domain Socket 模式，并且可以启用强大的 Redis 连接池功能。</p><p><strong>test</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /foo &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> auth <span class="number">123123</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">set</span> <span class="variable">$value</span> <span class="string">&#x27;first&#x27;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> set one <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_pass</span> <span class="number">192.168.199.161:6379</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>get</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /get &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_pass</span> <span class="number">192.168.199.161:6379</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> auth <span class="number">123123</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">set_unescape_uri</span> <span class="variable">$key</span> <span class="variable">$arg_key</span>;  <span class="comment"># this requires ngx_set_misc</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> get <span class="variable">$key</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>set</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET /set?key=one&amp;val=first%20value</span></span><br><span class="line"></span><br><span class="line"><span class="section">location</span> = /set &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line"><span class="attribute">redis2_pass</span> <span class="number">192.168.199.161:6379</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">redis2_query</span> auth <span class="number">123123</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="attribute">set_unescape_uri</span> <span class="variable">$key</span> <span class="variable">$arg_key</span>;  <span class="comment"># this requires ngx_set_misc</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">set_unescape_uri</span> <span class="variable">$val</span> <span class="variable">$arg_val</span>;  <span class="comment"># this requires ngx_set_misc</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> set <span class="variable">$key</span> <span class="variable">$val</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>pipeline</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     <span class="attribute">set</span> <span class="variable">$value</span> <span class="string">&#x27;first&#x27;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> set one <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> get one;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> set one two;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">redis2_query</span> get one;</span><br><span class="line"></span><br><span class="line"><span class="attribute">redis2_query</span> del key1;</span><br></pre></td></tr></table></figure><p><strong>list</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    redis2_query lpush key1 C;</span><br><span class="line"></span><br><span class="line">    redis2_query lpush key1 B;</span><br><span class="line"></span><br><span class="line">    redis2_query lpush key1 A;</span><br><span class="line"></span><br><span class="line">redis2_query lrange key1 <span class="number">0</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><hr><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> redis_cluster &#123;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.199.161:6379</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.199.161:6379</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> = /redis &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">         <span class="attribute">redis2_next_upstream</span> <span class="literal">error</span> timeout invalid_response;</span><br><span class="line"></span><br><span class="line">         <span class="attribute">redis2_query</span> get foo;</span><br><span class="line"></span><br><span class="line">         <span class="attribute">redis2_pass</span> redis_cluster;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="lua-resty-mysql"><a href="#lua-resty-mysql" class="headerlink" title="lua-resty-mysql"></a>lua-resty-mysql</h3><p><font color="cornflowerblue">nginx连接redis或者mysql用于直接从nginx获取redis、mysql中的数据，简化从tomcat让tomcat连接数据库再传值回来，数据库中的值的写入由tomcat完成，nginx只需要读取就好</font></p><p> <a href="https://github.com/openresty/lua-resty-mysql">https://github.com/openresty/lua-resty-mysql</a></p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mysql = <span class="built_in">require</span> <span class="string">&quot;resty.mysql&quot;</span></span><br><span class="line">            <span class="keyword">local</span> db, err = mysql:new()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> db <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;failed to instantiate mysql: &quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            db:set_timeout(<span class="number">1000</span>) <span class="comment">-- 1 sec</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">--自己的mysql信息</span></span><br><span class="line">            <span class="keyword">local</span> ok, err, errcode, sqlstate = db:connect&#123;</span><br><span class="line">                host = <span class="string">&quot;192.168.111.100&quot;</span>,</span><br><span class="line">                port = <span class="number">3306</span>,</span><br><span class="line">                database = <span class="string">&quot;zhangmen&quot;</span>,</span><br><span class="line">                user = <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                password = <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                charset = <span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">                max_packet_size = <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            ngx.say(<span class="string">&quot;connected to mysql.&lt;br&gt;&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">--业务代码，根据实际情况修改</span></span><br><span class="line">            <span class="keyword">local</span> res, err, errcode, sqlstate = db:query(<span class="string">&quot;drop table if exists cats&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;bad result: &quot;</span>, err, <span class="string">&quot;: &quot;</span>, errcode, <span class="string">&quot;: &quot;</span>, sqlstate, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            res, err, errcode, sqlstate =</span><br><span class="line">                db:query(<span class="string">&quot;create table cats &quot;</span></span><br><span class="line">                         .. <span class="string">&quot;(id serial primary key, &quot;</span></span><br><span class="line">                         .. <span class="string">&quot;name varchar(5))&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;bad result: &quot;</span>, err, <span class="string">&quot;: &quot;</span>, errcode, <span class="string">&quot;: &quot;</span>, sqlstate, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            ngx.say(<span class="string">&quot;table cats created.&lt;br&gt;&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            res, err, errcode, sqlstate =</span><br><span class="line">                db:query(<span class="string">&quot;select * from t_emp&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;bad result: &quot;</span>, err, <span class="string">&quot;: &quot;</span>, errcode, <span class="string">&quot;: &quot;</span>, sqlstate, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br><span class="line">            ngx.say(<span class="string">&quot;result: &quot;</span>, cjson.encode(res))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">local</span> ok, err = db:set_keepalive(<span class="number">10000</span>, <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">                ngx.say(<span class="string">&quot;failed to set keepalive: &quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="模板实时渲染-lua-resty-template"><a href="#模板实时渲染-lua-resty-template" class="headerlink" title="模板实时渲染 lua-resty-template"></a>模板实时渲染 lua-resty-template</h2><p><a href="https://github.com/bungle/lua-resty-template">https://github.com/bungle/lua-resty-template</a></p><p>如果学习过JavaEE中的servlet和JSP的话，应该知道JSP模板最终会被翻译成Servlet来执行；</p><p>而lua-resty-template模板引擎可以认为是JSP，其最终会被翻译成Lua代码，然后通过ngx.print输出。   </p><p>lua-resty-template大体内容有： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">l   模板位置：从哪里查找模板； </span><br><span class="line"></span><br><span class="line">l   变量输出/转义：变量值输出； </span><br><span class="line"></span><br><span class="line">l   代码片段：执行代码片段，完成如if/else、for等复杂逻辑，调用对象函数/方法； </span><br><span class="line"></span><br><span class="line">l   注释：解释代码片段含义； </span><br><span class="line"></span><br><span class="line">l   include：包含另一个模板片段； </span><br><span class="line"></span><br><span class="line">l   其他：lua-resty-template还提供了不需要解析片段、简单布局、可复用的代码块、宏指令等支持。</span><br><span class="line"></span><br><span class="line">基础语法</span><br><span class="line"></span><br><span class="line">l   &#123;(include_file)&#125;：包含另一个模板文件；</span><br><span class="line"></span><br><span class="line">l   &#123;* var *&#125;：变量输出；</span><br><span class="line"></span><br><span class="line">l   &#123;&#123; var &#125;&#125;：变量转义输出；</span><br><span class="line"></span><br><span class="line">l   &#123;% code %&#125;：代码片段；</span><br><span class="line"></span><br><span class="line">l   &#123;# comment #&#125;：注释；</span><br><span class="line"></span><br><span class="line">l   &#123;-raw-&#125;：中间的内容不会解析，作为纯文本输出；</span><br></pre></td></tr></table></figure><h3 id="准备和简单测试"><a href="#准备和简单测试" class="headerlink" title="准备和简单测试"></a>准备和简单测试</h3><p><strong>解压移动模板引擎到openresty&#x2F;resty目录下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/openresty/lualib</span><br><span class="line"></span><br><span class="line">上传下载好的 lua-resty-template-2.0.tar.gz</span><br><span class="line">tar -zxvf lua-resty-template-2.0.tar.gz</span><br><span class="line">cd lua-resty-template-2.0/lib/resty</span><br><span class="line">mv template/ template.lua /usr/local/openresty/lualib/resty</span><br></pre></td></tr></table></figure><p><strong>写模板</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/openresty</span><br><span class="line">mkdir tpl</span><br><span class="line">cd tpl</span><br><span class="line">vim view.html#新建模板</span><br></pre></td></tr></table></figure><p>view.html内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>nginx.conf中配置</strong></p><p>lua代码热加载</p><p>在http模块中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_code_cache off;</span><br></pre></td></tr></table></figure><p>reload后Nginx会提示影响性能，记得在生产环境中关掉。</p><p>配置模板文件存放位置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /lua &#123;</span><br><span class="line">...</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$template_root</span> /usr/local/openresty/tpl;</span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/tpl.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写lua文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/openresty/nginx/lua</span><br><span class="line">vim tpl.lua</span><br></pre></td></tr></table></figure><p>tpl.lua内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Using template.new</span></span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span> <span class="string">&quot;resty.template&quot;</span></span><br><span class="line"><span class="keyword">local</span> view = template.new <span class="string">&quot;view.html&quot;</span><span class="comment">--读取前面写的模板view.html</span></span><br><span class="line">view.message = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">view:render()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using template.render</span></span><br><span class="line"><span class="comment">-- template.render(&quot;view.html&quot;, &#123; message = &quot;Hel11lo, Worl1d!&quot; &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>重启openresty nginx</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/openresty/nginx/sbin/</span><br><span class="line">./nginx -s stop</span><br><span class="line">./nginx -c /usr/local/openresty/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="其他测试配置"><a href="#其他测试配置" class="headerlink" title="其他测试配置"></a>其他测试配置</h3><p><strong>一、初始化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- Using template.new</span><br><span class="line">local template = require &quot;resty.template&quot;</span><br><span class="line">local view = template.new &quot;view.html&quot;</span><br><span class="line">view.message = &quot;Hello, World!&quot;</span><br><span class="line">view:render()</span><br><span class="line"></span><br><span class="line">-- Using template.render</span><br><span class="line">-- template.render(&quot;view.html&quot;, &#123; message = &quot;Hel11lo, Worl1d!&quot; &#125;)</span><br></pre></td></tr></table></figure><p><strong>二、执行函数，得到渲染之后的内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local func = template.compile(&quot;view.html&quot;)  </span><br><span class="line"></span><br><span class="line">local content = func(context)  </span><br><span class="line"></span><br><span class="line">ngx.say(&quot;xx:&quot;,content) </span><br></pre></td></tr></table></figure><p><strong>resty.template.html</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">&quot;resty.template&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> html = <span class="built_in">require</span> <span class="string">&quot;resty.template.html&quot;</span></span><br><span class="line"></span><br><span class="line">template.render(<span class="string">[[</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&#123;% for _, person in ipairs(context) do %&#125;</span></span><br><span class="line"><span class="string">    &#123;*html.li(person.name)*&#125; --</span></span><br><span class="line"><span class="string">&#123;% end %&#125;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;table&gt;</span></span><br><span class="line"><span class="string">&#123;% for _, person in ipairs(context) do %&#125;</span></span><br><span class="line"><span class="string">    &lt;tr data-sort=&quot;&#123;&#123;(person.name or &quot;&quot;):lower()&#125;&#125;&quot;&gt;</span></span><br><span class="line"><span class="string">        &#123;*html.td&#123; id = person.id &#125;(person.name)*&#125;</span></span><br><span class="line"><span class="string">    &lt;/tr&gt;</span></span><br><span class="line"><span class="string">&#123;% end %&#125;</span></span><br><span class="line"><span class="string">&lt;/table&gt;]]</span>, &#123;</span><br><span class="line">    &#123; id = <span class="number">1</span>, name = <span class="string">&quot;Emma&quot;</span>&#125;,</span><br><span class="line">    &#123; id = <span class="number">2</span>, name = <span class="string">&quot;James&quot;</span> &#125;,</span><br><span class="line">    &#123; id = <span class="number">3</span>, name = <span class="string">&quot;Nicholas&quot;</span> &#125;,</span><br><span class="line">    &#123; id = <span class="number">4</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>模板内容</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多值传入</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template.caching(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">&quot;resty.template&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">    name = <span class="string">&quot;lucy&quot;</span>,</span><br><span class="line">    age = <span class="number">50</span>,</span><br><span class="line">&#125;</span><br><span class="line">template.render(<span class="string">&quot;view.html&quot;</span>, context)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>模板内容</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;name:&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;h1&gt;age:&#123;&#123;age&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>模板管理与缓存</strong></p><p>模板缓存：默认开启，开发环境可以手动关闭</p><p><code>template.caching(true)</code></p><p>模板文件需要业务系统更新与维护，当模板文件更新后，可以通过模板版本号或消息通知Openresty清空缓存重载模板到内存中</p><p><code>template.cache = &#123;&#125;</code></p><h3 id="完整配置示例"><a href="#完整配置示例" class="headerlink" title="完整配置示例"></a>完整配置示例</h3><p><strong>完整页面</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">&quot;resty.template&quot;</span>)</span><br><span class="line">template.caching(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">    title = <span class="string">&quot;测试&quot;</span>,</span><br><span class="line">    name = <span class="string">&quot;lucy&quot;</span>,</span><br><span class="line">    description = <span class="string">&quot;&lt;script&gt;alert(1);&lt;/script&gt;&quot;</span>,</span><br><span class="line">    age = <span class="number">40</span>,</span><br><span class="line">    hobby = &#123;<span class="string">&quot;电影&quot;</span>, <span class="string">&quot;音乐&quot;</span>, <span class="string">&quot;阅读&quot;</span>&#125;,</span><br><span class="line">    score = &#123;语文 = <span class="number">90</span>, 数学 = <span class="number">80</span>, 英语 = <span class="number">70</span>&#125;,</span><br><span class="line">    score2 = &#123;</span><br><span class="line">        &#123;name = <span class="string">&quot;语文&quot;</span>, score = <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;name = <span class="string">&quot;数学&quot;</span>, score = <span class="number">80</span>&#125;,</span><br><span class="line">        &#123;name = <span class="string">&quot;英语&quot;</span>, score = <span class="number">70</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template.render(<span class="string">&quot;view.html&quot;</span>, context)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>模板</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;(header.html)&#125;  <span class="comment">&lt;!--引入页面，自己随便写一个，再view.html同目录--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">      &#123;# 不转义变量输出 #&#125;  </span><br><span class="line">      姓名：&#123;* string.upper(name) *&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span>  </span><br><span class="line">      &#123;# 转义变量输出 #&#125;  </span><br><span class="line">      简介：&#123;&#123;description&#125;&#125;</span><br><span class="line">           简介：&#123;* description *&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span>  </span><br><span class="line">      &#123;# 可以做一些运算 #&#125;  </span><br><span class="line">      年龄: &#123;* age + 10 *&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span>  </span><br><span class="line">      &#123;# 循环输出 #&#125;  </span><br><span class="line">      爱好：  </span><br><span class="line">      &#123;% for i, v in ipairs(hobby) do %&#125;  </span><br><span class="line">         &#123;% if v == &#x27;电影&#x27; then  %&#125; - xxoo</span><br><span class="line">            </span><br><span class="line">              &#123;%else%&#125;  - &#123;* v *&#125; </span><br><span class="line">&#123;% end %&#125;  </span><br><span class="line">         </span><br><span class="line">      &#123;% end %&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span>  </span><br><span class="line">  </span><br><span class="line">      成绩：  </span><br><span class="line">      &#123;% local i = 1; %&#125;  </span><br><span class="line">      &#123;% for k, v in pairs(score) do %&#125;  </span><br><span class="line">         &#123;% if i &gt; 1 then %&#125;，&#123;% end %&#125;  </span><br><span class="line">         &#123;* k *&#125; = &#123;* v *&#125;  </span><br><span class="line">         &#123;% i = i + 1 %&#125;  </span><br><span class="line">      &#123;% end %&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span>  </span><br><span class="line">      成绩2：  </span><br><span class="line">      &#123;% for i = 1, #score2 do local t = score2[i] %&#125;  </span><br><span class="line">         &#123;% if i &gt; 1 then %&#125;，&#123;% end %&#125;  </span><br><span class="line">          &#123;* t.name *&#125; = &#123;* t.score *&#125;  </span><br><span class="line">      &#123;% end %&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span>  </span><br><span class="line">      &#123;# 中间内容不解析 #&#125;  </span><br><span class="line">      &#123;-raw-&#125;&#123;(file)&#125;&#123;-raw-&#125;  </span><br><span class="line">&#123;(footer.html)&#125;  <span class="comment">&lt;!--引入页面，自己随便写一个，再view.html同目录--&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="layout-布局统一风格"><a href="#layout-布局统一风格" class="headerlink" title="layout 布局统一风格"></a>layout 布局统一风格</h3><p>使用模板内容嵌套可以实现全站风格同一布局</p><p><strong>lua</strong></p><p><code>local template = require &quot;resty.template&quot;</code></p><p>一、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local layout   = template.new &quot;layout.html&quot;</span><br><span class="line"></span><br><span class="line">layout.title   = &quot;Testing lua-resty-template&quot;</span><br><span class="line"></span><br><span class="line">layout.view    = template.compile &quot;view.html&quot; &#123; message = &quot;Hello, World!&quot; &#125;</span><br><span class="line"></span><br><span class="line">layout:render()</span><br></pre></td></tr></table></figure><p>二、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template.render(&quot;layout.html&quot;, &#123;</span><br><span class="line"></span><br><span class="line">  title = &quot;Testing lua-resty-template&quot;,</span><br><span class="line"></span><br><span class="line">  msg = &quot;type=2&quot;,</span><br><span class="line"></span><br><span class="line">  view  = template.compile &quot;view.html&quot; &#123; message = &quot;Hello, World!&quot; &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>三、</p><p>此方式重名变量值会被覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local view     = template.new(&quot;view.html&quot;, &quot;layout.html&quot;)</span><br><span class="line"></span><br><span class="line">view.title     = &quot;Testing lua-resty-template&quot;</span><br><span class="line"></span><br><span class="line">view.msg = &quot;type=3&quot;</span><br><span class="line"></span><br><span class="line">view.message   = &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">view:render()</span><br></pre></td></tr></table></figure><p>四、</p><p>可以区分一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local layout   = template.new &quot;layout.html&quot;</span><br><span class="line"></span><br><span class="line">layout.title   = &quot;Testing lua-resty-template&quot;</span><br><span class="line"></span><br><span class="line">layout.msg = &quot;type=4&quot;</span><br><span class="line"></span><br><span class="line">local view     = template.new(&quot;view.html&quot;, layout)</span><br><span class="line"></span><br><span class="line">view.message   = &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">view:render()</span><br></pre></td></tr></table></figure><p><strong>layout.html</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;layout&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">​    &#123;*view*&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>view.html·</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`msg:&#123;&#123;message&#125;&#125;`</span><br></pre></td></tr></table></figure><p><strong>多级嵌套</strong></p><p>lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local view     = template.new(&quot;view.html&quot;, &quot;layout.html&quot;)</span><br><span class="line"></span><br><span class="line">view.title     = &quot;Testing lua-resty-template&quot;</span><br><span class="line"></span><br><span class="line">view.message   = &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">view:render()</span><br><span class="line"></span><br><span class="line">view.html</span><br><span class="line"></span><br><span class="line">&#123;% layout=&quot;section.html&quot; %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h&gt;msg:&#123;&#123;message&#125;&#125;&lt;/h&gt;</span><br></pre></td></tr></table></figure><p>section.html</p><div id="section"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    &#123;*view*&#125; - sss</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>layout.html</p><!DOCTYPE html><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;h&gt;layout &#123;&#123;msg&#125;&#125;&lt;/h&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">​    &#123;*view*&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis缓存-mysql-模板输出"><a href="#Redis缓存-mysql-模板输出" class="headerlink" title="Redis缓存+mysql+模板输出"></a>Redis缓存+mysql+模板输出</h3><p>lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  cjson = require &quot;cjson&quot;</span><br><span class="line">sql=&quot;select * from t_emp&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local redis = require &quot;resty.redis&quot;</span><br><span class="line">                local red = redis:new()</span><br><span class="line"></span><br><span class="line">                red:set_timeouts(1000, 1000, 1000) -- 1 sec</span><br><span class="line"></span><br><span class="line">  local ok, err = red:connect(&quot;127.0.0.1&quot;, 6379)</span><br><span class="line"> if not ok then</span><br><span class="line">                    ngx.say(&quot;failed to connect: &quot;, err)</span><br><span class="line">                    return</span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">                local res, err = red:get(sql)</span><br><span class="line">                if not res then</span><br><span class="line">                    ngx.say(&quot;failed to get sql: &quot;, err)</span><br><span class="line">                    return</span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line">                if res == ngx.null then</span><br><span class="line">                    ngx.say(&quot;sql&quot;..sql..&quot; not found.&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--mysql查询</span><br><span class="line">local mysql = require &quot;resty.mysql&quot;</span><br><span class="line">                local db, err = mysql:new()</span><br><span class="line">                if not db then</span><br><span class="line">                    ngx.say(&quot;failed to instantiate mysql: &quot;, err)</span><br><span class="line">                    return</span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line">                db:set_timeout(1000) -- 1 sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                local ok, err, errcode, sqlstate = db:connect&#123;</span><br><span class="line">                    host = &quot;192.168.44.211&quot;,</span><br><span class="line">                    port = 3306,</span><br><span class="line">                    database = &quot;zhangmen&quot;,</span><br><span class="line">                    user = &quot;root&quot;,</span><br><span class="line">                    password = &quot;111111&quot;,</span><br><span class="line">                    charset = &quot;utf8&quot;,</span><br><span class="line">                    max_packet_size = 1024 * 1024,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                ngx.say(&quot;connected to mysql.&lt;br&gt;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> res, err, errcode, sqlstate =</span><br><span class="line">                    db:query(sql)</span><br><span class="line">                if not res then</span><br><span class="line">                    ngx.say(&quot;bad result: &quot;, err, &quot;: &quot;, errcode, &quot;: &quot;, sqlstate, &quot;.&quot;)</span><br><span class="line">                    return</span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          --ngx.say(&quot;result: &quot;, cjson.encode(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ok, err = red:set(sql, cjson.encode(res))</span><br><span class="line">                if not ok then</span><br><span class="line">                    ngx.say(&quot;failed to set sql: &quot;, err)</span><br><span class="line">                    return</span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line">                ngx.say(&quot;set result: &quot;, ok)</span><br><span class="line"></span><br><span class="line">                    return</span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local template = require(&quot;resty.template&quot;)</span><br><span class="line">template.caching(false)</span><br><span class="line">local context = &#123;</span><br><span class="line">    title = &quot;测试&quot;,</span><br><span class="line">    name = &quot;lucy&quot;,</span><br><span class="line">    description = &quot;&lt;script&gt;alert(1);&lt;/script&gt;&quot;,</span><br><span class="line">    age = 40,</span><br><span class="line">    hobby = &#123;&quot;电影&quot;, &quot;音乐&quot;, &quot;阅读&quot;&#125;,</span><br><span class="line">    score = &#123;语文 = 90, 数学 = 80, 英语 = 70&#125;,</span><br><span class="line">    score2 = &#123;</span><br><span class="line">        &#123;name = &quot;语文&quot;, score = 90&#125;,</span><br><span class="line">        &#123;name = &quot;数学&quot;, score = 80&#125;,</span><br><span class="line">        &#123;name = &quot;英语&quot;, score = 70&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">zhangmen=cjson.decode(res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template.render(&quot;view.html&quot;, context)</span><br></pre></td></tr></table></figure><p>模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;(header.html)&#125;  </span><br><span class="line">   &lt;body&gt;  </span><br><span class="line">      &#123;# 不转义变量输出 #&#125;  </span><br><span class="line">      姓名：&#123;* string.upper(name) *&#125;&lt;br/&gt;  </span><br><span class="line">      &#123;# 转义变量输出 #&#125;  </span><br><span class="line"></span><br><span class="line">      年龄: &#123;* age + 10 *&#125;&lt;br/&gt;  </span><br><span class="line">      &#123;# 循环输出 #&#125;  </span><br><span class="line">      爱好：  </span><br><span class="line">      &#123;% for i, v in ipairs(hobby) do %&#125;  </span><br><span class="line">         &#123;% if v == &#x27;电影&#x27; then  %&#125; - xxoo</span><br><span class="line">            </span><br><span class="line">              &#123;%else%&#125;  - &#123;* v *&#125; </span><br><span class="line">&#123;% end %&#125;  </span><br><span class="line">         </span><br><span class="line">      &#123;% end %&#125;&lt;br/&gt;  </span><br><span class="line">  </span><br><span class="line">      成绩：  </span><br><span class="line">      &#123;% local i = 1; %&#125;  </span><br><span class="line">      &#123;% for k, v in pairs(score) do %&#125;  </span><br><span class="line">         &#123;% if i &gt; 1 then %&#125;，&#123;% end %&#125;  </span><br><span class="line">         &#123;* k *&#125; = &#123;* v *&#125;  </span><br><span class="line">         &#123;% i = i + 1 %&#125;  </span><br><span class="line">      &#123;% end %&#125;&lt;br/&gt;  </span><br><span class="line">      成绩2：  </span><br><span class="line">      &#123;% for i = 1, #score2 do local t = score2[i] %&#125;  </span><br><span class="line">         &#123;% if i &gt; 1 then %&#125;，&#123;% end %&#125;  </span><br><span class="line">          &#123;* t.name *&#125; = &#123;* t.score *&#125;  </span><br><span class="line">      &#123;% end %&#125;&lt;br/&gt;  </span><br><span class="line">      &#123;# 中间内容不解析 #&#125;  </span><br><span class="line">      &#123;-raw-&#125;&#123;(file)&#125;&#123;-raw-&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">掌门：</span><br><span class="line">&#123;* zhangmen *&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#123;% for i = 1, #zhangmen do local z = zhangmen[i] %&#125;  </span><br><span class="line">         &#123;* z.deptId *&#125;,&#123;* z.age *&#125;,&#123;* z.name *&#125;,&#123;* z.empno *&#125;,&lt;br&gt;</span><br><span class="line">      &#123;% end %&#125;&lt;br/&gt;  </span><br><span class="line"></span><br><span class="line">&#123;(footer.html)&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Lua-开源项目"><a href="#Lua-开源项目" class="headerlink" title="Lua 开源项目"></a>Lua 开源项目</h2><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p><a href="https://github.com/unixhot/waf">https://github.com/unixhot/waf</a></p><p><a href="https://github.com/loveshell/ngx_lua_waf">https://github.com/loveshell/ngx_lua_waf</a></p><p>l   防止 SQL 注入，本地包含，部分溢出，fuzzing 测试，XSS&#x2F;SSRF 等 Web 攻击</p><p>l   防止 Apache Bench 之类压力测试工具的攻击</p><p>l   屏蔽常见的扫描黑客工具，扫描器</p><p>l   屏蔽图片附件类目录执行权限、防止 webshell 上传</p><p>l   支持 IP 白名单和黑名单功能，直接将黑名单的 IP 访问拒绝</p><p>l   支持 URL 白名单，将不需要过滤的 URL 进行定义</p><p>l   支持 User-Agent 的过滤、支持 CC 攻击防护、限制单个 URL 指定时间的访问次数</p><p>l   支持支持 Cookie 过滤，URL 与 URL 参数过滤</p><p>l   支持日志记录，将所有拒绝的操作，记录到日志中去</p><h3 id="Kong-基于Openresty的流量网关"><a href="#Kong-基于Openresty的流量网关" class="headerlink" title="Kong 基于Openresty的流量网关"></a>Kong 基于Openresty的流量网关</h3><p><a href="https://konghq.com/">https://konghq.com/</a></p><p><a href="https://github.com/kong/kong">https://github.com/kong/kong</a></p><p>Kong 基于 OpenResty，是一个云原生、快速、可扩展、分布式的微服务抽象层（Microservice Abstraction Layer），也叫 API 网关（API Gateway），在 Service Mesh 里也叫 API 中间件（API Middleware）。</p><p>Kong 开源于 2015 年，核心价值在于高性能和扩展性。从全球 5000 强的组织统计数据来看，Kong 是现在依然在维护的，在生产环境使用最广泛的 API 网关。</p><p>Kong 宣称自己是世界上最流行的开源微服务 API 网关（The World’s Most Popular Open Source Microservice API Gateway）。</p><p>核心优势：</p><p>l   可扩展：可以方便的通过添加节点水平扩展，这意味着可以在很低的延迟下支持很大的系统负载。</p><p>l   模块化：可以通过添加新的插件来扩展 Kong 的能力，这些插件可以通过 RESTful Admin API 来安装和配置。</p><p>l   在任何基础架构上运行：Kong 可以在任何地方都能运行，比如在云或混合环境中部署 Kong，单个或全球的数据中心。</p><h3 id="APISIX"><a href="#APISIX" class="headerlink" title="APISIX"></a>APISIX</h3><h3 id="ABTestingGateway"><a href="#ABTestingGateway" class="headerlink" title="ABTestingGateway"></a>ABTestingGateway</h3><p><a href="https://github.com/CNSRE/ABTestingGateway">https://github.com/CNSRE/ABTestingGateway</a></p><p>ABTestingGateway 是一个可以动态设置分流策略的网关，关注与灰度发布相关领域，基于 Nginx 和 ngx-lua 开发，使用 Redis 作为分流策略数据库，可以实现动态调度功能。</p><p>ABTestingGateway 是新浪微博内部的动态路由系统 dygateway 的一部分，目前已经开源。在以往的基于 Nginx 实现的灰度系统中，分流逻辑往往通过 rewrite 阶段的 if 和 rewrite 指令等实现，优点是性能较高，缺点是功能受限、容易出错，以及转发规则固定，只能静态分流。ABTestingGateway 则采用 ngx-lua，通过启用 lua-shared-dict 和 lua-resty-lock 作为系统缓存和缓存锁，系统获得了较为接近原生 Nginx 转发的性能。</p><p>l   支持多种分流方式，目前包括 iprange、uidrange、uid 尾数和指定uid分流</p><p>l   支持多级分流，动态设置分流策略，即时生效，无需重启</p><p>l   可扩展性，提供了开发框架，开发者可以灵活添加新的分流方式，实现二次开发</p><p>l   高性能，压测数据接近原生 Nginx 转发</p><p>l   灰度系统配置写在 Nginx 配置文件中，方便管理员配置</p><p>l   适用于多种场景：灰度发布、AB 测试和负载均衡等</p></div>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx基础篇笔记</title>
      <link href="/blog/nginx%E5%9F%BA%E7%A1%80/"/>
      <url>/blog/nginx%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx基本运行原理图"><a href="#nginx基本运行原理图" class="headerlink" title="nginx基本运行原理图"></a>nginx基本运行原理图</h1><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image%5Cnginx.assets%5Cimage-20230618145224781.png" alt="image-20230618145224781"></p><h1 id="Nginx配置与应用场景"><a href="#Nginx配置与应用场景" class="headerlink" title="Nginx配置与应用场景"></a>Nginx配置与应用场景</h1><h2 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h2><p><strong>worker_processes</strong></p><p>worker_processes 1; 默认为1，表示开启一个业务进程</p><p><strong>worker_connections</strong></p><p>worker_connections 1024; 单个业务进程可接受连接数</p><p><strong>include mime.types;</strong></p><p>include mime.types; 引入http mime类型</p><p><strong>default_type application&#x2F;octet-stream;</strong></p><p>default_type application&#x2F;octet-stream; 如果mime类型没匹配上，默认使用二进制流的方式传输。</p><p><strong>sendfifile on;</strong></p><p>sendfile on; 使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。</p><p>未开启sendfifile时：</p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230618151150474.png" alt="image-20230618151150474"></p><p>开启后：（<font color="red">nginx减少一次目标文件的复制</font>）</p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230618151244976.png" alt="image-20230618151244976"></p><p><strong>keepalive_timeout 65;</strong></p><p>keepalive_timeout 65;</p><p><strong>server</strong></p><p>虚拟主机配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#虚拟主机 vhost</span></span><br><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line">       <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">       <span class="attribute">server_name</span>  localhost;<span class="comment">#域名、主机名</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># location用于匹配uri</span></span><br><span class="line">       <span class="section">location</span> / &#123;</span><br><span class="line">           <span class="comment">#匹配目录：nginx根目录下的文件夹 这里是/nginx/index</span></span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line"></span><br><span class="line">           <span class="comment">#默认页</span></span><br><span class="line">           <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">#错误页</span></span><br><span class="line">       <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">       <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务</p><h3 id="servername匹配规则"><a href="#servername匹配规则" class="headerlink" title="servername匹配规则"></a>servername匹配规则</h3><p>我们需要注意的是servername匹配分先后顺序，写在前面的匹配上就不会继续往下匹配了。</p><p><strong>完整匹配</strong></p><p>我们可以在同一servername中匹配多个域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name vod.mmban.com www1.mmban.com;</span><br></pre></td></tr></table></figure><p><strong>通配符匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name *.mmban.com</span><br></pre></td></tr></table></figure><p><strong>通配符结束匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name vod.*;</span><br></pre></td></tr></table></figure><p><strong>正则匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name ~^[0-9]+\.mmban\.com$;</span><br></pre></td></tr></table></figure><h3 id="配置多台虚拟主机"><a href="#配置多台虚拟主机" class="headerlink" title="配置多台虚拟主机"></a>配置多台虚拟主机</h3><ul><li><p>listen端口相同，server_name不能相同</p></li><li><p>server_name相同，listen端口不能相同</p><p>  #虚拟主机 vhost1<br>  server {<br>  listen       80;<br>  server_name  www1.test.com;#域名、主机名</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># location用于匹配uri</span></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#匹配目录：nginx根目录下的文件夹 这里是/nginx/index</span></span><br><span class="line">    <span class="attribute">root</span>   html;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#默认页</span></span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误页</span></span><br><span class="line"><span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line"><span class="section">location</span> = /50x.html &#123;</span><br><span class="line">    <span class="attribute">root</span>   html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  #虚拟主机 vhost2<br>  server {<br>  listen       80;<br>  server_name  www2.test.com;#域名、主机名</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># location用于匹配uri</span></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#匹配目录：nginx根目录下的文件夹 这里是/nginx/index</span></span><br><span class="line">    <span class="attribute">root</span>   html;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#默认页</span></span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误页</span></span><br><span class="line"><span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line"><span class="section">location</span> = /50x.html &#123;</span><br><span class="line">    <span class="attribute">root</span>   html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p></li></ul><h3 id="反向代理基础配置"><a href="#反向代理基础配置" class="headerlink" title="反向代理基础配置"></a>反向代理基础配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http://baidu.com;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_pass</span> http://atguigu.com/;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><h3 id="多用户二级域名和短网址"><a href="#多用户二级域名和短网址" class="headerlink" title="多用户二级域名和短网址"></a>多用户二级域名和短网址</h3><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230618225732811.png" alt="image-20230618225732811"></p><p>用户访问缩短后的URL时，通常将会重定向到原来的URL。</p><p>利用键值对应方式，将网址对应成被缩短的代码来散布使用。 使用时，系统先查询出原本的网址，再以网址重导向（URL redirection）来将缩短后的地址重定向到原来的URL。</p><p>xxx.test.com&#x2F;xxxxxxxx</p><p>xxx：二级域名</p><p>xxxxxxxx：短网址、短链</p><p>一句话：<font color="red">二级域名截前面查库，短链截后面查数据库</font></p><h3 id="httpdns"><a href="#httpdns" class="headerlink" title="httpdns"></a>httpdns</h3><p>HTTPDNS 利用 HTTP 协议与 DNS 服务器交互，代替了传统的基于 UDP 协议的 DNS 交互，绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率。另外，由于 DNS 服务器端获取的是真实客户端 IP 而非 Local DNS 的 IP，能够精确定位客户端地理位置、运营商信息，从而有效改进调度精确性。</p><p>正是由于传统的DNS存在诸多的缺点，所以现在稍微有点规模的公司都会自己搭建HTTPDNS服务器。HTTPDNS 的原理很简单，将 DNS 这种容易被劫持的协议，转为使用 HTTP 协议请求 Domain &lt;-&gt; IP 映射。 获得正确 IP 之后，Client 自己组装 HTTP 协议，从而避免 ISP 篡改数据。它的架构图也比较简单，如下图所示。</p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230618231052692.png" alt="image-20230618231052692"></p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230618231106954.png" alt="image32132d123123"></p><p>使用HttpDns，可以有效解决传统DNS的DNS劫持、访问时间延迟等问题。 - <strong>避免Local DNS 劫持</strong>：由于 HttpDns 是通过 IP 直接请求 HTTP 获取服务器 A 记录地址，不存在向本地运营商询问 domain 解析过程，所以从根本避免了劫持问题。 - <strong>平均访问延迟下降</strong>：由于是 IP 直接访问省掉了一次 domain 解析过程，通过智能算法排序后找到最快节点进行访问。 - <strong>用户连接失败率下降</strong>：通过算法降低以往失败率过高的服务器排序，通过时间近期访问过的数据提高服务器排序，通过历史访问成功记录提高服务器排序。</p><h1 id="基于反向代理的负载均衡"><a href="#基于反向代理的负载均衡" class="headerlink" title="基于反向代理的负载均衡"></a>基于反向代理的负载均衡</h1><h2 id="代理与负载均衡的概念"><a href="#代理与负载均衡的概念" class="headerlink" title="代理与负载均衡的概念"></a>代理与负载均衡的概念</h2><p><strong>正向代理</strong></p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230619213804802.png" alt="image-20230619213804802"></p><p>用户和代理服务器是一家的，是用户主动配置的服务器，用于能够访问外网（A能ping通B，A不能ping通C，但是B能ping通C，A借助B访问C）</p><p><strong>反向代理</strong>：由服务提供方方向提供的服务器，让用户能够访问到应用服务器</p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230619214246279.png" alt="image-20230619214246279"></p><p>隧道式代理</p><p><strong>负载均衡</strong></p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230619220304390.png" alt="image-20230619220304390"></p><p>这里是轮询算法，为了避免一台微服务承受不住压力，于是相同微服务为一个集群，将他们的压力分配在集群各台主机上</p><h2 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h2><hr><p><strong>前提注意：本机ip是192.168.111.100，浏览器输入本机ip或者hosts文件中配置的主机名，或者域名解析的地址</strong></p><p><strong>注意：配置反向代理后，不会配置root路径，故改台主机将无法提供网页服务</strong></p><hr><p><strong>1、反向代理到其他服务器网址——url不改变</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#反向代理</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.atguigu.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#root   /www/www;</span></span><br><span class="line">    <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、反向代理到其他服务器网址——url改变为真实网址</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#反向代理</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://atguigu.com;<span class="comment">#相比上条没输入www</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#root   /www/www;</span></span><br><span class="line">    <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、反向代理到其他虚拟机</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#反向代理</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> <span class="number">192.168.111.101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#root   /www/www;</span></span><br><span class="line">    <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义集群</span></span><br><span class="line"><span class="section">upstream</span> cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.111.101:80</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.111.102:80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#反向代理到集群，配置负载均衡用到上面定义的集群</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://cluster;<span class="comment">#不要忘记写http://</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#root   /www/www;</span></span><br><span class="line">        <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负载均衡策略</strong></p><p><strong>轮询</strong></p><p>默认情况下使用轮询方式，逐一转发，这种方式适用于无状态请求</p><p><strong>weight(权重)</strong></p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> cluster &#123;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.111.101:80</span> weight=<span class="number">4</span> down;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.111.102:80</span> weight=<span class="number">8</span> backup;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>down：表示当前的server暂时不参与负载</li><li><strong>weight</strong>：默认为1.weight越大，负载的权重就越大。</li><li>backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。</li></ul><p>down和backup不常用</p><p><strong>以下负载均衡算法均不常用：</strong></p><p><strong>ip_hash</strong></p><p>根据客户端的ip地址转发同一台服务器，可以保持回话。</p><p><strong>least_conn</strong></p><p>最少连接访问</p><p><strong>url_hash</strong></p><p>根据用户访问的url定向转发请求</p><p><strong>fair</strong></p><p>根据后端服务器响应时间转发请求</p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230620195424300.png" alt="image-20230620195424300"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230620203844511.png" alt="image-20230620203844511"></p><p>只适合小型网站，静态资源较少，<font color="red">能起到系统加速的作用</font></p><p>将静态资源前置，网页请求静态资源时就不会把太多静态资源的请求打在后端tomcat服务器上，<font color="red">让后端服务器专心响应动态请求</font></p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230620204544669.png" alt="image-20230620204544669"></p><p><strong>动静配置配置</strong></p><p>需要有一台虚拟机在tomcat上运行一个war包</p><p>1 配置反向代理：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.111.102:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 配置静态资源路径</p><p>方式一：通用匹配：需要增加很多个location</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /css &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/static;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/static;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /js &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/static;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：<strong>正则匹配</strong>：只需要一个location</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> ~*/(css|js|img) &#123;<span class="comment">#~*表示正则匹配不区分大小写</span></span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/static;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意：<font color="red">正则匹配优先级大于通用匹配</font></p><p><strong>location前缀</strong> </p><ul><li><p>&#x2F; 通用匹配，任何请求都会匹配到。</p></li><li><p>&#x3D; 精准匹配，不是以指定模式开头</p></li><li><p>~ 正则匹配，区分大小写</p></li><li><p>~* 正则匹配，不区分大小写</p></li></ul><p><strong>location匹配顺序</strong></p><ul><li>多个正则location直接按书写顺序匹配，成功后就不会继续往后面匹配</li><li>普通（非正则）location会一直往下，直到找到匹配度最高的（最大前缀匹配）</li><li>当普通location与正则location同时存在，如果正则匹配成功,则不会再执行普通匹配</li><li>所有类型location存在时，“&#x3D;”匹配 &gt; “^~”匹配 &gt; 正则匹配 &gt; 普通（最大前缀匹配）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//location大致可以分为三类</span></span><br><span class="line">精准匹配：location = /&#123;&#125;</span><br><span class="line">一般匹配：location /&#123;&#125;</span><br><span class="line">正则匹配：location ~/&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//location常用的匹配规则：</span></span><br><span class="line">= ：进行普通字符精确匹配，也就是完全匹配。</span><br><span class="line">^~ ：表示前缀字符串匹配（不是正则匹配，需要使用字符串），如果匹配成功，则不再匹配其它 location。</span><br><span class="line">~ ：区分大小写的匹配（需要使用正则表达式）。</span><br><span class="line">~* ：不区分大小写的匹配（需要使用正则表达式）。</span><br><span class="line">!~ ：区分大小写的匹配取非（需要使用正则表达式）。</span><br><span class="line">!~* ：不区分大小写的匹配取非（需要使用正则表达式）。</span><br><span class="line"></span><br><span class="line"><span class="comment">//正则规则：</span></span><br><span class="line">() ：表达式的开始和结束位置</span><br><span class="line">| ：或运算符  <span class="comment">//例(js|img|css)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级</span></span><br><span class="line">首先精确匹配 =</span><br><span class="line">其次前缀匹配 ^~</span><br><span class="line">其次是按文件中顺序的正则匹配 ~或~*</span><br><span class="line">然后匹配不带任何修饰的前缀匹配</span><br><span class="line">最后是交给 / 通用匹配</span><br></pre></td></tr></table></figure><p><strong>alias与root</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /css &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/static/css;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root用来设置根目录，而alias在接受请求的时候在路径上不会加上location。</p><p>1）alias指定的目录是准确的，即location匹配访问的path目录下的文件直接是在alias目录下查找的； 2）root指定</p><p>的目录是location匹配访问的path目录的上一级目录,这个path目录一定要是真实存在root指定目录下的； 3）使用</p><p>alias标签的目录块中不能使用rewrite的break（具体原因不明）；另外，alias指定的目录后面必须要加上”&#x2F;“符</p><p>号！！ 4）alias虚拟目录配置中，location匹配的path目录如果后面不带”&#x2F;“，那么访问的url地址中这个path目录后</p><p>面加不加”&#x2F;“不影响访问，访问时它会自动加上”&#x2F;“； 但是如果location匹配的path目录后面加上”&#x2F;“，那么访问的url地</p><p>址中这个path目录必须要加上”&#x2F;“，访问时它不会自动加上”&#x2F;“。如果不加上”&#x2F;“，访问就会失败！ 5）root目录配置</p><p>中，location匹配的path目录后面带不带”&#x2F;“，都不会影响访问。</p><h2 id="UrlRewrite"><a href="#UrlRewrite" class="headerlink" title="UrlRewrite"></a><strong>UrlRewrite</strong></h2><p>优点：掩藏真实的url以及url中可能暴露的参数，以及隐藏web使用的编程语言，提高安全性便于搜索引擎收录</p><p>缺点：降低效率，影响性能。如果项目是内网使用，比如公司内部软件，则没有必要配置。</p><p><strong>rewrite语法格式及参数语法:</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rewrite是实现URL重写的关键指令，根据<span class="attribute">regex</span> (正则表达式)部分内容，</span><br><span class="line">重定向到replacement，结尾是flag标记。</span><br><span class="line"></span><br><span class="line">rewrite &lt;regex&gt; &lt;replacement&gt; [flag];</span><br><span class="line">关键字 正则 替代内容 flag标记</span><br><span class="line"></span><br><span class="line">关键字：其中关键字error_log不能改变</span><br><span class="line">正则：perl兼容正则表达式语句进行规则匹配</span><br><span class="line">替代内容：将正则匹配的内容替换成<span class="attribute">replacement</span></span><br><span class="line">flag标记：rewrite支持的flag标记</span><br><span class="line"></span><br><span class="line">rewrite参数的标签段位置：</span><br><span class="line">server,location,if</span><br><span class="line"></span><br><span class="line">flag标记说明：</span><br><span class="line"><span class="literal">last</span> <span class="comment">#本条规则匹配完成后，继续向下匹配新的location URI规则</span></span><br><span class="line"><span class="literal">break</span> <span class="comment">#本条规则匹配完成即终止，不再匹配后面的任何规则</span></span><br><span class="line"><span class="literal">redirect</span> <span class="comment">#返回302临时重定向，浏览器地址会显示跳转后的URL地址</span></span><br><span class="line"><span class="literal">permanent</span> <span class="comment">#返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    </span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^/([0-9]+).html$</span> /index.jsp?pageNum=<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#反向代理到集群，配置负载均衡</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">正则：^/([<span class="number">0</span>-<span class="number">9</span>]+).<span class="property">html$</span></span><br><span class="line">^表示正则表达式开头</span><br><span class="line">$表示正则表达式结尾</span><br><span class="line">()表达式的开始和结束位置</span><br><span class="line">+表示匹配一次或多次</span><br><span class="line"></span><br><span class="line">替代内容：/index.<span class="property">jsp</span>?pageNum=$1</span><br><span class="line">服务器解析uri时将正则匹配到的内容替换成/index.<span class="property">jsp</span>?pageNum=$1</span><br><span class="line">$1表示正则表达式匹配到的第一个</span><br><span class="line"></span><br><span class="line">flag标记：<span class="keyword">break</span></span><br><span class="line">本条规则匹配完成即终止，不再匹配后面的任何规则</span><br></pre></td></tr></table></figure><h2 id="内网可访问防火墙配置"><a href="#内网可访问防火墙配置" class="headerlink" title="内网可访问防火墙配置"></a>内网可访问防火墙配置</h2><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230621144550679.png" alt="image-20230621144550679"></p><p>目前nginx已经可以实现反向代理、负载均衡、动静分离、UrlRewrite，因此我们将nginx服务器叫做网关服务器</p><p>若要将应用服务器设置为外网无法访问，内网可以访问，需要进行以下防火墙配置：</p><p><strong>开启防火墙</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p><strong>指定端口和ip访问</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.111.100&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; accept&quot;</span><br></pre></td></tr></table></figure><p>若要移除规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.111.100&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; accept&quot;</span><br></pre></td></tr></table></figure><p><strong>重载规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>查看已配置规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><strong>反向代理、负载均衡、动静分离、UrlRewrite综合实现：</strong></p><p><strong>网关配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#定义集群负载均衡</span></span><br><span class="line">   <span class="section">upstream</span> cluster &#123;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.111.101:80</span> weight=<span class="number">4</span>;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.111.102:80</span> weight=<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line">       <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">       <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">       <span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">#UrlRewrite</span></span><br><span class="line">           <span class="attribute">rewrite</span><span class="regexp"> ^/([0-9]+).html$</span> /index.jsp?pageNum=<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">#反向代理到集群，配置负载均衡</span></span><br><span class="line">           <span class="attribute">proxy_pass</span> http://cluster;</span><br><span class="line"></span><br><span class="line">           <span class="comment">#root   /www/www;</span></span><br><span class="line">           <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#动静分离</span></span><br><span class="line">       <span class="section">location</span> ~*/(css|js|img) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line">           <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在访问应用服务器本机，我这里是redis102，将不能访问，</p><p>但访问nginx时，可以访问到redis102</p><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><p><strong>配置</strong>：在需要防盗链的location中配置，一般配置在动静分离location中的前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valid_referers none | blocked | server_names | strings ....;</span><br></pre></td></tr></table></figure><ul><li><strong>none</strong>， 检测 Referer 头域不存在的情况。</li><li>blocked，检测 Referer 头域的值被防火墙或者代理服务器删除或伪装的情况。这种情况该头域的值不以“http:&#x2F;&#x2F;” 或 “https:&#x2F;&#x2F;” 开头。</li><li>server_names ，设置一个或多个 URL ，检测 Referer 头域的值是否是这些 URL 中的某一个。</li></ul><p><strong>实例</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> ~*/(css|js|img) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">valid_referers</span> <span class="number">192.168.44.100</span>;<span class="comment">#实际中应该配置为域名而不是IP</span></span><br><span class="line">       <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">           <span class="attribute">return</span> <span class="number">403</span>;<span class="comment">#return过后将不会再继续执行</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">root</span>   html;</span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>浏览器请求referer中带192.168.44.100，则允许访问，否则返回403</p><p><font color="red">未授权的服务器和直接访问静态资源都不能访问</font></p><p><strong>若配置为：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valid_referers none 192.168.44.100; #添加了none</span><br></pre></td></tr></table></figure><p>浏览器请求referer中带192.168.44.100或者为空时，允许访问</p><p><font color="red">即自己授权的服务器和直接访问静态资源时可以访问，未授权的服务器不能访问</font></p><p><strong>使用curl测试防盗链</strong></p><p>安装curl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y curl</span><br></pre></td></tr></table></figure><p>返回页面代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.44.101/img/logo.png</span><br></pre></td></tr></table></figure><p>只返回响应头：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I http://192.168.44.101/img/logo.png</span><br></pre></td></tr></table></figure><p>带引用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -e &quot;http://baidu.com&quot; -I http://192.168.44.101/img/logo.png</span><br></pre></td></tr></table></figure><p><strong>配置错误提示页面</strong></p><p>在nginx.conf配置文件对应server中添加错误页面location：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error_page   403  /403.html;</span><br><span class="line">location = /403.html &#123;</span><br><span class="line">    root   html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在nginx服务器403匹配目录下添加403.html:</p><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230621154718389.png" alt="image-20230621154718389"></p><p><strong>配置错误返回图片</strong></p><p>在匹配图片的localtion的防盗链不匹配中添加rewrite：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location ~*/(css|js|img) &#123;</span><br><span class="line"></span><br><span class="line">    valid_referers 192.168.44.100;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line"></span><br><span class="line">        rewrite ^/ /img/403.png break;#返回错误图片</span><br><span class="line">        #return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;img中添加图片403.png</p><h1 id="高可用keepalived"><a href="#高可用keepalived" class="headerlink" title="高可用keepalived"></a>高可用keepalived</h1><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230621161313025.png" alt="image-20230621161313025"></p><p><strong>nginx间的keepalived可以相互通信，共同虚拟出一个虚拟ip（vip），<font color="red">vip是可以在两台nginx中切换的</font>，根据实际情况漂移vip实现nginx的负载均衡</strong></p><p><strong>配置keepalived</strong>：</p><p>先将原本的nginx虚拟机克隆一份，修改ip，保证nginx配置和环境相同</p><p>两台虚拟机安装keepalived：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure><p>使用yum安装后配置文件在&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</p><p>最小配置：</p><p>第一台机器：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">! <span class="attribute">Configuration</span> File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">router_id</span> lb100<span class="comment">#该台机器的id，不能重复</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="attribute">state</span> MASTER<span class="comment">#表示主机</span></span><br><span class="line">    interface ens33<span class="comment">#对方网卡名称，根据真实情况</span></span><br><span class="line">    virtual_router_id <span class="number">51</span></span><br><span class="line">    priority <span class="number">100</span><span class="comment">#优先级</span></span><br><span class="line">    advert_int <span class="number">1</span></span><br><span class="line">    authentication &#123;<span class="comment">#身份识别，相同为同一组</span></span><br><span class="line">        <span class="attribute">auth_type</span> PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;<span class="comment">#虚拟ip，可配置多个</span></span><br><span class="line">        192.168.111.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二台机器：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">! <span class="attribute">Configuration</span> File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">router_id</span> lb101<span class="comment">#该台机器的id，不能重复</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="attribute">state</span> BACKUP<span class="comment">#表示从机</span></span><br><span class="line">    interface ens33<span class="comment">#对方网卡名称，根据真实情况</span></span><br><span class="line">    virtual_router_id <span class="number">51</span></span><br><span class="line">    priority <span class="number">50</span><span class="comment">#优先级</span></span><br><span class="line">    advert_int <span class="number">1</span></span><br><span class="line">    authentication &#123;<span class="comment">#身份识别，相同为同一组</span></span><br><span class="line">        <span class="attribute">auth_type</span> PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;<span class="comment">#虚拟ip，可配置多个</span></span><br><span class="line">        192.168.111.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动两台机器的keepalived：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived</span><br></pre></td></tr></table></figure><p>可以使用ip a 查看ens33网卡的ip，可看到其中一个虚拟机多了一个虚拟ip，<strong>若这台虚拟机down掉，vip将漂移到另一台虚拟机</strong></p><p><font color="red"><strong>实际应用中，需要写对应的脚本监测本机的keepalived和nginx的服务运行状态，否则可能本机没有down掉，但是nginx服务关闭了，但是keepalived并没有关闭，则不会进行vip漂移，需要脚本监测到nginx down掉后，自动kill掉自己的keepalived</strong></font></p><p><strong><font color="cornflowerblue">也适用于mysql、redis等其他服务</font></strong></p><h1 id="Https证书配置"><a href="#Https证书配置" class="headerlink" title="Https证书配置"></a>Https证书配置</h1><h2 id="不安全的http协议与对称加密"><a href="#不安全的http协议与对称加密" class="headerlink" title="不安全的http协议与对称加密"></a>不安全的http协议与对称加密</h2><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230621191710171.png" alt="image-20230621191710171"></p><ul><li>http协议不安全，因为采用的是明文方式发送数据</li><li>防火墙只能拦截在服务器或客户端主机上的违法操作，但是无法处理网络传输过程中的拦截</li><li>于是需要加密算法，比如凯撒加密算法，用户方将明文加密成密文后发送出去，服务方再采用相同的算法解密成明文</li><li>像上面的两方使用相同的加密算法叫做<font color="cornflowerblue"><strong>对称加密</strong></font></li><li>但是对称加密也<strong>不安全</strong>，因为对称加密的算法需要内置到服务器端，而例如nginx是开源的，拦截者也能知道内置了哪些加密算法</li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230621193226227.png" alt="image-20230621193226227"></p><ul><li><strong>用户先访问443端口下载公钥，再通过公钥发送后续真正的请求</strong></li><li>用户 –》 服务端公钥加密，私钥解密</li><li>服务端 –》 用户私钥加密，公钥解密</li></ul><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230621194104815.png" alt="image-20230621194104815"></p><ul><li>私钥不传输，一直在服务端，因此私钥安全</li><li><strong>公钥加密，但是拦截者拦截公钥后，<font color="cornflowerblue">用公钥解不开</font></strong></li><li>但是，非对称加密也是<strong>不安全</strong>的</li><li>因为，虽然不能伪造客户端，但是可以<strong>伪造服务端</strong>，代替客户端与服务端通信，给客户端假公钥</li></ul><h2 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h2><p><img src="https://www.hahhome.top/blog/nginx%E5%9F%BA%E7%A1%80/../../image/image-20230621200836558.png" alt="image-20230621200836558"></p><ul><li>引入了CA机构，具有公信度</li><li>不再像非对称加密一样，传递服务端的公钥，而是<strong>传递证书</strong></li><li>服务端将公钥交给CA机构认证，经过<strong>检测确实是真实服务器</strong>后认证成功，然后CA机构通过自己的<strong>私钥+加密算法</strong>加密服务器的公钥生成<strong>证书</strong>，服务端发送给用户证书</li><li>证书可以被截取解开，但是截取解开后，<strong>没有CA机构的私钥再进行加密</strong>，因此会显示是<strong>不安全</strong>的</li><li>用户接收到证书后，通过<strong>操作系统内置的ca.公钥</strong>解开证书得到服务器的公钥，再用服务器的公钥加密数据进行传输，就算拦截者有服务器公钥，也无法解开用户传输的数据，因为<strong>公钥加密，公钥解不开，公私对应才能解开</strong></li></ul><h2 id="申请配置SSL证书"><a href="#申请配置SSL证书" class="headerlink" title="申请配置SSL证书"></a>申请配置SSL证书</h2><p><strong>先购买自己的域名，和ECS云服务器，这里采用阿里云</strong></p><p><strong>安装LNMP环境</strong></p><p>使用下列网站</p><p><a href="https://oneinstack.com/">OneinStack - 一键PHP&#x2F;JAVA安装工具</a></p><p>自动安装 –》 若有mysql数据库则取消勾选mysql – 》Nodejs、Pure-FTPd、phpMyAdmin、redis、memcached、iptables全部取消勾选–》 自己决定是否重启</p><p><strong>配置云服务器安全组</strong></p><p>将80端口和443端口为0.0.0.0开放，此时即可正常访问nginx主页</p><p><strong>修改nginx网页默认位置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>将server下的root修改为html</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> _;</span><br><span class="line">  <span class="attribute">access_log</span> /data/wwwlogs/access_nginx.log combined;</span><br><span class="line">  <span class="attribute">root</span> html;<span class="comment">#修改这里为html相对路径</span></span><br><span class="line">  .</span><br></pre></td></tr></table></figure><p>本服务器没有完成备案，后续教程查看<a href="https://hashnode.blog.csdn.net/article/details/124555303">【初探篇】申请阿里云免费SSL证书并配置https访问实战_ssl证书申请了不用在服务器上配置吗_潮浪之巅的博客-CSDN博客</a></p><h1 id="安装discuz论坛"><a href="#安装discuz论坛" class="headerlink" title="安装discuz论坛"></a>安装discuz论坛</h1><p><a href="https://www.bilibili.com/video/BV1yS4y1N76R?p=51&vd_source=34da131fa0b4ef9d62e5e0c78828f630">51-线上实战-安装Discuz与协议自动跳转_哔哩哔哩_bilibili</a></p><p>需要安装好上面的LNMP环境</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-SR12 + CloudAlibaba 2.2.8RELEASE笔记</title>
      <link href="/blog/springcloud/"/>
      <url>/blog/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud-SR12"><a href="#SpringCloud-SR12" class="headerlink" title="SpringCloud-SR12"></a>SpringCloud-SR12</h1><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230507205944262-shareX-20230507205945.png" alt="image-20230507205944262"></p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230508195351399-shareX-20230508195401.png" alt="image-20230508195351399"></p><p>&#x3D;&#x3D;所使用的是springcloud-SR12，笔记中所有组件都是选择的适配该版本的组件&#x3D;&#x3D;</p><p>springboot使用的是2.3.12.RELEASE</p><h1 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h1><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230509213520514-shareX-20230509213521.png" alt="image-20230509213520514"></p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230510125426563-shareX-20230510125427.png" alt="image-20230510125426563"></p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230510144903537-shareX-20230510144904.png" alt="image-20230510144903537" style="zoom:50%;"><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230510154136587-shareX-20230510154138.png" alt="image-20230510154136587"></p><p>&#x3D;&#x3D;网站客户端通过restTemplate调用网站服务端的服务&#x3D;&#x3D;</p><h2 id="Eureka（AP）"><a href="#Eureka（AP）" class="headerlink" title="Eureka（AP）"></a>Eureka（AP）</h2><h3 id="Eureka单机-集群配置"><a href="#Eureka单机-集群配置" class="headerlink" title="Eureka单机&#x2F;集群配置"></a>Eureka单机&#x2F;集群配置</h3><p>eureka的服务端加注解&#x3D;&#x3D;@EnableEurekaServer&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka-server--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>网站的服务端和客户端加注解&#x3D;&#x3D;@EnableEurekaClient&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.当eureka为单机版时，配置文件自己注册自己，网站的服务端和客户端都是eureka客户端，都只用写一个eureka-server的地址</p><p>2.当eureka为集群版时，相互注册，多者用逗号分隔，网站的服务端和客户端都是eureka客户端，都需要写全部的eureka-server的地址</p><p>（可在Windows的host文件中绑定eureka端口号与名字的对应关系）</p><h3 id="网站服务端单机-集群配置"><a href="#网站服务端单机-集群配置" class="headerlink" title="网站服务端单机&#x2F;集群配置"></a>网站服务端单机&#x2F;集群配置</h3><p>1.当网站的当服务提供者为单机版时，网站的客户端controller中的服务端url可以写死，</p><p>2.当网站的当服务提供者为集群版时，网站的客户端controller中的服务端url不能写死，可以写为服务端的注册名称，并且要在网站的客户端的config中在restTemplate的@Bean注解处加上注解&#x3D;&#x3D;@LoadBalanced&#x3D;&#x3D;，赋予restTemplate负载均衡的能力，才能通过网站服务提供者的注册名称得到服务</p><h3 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h3><p>在网站服务端集群的每个配置文件中，在eureka下都要加上instance配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span>    </span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">      <span class="attr">instance-id:</span> <span class="string">payment8001</span>    <span class="comment">#修改eureka中显示的服务名称  localhost:cloud-payment-service:8001 变为 payment8001</span></span><br><span class="line">      <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment">#访问路径可以显示ip地址</span></span><br></pre></td></tr></table></figure><h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>在controller中注入DiscoveryClient变量，写discovery方法，并在主启动类上加注解&#x3D;&#x3D;@EnableDiscoveryClient&#x3D;&#x3D;</p><h3 id="关闭自我保护"><a href="#关闭自我保护" class="headerlink" title="关闭自我保护"></a>关闭自我保护</h3><p>在eureka服务端配置文件中加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#关闭自我保护机制，保证不可用服务被及时踢除</span></span><br><span class="line">  <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>在网站服务端配置文件中加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span></span><br><span class="line"><span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务</span></span><br><span class="line"><span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="配置文件集合"><a href="#配置文件集合" class="headerlink" title="配置文件集合"></a>配置文件集合</h3><p>eureka服务端</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line"><span class="comment">#  hostname: localhost   #单机版</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment">#eureka服务端的实例名称  要在windows host文件中绑定id和名称的对应关系</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span></span><br><span class="line">      <span class="comment">#集群版相互注册，单机版注册自己</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br><span class="line">          </span><br><span class="line"><span class="comment">#  server:</span></span><br><span class="line"><span class="comment">#    #关闭自我保护机制，保证不可用服务被及时踢除</span></span><br><span class="line"><span class="comment">#    enable-self-preservation: false</span></span><br><span class="line"><span class="comment">#    eviction-interval-timer-in-ms: 2000</span></span><br></pre></td></tr></table></figure><p>网站服务端</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_test?useUnicode=true&amp;characterEncoding=utf-8&amp;userSSL-false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxx</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.spongehah.springcloud.entities</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka    #单机版</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span>    <span class="comment">#集群版</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span>    <span class="comment">#修改eureka中显示的服务名称  localhost:cloud-payment-service:8001 变为 payment8001</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment">#访问路径可以显示ip地址</span></span><br><span class="line">          </span><br><span class="line"><span class="comment">#    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span></span><br><span class="line"><span class="comment">#    lease-renewal-interval-in-seconds: 1</span></span><br><span class="line"><span class="comment">#    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务</span></span><br><span class="line"><span class="comment">#    lease-expiration-duration-in-seconds: 2</span></span><br></pre></td></tr></table></figure><p>网站客户端</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#      defaultZone: http://localhost:7001/eureka    #单机版</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span>    <span class="comment">#集群版</span></span><br></pre></td></tr></table></figure><h2 id="Zookeeper（CP）"><a href="#Zookeeper（CP）" class="headerlink" title="Zookeeper（CP）"></a>Zookeeper（CP）</h2><p>关闭linux防火墙后，启动zookeeper服务器</p><p>linux启动zookeeper：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/module/zookeeper-3.5.7/bin</span><br><span class="line">./zkServer.sh start#启动zk服务器</span><br><span class="line">./zkCli.sh#启动zk客户端</span><br><span class="line">./zkServer.sh stop</span><br><span class="line">./zkServer.sh status</span><br><span class="line">quit#退出客户端</span><br></pre></td></tr></table></figure><p>新建module</p><p>改pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--若环境报错，排除自带的zookeeper3.5.3--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;exclusions&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;exclusion&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;/exclusion&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;/exclusions&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加zookeeper3.5.7版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#8004表示注册到zookeeper服务器的支付服务提供者端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span><span class="string">/80(被占用用8080)</span></span><br><span class="line"><span class="comment">#服务别名----注册zookeeper到注册中心名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment/cloud-consumer-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.111</span><span class="number">.100</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><p>主启动类  加上&#x3D;&#x3D;@EnableDiscoveryClient&#x3D;&#x3D;注解</p><p>controller： 和eureka中的网站服务端客户端controller类似，网站客户端记得给restTemplate加上&#x3D;&#x3D;@LoadBalanced&#x3D;&#x3D;</p><h2 id="Consul（CP）"><a href="#Consul（CP）" class="headerlink" title="Consul（CP）"></a>Consul（CP）</h2><p>windows启动consul：</p><p>来到consul路径下，启动cmd，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure><p>通过网址  <a href="http://localhost:8500/">http://localhost:8500</a>  访问consul界面</p><p>新建module</p><p>改pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud consul-server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##consul服务端口号</span></span></span><br><span class="line">server:</span><br><span class="line">  port: 8006/8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consul-provider-payment/cloud-consumer-order</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###consul注册中心地址</span></span></span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br><span class="line">      discovery:</span><br><span class="line">        #hostname: 127.0.0.1</span><br><span class="line">        service-name: $&#123;spring.application.name&#125;</span><br></pre></td></tr></table></figure><p>主启动类  加上&#x3D;&#x3D;@EnableDiscoveryClient&#x3D;&#x3D;注解</p><p>controller： 和eureka中的网站服务端客户端controller类似，网站客户端记得给restTemplate加上&#x3D;&#x3D;@LoadBalanced&#x3D;&#x3D;</p><h2 id="三个注册中心的异同点（CAP概念）"><a href="#三个注册中心的异同点（CAP概念）" class="headerlink" title="三个注册中心的异同点（CAP概念）"></a>三个注册中心的异同点（CAP概念）</h2><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511190346678-shareX-20230511190353.png" alt="image-20230511190346678"></p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511190502168-shareX-20230511190502-shareX-20230511190527-shareX-20230517161159-shareX-20230517161209.png" alt="image-20230511190502168"></p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230517161117543-shareX-20230517161126-shareX-20230517161235.png"><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511190441650-shareX-20230511190441.png" alt="image-20230511190441650"></p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511190705880-shareX-20230511190706.png" alt="image-20230511190705880"></p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511190719259-shareX-20230511190719.png" alt="image-20230511190719259"></p><h1 id="服务调用1"><a href="#服务调用1" class="headerlink" title="服务调用1"></a>服务调用1</h1><p>&#x3D;&#x3D;服务调用：选取服务提供者集群中的具体某一个实例&#x3D;&#x3D;（从8001、8002中选择一个处理客户端的请求）</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511192521503-shareX-20230511192521.png" alt="image-20230511192521503"></p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>&#x3D;&#x3D;restTemplate实现调用服务端，@LoadBalance实现负载均衡&#x3D;&#x3D;</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511192644735-shareX-20230511192645.png" alt="image-20230511192644735"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入eureka依赖时就会引入ribbon依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="restTemplate的使用"><a href="#restTemplate的使用" class="headerlink" title="restTemplate的使用"></a>restTemplate的使用</h3><p>&#x3D;&#x3D;@LoadBalanced&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//    @LoadBalanced       //赋予RestTemplate负载均衡的能力，才能通过网站服务提供者的注册名称得到服务      自写轮询算法时注释掉</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public static final String PAYMENT_URL &#x3D; “<a href="http://cloud-payment-service/">http://CLOUD-PAYMENT-SERVICE</a>“;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;     //服务提供为单机版</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYMENT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;        <span class="comment">//服务提供为集群版，不能写死，写服务提供者的注册名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者插入时，插入了一条空数据：因为8001controller的create属性没有加<span class="doctag">@RequestBody</span>注解,重启两个module</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> payment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">create</span><span class="params">(Payment payment)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">&quot;/payment/create&quot;</span>,payment,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511195014319-shareX-20230511195014.png" alt="image-20230511195014319"></p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511195021942-shareX-20230511195022.png" alt="image-20230511195021942"></p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511195021942-shareX-20230511195022-shareX-20230511195040.png"></p><h3 id="IRule接口替换负载均衡算法"><a href="#IRule接口替换负载均衡算法" class="headerlink" title="IRule接口替换负载均衡算法"></a>IRule接口替换负载均衡算法</h3><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511195733581-shareX-20230511195734.png" alt="image-20230511195733581"></p><p>默认为轮询算法</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511200555370-shareX-20230511200555.png" alt="image-20230511200555370"></p><p>在客户端的主启动类的上一级包下新建一个包</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511200719617-shareX-20230511200719.png" alt="image-20230511200719617"></p><p>在新建包下新建MySelfRule规则类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfRule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();<span class="comment">//定义为随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在主启动类上添加@RibbonClient注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration=MySelfRule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="负载均衡算法原理"><a href="#负载均衡算法原理" class="headerlink" title="负载均衡算法原理"></a>负载均衡算法原理</h3><p>轮询算法原理：</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511201741922-shareX-20230511201743.png" alt="image-20230511201741922"></p><h3 id="手写轮询算法"><a href="#手写轮询算法" class="headerlink" title="手写轮询算法"></a>手写轮询算法</h3><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511212600922-shareX-20230511212601.png" alt="image-20230511212600922"></p><p>1、服务端8001、8002改造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只为测试用，在实际生产中为实际的CRUD操作</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/lb&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getPaymentLB</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> serverPort;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>2、去掉@LoadBalanced注解，确保是由自己写的算法生效</p><p>3、新建包lb，新建自写lb接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalancer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    ServiceInstance <span class="title function_">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、新建MyLB类，实现自写的lb接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLB</span> <span class="keyword">implements</span> <span class="title class_">LoadBalancer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">//初始值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="type">int</span> next;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = <span class="built_in">this</span>.atomicInteger.get();</span><br><span class="line">            next = current &gt;= <span class="number">2147483647</span> ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.atomicInteger.compareAndSet(current, next));       <span class="comment">//JUC内容，使用CAS+自旋锁减少锁的使用（当atomicInteger.get()==current,atomicInteger.set(next)）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****next: &quot;</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInstance <span class="title function_">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getAndIncrement() % serviceInstances.size();</span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、客户端80&#x2F;8080改造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> LoadBalancer loadBalancer;      <span class="comment">//引入自己的写的loadBalancer</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//在实际生产中，调用的是实际的CRUD操作，只是在CRUD操作前加上了选取服务的java语句</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/consumer/payment/lb&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getPaymentLB</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (instances == <span class="literal">null</span> || instances.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancer.instances(instances);</span><br><span class="line">       <span class="comment">//自写算法获取的服务的uri，若使用的是Ribbon，则通过PAYMENT_URL设置的算法自动获取</span></span><br><span class="line">       <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> serviceInstance.getUri();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> restTemplate.getForObject(uri + <span class="string">&quot;/payment/lb&quot;</span>,String.class);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="服务调用2"><a href="#服务调用2" class="headerlink" title="服务调用2"></a>服务调用2</h1><h2 id="OpenFeign（集成Ribbon，简化开发）"><a href="#OpenFeign（集成Ribbon，简化开发）" class="headerlink" title="OpenFeign（集成Ribbon，简化开发）"></a>OpenFeign（集成Ribbon，简化开发）</h2><p><strong>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。</strong></p><p><strong>它的使用方法是<span style="color:red;">定义一个服务接口然后在上面添加注解</span>。Feign也支持可拔插式的编码器和解码器。Spring Cloud</strong></p><p><strong>对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡</strong></p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230511215514842-shareX-20230511215515.png" alt="image-20230511215514842"><p>&#x3D;&#x3D;不再使用restTemplate，使用@EnableFejgnClients + @FeignClient(value &#x3D; “服务注册名”)实现调用服务端&#x3D;&#x3D;</p><p>&#x3D;&#x3D;OpenFeign自带负载均衡功能，不用再加@LoadBalance注解&#x3D;&#x3D;</p><h3 id="OpenFeign的使用：（客户端）"><a href="#OpenFeign的使用：（客户端）" class="headerlink" title="OpenFeign的使用：（客户端）"></a>OpenFeign的使用：（客户端）</h3><p>1、新建module，该module是客户端，不再使用原客户端（原客户端是使用的restTemplate）</p><p>2、改pom：（因为也是使用的eureka注册的服务，所以要加上eureka-client的依赖）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span><span class="string">//这里没有把自己注册到eureka服务中心</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><p>4、主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignMain80</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类：</p><p>业务逻辑接口+@FeignClient配置调用provider服务</p><p>（1）新建PaymentFeignService接口并新增注解@FeignClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）控制层Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>&#x3D;&#x3D;默认Feign客户端只等待一秒钟&#x3D;&#x3D;，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接返回报错。</p><p>为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p><p>&#x3D;&#x3D;yml文件中开启配置&#x3D;&#x3D;</p><p>服务提供方8001故意写暂停程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentFeignTimeOut</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;*****paymentFeignTimeOut from port: &quot;</span>+serverPort);</span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    <span class="keyword">return</span> serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务消费方80添加超时方法PaymentFeignService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentFeignTimeOut</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>服务消费方80添加超时方法OrderFeignController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentFeignTimeOut</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  paymentFeignService.paymentFeignTimeOut();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：  测试错误：Read timed out executing GET <a href="http://cloud-payment-service/payment/feign/timeout">http://CLOUD-PAYMENT-SERVICE/payment/feign/timeout</a></p><p>网站客户端YML文件里需要开启OpenFeign客户端超时控制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">read-timeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">connect-timeout:</span> <span class="number">5000</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">##爆黄，没有这个属性   也可以使用，但推荐使用feign中的属性</span></span><br><span class="line"><span class="comment">##设置feign客户端超时时间(OpenFeign默认支持ribbon)</span></span><br><span class="line"><span class="comment">#ribbon:</span></span><br><span class="line"><span class="comment">#  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line"><span class="comment">#  ReadTimeout: 5000</span></span><br><span class="line"><span class="comment">#  #指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line"><span class="comment">#  ConnectTimeout: 5000</span></span><br></pre></td></tr></table></figure><h3 id="OpenFeign日志打印功能"><a href="#OpenFeign日志打印功能" class="headerlink" title="OpenFeign日志打印功能"></a>OpenFeign日志打印功能</h3><p>Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。</p><p>说白了就是<span style="color:red;">对Feign接口的调用情况进行监控和输出</span></p><p>日志级别：</p><p>NONE：默认的，不显示任何日志；</p><p>BASIC：仅记录请求方法、URL、响应状态码及执行时间；</p><p>HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；</p><p>FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。</p><p>开启OpenFeign日志打印功能：</p><p>配置日志bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span><span class="comment">//Logger是feign下的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>YML文件里需要开启日志的Feign客户端：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.spongehah.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h1 id="服务降级、熔断、限流"><a href="#服务降级、熔断、限流" class="headerlink" title="服务降级、熔断、限流"></a>服务降级、熔断、限流</h1><p>分布式系统面临的问题</p><p><span style="color:red;">复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</span></p><p><span style="color:blue;"><strong>服务雪崩</strong></span><br>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的<span style="color:red;">“扇出”</span>。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.</p><p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。<br>所以，<br>通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>Hystrix是一个用于处理分布式系统的<span style="color:red;">延迟</span>和<span style="color:red;">容错</span>的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，<span style="color:red;">不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</span></p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），<span style="color:red;">向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常</span>，这样就<span style="color:red;">保证了服务调用方的线程不会被长时间、不必要地占用</span>，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><p><strong>Hystrix重要概念：</strong></p><p>服务降级(fallback)：服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示</p><p>服务熔断(break)：类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p><p>服务限流(flowlimit)：秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><p><strong>哪些情况会触发服务降级：</strong></p><p>程序运行异常</p><p>超时</p><p>服务熔断触发服务降级</p><p>线程池&#x2F;信号量打满也会导致服务降级</p><h3 id="Hystrix新建案例模块"><a href="#Hystrix新建案例模块" class="headerlink" title="Hystrix新建案例模块"></a>Hystrix新建案例模块</h3><p>1、新建cloud-provider-hystrix-payment8001</p><p>改pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentHystrixMain8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常访问，一切OK</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;paymentInfo_OK,id: &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时访问，演示降级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(timeout); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;paymentInfo_TimeOut,id: &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O，耗费(秒)   &quot;</span> + timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.paymentInfo_OK(id);</span><br><span class="line">        log.info(<span class="string">&quot;****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        log.info(<span class="string">&quot;****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、新建客户端cloud-consumer-feign-hystrix-order8080</p><p>改pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystrixMain8080</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain8080.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentHystrixService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystrixController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;通过jemeter高并发测试，使得服务拥挤&#x3D;&#x3D;</p><p><strong>解决方案：</strong></p><p>对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级</p><p>对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级</p><p>对方服务(8001)OK，调用者(80)自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级</p><h3 id="服务端服务降级"><a href="#服务端服务降级" class="headerlink" title="服务端服务降级"></a>服务端服务降级</h3><p>给服务端8001主启动类添加注解&#x3D;&#x3D;@EnableCircuitBreaker&#x3D;&#x3D;</p><p>给服务端8001 service层需要服务降级的方法添加注解&#x3D;&#x3D;@HystrixCommand&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span>       <span class="comment">//Hystrix注解激活标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentHystrixMain8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,commandProperties = &#123;     //指定服务降级fallback方法</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;)        //指定超时上限(ms)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(timeout); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;paymentInfo_TimeOut,id: &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O，耗费(秒)   &quot;</span> + timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//paymentInfo_TimeOut方法的备选方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/(ㄒoㄒ)/8001调用支付接口超时或异常：\t&quot;</span>+ <span class="string">&quot;\t当前线程池名字&quot;</span> + Thread.currentThread().getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端降级（降级一般是客户端）"><a href="#客户端降级（降级一般是客户端）" class="headerlink" title="客户端降级（降级一般是客户端）"></a>客户端降级（降级一般是客户端）</h3><p>改yaml：&#x3D;&#x3D;坑！！这里记得配置feign的超时控制时间，避免覆盖fallback方法设定的时间&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://eureka7001.com:7001/eureka/</span><br><span class="line"></span><br><span class="line">#设置Feign的超时控制，避免默认时长覆盖@HystrixProperty注解的设定时长</span><br><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default:</span><br><span class="line">        connect-timeout: 5000</span><br><span class="line">        read-timeout: 5000</span><br><span class="line">#  #开启@FeignClient注解的Hystrix功能，能指定fallback类</span><br><span class="line">#  hystrix:</span><br><span class="line">#    enabled: true</span><br><span class="line">##设置@FeignClient注解的Hystrix功能的全局超时时间</span><br><span class="line">#hystrix:</span><br><span class="line">#  command:</span><br><span class="line">#    default:</span><br><span class="line">#      execution:</span><br><span class="line">#        isolation:</span><br><span class="line">#          thread:</span><br><span class="line">#            timeoutInMilliseconds: 5000</span><br></pre></td></tr></table></figure><p>给客户端80&#x2F;8080主启动类添加注解&#x3D;&#x3D;@EnableHystrix&#x3D;&#x3D;（@EnableHystrix包含了@EnableCircuitBreaker，即@EnableHystrix继承了@EnableCircuitBreaker）</p><p>给服务端80&#x2F;8080 controller&#x2F;service层需要服务降级的方法添加注解&#x3D;&#x3D;@HystrixCommand&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystrixMain8080</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain8080.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        //这里设置的时间被Feign/Ribbon的客户端默认最长等待时间覆盖，还需要修改配置文件yaml</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;5000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局fallback方法配置（减少代码膨胀）"><a href="#全局fallback方法配置（减少代码膨胀）" class="headerlink" title="全局fallback方法配置（减少代码膨胀）"></a>全局fallback方法配置（减少代码膨胀）</h3><p>&#x3D;&#x3D;@DefaultProperties(defaultFallback &#x3D; “”)&#x3D;&#x3D;</p><p>  1：1 每个方法配置一个服务降级方法，技术上可以，实际上傻X</p><p>  1：N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback &#x3D; “”)  统一跳转到统一处理结果页面</p><p>   <span style="color:blue;">通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量，O(∩_∩)O哈哈~</span></p><p>在对应业务类上加注解@DefaultProperties(defaultFallback &#x3D; “”)指定全局通用fallback方法，再在改业务类中写一个全局通用fallback方法，加上了@Hystrix注解但未指明独有fallback方法的方法就调用全局通用fallback方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span>       <span class="comment">//指定通用fallback方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystrixController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="comment">//    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="comment">//            //这里设置的时间被Feign/Ribbon的客户端默认最长等待时间覆盖，还需要修改配置文件yaml</span></span><br><span class="line"><span class="comment">//            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;)</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局fallback方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">payment_Global_FallbackMethod</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service层使用Feign配置fallback类（实现解耦）"><a href="#Service层使用Feign配置fallback类（实现解耦）" class="headerlink" title="Service层使用Feign配置fallback类（实现解耦）"></a>Service层使用Feign配置fallback类（实现解耦）</h3><p>&#x3D;&#x3D;当服务端down机时，能够返回fallback类的fallback方法&#x3D;&#x3D;</p><p>改yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置Feign的超时控制，避免默认时长覆盖@HystrixProperty注解的设定时长</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connect-timeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">read-timeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#开启@FeignClient注解的Hystrix功能，能指定fallback类</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#设置@FeignClient注解的Hystrix功能的全局超时时间</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，<br>重新新建一个类(PaymentFallbackService)实现该接口，统一为接口里面的方法进行异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title class_">PaymentHystrixService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----PaymentFallbackservice fall back-paymentInfo_OK ,┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----PaymentFallbackservice fall back-paymentInfo_Timeout ,┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原PaymentHystrixService接口更改@FeignClient注解，指定fallback类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class)</span>  <span class="comment">//使用fallback需开启feign.hystrix.enabled=true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentHystrixService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务熔断break（熔断是服务端）"><a href="#服务熔断break（熔断是服务端）" class="headerlink" title="服务熔断break（熔断是服务端）"></a>服务熔断break（熔断是服务端）</h3><p><span style="color:blue;">熔断机制概述</span><br>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，<br>会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。</p><p>！！！！！！！！！！！！！</p><p>&#x3D;&#x3D;<span style="color:blue;">当检测到该节点微服务调用响应正常后，恢复调用链路。</span>&#x3D;&#x3D;</p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，<br>当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解也是&#x3D;&#x3D;@HystrixCommand。&#x3D;&#x3D;</p><p><span style="color:blue;">熔断类型：</span></p><p>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态</p><p>熔断关闭：熔断关闭不会对服务进行熔断</p><p>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</p><p>涉及到断路器的三个重要参数：<span style="color:blue;">快照时间窗、请求总数阀值、错误百分比阀值。</span></p><p>1：快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</p><p>2：请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</p><p>3：错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</p><p>断路器开启或者关闭的条件：</p><p>​当满足一定的阀值的时候（默认10秒内超过20个请求次数）且 当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p><p>​到达以上阀值，断路器将会开启，当开启的时候，所有请求都不会进行转发</p><p>​一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5</p><p>断路器打开之后：</p><p>1：再有请求调用的时候，将不会调用主逻辑，而是<span style="color:blue;">直接调用降级fallback</span>。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p><p>2：原来的主逻辑要如何恢复呢？<br>对于这一问题，hystrix也为我们实现了<span style="color:blue;">自动恢复功能</span>。<br>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，<br>当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，<br>主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p><p>修改cloud-provider-hystrix-payment8001：</p><p>1、修改PaymentServiceImpl:</p><p>添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=========服务熔断</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//设置属性来源：HystrixCommandProperties类，如果不设置，有缺省值</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),//是否开启断路器</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),//请求次数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;),//时间窗口期</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),//失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;******id 不能负数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serialNumber</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: &quot;</span> +id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、修改PaymentController：</p><p>添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.paymentCircuitBreaker(id);</span><br><span class="line">    log.info(<span class="string">&quot;****result: &quot;</span>+result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的配置说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//========================All</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;str_fallbackMethod&quot;,</span></span><br><span class="line"><span class="meta">        groupKey = &quot;strGroupCommand&quot;,</span></span><br><span class="line"><span class="meta">        commandKey = &quot;strCommand&quot;,</span></span><br><span class="line"><span class="meta">        threadPoolKey = &quot;strThreadPool&quot;,</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">        commandProperties = &#123;</span></span><br><span class="line"><span class="meta">                // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;execution.isolation.strategy&quot;, value = &quot;THREAD&quot;),</span></span><br><span class="line"><span class="meta">                // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                // 配置命令执行的超时时间</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;execution.isolation.thread.timeoutinMilliseconds&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                // 是否启用超时时间</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;execution.timeout.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                // 执行超时的时候是否中断</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnTimeout&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                // 执行被取消的时候是否中断</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnCancel&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                // 允许回调方法执行的最大并发数</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;fallback.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                // 服务降级是否启用，是否执行回调函数</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                // 是否启用断路器</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，</span></span><br><span class="line"><span class="meta">                // 如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过</span></span><br><span class="line"><span class="meta">                // circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50,</span></span><br><span class="line"><span class="meta">                // 就把断路器设置为 &quot;打开&quot; 状态，否则就设置为 &quot;关闭&quot; 状态。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，</span></span><br><span class="line"><span class="meta">                // 会将断路器置为 &quot;半开&quot; 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 &quot;打开&quot; 状态，</span></span><br><span class="line"><span class="meta">                // 如果成功就设置为 &quot;关闭&quot; 状态。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;circuitBreaker.sleepWindowinMilliseconds&quot;, value = &quot;5000&quot;),</span></span><br><span class="line"><span class="meta">                // 断路器强制打开</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;circuitBreaker.forceOpen&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                // 断路器强制关闭</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;circuitBreaker.forceClosed&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;metrics.rollingStats.timeinMilliseconds&quot;, value = &quot;10000&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置滚动时间窗统计指标信息时划分&quot;桶&quot;的数量，断路器在收集指标信息的时候会根据</span></span><br><span class="line"><span class="meta">                // 设置的时间窗长度拆分成多个 &quot;桶&quot; 来累计各度量值，每个&quot;桶&quot;记录了一段时间内的采集指标。</span></span><br><span class="line"><span class="meta">                // 比如 10 秒内拆分成 10 个&quot;桶&quot;收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;metrics.rollingPercentile.enabled&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;metrics.rollingPercentile.timeInMilliseconds&quot;, value = &quot;60000&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;metrics.rollingPercentile.numBuckets&quot;, value = &quot;60000&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，</span></span><br><span class="line"><span class="meta">                // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，</span></span><br><span class="line"><span class="meta">                // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;metrics.rollingPercentile.bucketSize&quot;, value = &quot;100&quot;),</span></span><br><span class="line"><span class="meta">                // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;metrics.healthSnapshot.intervalinMilliseconds&quot;, value = &quot;500&quot;),</span></span><br><span class="line"><span class="meta">                // 是否开启请求缓存</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;requestCache.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;requestLog.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        &#125;,</span></span><br><span class="line"><span class="meta">        threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">                // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，</span></span><br><span class="line"><span class="meta">                // 否则将使用 LinkedBlockingQueue 实现的队列。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;-1&quot;),</span></span><br><span class="line"><span class="meta">                // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。</span></span><br><span class="line"><span class="meta">                // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue</span></span><br><span class="line"><span class="meta">                // 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。</span></span><br><span class="line"><span class="meta">                @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;5&quot;),</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">strConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello 2020&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">str_fallbackMethod</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;*****fall back str_fallbackMethod&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Hystrix仪表盘HystrixDashboard9001"><a href="#Hystrix仪表盘HystrixDashboard9001" class="headerlink" title="Hystrix仪表盘HystrixDashboard9001"></a>Hystrix仪表盘HystrixDashboard9001</h3><p>新建module ： cloud-consumer-hystrix-dashboard9001</p><p>改pom：<span style="color:blue;">（actuator指标监控是各种监控的必备依赖）</span></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前学到的拥有可视化界面的组件：</p><p>druid</p><p>actuator</p><p>eureka</p><p>swagger</p><p>consul</p><p>hystrix</p><p>rabbitmq</p><p>zipkin</p><p>nacos</p><p>写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">proxy-stream-allow-list:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>主启动类：加上注解&#x3D;&#x3D;@EnableHystrixDashboard&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashboardMain9001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有Provider微服务提供类(8001&#x2F;8002&#x2F;8003)也都需要监控依赖配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意:新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径或者在yaml中开启hystrix.stream的指标监控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment"> *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment"> *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">    <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与上面加Bean二选一即可</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;hystrix.stream&quot;</span></span><br></pre></td></tr></table></figure><p>启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001：</p><p><a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></p><p>dashboard中输入<a href="http://localhost:8001/actuator/hystrix.stream%E8%AE%BF%E9%97%AE%E5%AF%B9%E5%BA%94%E5%AE%9E%E4%BE%8B%E6%9F%A5%E7%9C%8B%E7%9B%91%E6%8E%A7">http://localhost:8001/actuator/hystrix.stream访问对应实例查看监控</a></p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230513224938718-shareX-20230513224947.png" alt="image-20230513224938718" style="zoom:50%;"><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230513225002774-shareX-20230513225004.png" alt="image-20230513225002774"><h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。<br>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等</p><p>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控&#x2F;指标，和限流。</p><p>SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。</p><p>能干嘛？    反向代理、鉴权、流量控制、熔断、日志监控。。。。。。</p><p>Spring Cloud Gateway 具有如下特性：</p><p>基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；<br>动态路由：能够匹配任何请求属性；<br>可以对路由指定 Predicate（断言）和 Filter（过滤器）；<br>集成Hystrix的断路器功能；<br>集成 Spring Cloud 服务发现功能；<br>易于编写的 Predicate（断言）和 Filter（过滤器）；<br>请求限流功能；<br>支持路径重写。</p><p>三大核心概念：</p><p>Route(路由)：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</p><p>Predicate(断言)：参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，<span style="color:red;">如果请求与断言相匹配则进行路由</span></p><p>Filter(过滤)：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</p><p>微服务通用架构：</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230513225258009-shareX-20230513225300.png" alt="image-20230513225258009" style="zoom: 67%;"><h3 id="路由和断言配置（yaml）："><a href="#路由和断言配置（yaml）：" class="headerlink" title="路由和断言配置（yaml）："></a>路由和断言配置（yaml）：</h3><p>1、新建module cloud-gateway-gateway9527：</p><p>2、改pom：（不需要引入web-starter和actuator）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayMain9527</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GateWayMain9527.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、没有业务类</p><p>6、9527网关路由映射：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#访问路径localhost:9527+path的实际访问路径为：uri+path</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><h3 id="路由和断言配置（Bean注入）："><a href="#路由和断言配置（Bean注入）：" class="headerlink" title="路由和断言配置（Bean注入）："></a>路由和断言配置（Bean注入）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置了一个id为route-name的路由规则，</span></span><br><span class="line"><span class="comment">     * 当访问地址 http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RouteLocatorBuilder.<span class="type">Builder</span> <span class="variable">routes</span> <span class="operator">=</span> builder.routes();</span><br><span class="line"></span><br><span class="line">        routes.route(<span class="string">&quot;path_route_atguigu&quot;</span>, r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>).uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>)).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator2</span><span class="params">(RouteLocatorBuilder builder)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RouteLocatorBuilder.<span class="type">Builder</span> <span class="variable">routes</span> <span class="operator">=</span> builder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_atguigu2&quot;</span>, r -&gt; r.path(<span class="string">&quot;/guoji&quot;</span>).uri(<span class="string">&quot;http://news.baidu.com/guoji&quot;</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过微服务名实现动态路由"><a href="#通过微服务名实现动态路由" class="headerlink" title="通过微服务名实现动态路由"></a>通过微服务名实现动态路由</h3><p>在上列基础上，修改yaml文件，实现动态路由和负载均衡：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment"># uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment"># uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><h3 id="断言的具体使用："><a href="#断言的具体使用：" class="headerlink" title="断言的具体使用："></a>断言的具体使用：</h3><p>（一共九种）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment"># uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment"># uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">After=2023-05-14T14:42:57.342+08:00[Asia/Shanghai]</span>      <span class="comment">#满足这些断言才能放行</span></span><br><span class="line">            <span class="comment">#- Before=2020-02-05T15:10:03.685+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Between=2020-02-02T17:45:06.206+08:00[Asia/Shanghai],2020-03-25T18:59:06.206+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Cookie=username,zzyy</span></span><br><span class="line">            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式</span></span><br><span class="line">            <span class="comment">#- Host=**.atguigu.com</span></span><br><span class="line">            <span class="comment">#- Method=GET</span></span><br><span class="line">            <span class="comment">#- Query=username, \d+  # 要有参数名username并且值还要是整数才能路由</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230514151736394-shareX-20230514151744.png" alt="image-20230514151736394"></p><p>自带的过滤GatewayFilter和Gloabal过滤器都太多，且不常用，主要用的是&#x3D;&#x3D;自定义全局过滤器：&#x3D;&#x3D;</p><p>自认为：可以充当过滤器的：servlet原生filter，springboot-interceptor，网关的断言，网关的过滤器</p><p>​网关的过滤器是所有微服务的过滤器，而interceptor只是某个微服务自己的过滤器</p><p>自定义GlobalFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;*************come in MyLogGateWayFilter:  &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*******用户为null，非法用户，┭┮﹏┭┮&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230514171341136-shareX-20230514171342.png" alt="image-20230514171341136"></p><h3 id="config服务端配置与测试"><a href="#config服务端配置与测试" class="headerlink" title="config服务端配置与测试"></a>config服务端配置与测试</h3><p>准备工作：</p><p>1、用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository</p><p>2、由上一步获得刚新建的git地址  <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;">&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:spongehah&#x2F;springcloud-config.git</p><p>3、本地硬盘目录上新建git仓库并clonegit clone <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:spongehah&#x2F;springcloud-config.git（不行使用http）</p><p>新建Module模块cloud-config-center-3344<br>它即为Cloud的配置中心模块cloudConfig Center</p><p>&#x3D;&#x3D;这里有坑&#x3D;&#x3D;：解决踩坑参考帖子：<a href="https://blog.csdn.net/Learning_xzj/article/details/124472210?spm=1001.2014.3001.5506">https://blog.csdn.net/Learning_xzj/article/details/124472210?spm=1001.2014.3001.5506</a></p><p>改pom：（需要注册进eureka）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    坑！！！！！</span></span><br><span class="line"><span class="comment">    这里需要引入新的依赖，因为springcloudconfig不支持较新版本的rsa公钥            </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 不引入这个较旧的、没有维护的库，因为该版本不支持较新版本的RSA加密 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jcraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该版本支持较新版本的RSA（sha2-256 / sha2-512） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.mwiede<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写解析rsa公钥的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JschConfig</span> &#123;</span><br><span class="line">    <span class="comment">//Shim to fix the way jGit configures JSch</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        JSch.setConfig(<span class="string">&quot;signature.rsa&quot;</span>, <span class="string">&quot;com.jcraft.jsch.jce.SignatureRSA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:spongehah/springcloud-config.git</span> <span class="comment">#GitHub上面的git仓库名字</span></span><br><span class="line">          <span class="comment">####搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">####读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span><span class="comment">#新git主分支变为main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigCenterMain3344</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigCenterMain3344.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>windows下修改hosts文件，增加映射：  127.0.0.1  config-3344.com（可选）</p><h3 id="配置读取规则"><a href="#配置读取规则" class="headerlink" title="配置读取规则"></a>配置读取规则</h3><p>1、&#x2F;{label}&#x2F;{application}-{profile}.ymleg：<a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></p><p>2、&#x2F;{application}-{profile}.ymleg：<a href="http://config-3344.com:3344/config-dev.yml">http://config-3344.com:3344/config-dev.yml</a></p><p>3、&#x2F;{application}&#x2F;{profile}[&#x2F;{label}]eg：<a href="http://config-3344.com:3344/config/dev/master">http://config-3344.com:3344/config/dev/master</a></p><h3 id="config客户端配置与测试"><a href="#config客户端配置与测试" class="headerlink" title="config客户端配置与测试"></a>config客户端配置与测试</h3><p><span style="color:red;">bootstrap.yml</span>: </p><p>applicaiton.yml是用户级的资源配置项<br>bootstrap.yml是系统级的，<span style="color:red;">优先级更加高</span></p><p>Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用的<code>Application Context</code>的<span style="color:red;">父上下文</span>。初始化的时候，<code>Bootstrap Context</code>负责从<span style="color:red;">外部源</span>加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。</p><p><code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。 <code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，所以新增了一个<code>bootstrap.yml</code>文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p><p><span style="color:red;">要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，</span><br>因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml</p><p>1、新建cloud-config-client-3355</p><p>2、改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写bootstrap.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://localhost:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientMain3355</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3355.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坑！！！！！！！！！！！！！！！</p><p>&#x3D;&#x3D;修改git上的配置文件时，一定要注意yaml格式，冒号后面要加空格，否则config-client无法启动成功，@Value读取不到值&#x3D;&#x3D;</p><h3 id="config客户端之动态刷新"><a href="#config客户端之动态刷新" class="headerlink" title="config客户端之动态刷新"></a>config客户端之动态刷新</h3><p>当在github修改配置文件后，config-server会立即响应，而config-client只能重启或者重新加载才会更新</p><p>所以需要动态刷新：</p><p>修改3355模块：</p><p>pom引入actuator依赖：（除了网关都需要引入）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改YML，暴露监控端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端点(用于动态刷新)</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;@RefreshScope&#x3D;&#x3D;业务类Controller修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要运维人员发送Post请求刷新3355：</p><p>curl -X POST “<a href="http://localhost:3355/actuator/refresh">http://localhost:3355/actuator/refresh</a>“</p><p>若想一次刷新，处处生效，就需要用到服务总线：看下节</p><h1 id="服务总线"><a href="#服务总线" class="headerlink" title="服务总线"></a>服务总线</h1><p>什么是总线<br>在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。</p><h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。</p><p>基本原理<br>ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。</p><p>Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。</p><p>Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，<br>它整合了Java的事件处理机制和消息中间件的功能。<br>Spring Clud Bus目前支持<span style="color:red;">RabbitMQ和Kafka</span></p><h3 id="Erl-RabbitMQ环境配置"><a href="#Erl-RabbitMQ环境配置" class="headerlink" title="Erl+RabbitMQ环境配置"></a>Erl+RabbitMQ环境配置</h3><p>安装Erlang，下载地址：<a href="http://erlang.org/download/otp_win64_21.3.exe">http://erlang.org/download/otp_win64_21.3.exe</a></p><p>安装RabbitMQ，下载地址：<a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe">https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe</a></p><p>进入RabbitMQ安装目录下的sbin目录，输入以下命令启动管理功能和可视化插件：rabbitmq-plugins enable rabbitmq_management</p><p>访问地址查看是否安装成功：<a href="http://localhost:15672/">http://localhost:15672/</a>输入账号密码并登录：guest guest</p><h3 id="SpringCloud-Bus动态刷新全局广播"><a href="#SpringCloud-Bus动态刷新全局广播" class="headerlink" title="SpringCloud Bus动态刷新全局广播"></a>SpringCloud Bus动态刷新全局广播</h3><p>设计思想：</p><p>1）利用消息总线触发一个客户端&#x2F;bus&#x2F;refresh,而刷新所有客户端的配置</p><p>2）<span style="color:red;">利用消息总线触发一个服务端ConfigServer的&#x2F;bus&#x2F;refresh端点，而刷新所有客户端的配置</span></p><p>二的架构显然更加适合，一不适合的原因如下：</p><p>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。</p><p>破坏了微服务各节点的对等性。</p><p>有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改</p><p>1、必须先具备良好的RabbitMQ环境</p><p>2、新建cloud-config-client-3366，拥有两个config-client</p><p>3、改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、写bootstrap.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3366</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://localhost:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露监控端点(用于动态刷新)</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>5、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientMain3366</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3366.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>6、业务类：和3355一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、给config-server3344和   config-client3355、3366添加mq-bus依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>8、给config-server3344添加yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line"><span class="comment">#          uri: https://github.com/spongehah/springcloud-config.git #GitHub上面的git仓库名字</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@gitee.com:zhaoyingjiehaha/springcloud-config.git</span></span><br><span class="line">          <span class="comment">####搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">          <span class="attr">default-label:</span> <span class="string">main</span></span><br><span class="line">      <span class="comment">####读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br><span class="line">  <span class="comment">#rabbitmq相关配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span> </span><br><span class="line">      </span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span> </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">##rabbitmq相关配置,暴露bus刷新配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span> <span class="comment">#暴露bus刷新配置的端点</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;bus-refresh&#x27;</span></span><br></pre></td></tr></table></figure><p>9、给config-client3355、3366添加yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span><span class="string">/3366</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://localhost:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line">  <span class="comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 暴露监控端点(用于动态刷新)</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>10、全局广播：git上修改配置文件后，给config-server发送post请求：curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh">http://localhost:3344/actuator/bus-refresh</a>“</p><h3 id="SpringCloud-Bus动态刷新定点通知"><a href="#SpringCloud-Bus动态刷新定点通知" class="headerlink" title="SpringCloud Bus动态刷新定点通知"></a>SpringCloud Bus动态刷新定点通知</h3><p>指定具体某一个实例生效而不是全部 </p><p>公式：<a href="http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}">http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}</a></p><p>我们这里以刷新运行在3355端口上的config-client为例：curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh/config-client:3355">http://localhost:3344/actuator/bus-refresh/config-client:3355</a>“</p><p>坑！！！！！！！！！！！！！！！</p><p>&#x3D;&#x3D;修改git上的配置文件时，一定要注意yaml格式，冒号后面要加空格，否则config-client无法启动成功，@Value读取不到值&#x3D;&#x3D;</p><h1 id="服务优化"><a href="#服务优化" class="headerlink" title="服务优化"></a>服务优化</h1><h2 id="Stream消息驱动"><a href="#Stream消息驱动" class="headerlink" title="Stream消息驱动"></a>Stream消息驱动</h2><p><span style="color:blue;">什么是SpringCloudStream</span>：<span style="color:red;">屏蔽底层消息中间件的差异,降低切换成本，统一消息的编程模型</span><br>官方定义 Spring Cloud Stream 是一个构建消息驱动微服务的框架。</p><p>应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream中binder对象交互。<br>通过我们配置来binding(绑定) ，而 Spring Cloud Stream 的 binder对象负责与消息中间件交互。<br>所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。</p><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。<br>Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p><p>目前仅支持<span style="color:red;">RabbitMQ和Kafka</span></p><p>通过定义绑定器作为中间层，完美地实现了<span style="color:red;">应用程序与消息中间件细节之间的隔离</span>。<br>通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230516132509415-shareX-20230516132517.png" alt="image-20230516132509415"></p><p>&#x3D;&#x3D;Stream中的消息通信方式遵循了发布-订阅模式，Topic主题进行广播，在RabbitMQ就是Exchange，在Kakfa中就是Topic&#x3D;&#x3D;</p><p>Spring Cloud Stream标准流程套路：</p><p>Binder：很方便的连接中间件，屏蔽差异</p><p>Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置</p><p>Source和Sink：简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230516132942813-shareX-20230516132944.png" alt="image-20230516132942813"><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230516133057166-shareX-20230516133058.png" alt="image-20230516133057166"></p><h3 id="消息驱动之生产者配置"><a href="#消息驱动之生产者配置" class="headerlink" title="消息驱动之生产者配置"></a>消息驱动之生产者配置</h3><p>先搭建好kafka或者rabbitMQ的环境</p><p>1、新建modulecloud-stream-rabbitmq-provider8801</p><p>2、改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写yaml：（爆红不管）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure><p>4、主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMQMain8801</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8801.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类</p><p>发送消息接口IMessageProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMessageProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息接口实现类MessageProviderImpl </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spongehah.springcloud.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spongehah.springcloud.service.IMessageProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding(Source.class)</span><span class="comment">// 可以理解为是一个消息的发送管道的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title class_">IMessageProvider</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serial</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="built_in">this</span>.output.send(MessageBuilder.withPayload(serial).build()); <span class="comment">// 创建并发送消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;***serial: &quot;</span> + serial);</span><br><span class="line">        <span class="keyword">return</span> serial;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider messageProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息驱动之消费者配置"><a href="#消息驱动之消费者配置" class="headerlink" title="消息驱动之消费者配置"></a>消息驱动之消费者配置</h3><p>1、新建modulecloud-stream-rabbitmq-consumer8802</p><p>2、改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMQMain8802</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8802.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spongehah.springcloud.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.StreamListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Sink;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageListener</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">(Message&lt;String&gt; message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号，-------&gt;接收到的消息：&quot;</span> + message.getPayload()+<span class="string">&quot;\t port: &quot;</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试8801看8802能不能收到消息</p><h3 id="分组消费与持久化"><a href="#分组消费与持久化" class="headerlink" title="分组消费与持久化"></a>分组消费与持久化</h3><p>&#x3D;&#x3D;重复消费问题：&#x3D;&#x3D;</p><p>不指定消费者group时，系统会自动分配给两个消费者不同的组别，若两个微服务属于同一种微服务类型，就会造成重复消费，所以要把相同类型的微服务放到同一个group中</p><p>1、将8802复制一份为8803，更改名字和端口号即可</p><p>2、<a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a>目前是8802&#x2F;8803同时都收到了，存在重复消费问题</p><p>3、分组：</p><p>&#x3D;&#x3D;微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。&#x3D;&#x3D;<br>不同的组是可以消费的，同一个组内会发生竞争关系，只有其中一个可以消费。</p><p>更改group：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">spongehahA</span>   <span class="comment">#设置消费组，避免重复消费问题和消息丢失问题</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;持久化：&#x3D;&#x3D;</p><p>当配置好group时，就拥有了持久化，配置好group后，当消费者down机重启时，未消费过的消息也会被读取到</p><p>若未配置group，当消费者down机重启时，未消费过的消息不会再被读取到，出现消息&#x3D;&#x3D;丢失问题&#x3D;&#x3D;</p><h2 id="Sleuth分布式请求链路跟踪"><a href="#Sleuth分布式请求链路跟踪" class="headerlink" title="Sleuth分布式请求链路跟踪"></a>Sleuth分布式请求链路跟踪</h2><p> 在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p><p>Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin</p><p>一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各span通过parent id 关联起来</p><p>Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识</p><p>span:表示调用链路来源，通俗的理解span就是一次请求信息</p><h3 id="zipkin环境安装"><a href="#zipkin环境安装" class="headerlink" title="zipkin环境安装"></a>zipkin环境安装</h3><p><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/%E4%B8%8B%E8%BD%BDjar%E5%8C%85">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/下载jar包</a></p><p>目录下找到jar包，使用java -jar命令运行jar包</p><p>网页控制台：<a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>在cloud-provider-payment8001中：</p><p>改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--包含了sleuth+zipkin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改yaml：（spring：下加入zipkin和sleuth部分）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment">#采样率值介于 0 到 1 之间，1 则表示全部采集,一般写0.5</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_test?useUnicode=true&amp;characterEncoding=utf-8&amp;userSSL-false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/payment/zipkin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentZipkin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi ,i&#x27;am paymentzipkin server fall back，welcome to atguigu，O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在cloud-consumer-order80中：</p><p>改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--包含了sleuth+zipkin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment">#采样率值介于 0 到 1 之间，1 则表示全部采集,一般写0.5</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================&gt; zipkin+sleuth</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/zipkin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentZipkin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8001&quot;</span>+<span class="string">&quot;/payment/zipkin/&quot;</span>, String.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringcloudAlibaba-2-2-8RELEASE"><a href="#SpringcloudAlibaba-2-2-8RELEASE" class="headerlink" title="SpringcloudAlibaba-2.2.8RELEASE"></a>SpringcloudAlibaba-2.2.8RELEASE</h1><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230516203908008-shareX-20230516203910.png" alt="image-20230516203908008"></p><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>版本参考目录SpringcloudAlibaba处的表格对照，这里选用的是2.1.0</p><p>Nacos就是注册中心 + 配置中心的组合</p><p>Nacos &#x3D; Eureka+Config +Bus</p><p>安装运行Nacos：</p><p>本地Java8+Maven环境已经OK</p><p>先从官网下载Nacos</p><p>解压安装包，直接运行bin目录下的startup.cmd</p><p>（较新版本的nacos默认启动方式为集群cluster模式，运行前先修改startup.cmd文件，将mode修改为standalone，或者启动命令后加加上-m standalone）且安装目录不能有中文</p><p>命令运行成功后直接访问<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a>默认账号密码都是nacos</p><h2 id="Nacos作为注册中心（AP）"><a href="#Nacos作为注册中心（AP）" class="headerlink" title="Nacos作为注册中心（AP）"></a>Nacos作为注册中心（AP）</h2><h3 id="网站服务端"><a href="#网站服务端" class="headerlink" title="网站服务端"></a>网站服务端</h3><p>1、新建module：cloudalibaba-provider-payment9001</p><p>2、改pom：</p><p>父项目pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring cloud alibaba 2.2.8.RELEASE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>module的pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain9001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nacos registry, serverPort: &quot;</span>+ serverPort+<span class="string">&quot;\t id&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、新建9002构成网站服务端集群，因为配置和9001完全一样，故使用copy configuration复制一个相同的环境使用虚拟端口映射，使用9002号端口进行启动</p><p>name：PaymentMain9002 CopyOf 9001</p><p>VM options：-DServer.port&#x3D;9002</p><h3 id="网站客户端-消费端ribbon版（使用restRemplate）"><a href="#网站客户端-消费端ribbon版（使用restRemplate）" class="headerlink" title="网站客户端&#x2F;消费端ribbon版（使用restRemplate）"></a>网站客户端&#x2F;消费端ribbon版（使用restRemplate）</h3><p>1、新建module：cloudalibaba-consumer-nacos-order83</p><p>2、改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span> </span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosMain83</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain83.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类：ribbon版（使用restRemplate）</p><p>写config：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网站客户端-消费端Feign版"><a href="#网站客户端-消费端Feign版" class="headerlink" title="网站客户端&#x2F;消费端Feign版"></a>网站客户端&#x2F;消费端Feign版</h3><p><strong>客户端&#x2F;消费端是调用服务的那一端，不是提供服务的那一端</strong></p><p>1、新建module：cloudalibaba-consumer-nacos-feign-order83</p><p>2、改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosFeignMain83</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosFeignMain83.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类：</p><p>业务逻辑接口+@FeignClient配置调用provider服务</p><p>（1）新建PaymentFeignService接口并新增注解@FeignClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;nacos-payment-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosFeignController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPayment(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nacos与其他服务注册中心的对比"><a href="#Nacos与其他服务注册中心的对比" class="headerlink" title="Nacos与其他服务注册中心的对比"></a>Nacos与其他服务注册中心的对比</h3><p><span style="color:red;">C是所有节点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。</span></p><p>何时选择使用何种模式？<br>一般来说，<br>如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如 Spring cloud 和 Dubbo 服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。</p><p>如果需要在服务级别编辑或者存储配置信息，那么 CP 是必须，K8S服务和DNS服务则适用于CP模式。<br>CP模式下则支持注册持久化实例，此时则是以 Raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</p><p><span style="color:red;">Nacos 支持AP和CP模式的切换</span></p><p>curl -X PUT ‘$NACOS_SERVER:8848&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;operator&#x2F;switches?entry&#x3D;serverMode&amp;value&#x3D;CP’</p><h2 id="Nacos作为配置中心"><a href="#Nacos作为配置中心" class="headerlink" title="Nacos作为配置中心"></a>Nacos作为配置中心</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>1、新建module：cloudalibaba-config-nacos-client3377</p><p>2、改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、写yaml：</p><p>Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，<br>拉取配置之后，才能保证项目的正常启动。</p><p>springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application</p><p>这里要写bootstrap.yaml + application.yaml:</p><p>bootstrap.yaml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br></pre></td></tr></table></figure><p>application.yaml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConfigClientMain3377</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(NacosConfigClientMain3377.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line">    <span class="meta">@RefreshScope</span><span class="comment">//在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置读取规则-1"><a href="#配置读取规则-1" class="headerlink" title="配置读取规则"></a>配置读取规则</h3><p>新增、修改配置：</p><p>&#x3D;&#x3D;注意前面的坑：注意yaml文件的缩进格式，冒号后面不要漏写空格&#x3D;&#x3D;</p><p>在<a href="http://localhost:8848/nacos/%E9%A1%B5%E9%9D%A2%E6%96%B0%E5%A2%9E%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">http://localhost:8848/nacos/页面新增修改配置文件</a></p><p>公式：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230517170901825-shareX-20230517170902.png" alt="image-20230517170901825" style="zoom: 80%;"><p>Nacos会记录配置文件的历史版本默认保留30天，此外还有&#x3D;&#x3D;一键回滚&#x3D;&#x3D;功能，回滚操作将会触发配置更新</p><p>&#x3D;&#x3D;自带动态刷新：&#x3D;&#x3D;（已经加上了@RefreshScope）</p><p>修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新</p><h3 id="三种方案加载配置"><a href="#三种方案加载配置" class="headerlink" title="三种方案加载配置"></a>三种方案加载配置</h3><p>Namespace+Group+Data ID三者关系？为什么这么设计？</p><p>默认情况：<br>Namespace&#x3D;public，Group&#x3D;DEFAULT_GROUP, 默认Cluster是DEFAULT</p><p>Nacos默认的命名空间是public，Namespace主要用来实现隔离。<br>比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。</p><p>Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去</p><p>Service就是微服务；一个Service可以包含多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。<br>比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，<br>这时就可以给杭州机房的Service微服务起一个集群名称（HZ），<br>给广州机房的Service微服务起一个集群名称（GZ），还可以尽量让同一个机房的微服务互相调用，以提升性能。</p><p>最后是Instance，就是微服务的实例。</p><p>&#x3D;&#x3D;DataID方案&#x3D;&#x3D;：</p><p>指定application.yaml配置文件中spring.profile.active的值和Nacos服务端配置文件的DataID来使不同环境下读取不同的配置</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230517175103150-shareX-20230517175104.png" alt="image-20230517175103150" style="zoom: 67%;"><p>&#x3D;&#x3D;Group方案&#x3D;&#x3D;：</p><p>通过Group实现环境区分</p><p>在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST_GROUP</p><p>指定bootstrap.yaml下nacos.config.group的值和application.yaml中spring.profile.active的值且与nacos中心的对应值相等</p><p>修改bootstrap.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEV_GROUP</span> <span class="comment">#指定nacos中心配置文件的分组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br></pre></td></tr></table></figure><p>application.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line"><span class="comment">#    active: test # 表示测试环境</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Namespace方案&#x3D;&#x3D;：</p><p>指定bootstrap.yaml下nacos.config.group和namespace的值和application.yaml中spring.profile.active的值且与nacos中心的对应值相等</p><p>bootstrap.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEV_GROUP</span> <span class="comment">#指定nacos中心配置文件的分组</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">deve9a0eac7-5df9-4a4b-beae-5ac71df2e76e</span>   <span class="comment">#指定nacos中心配置文件的命名空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br></pre></td></tr></table></figure><p>application.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line"><span class="comment">#    active: test # 表示测试环境</span></span><br></pre></td></tr></table></figure><h2 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h2><h3 id="Windows版持久化（设置为mysql数据库）"><a href="#Windows版持久化（设置为mysql数据库）" class="headerlink" title="Windows版持久化（设置为mysql数据库）"></a>Windows版持久化（设置为mysql数据库）</h3><p>Nacos默认自带的是嵌入式数据库derby，nacos集群中一台nacos一个数据库，按照上述，我们需要mysql数据库，统一nacos集群之间的数据来源</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230517193253725-shareX-20230517193255.png" alt="image-20230517193253725"></p><p>nacos-server-1.1.4\nacos\conf目录下找到nacos-mysql.sql脚本，在mysql中执行脚本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">64</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`enabled` <span class="type">boolean</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `roles` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="keyword">ASC</span>, `role` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permissions` (</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password, enabled) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> roles (username, role) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>nacos-server-1.1.4\nacos\conf目录下找到application.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">db.user</span>=<span class="string">root#自己的mysql用户名</span></span><br><span class="line"><span class="attr">db.password</span>=<span class="string">123456#自己的mysql密码</span></span><br></pre></td></tr></table></figure><p>重新启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby</p><h3 id="Nacos2-x集群配置步骤-重点"><a href="#Nacos2-x集群配置步骤-重点" class="headerlink" title="Nacos2.x集群配置步骤(重点)"></a>Nacos2.x集群配置步骤(重点)</h3><p><span style="color:red;">因选用的是nacos2.x版本，采用网上很多教学踩了很多坑，用了两天才把坑圆过来呜呜呜</span>(主要是nginx&#x2F;VIP转发的配置)</p><h4 id="linux安装Nacos："><a href="#linux安装Nacos：" class="headerlink" title="&#x3D;&#x3D;linux安装Nacos：&#x3D;&#x3D;"></a>&#x3D;&#x3D;linux安装Nacos：&#x3D;&#x3D;</h4><p>下载nacos.tar.gz包到&#x2F;opt&#x2F;下</p><p>使用tar -zxvf nacos.tar.gz命令解压</p><p>将解压出来的nacos包复制到&#x2F;mynacos&#x2F;nacoscp -r nacos &#x2F;mynacos&#x2F;nacos</p><p>cd &#x2F;mynacos&#x2F;bin</p><p>.&#x2F;startup.sh</p><h4 id="nacos2-x集群配置：-三台才能构成集群"><a href="#nacos2-x集群配置：-三台才能构成集群" class="headerlink" title="&#x3D;&#x3D;nacos2.x集群配置：&#x3D;&#x3D;(三台才能构成集群)"></a>&#x3D;&#x3D;nacos2.x集群配置：&#x3D;&#x3D;(三台才能构成集群)</h4><p>1、修改nacos持久化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /mynacos/nacos/conf/application.properties</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root#自己的mysql用户名</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">123456#自己的mysql密码</span></span><br></pre></td></tr></table></figure><p>2、创建nacos_config数据库，并执行nacos提供的nacos-mysql.sql脚本 ，脚本文件放在 conf&#x2F;nacos-mysql.sql:</p><p>3、修改 nacos 的集群配置:</p><p>进入到 conf 目录中，将集群文件拷贝一份以便进行后续的操作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp cluster.conf.example cluster.conf</span><br></pre></td></tr></table></figure><p>对集群配置文件进行修改:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim cluster.conf</span><br></pre></td></tr></table></figure><p>在一台机器上部署nacos集群时，&#x3D;&#x3D;不能将运行端口设置为连续端口&#x3D;&#x3D;，比如8841、8842、8843，否则会发生端口冲突。<br>运行在8841端口nacos服务实际上会占用8841、8941、8942三个端口；</p><p>修改 ip 配置（如果是不同机器的同端口）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip1:端口</span><br><span class="line">ip2</span><br><span class="line">ip3</span><br></pre></td></tr></table></figure><p>修改ip配置（如果是同一台机器的不同端口，端口号不能连续）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip1:端口1</span><br><span class="line">ip1:端口2</span><br><span class="line">ip1:端口3</span><br></pre></td></tr></table></figure><p>4、 修改配置文件中的 nacos 启动端口:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/application.properties</span><br></pre></td></tr></table></figure><p>修改server.port:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">集群端口1</span></span><br></pre></td></tr></table></figure><p>5、进入bin目录，修改运行内存，默认的 nacos 启动配置的消耗资源很大，如果服务器支持则可以不进行修改，服务器资源不支持可能会出现启动之后 nacos 集群循环重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim startup.sh</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230518113700571-shareX-20230518113702.png" alt="image-20230518113700571"></p><p>6、复制出两份 nacos 文件夹，制作集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -r /mynacos/nacos /mynacos/nacos-2</span><br><span class="line">cp -r /mynacos/nacos /mynacos/nacos-3</span><br></pre></td></tr></table></figure><p>分别进入nacos-2&#x2F;conf、nacos-3&#x2F;conf目录下，将其application.properties配置文件中的server.port修改为自定义集群端口2、自定义集群端口3</p><p>7、启动 | 停止 nacos 集群<br>分别进入&#x2F;nacos&#x2F;bin、&#x2F;nacos-2&#x2F;bin、&#x2F;nacos-3&#x2F;bin目录下，执行命令.&#x2F;startup.sh启动nacos服务。</p><p>分别进入&#x2F;nacos&#x2F;bin、&#x2F;nacos-2&#x2F;bin、&#x2F;nacos-3&#x2F;bin目录下，执行命令.&#x2F;shutdown.sh停止nacos服务。</p><p>至此，基于 tar 包的 nacos 2.x 集群部署就结束了</p><p>还要布置ngnix环境，才能通过ngnix访问到nacos集群</p><h4 id="nginx环境配置"><a href="#nginx环境配置" class="headerlink" title="&#x3D;&#x3D;nginx环境配置&#x3D;&#x3D;"></a>&#x3D;&#x3D;nginx环境配置&#x3D;&#x3D;</h4><p>从官网下载tar.gz包后，放到&#x2F;opt目录下</p><p>使用tar -zxvf xxx.tar.gz解压</p><p>cd nginx-1.21.6</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用改命令配置nginx，若出现依赖项缺少，复制出错内容上网搜索对应依赖项安装后继续执行该语句</span></span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-stream</span><br></pre></td></tr></table></figure><p>执行成功后：执行make &amp;&amp; make install安装，安装的默认路径是&#x2F;usr&#x2F;local&#x2F;nginx</p><p>修改ngnix配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">cp nginx.conf nginx.conf.bk#备份配置文件</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230518215622709-shareX-20230518215624.png" alt="image-20230518215622709"></p><p>详细配置看：<a href="https://blog.csdn.net/qq_42971035/article/details/127243864">https://blog.csdn.net/qq_42971035/article/details/127243864</a></p><p>找到对应模块，修改内容如下：#代表修改过的地方</p><p>若为nacos1.x：只需要配置http服务即可</p><p>若为nacos2.x：则&#x3D;&#x3D;http服务和tcp服务&#x3D;&#x3D;都必须配置，缺一不可，坑：没配置tcp服务，将会出现浏览器能访问，而项目无法启动</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http服务</span></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">...其他...</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">cluster&#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:3333;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:4444;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:5555;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&#125;</span>   <span class="string"></span></span><br><span class="line"></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">1111;</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">192.168.111.100;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123; </span></span><br><span class="line"><span class="comment">            #root   html;</span></span><br><span class="line"><span class="comment">            #index  index.html index.htm;</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://cluster;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span></span><br><span class="line">        <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">...其他...</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># tpc服务</span></span><br><span class="line"><span class="attr">stream&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # tcp负载均衡</span></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">nacos-grpc &#123;</span></span><br><span class="line">         <span class="attr">server</span> <span class="string">192.168.111.100:4333;</span></span><br><span class="line">         <span class="attr">server</span> <span class="string">192.168.111.100:5444;</span></span><br><span class="line">         <span class="attr">server</span> <span class="string">192.168.111.100:6555;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="comment">    # Nacos客户端gRPC请求服务端端口</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">        #listen 5444;</span></span><br><span class="line">        <span class="attr">listen</span> <span class="string">2111;</span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">nacos-grpc;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # tcp负载均衡</span></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">nacos-tcp-5445 &#123;</span></span><br><span class="line">         <span class="attr">server</span> <span class="string">192.168.111:4334 weight=1;</span></span><br><span class="line">         <span class="attr">server</span> <span class="string">192.168.111:5445 weight=1;</span></span><br><span class="line">         <span class="attr">server</span> <span class="string">192.168.111:6556 weight=1;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="comment">    # Nacos服务端gRPC请求服务端端口</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">        #listen 5445;</span></span><br><span class="line">        <span class="attr">listen</span> <span class="string">2112;</span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">nacos-tcp-5445;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动nacos集群后，启动nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nginx其他命令：</span></span><br><span class="line">./nginx -V#可查看nginx安装的插件</span><br><span class="line">./nginx -s reload#重载配置文件</span><br><span class="line">./nginx -s stop#强制中断</span><br><span class="line">./nginx -s quit#安全退出</span><br></pre></td></tr></table></figure><p>关闭防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>这样，就可以通过自己的虚拟机ip：</p><p>&#x3D;&#x3D;192.168.111.100:1111&#x2F;nacos访问到nacos集群了&#x3D;&#x3D;</p><p>也可以通过指定端口号访问集群中的某台主机：</p><p>192.168.111.100:3333&#x2F;nacos</p><p>踩坑结束</p><h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>版本参考目录SpringcloudAlibaba处的表格对照这里选用的是1.8.4</p><p>官网下载<a href="https://github.com/alibaba/Sentinel/releases%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E5%90%8E%EF%BC%8C">https://github.com/alibaba/Sentinel/releases对应版本后，</a></p><p>直接用java -jar命令运行，默认运行端口为8080，若端口被占用，可使用–server.port&#x3D;xxx更改启动端口</p><p>访问sentinel管理界面：<a href="http://localhost:8080/">http://localhost:8080</a>登录账号密码均为sentinel</p><p>启动nacos</p><h2 id="sentinel新建案例模块"><a href="#sentinel新建案例模块" class="headerlink" title="sentinel新建案例模块"></a>sentinel新建案例模块</h2><p>1、新建网站服务端：cloudalibaba-sentinel-service8401</p><p>改pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud alibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud alibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud alibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp8401</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApp8401.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动8401微服务后查看sentienl控制台：空空如也，啥都没有</p><p>Sentinel采用的懒加载，执行一次访问即可</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li><p>资源名：唯一名称，默认请求路径</p></li><li><p>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default(不区分来源)</p></li><li><p>阈值类型单机阈值：</p><ul><li>QPS(每秒钟的请求数量)：当调用该pi的QPS达到阈值的时候，进行限流</li><li>线程数：当调用该api的线程数达到阈值的时候，进行限流</li></ul></li><li><p>是否集群：不需要集群</p></li><li><p>流控模式：</p><ul><li>直接：api达到限流条件时，直接限流</li><li>关联：当关联的资源达到阈值时，就限流自己</li><li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】</li></ul></li><li><p>流控效果：</p><ul><li><p>快速失败：直接失败，抛异常</p></li><li><p>Warm Up:根据codeFactor(冷加载因子，默认3)的值，从阈值&#x2F;codeFactor,经过预热时长，才达到设置的QPS阈值</p></li><li><p>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS,否则无效</p></li></ul></li></ul><h3 id="流控模式（流控效果默认快速失败）"><a href="#流控模式（流控效果默认快速失败）" class="headerlink" title="流控模式（流控效果默认快速失败）"></a>流控模式（流控效果默认快速失败）</h3><h4 id="直接"><a href="#直接" class="headerlink" title="直接"></a>直接</h4><p>该设置表示1秒钟内查询1（阈值）次就是OK，若超过次数1，就直接-快速失败，报默认错误：</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519174812532-shareX-20230519174820.png" alt="image-20230519174812532" style="zoom: 67%;"><p>测试：</p><p>快速点击访问<a href="http://localhost:8401/testA">http://localhost:8401/testA</a></p><p>结果：Blocked by Sentinel (flow limiting)</p><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>当关联的资源达到阈值时，就限流自己</p><p>eg：当与A关联的资源B达到阀值后，就限流A自己</p><p>该设置表示当关联资源&#x2F;testB的qps阀值超过1时，就限流&#x2F;testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519175109657-shareX-20230519175110.png" alt="image-20230519175109657" style="zoom:67%;"><p>测试：</p><p>快速点击访问<a href="http://localhost:8401/testB%E8%BF%87%E5%90%8E%EF%BC%8C%E5%9C%A8%E4%B8%80%E7%A7%92%E5%86%85%E8%AE%BF%E9%97%AEhttp://localhost:8401/testA%E5%B0%86%E4%BC%9A%E5%87%BA%E7%8E%B0Blocked">http://localhost:8401/testB过后，在一秒内访问http://localhost:8401/testA将会出现Blocked</a> by Sentinel (flow limiting)</p><p>大批量线程高并发访问B，导致A失效了</p><p>或者用jemter或postman测试</p><h4 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h4><p>新建接口OrderService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用@SentinelResource注解</span></span><br><span class="line">    <span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询商品。。。。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderService.queryGoods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderService.queryGoods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yaml将  web-context-unify设置为false，关闭context整合</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span>  <span class="comment">#关闭context整合</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>在controller中，query和save方法都调用了orderService.queryGoods()方法，那么query和save方法的&#x3D;&#x3D;uri就是queryGoods()方法的入口资源&#x3D;&#x3D;，流控的资源名由@SentinelResource注解设置</p><p>链路模式依赖 &#x2F;a &#x2F;b这样的路径，而做整合后，原始的&#x2F;a &#x2F;b被隐藏掉了，无法判断上下游直接的关系了</p><p>所以这里要将web-context-unify设置为false，因为Sentinel默认会将Controller方法做context整合，导致链路模式的流控失效</p><p>参考：<a href="https://blog.csdn.net/m0_45406092/article/details/123303275">https://blog.csdn.net/m0_45406092/article/details/123303275</a></p><p>该设置表示设置入口资源为&#x2F;save   时，对goods进行限流</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519204610131-shareX-20230519204611.png" alt="image-20230519204610131" style="zoom: 50%;"><p>测试：</p><p>快速访问localhost:8401&#x2F;query时，不会限流</p><p>快速访问localhost:84save时，会限流</p><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><h4 id="快速失败："><a href="#快速失败：" class="headerlink" title="快速失败："></a>快速失败：</h4><p>若限流，直接失败，抛出异常，默认为Blocked by Sentinel (flow limiting)</p><h4 id="预热WarmUp"><a href="#预热WarmUp" class="headerlink" title="预热WarmUp"></a>预热WarmUp</h4><p>如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。</p><p>即限流，冷启动</p><p>公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值</p><p>默认coldFactor为3，即请求 QPS 从 threshold &#x2F; 3 开始，经预热时长逐渐升至设定的 QPS 阈值。</p><p>案例，阀值为10+预热时长设置5秒。<br>系统初始化的阀值为10 &#x2F; 3 约等于3,即阀值刚开始为3；然后过了5秒后阀值才慢慢升高恢复到10</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519210017823-shareX-20230519210019.png" alt="image-20230519210017823" style="zoom:67%;"><p>多次点击<a href="http://localhost:8401/testB%EF%BC%8C%E5%88%9A%E5%BC%80%E5%A7%8B%E4%B8%8D%E8%A1%8C%EF%BC%8C%E5%90%8E%E7%BB%AD%E6%85%A2%E6%85%A2OK">http://localhost:8401/testB，刚开始不行，后续慢慢OK</a></p><h4 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h4><p>匀速排队，阈值必须设置为QPS</p><p>匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。</p><p>案例：设置含义：&#x2F;testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519210444352-shareX-20230519210445.png" alt="image-20230519210444352" style="zoom:67%;"><h2 id="熔断降级（无blockHandler）"><a href="#熔断降级（无blockHandler）" class="headerlink" title="熔断降级（无blockHandler）"></a>熔断降级（无blockHandler）</h2><p>Sentinel 提供以下几种熔断策略：</p><ul><li>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入&#x3D;&#x3D;探测恢复状态（HALF-OPEN 状态）&#x3D;&#x3D;，若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li><li>异常比例 (<code>ERROR_RATIO</code>)：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入&#x3D;&#x3D;探测恢复状态（HALF-OPEN 状态）&#x3D;&#x3D;，若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li><li>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入&#x3D;&#x3D;探测恢复状态（HALF-OPEN 状态）&#x3D;&#x3D;，若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li></ul><p>探测恢复状态（HALF-OPEN 状态）：</p><p>&#x3D;&#x3D;Sentinel1.8之前的断路器是没有半开状态的，1.8之后和hystrix一样有了&#x3D;&#x3D;</p><p><span style="color:blue;">RT （1.8过后变为慢调用比例）（平均响应时间，秒级）</span><br>      平均响应时间   <span style="color:blue;">超出响应阈值的比例超过比例阈值  且   在时间窗口内通过的请求&gt;&#x3D;5</span>，两个条件同时满足后触发降级<br>      窗口期过后关闭断路器<br>      RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt&#x3D;XXXX才能生效）</p><p><span style="color:blue;">异常比列（秒级）</span><br>    QPS &gt;&#x3D; 5 且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</p><p><span style="color:blue;">异常数（分钟级）</span><br>     异常数（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</p><p>Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，<br>让请求快速失败，避免影响到其它的资源而导致级联错误。</p><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。</p><h3 id="慢调用比例"><a href="#慢调用比例" class="headerlink" title="慢调用比例"></a>慢调用比例</h3><p>是什么：看上面大标题  熔断降级  统一介绍</p><p>controller添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519214010926-shareX-20230519214012.png" alt="image-20230519214010926" style="zoom: 50%;"><p>这里设置的是完成请求的最大响应时间为200ms，若未在200ms内完成响应，则把该次请求统计为慢调用，</p><p>当统计时长2000ms内，有&gt;&#x3D;5个请求时，且满调用占总请求次数的0.5以上，就触发熔断限流，熔断时间为2秒</p><p>测试：</p><p>上面controller中testD方法执行时间永远大于1秒，那么每次调用都会是慢调用</p><p>使用工具或者狂点localhost:8401&#x2F;testD，2000ms内大于5个请求调用testD，我们希望200毫秒处理完本次任务，<br>如果超过200毫秒还没处理完，在未来2秒钟的时间窗口内，断路器打开(保险丝跳闸)微服务不可用，保险丝跳闸断电了</p><h3 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h3><p>是什么：看上面大标题  熔断降级  统一介绍，类似hystrix的熔断规则</p><p>controller添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testC 测试异常比例&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519224208453-shareX-20230519224210.png" alt="image-20230519224208453" style="zoom:50%;"><p>按照上述配置，统计时长1000ms内，&gt;&#x3D;5次请求且错误比例大于0.5就发生熔断降级<br>testC方法单独访问一次，必然来一次报错一次(int age  &#x3D; 10&#x2F;0)，调一次错一次；</p><h3 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h3><p>是什么：看上面大标题  熔断降级  统一介绍</p><p>controller添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testE 测试异常比例&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testE 测试异常比例&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519225050615-shareX-20230519225052.png" alt="image-20230519225050615" style="zoom:50%;"><p>&#x3D;&#x3D;Sentinel1.8之前异常数是按照分钟统计的，统计时长必须&gt;&#x3D;60s，1.8之后变为秒级&#x3D;&#x3D;</p><p> <a href="http://localhost:8401/testE%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E7%BB%9D%E5%AF%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%99%A4%E6%95%B0%E4%B8%8D%E8%83%BD%E4%B8%BA%E9%9B%B6%EF%BC%8C">http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，</a><br>我们看到error窗口，但是达到5次报错后，进入熔断后降级。</p><h2 id="热点key"><a href="#热点key" class="headerlink" title="热点key"></a>热点key</h2><p>何为热点<br>热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作</p><p>兜底方法<br>分为系统默认和客户自定义，两种</p><p>  之前的case，限流出问题后，都是用sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</p><p>  我们能不能自定?类似hystrix，某个方法出问题了，就找对应的兜底降级方法？</p><p>结论<br>    &#x3D;&#x3D;@HystrixCommand 到@SentinelResource&#x3D;&#x3D;</p><p>controller添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;dealHandler_testHotKey&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dealHandler_testHotKey</span><span class="params">(String p1, String p2, BlockException exception)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----dealHandler_testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519230220145-shareX-20230519230221.png" alt="image-20230519230220145"></p><p>@SentinelResource(value &#x3D; “testHotKey”,blockHandler &#x3D; “dealHandler_testHotKey”)</p><p>方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理，用了我们自己定义的降级方法</p><p>若为设置blockHandler ，将会返回异常页面给用户，非常不友好</p><p>上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流</p><p>&#x3D;&#x3D;特例情况：&#x3D;&#x3D;</p><p>我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样</p><p>假如当p1的值等于5时，它的阈值可以达到200</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230519230806988-shareX-20230519230808.png" alt="image-20230519230806988" style="zoom: 67%;"><p>访问<a href="http://localhost:8401/testHotKey?p1=5%E7%9A%84%E9%98%88%E5%80%BC%E5%8F%98%E4%B8%BA200">http://localhost:8401/testHotKey?p1=5的阈值变为200</a></p><p>&#x3D;&#x3D;热点参数的注意点，参数必须是基本类型或者String&#x3D;&#x3D;</p><p>@SentinelResource<br>处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理；</p><p>RuntimeException<br>int age &#x3D; 10&#x2F;0,这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管</p><p>总结<br> &#x3D;&#x3D;@SentinelResource主管配置出错，运行出错该走异常走异常&#x3D;&#x3D;，hystrix的@HystrixCommand都管</p><h2 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h2><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><p>系统规则支持以下的模式：</p><ul><li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li><li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul><p>&#x3D;&#x3D;上面的是对具体某个请求或资源进行流控，这里是对整个微服务进行流控&#x3D;&#x3D;</p><h2 id="SentinelResource的使用"><a href="#SentinelResource的使用" class="headerlink" title="@SentinelResource的使用"></a>@SentinelResource的使用</h2><p>&#x3D;&#x3D;Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用@SentinelResource注解&#x3D;&#x3D;</p><p>比如前面链路流控模式中在service中添加过该注解，将service中的方法也标记为资源</p><p><span style="color:red;">@SentinelResource属性介绍：</span></p><p>value：设置资源名</p><p>blockHandler：只负责sentinel控制台配置违规（当未满足配置违规时，<span style="color:red;">若java程序有异常，将不会处理</span>，返回error页，当满足配置违规时，即使java程序有异常，也会进行处理，返回配置的blockHandler方法处理的值）且未设置sentinel持久化时，项目重启后，sentinel控制台配置将失效丢失</p><p>fallback：类似于hystrix的fallback，会处理java程序异常</p><h3 id="按资源名称限流-后续处理"><a href="#按资源名称限流-后续处理" class="headerlink" title="按资源名称限流+后续处理"></a>按资源名称限流+后续处理</h3><p>给cloudalibaba-sentinel-service的</p><p>pom添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spongehah.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>controller添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/byResource&quot;)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * value：设置资源名称</span></span><br><span class="line"><span class="comment">     * blockHandler：设置专有限流方法，只处理sentinel设置的规则，不处理运行时异常，与hystrix的fallback方法区分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">byResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;按资源名称限流测试OK&quot;</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">2020L</span>,<span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">handleException</span><span class="params">(BlockException exception)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,exception.getClass().getCanonicalName()+<span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230520170352540-shareX-20230520170401.png" alt="image-20230520170352540"></p><p>&#x3D;&#x3D;未作持久化配置时，此时关闭问服务8401看看，Sentinel控制台，流控规则消失了？？？？？sentinel设置的规则是临时的，持久化配置在后面&#x3D;&#x3D;</p><h3 id="按照Url地址限流-后续处理"><a href="#按照Url地址限流-后续处理" class="headerlink" title="按照Url地址限流+后续处理"></a>按照Url地址限流+后续处理</h3><p>通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息</p><p>RateLimitController添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;byUrl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CommonResult <span class="title function_">byUrl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;按url限流测试OK&quot;</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">2020L</span>,<span class="string">&quot;serial002&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台中添加资源名时，使用&#x2F;rateLimit&#x2F;byUrl，是带 &#x2F;的，而不是@SentinelResource中的value属性</p><h3 id="客户自定义通用限流处理逻辑"><a href="#客户自定义通用限流处理逻辑" class="headerlink" title="客户自定义通用限流处理逻辑"></a>客户自定义通用限流处理逻辑</h3><p>上面兜底方案面临的问题：</p><p>1    系统默认的，没有体现我们自己的业务要求。</p><p>2  依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。</p><p>3  每个业务方法都添加一个兜底的，那代码膨胀加剧。</p><p>4  全局统一的处理方法没有体现。</p><p>创建myhandler.CustomerBlockHandler类用于自定义限流处理逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBlockHandler</span> &#123;</span><br><span class="line">    <span class="comment">//必须为static</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title function_">handleException</span><span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">2020</span>,<span class="string">&quot;自定义的限流处理信息......CustomerBlockHandler-------1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title function_">handleException2</span><span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">2020</span>,<span class="string">&quot;自定义的限流处理信息......CustomerBlockHandler-------2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RateLimitController添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义通用的限流处理逻辑，</span></span><br><span class="line"><span class="comment"> * blockHandlerClass = CustomerBlockHandler.class</span></span><br><span class="line"><span class="comment"> * blockHandler = handleException2</span></span><br><span class="line"><span class="comment"> * 上述配置：找CustomerBlockHandler类里的handleException2方法进行兜底处理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 自定义通用的限流处理逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomerBlockHandler.class, blockHandler = &quot;handleException2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CommonResult <span class="title function_">customerBlockHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>, <span class="string">&quot;按客户自定义限流处理逻辑&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好sentinel控制台的规则后进行测试</p><p>这里只是指定了一个blockHandlerClass，其blockHandler方法去这个类里面找</p><h3 id="服务熔断功能（设置blockHandler和fallback）"><a href="#服务熔断功能（设置blockHandler和fallback）" class="headerlink" title="服务熔断功能（设置blockHandler和fallback）"></a>服务熔断功能（设置blockHandler和fallback）</h3><h4 id="整合ribbon"><a href="#整合ribbon" class="headerlink" title="整合ribbon"></a>整合ribbon</h4><p>1、新建网站服务端提供者</p><p>新建cloudalibaba-provider-payment9003&#x2F;9004两个一样的做法，可使用-DServer.port&#x3D;9004复制9003启动</p><p>pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spongehah.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain9003</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9003.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long, Payment&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">1L</span>,<span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">2L</span>,<span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">3L</span>,<span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> hashMap.get(id);</span><br><span class="line">        CommonResult&lt;Payment&gt; result = <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;from mysql,serverPort:  &quot;</span>+serverPort,payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、网站客户端消费者：</p><p>新建cloudalibaba-consumer-nacos-order84：</p><p>pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spongehah.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span> </span><br></pre></td></tr></table></figure><p>主启动类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class OrderNacosMain84 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类：</p><p>config：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String SERVICE_URL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id, CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span> (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、测试：</p><p>当@SentinelResource(value &#x3D; “fallback”)注解不配置任何兜底方法时，给客户error页面，不友好</p><p>（1）只配置fallback方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span> <span class="comment">//fallback负责业务异常</span></span><br><span class="line"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span> + id, CommonResult.class, id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CommonResult <span class="title function_">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id, Throwable e)</span> &#123;</span><br><span class="line">    <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span> + e.getMessage(), payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<a href="http://localhost:84/consumer/fallback/%7Bid%7D">http://localhost:84/consumer/fallback/{id}</a></p><p>当id&#x3D;4和id&gt;4时，会报异常，由fallback兜底方法handlerFallback进行处理，当设置了sentinel流控规则时，违规后返回默认处理</p><p>（2）只配置blockHandler时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;, blockHandler = &quot;blockHandler&quot;)</span> <span class="comment">//blockHandler负责在sentinel里面配置的降级限流</span></span><br><span class="line"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span> + id, CommonResult.class, id);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;非法参数异常....&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;NullPointerException,该ID没有对应记录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CommonResult <span class="title function_">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span> Long id, BlockException blockException)</span> &#123;</span><br><span class="line">    <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">445</span>, <span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span> + blockException.getMessage(), payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sentinel控制台进行限流配置</p><p>测试<a href="http://localhost:84/consumer/fallback/%7Bid%7D">http://localhost:84/consumer/fallback/{id}</a></p><p>当查询id&gt;&#x3D;4时，会返回error页，因为无fallback方法兜底，但当违反sentinel设定规则时，将会由blockHandler方法兜底，无论有没有运行时异常</p><p>（3）fallback和blockHandler都配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;, blockHandler = &quot;blockHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span> + id, CommonResult.class, id);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;非法参数异常....&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;NullPointerException,该ID没有对应记录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CommonResult <span class="title function_">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id, Throwable e)</span> &#123;</span><br><span class="line">    <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;fallback,无此流水,exception  &quot;</span> + e.getMessage(), payment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CommonResult <span class="title function_">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span> Long id, BlockException blockException)</span> &#123;</span><br><span class="line">    <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">445</span>, <span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span> + blockException.getMessage(), payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<a href="http://localhost:84/consumer/fallback/%7Bid%7D">http://localhost:84/consumer/fallback/{id}</a></p><p>不违反设定sentinel限流规则时，若发生异常，由fallback兜底，</p><p>违反先流规则，blockHandler优先级高，发生异常也是blockHandler兜底</p><p>（4）忽略异常属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;, blockHandler = &quot;blockHandler&quot;,</span></span><br><span class="line"><span class="meta">        exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)</span></span><br></pre></td></tr></table></figure><p>忽略指定异常，发生该种异常时不进行处理</p><h4 id="整合Feign"><a href="#整合Feign" class="headerlink" title="整合Feign"></a>整合Feign</h4><p>&#x3D;&#x3D;feign的fallback类只对服务端down机时使用&#x3D;&#x3D;</p><p>修改cloudalibaba-consumer-nacos-order84：</p><p>&#x3D;&#x3D;坑！！！！！！这里会启动报错，需要把devtools的依赖注释掉&#x3D;&#x3D;</p><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud openfeign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yaml激活Sentinel对Feign的支持</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">84</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="comment"># 激活Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>  </span><br></pre></td></tr></table></figure><p>主启动类：添加@EnableFeignClients启动Feign的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosMain84</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PaymentService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PaymentFallbackService implements PaymentService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;服务降级返回,没有该流水信息&quot;</span>, <span class="keyword">new</span> <span class="title class_">Payment</span>(id, <span class="string">&quot;errorSerial......&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==================OpenFeign</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/openfeign/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有该id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<a href="http://localhost:84/consumer/openfeign/1">http://localhost:84/consumer/openfeign/1</a></p><p>当网站服务端正常时：返回信息</p><p>当网站服务端down机时，返回fallback信息</p><h4 id="熔断框架比较"><a href="#熔断框架比较" class="headerlink" title="熔断框架比较"></a>熔断框架比较</h4><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230521161909295-shareX-20230521161917.png" alt="image-20230521161909295"><h2 id="sentinel规则持久化"><a href="#sentinel规则持久化" class="headerlink" title="sentinel规则持久化"></a>sentinel规则持久化</h2><p>一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化</p><p>思路：</p><p>将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台<br>的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效</p><p>修改cloudalibaba-sentinel-service8401：</p><p>pom添加：前面已经添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="comment">#sentinel持久化配置</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>nacos中新建配置文件：</p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230521162658614-shareX-20230521162659.png" alt="image-20230521162658614"><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置sentinel限流规则</span></span><br><span class="line"><span class="comment">resource：资源名称；</span></span><br><span class="line"><span class="comment">limitApp：来源应用；</span></span><br><span class="line"><span class="comment">grade：阈值类型，0表示线程数，1表示QPS；</span></span><br><span class="line"><span class="comment">count：单机阈值；</span></span><br><span class="line"><span class="comment">strategy：流控模式，0表示直接，1表示关联，2表示链路；</span></span><br><span class="line"><span class="comment">controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；</span></span><br><span class="line"><span class="comment">clusterMode：是否集群。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/rateLimit/byUrl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;clusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>持久化设置成功</p><p>重新启动8401再看sentinel，规则也还在</p><h1 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h1><p>从1：1  -&gt;  1：N  -&gt;  N：N</p><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，<br>业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。</p><p>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题</p><p>Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p><p>&#x3D;&#x3D;1+3模型：&#x3D;&#x3D;</p><p>分布式事务处理过程的一ID+三组件模型</p><p>1：Transaction ID XID： 全局唯一的事务ID</p><p>3：</p><p>Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚；</p><p>Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；</p><p>Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚</p><p>处理过程：</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230521225711614-shareX-20230521225713.png" alt="image-20230521225711614"></p><h2 id="Seata安装配置启动（MySQL8）"><a href="#Seata安装配置启动（MySQL8）" class="headerlink" title="Seata安装配置启动（MySQL8）"></a>Seata安装配置启动（MySQL8）</h2><p>版本参考目录SpringcloudAlibaba处的表格对照这里选用searta1.5.1适配cloudalibaba2.2.8RELEASE</p><p>参考文章：<a href="https://blog.csdn.net/yanzhenjingfan/article/details/125472153">https://blog.csdn.net/yanzhenjingfan/article/details/125472153</a></p><p>​   <a href="https://blog.csdn.net/sun9087/article/details/126484540">https://blog.csdn.net/sun9087/article/details/126484540</a></p><p>​   <a href="https://www.jianshu.com/p/37c3640284cc">https://www.jianshu.com/p/37c3640284cc</a>主要参考seataServer.properties</p><p>下载地址：<a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p><p>修改conf目录下的application.yml配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7091</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">classpath:logback-spring.xml</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">$&#123;user.home&#125;/logs/seata</span></span><br><span class="line">  <span class="attr">extend:</span></span><br><span class="line">    <span class="attr">logstash-appender:</span></span><br><span class="line">      <span class="attr">destination:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:4560</span></span><br><span class="line">    <span class="attr">kafka-appender:</span></span><br><span class="line">      <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line">      <span class="attr">topic:</span> <span class="string">logback_to_logstash</span></span><br><span class="line"></span><br><span class="line"><span class="attr">console:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">seata</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">seata</span></span><br><span class="line"></span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="comment"># support: nacos, consul, apollo, zk, etcd3</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="comment">##if use MSE Nacos with auth, mutex with username/password attribute</span></span><br><span class="line">      <span class="comment">#access-key: &quot;&quot;</span></span><br><span class="line">      <span class="comment">#secret-key: &quot;&quot;</span></span><br><span class="line">      <span class="attr">data-id:</span> <span class="string">seataServer.properties</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="comment"># support: nacos, eureka, redis, zk, consul, etcd3, sofa</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">namespace:</span> </span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"><span class="comment"># 以下存储配置，可以配置在nacos的seataServer.properties</span></span><br><span class="line"><span class="comment">#  store:</span></span><br><span class="line">    <span class="comment"># support: file 、 db 、 redis</span></span><br><span class="line"><span class="comment">#    mode: db</span></span><br><span class="line"><span class="comment">#    db:</span></span><br><span class="line"><span class="comment">#      datasource: druid</span></span><br><span class="line"><span class="comment">#      db-type: mysql</span></span><br><span class="line"><span class="comment">#      driver-class-name: com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#      url: jdbc:mysql://127.0.0.1:3306/seata?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="comment">#      user: root</span></span><br><span class="line"><span class="comment">#      password: admin</span></span><br><span class="line"><span class="comment">#      min-conn: 5</span></span><br><span class="line"><span class="comment">#      max-conn: 100</span></span><br><span class="line"><span class="comment">#      global-table: global_table</span></span><br><span class="line"><span class="comment">#      branch-table: branch_table</span></span><br><span class="line"><span class="comment">#      lock-table: lock_table</span></span><br><span class="line"><span class="comment">#      distributed-lock-table: distributed_lock</span></span><br><span class="line"><span class="comment">#      query-limit: 100</span></span><br><span class="line"><span class="comment">#      max-wait: 5000</span></span><br><span class="line"><span class="comment">#  server:</span></span><br><span class="line"><span class="comment">#    service-port: 8091 #If not configured, the default is &#x27;$&#123;server.port&#125; + 1000&#x27;</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="string">SeataSecretKey0c382ef121d778043159209298fd40bf3850a017</span></span><br><span class="line">    <span class="attr">tokenValidityInMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">ignore:</span></span><br><span class="line">      <span class="attr">urls:</span> <span class="string">/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/api/v1/auth/login</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动nacos，在nacos面板中，添加<strong>seataServer.properties</strong>和service.vgroupMapping.default_tx_group两个配置</p><p><strong>seataServer.properties</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data ID:seataServer.properties</span><br><span class="line">Group:SEATA_GROUP</span><br><span class="line">配置格式:properties</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务组要和yml保持一致</span></span><br><span class="line"><span class="attr">seata.tx-service-group</span>=<span class="string">default_tx_group</span></span><br><span class="line"><span class="attr">seata.service.vgroup-mapping.default_tx_group</span>=<span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="comment">#-----db-----</span></span><br><span class="line"><span class="attr">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="attr">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"># 需要根据mysql的版本调整driverClassName</span></span><br><span class="line"><span class="comment"># mysql8及以上版本对应的driver：com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql8以下版本的driver：com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">store.db.driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">store.db.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true&amp;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false</span></span><br><span class="line"><span class="attr">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">store.db.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 数据库初始连接数</span></span><br><span class="line"><span class="attr">store.db.minConn</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 数据库最大连接数</span></span><br><span class="line"><span class="attr">store.db.maxConn</span>=<span class="string">30</span></span><br><span class="line"><span class="comment"># 全局事务表名 默认global_table</span></span><br><span class="line"><span class="attr">store.db.globalTable</span>=<span class="string">global_table</span></span><br><span class="line"><span class="comment"># 分支事务表名 默认branch_table</span></span><br><span class="line"><span class="attr">store.db.branchTable</span>=<span class="string">branch_table</span></span><br><span class="line"><span class="comment"># 全局锁表名 默认lock_table</span></span><br><span class="line"><span class="attr">store.db.lockTable</span>=<span class="string">lock_table</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="attr">store.db.distributedLockTable</span>=<span class="string">distributed_lock</span></span><br><span class="line"><span class="comment"># 查询全局事务一次的最大条数 默认100</span></span><br><span class="line"><span class="attr">store.db.queryLimit</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"># 获取连接时最大等待时间 默认5000，单位毫秒</span></span><br><span class="line"><span class="attr">store.db.maxWait</span>=<span class="string">5000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">client.undo.dataValidation</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.undo.logSerialization</span>=<span class="string">jackson</span></span><br><span class="line"><span class="attr">client.undo.onlyCareUpdateColumns</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.undo.logTable</span>=<span class="string">undo_log</span></span><br><span class="line"><span class="attr">client.undo.compress.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.undo.compress.type</span>=<span class="string">zip</span></span><br><span class="line"><span class="attr">client.undo.compress.threshold</span>=<span class="string">64k</span></span><br><span class="line"><span class="comment"># undo保留天数 默认7天,log_status=1（附录3）和未正常清理的undo</span></span><br><span class="line"><span class="attr">server.undo.logSaveDays</span>=<span class="string">7</span></span><br><span class="line"><span class="comment"># undo清理线程间隔时间 默认86400000，单位毫秒</span></span><br><span class="line"><span class="attr">server.undo.logDeletePeriod</span>=<span class="string">86400000</span></span><br><span class="line"><span class="comment"># 二阶段提交重试超时时长 单位ms,s,m,h,d,对应毫秒,秒,分,小时,天,默认毫秒。默认值-1表示无限重试</span></span><br><span class="line"><span class="comment"># 公式: timeout&gt;=now-globalTransactionBeginTime,true表示超时则不再重试</span></span><br><span class="line"><span class="comment"># 注: 达到超时时间后将不会做任何重试,有数据不一致风险,除非业务自行可校准数据,否者慎用</span></span><br><span class="line"><span class="attr">server.maxCommitRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 二阶段回滚重试超时时长</span></span><br><span class="line"><span class="attr">server.maxRollbackRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 二阶段提交未完成状态全局事务重试提交线程间隔时间 默认1000，单位毫秒</span></span><br><span class="line"><span class="attr">server.recovery.committingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"># 二阶段异步提交状态重试提交线程间隔时间 默认1000，单位毫秒</span></span><br><span class="line"><span class="attr">server.recovery.asynCommittingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"># 二阶段回滚状态重试回滚线程间隔时间  默认1000，单位毫秒</span></span><br><span class="line"><span class="attr">server.recovery.rollbackingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"># 超时状态检测重试线程间隔时间 默认1000，单位毫秒，检测出超时将全局事务置入回滚会话管理器</span></span><br><span class="line"><span class="attr">server.recovery.timeoutRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Transaction rule configuration, only for the server</span></span><br><span class="line"><span class="attr">server.rollbackRetryTimeoutUnlockEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">server.distributedLockExpireTime</span>=<span class="string">10000</span></span><br><span class="line"><span class="attr">server.xaerNotaRetryTimeout</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">server.session.branchAsyncQueueSize</span>=<span class="string">5000</span></span><br><span class="line"><span class="attr">server.session.enableBranchAsyncRemove</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Transaction rule configuration, only for the client</span></span><br><span class="line"><span class="attr">client.rm.asyncCommitBufferLimit</span>=<span class="string">10000</span></span><br><span class="line"><span class="attr">client.rm.lock.retryInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">client.rm.lock.retryTimes</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">client.rm.lock.retryPolicyBranchRollbackOnConflict</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.rm.reportRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">client.rm.tableMetaCheckEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.rm.tableMetaCheckerInterval</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">client.rm.sqlParserType</span>=<span class="string">druid</span></span><br><span class="line"><span class="attr">client.rm.reportSuccessEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">client.rm.sagaBranchRegisterEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">client.rm.sagaJsonParser</span>=<span class="string">fastjson</span></span><br><span class="line"><span class="attr">client.rm.tccActionInterceptorOrder</span>=<span class="string">-2147482648</span></span><br><span class="line"><span class="attr">client.tm.commitRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">client.tm.rollbackRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">client.tm.defaultGlobalTransactionTimeout</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">client.tm.degradeCheck</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">client.tm.degradeCheckAllowTimes</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">client.tm.degradeCheckPeriod</span>=<span class="string">2000</span></span><br><span class="line"><span class="attr">client.tm.interceptorOrder</span>=<span class="string">-2147482648</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#For TCC transaction mode</span></span><br><span class="line"><span class="attr">tcc.fence.logTableName</span>=<span class="string">tcc_fence_log</span></span><br><span class="line"><span class="attr">tcc.fence.cleanPeriod</span>=<span class="string">1h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Log rule configuration, for client and server</span></span><br><span class="line"><span class="attr">log.exceptionRate</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Metrics configuration, only for the server</span></span><br><span class="line"><span class="attr">metrics.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">metrics.registryType</span>=<span class="string">compact</span></span><br><span class="line"><span class="attr">metrics.exporterList</span>=<span class="string">prometheus</span></span><br><span class="line"><span class="attr">metrics.exporterPrometheusPort</span>=<span class="string">9898</span></span><br><span class="line"></span><br><span class="line"><span class="attr">transport.type</span>=<span class="string">TCP</span></span><br><span class="line"><span class="attr">transport.server</span>=<span class="string">NIO</span></span><br><span class="line"><span class="attr">transport.heartbeat</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">transport.enableTmClientBatchSendRequest</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">transport.enableRmClientBatchSendRequest</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">transport.enableTcServerBatchSendResponse</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">transport.rpcRmRequestTimeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="attr">transport.rpcTmRequestTimeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="attr">transport.rpcTcRequestTimeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="attr">transport.threadFactory.bossThreadPrefix</span>=<span class="string">NettyBoss</span></span><br><span class="line"><span class="attr">transport.threadFactory.workerThreadPrefix</span>=<span class="string">NettyServerNIOWorker</span></span><br><span class="line"><span class="attr">transport.threadFactory.serverExecutorThreadPrefix</span>=<span class="string">NettyServerBizHandler</span></span><br><span class="line"><span class="attr">transport.threadFactory.shareBossWorker</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">transport.threadFactory.clientSelectorThreadPrefix</span>=<span class="string">NettyClientSelector</span></span><br><span class="line"><span class="attr">transport.threadFactory.clientSelectorThreadSize</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">transport.threadFactory.clientWorkerThreadPrefix</span>=<span class="string">NettyClientWorkerThread</span></span><br><span class="line"><span class="attr">transport.threadFactory.bossThreadSize</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">transport.threadFactory.workerThreadSize</span>=<span class="string">default</span></span><br><span class="line"><span class="attr">transport.shutdown.wait</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">transport.serialization</span>=<span class="string">seata</span></span><br><span class="line"><span class="attr">transport.compressor</span>=<span class="string">none</span></span><br></pre></td></tr></table></figure><p>service.vgroupMapping.default_tx_group，值为default。如果不新建这个文件，客户端启动，控制台会报错can not get cluster name in registry config ‘service.vgroupMapping.default_tx_group’, please make sure registry config correct</p><p>service.vgroupMapping.default_tx_group：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Data ID:service.vgroupMapping.default_tx_group</span><br><span class="line">Group:SEATA_GROUP</span><br><span class="line">配置格式:text</span><br><span class="line">配置内容：default</span><br></pre></td></tr></table></figure><p>我的数据库是mysql8.0.29，数据库新建数据库库seata</p><p>前往官网复制sql代码：<a href="https://github.com/seata/seata/tree/1.5.0/script/server/db">https://github.com/seata/seata/tree/1.5.0/script/server/db</a></p><p>在新建的seata数据库中运行复制的sql代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span></span><br><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `global_table`</span><br><span class="line">(</span><br><span class="line">    `xid`                       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`            <span class="type">BIGINT</span>,</span><br><span class="line">    `status`                    TINYINT      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `application_id`            <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_service_group` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_name`          <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `timeout`                   <span class="type">INT</span>,</span><br><span class="line">    `begin_time`                <span class="type">BIGINT</span>,</span><br><span class="line">    `application_data`          <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`                DATETIME,</span><br><span class="line">    `gmt_modified`              DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`xid`),</span><br><span class="line">    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),</span><br><span class="line">    KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `branch_table`</span><br><span class="line">(</span><br><span class="line">    `branch_id`         <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`               <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`    <span class="type">BIGINT</span>,</span><br><span class="line">    `resource_group_id` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `resource_id`       <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `branch_type`       <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    `status`            TINYINT,</span><br><span class="line">    `client_id`         <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    `application_data`  <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`        DATETIME(<span class="number">6</span>),</span><br><span class="line">    `gmt_modified`      DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`branch_id`),</span><br><span class="line">    KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `lock_table`</span><br><span class="line">(</span><br><span class="line">    `row_key`        <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`            <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">    `branch_id`      <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource_id`    <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `table_name`     <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `pk`             <span class="type">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    `status`         TINYINT      <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0:locked ,1:rollbacking&#x27;</span>,</span><br><span class="line">    `gmt_create`     DATETIME,</span><br><span class="line">    `gmt_modified`   DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`row_key`),</span><br><span class="line">    KEY `idx_status` (`status`),</span><br><span class="line">    KEY `idx_branch_id` (`branch_id`),</span><br><span class="line">    KEY `idx_xid_and_branch_id` (`xid` , `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `distributed_lock`</span><br><span class="line">(</span><br><span class="line">    `lock_key`       <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `lock_value`     <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `expire`         <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (`lock_key`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;AsyncCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryRollbacking&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;TxTimeoutCheck&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>Seata1.5.1默认使用的是mysql5，需要将jar包换为mysql8的</p><p>Seata1.5.2及以后默认使用的是mysql8</p><p>更换jar包：</p><p>&#x3D;&#x3D;jar包不能直接复制&#x2F;更换进去，因为会导致jar包压缩而无法使用&#x3D;&#x3D;</p><p>参考：<a href="https://blog.csdn.net/educast/article/details/106659197">https://blog.csdn.net/educast/article/details/106659197</a></p><p>若是在windows环境下，将seata&#x2F;target&#x2F;seata-server.jar包和所要更换的mysql-connector-java-8.0.29.jar传送到Linux服务器&#x2F;虚拟机</p><p>在linux环境找到传输过来的jar报所在目录，依次运行下列命令：</p><p>具体文件名称根据自己实际情况来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar -xvf seata-server.jar#先解压jar包</span><br><span class="line">rm -rf BOOT-INF/lib/mysql-connector-java-5.1.35.jar#先移除mysql5jar报</span><br><span class="line">mv mysql-connector-java-8.0.29.jar BOOT-INF/lib/#将mysql8jar包移动过去</span><br><span class="line">rm -rf seata-server.jar#删除原seata-server.jar</span><br><span class="line">jar -cfM0 seata-server.jar BOOT-INF/ META-INF/ org/#重新将这三个目录打包为seata-server.jar</span><br></pre></td></tr></table></figure><p>然后将seata-server.jar传回windows原位置即可</p><p>启动：</p><p>先启动nacos</p><p>再启动seata：&#x2F;seata&#x2F;bin&#x2F;seata-server</p><h2 id="seata-client微服务新建配置启动"><a href="#seata-client微服务新建配置启动" class="headerlink" title="seata-client微服务新建配置启动"></a>seata-client微服务新建配置启动</h2><h3 id="案例演示数据库准备"><a href="#案例演示数据库准备" class="headerlink" title="案例演示数据库准备"></a>案例演示数据库准备</h3><p>这里我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务。</p><p>当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存，<br>再通过远程调用账户服务来扣减用户账户里面的余额，<br>最后在订单服务中修改订单状态为已完成。</p><p>该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题。</p><p>下订单—&gt;扣库存—&gt;减账户(余额)</p><p>创建业务数据库：</p><p>seata_order：存储订单的数据库；CREATE DATABASE seata_order;</p><p>seata_storage：存储库存的数据库；CREATE DATABASE seata_storage;</p><p>seata_account：存储账户信息的数据库。CREATE DATABASE seata_account;</p><p>建表：</p><p>seata_order库下建t_order表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order (</span><br><span class="line">  `id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  `user_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `product_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">  `count` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  `money` <span class="type">DECIMAL</span>(<span class="number">11</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;金额&#x27;</span>,</span><br><span class="line">  `status` <span class="type">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态：0：创建中；1：已完结&#x27;</span> </span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">7</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order;</span><br></pre></td></tr></table></figure><p>seata_storage库下建t_storage 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_storage (</span><br><span class="line"> `id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line"> `product_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line"> `total` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line"> `used` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已用库存&#x27;</span>,</span><br><span class="line"> `residue` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;剩余库存&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_storage.t_storage(`id`, `product_id`, `total`, `used`, `residue`)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_storage;</span><br></pre></td></tr></table></figure><p>seata_account库下建t_account 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_account (</span><br><span class="line">  `id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `total` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总额度&#x27;</span>,</span><br><span class="line">  `used` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已用余额&#x27;</span>,</span><br><span class="line">  `residue` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;剩余可用额度&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_account.t_account(`id`, `user_id`, `total`, `used`, `residue`)  <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_account;</span><br></pre></td></tr></table></figure><p>三个业务库下都分别建一个&#x3D;&#x3D;undo_log&#x3D;&#x3D;表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>数据库准备完成，一共四个数据库，seata总库，和上面三个新建的数据库</p><h3 id="新建订单Order-Module"><a href="#新建订单Order-Module" class="headerlink" title="新建订单Order-Module"></a>新建订单Order-Module</h3><p>参考文章：目录Seata处三篇加下面一篇</p><p>​ <a href="https://blog.csdn.net/Jason_We/article/details/113538673">https://blog.csdn.net/Jason_We/article/details/113538673</a>mysql-druid启动报错参考</p><p>-Ddruid.mysql.usePingMethod&#x3D;false</p><p>1、新建moduleseata-order-service2001</p><p>2、pom：父工程下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--feign--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web-actuator--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql-druid--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、application.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata-order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">        <span class="attr">register-enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/seata_order</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">application-id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">default_tx_group</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">default_tx_group:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="comment"># support: nacos, consul, apollo, zk, etcd3</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line"><span class="comment">#      namespace:</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">data-id:</span> <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="comment"># support: nacos, eureka, redis, zk, consul, etcd3, sofa</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line"><span class="comment">#      namespace:</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io:</span></span><br><span class="line">      <span class="attr">seata:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataOrderMainApp2001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SeataOrderMainApp2001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、domain：</p><p>CommonResult：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonResult</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonResult</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(code, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Order订单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单状态：0：创建中；1：已完结</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、dao：</p><p>OrderDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改订单金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;status&quot;)</span> Integer status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、resources文件夹下新建mapper文件夹后添加OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.spongehah.seata.dao.OrderDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.spongehah.seata.domain.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;product_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;productId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;count&quot;</span> <span class="attr">property</span>=<span class="string">&quot;count&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;create&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO `t_order` (`id`, `user_id`, `product_id`, `count`, `money`, `status`)</span><br><span class="line">        VALUES (NULL, #&#123;userId&#125;, #&#123;productId&#125;, #&#123;count&#125;, #&#123;money&#125;, 0);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        UPDATE `t_order`</span><br><span class="line">        SET status = 1</span><br><span class="line">        WHERE user_id = #&#123;userId&#125; AND status = #&#123;status&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>8、Service接口及实现</p><p>OrderService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderServiceImpl ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span></span><br><span class="line"><span class="comment">     * 简单说：</span></span><br><span class="line"><span class="comment">     * 下订单-&gt;减库存-&gt;减余额-&gt;改状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;下单开始&quot;</span>);</span><br><span class="line">        <span class="comment">//本应用创建订单</span></span><br><span class="line">        orderDao.create(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//远程调用库存服务扣减库存</span></span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;order-service中扣减库存开始&quot;</span>);</span><br><span class="line">        storageService.decrease(order.getProductId(),order.getCount());</span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;order-service中扣减库存结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//远程调用账户服务扣减余额</span></span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;order-service中扣减余额开始&quot;</span>);</span><br><span class="line">        accountService.decrease(order.getUserId(),order.getMoney());</span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;order-service中扣减余额结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改订单状态为已完成</span></span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;order-service中修改订单状态开始&quot;</span>);</span><br><span class="line">        orderDao.update(order.getUserId(),<span class="number">0</span>);</span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;order-service中修改订单状态结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;下单结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;seata-account-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/account/decrease&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StorageService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;seata-storage-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/storage/decrease&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;productId&quot;)</span>Long productId,<span class="meta">@RequestParam(&quot;count&quot;)</span> Integer count)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">create</span><span class="params">(Order order)</span>&#123;</span><br><span class="line">        orderService.create(order);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;订单创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建库存Storage-Module"><a href="#新建库存Storage-Module" class="headerlink" title="新建库存Storage-Module"></a>新建库存Storage-Module</h3><p>1、新建module：seata-storage-service2002</p><p>2、pom：和订单模块Order-Module一致</p><p>3、yaml：和订单模块Order-Module一致，就修改端口号为2002，数据库url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;seata_storage</p><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataStorageServiceApplication2002</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SeataStorageServiceApplication2002 .class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、domian：</p><p>CommonResult</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonResult</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonResult</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(code, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Storage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已用库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剩余库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer residue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、dao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="meta">@Param(&quot;productId&quot;)</span> Long productId, <span class="meta">@Param(&quot;count&quot;)</span> Integer count)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.spongehah.seata.dao.StorageDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.spongehah.seata.domain.Storage&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;product_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;productId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;used&quot;</span> <span class="attr">property</span>=<span class="string">&quot;used&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;residue&quot;</span> <span class="attr">property</span>=<span class="string">&quot;residue&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;decrease&quot;</span>&gt;</span></span><br><span class="line">        UPDATE t_storage</span><br><span class="line">        SET used    = used + #&#123;count&#125;,</span><br><span class="line">            residue = residue - #&#123;count&#125;</span><br><span class="line">        WHERE product_id = #&#123;productId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>8、service：</p><p>StorageService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(Long productId, Integer count)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StorageServiceImpl implements StorageService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(StorageServiceImpl.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageDao storageDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(Long productId, Integer count)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;storage-service中扣减库存开始&quot;</span>);</span><br><span class="line">        storageDao.decrease(productId,count);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;storage-service中扣减库存结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/storage/decrease&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;productId&quot;)</span>Long productId, <span class="meta">@RequestParam(&quot;count&quot;)</span> Integer count)</span> &#123;</span><br><span class="line">        storageService.decrease(productId, count);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>, <span class="string">&quot;扣减库存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建账户Account-Module"><a href="#新建账户Account-Module" class="headerlink" title="新建账户Account-Module"></a>新建账户Account-Module</h3><p>1、新建moduleseata-account-service2003</p><p>2、pom：和订单模块Order-Module一致</p><p>3、yaml：和订单模块Order-Module一致，就修改端口号为2003，数据库url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;seata_account</p><p>4、主启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataAccountMainApp2003</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SeataAccountMainApp2003.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、domain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonResult</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonResult</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(code, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总额度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已用额度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剩余额度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal residue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、dao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;money&quot;)</span> BigDecimal money)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、mapper</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.spongehah.seata.dao.AccountDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.spongehah.seata.domain.Account&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;used&quot;</span> <span class="attr">property</span>=<span class="string">&quot;used&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;residue&quot;</span> <span class="attr">property</span>=<span class="string">&quot;residue&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;decrease&quot;</span>&gt;</span></span><br><span class="line">        UPDATE t_account</span><br><span class="line">        SET residue = residue - #&#123;money&#125;,</span><br><span class="line">            used    = used + #&#123;money&#125;</span><br><span class="line">        WHERE user_id = #&#123;userId&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>8、service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(Long userId, BigDecimal money)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;account-service中扣减账户余额开始&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟超时异常，全局事务回滚</span></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        accountDao.decrease(userId,money);</span><br><span class="line">        log.info(<span class="string">&quot;-------&gt;account-service中扣减账户余额结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/account/decrease&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span> &#123;</span><br><span class="line">        accountService.decrease(userId, money);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>, <span class="string">&quot;扣减账户余额成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试：-GlobalTransactional的使用"><a href="#测试：-GlobalTransactional的使用" class="headerlink" title="测试：@GlobalTransactional的使用"></a>测试：@GlobalTransactional的使用</h3><p>&#x3D;&#x3D;注意事项：&#x3D;&#x3D;</p><p>1、mapper.xml中，insert语句不能含有主键，否则会找不到主键，调用该insert语句的微服务的undo会一直刷新，idea控制台会一直刷屏但是不报错，该微服务连接的数据库无法正常fallback，其他微服务的数据库正常fallback</p><p>2、mapper.xml中，我是数据库已经设置自增主键，但是还设置了 useGeneratedKeys&#x3D;”true” keyProperty&#x3D;”id”，导致idea控制台也一直刷屏，导致即使程序没有异常，所有微服务的表都全部fallback，没有试过数据库没有设置自增主键的情况，若有请自行尝试</p><p>在AccountServiceImpl的decrease方法中加入超时测试语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟超时测试</span></span><br><span class="line"><span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br></pre></td></tr></table></figure><p>在OrderServiceImpl的create方法头上加上&#x3D;&#x3D;@GlobalTransactional&#x3D;&#x3D;注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//name：随意起，不重复即可</span></span><br><span class="line"><span class="comment">//rollbackFor：哪些异常需要fallback</span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;create-order&quot;,rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;-------&gt;下单开始&quot;</span>);</span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;-------&gt;下单结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：若是不想要超时报错，则需要用到前面hystrix学到的超时异常处理，在2001yaml中加入：单位毫秒</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#feign:</span></span><br><span class="line"><span class="comment">#  client:</span></span><br><span class="line"><span class="comment">#    config:</span></span><br><span class="line"><span class="comment">#      default:</span></span><br><span class="line"><span class="comment">#        connect-timeout: 5000</span></span><br><span class="line"><span class="comment">#        read-timeout: 5000</span></span><br></pre></td></tr></table></figure><h2 id="Seata原理补充"><a href="#Seata原理补充" class="headerlink" title="Seata原理补充"></a>Seata原理补充</h2><p>Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架</p><p>分布式事务的执行流程：</p><p>TM 开启分布式事务（TM 向 TC 注册全局事务记录）；</p><p>按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）；</p><p>TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交&#x2F;回滚分布式事务）；</p><p>TC 汇总事务信息，决定分布式事务是提交还是回滚；</p><p>TC 通知所有 RM 提交&#x2F;回滚 资源，事务二阶段结束。</p><p>AT模式如何做到对业务的无侵入</p><p>一阶段加载：在一阶段，Seata 会拦截“业务 SQL”，<br>1  解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在<span style="color:red;">业务数据被更新前，将其保存成“before image”，</span><br>2  执行“业务 SQL”更新业务数据，<br>3  <span style="color:red;">在业务数据更新之后，其保存成“after image”，最后生成行锁。</span><br>以上操作全部<span style="color:red;">在一个数据库事务内完成</span>，这样保证了一阶段操作的原子性。</p><p>二阶段提交：</p><p>二阶段如是顺利提交的话，<br>因为“业务 SQL”在一阶段已经提交至数据库，所以Seata框架只需<span style="color:red;">将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</span></p><p>二阶段回滚：</p><p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。<br><span style="color:red;">回滚方式便是用“before image”还原业务数据</span>；但在还原前要首先要校验脏写，<span style="color:red;">对比“数据库当前业务数据”和 “after image”</span>，<br>如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，<span style="color:red;">出现脏写就需要转人工处理</span>。</p><p><img src="https://www.hahhome.top/blog/springcloud/../../image/springcloud.assets/image-20230524185108734-shareX-20230524185116.png" alt="image-20230524185108734"></p><p>debug时，可以查看各业务数据库中的<span style="color:red;">undo_log表中的rollback_info字段，里面存有前后镜像</span>的信息等</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC笔记大纲</title>
      <link href="/blog/JUCGuide/"/>
      <url>/blog/JUCGuide/</url>
      
        <content type="html"><![CDATA[<p>尚硅谷周阳JUC全程跟做笔记，感谢尚硅谷，感谢周阳老师，看到评论区的别人的笔记我都不太满意，一楼的伙伴分享的笔记我看加入了很多自己的东西，并没有完全按照老师的课程来走，所以我就自己写了一些笔记，包含老师99%的课件以及一部分自己的理解，让老师的课更通俗易懂</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="http://t.csdn.cn/wybRl">JUCBase-JUC基础：JUC基础框架体系大致了解</a><br><a href="https://blog.csdn.net/m0_62176282/article/details/131746345?spm=1001.2014.3001.5501">JUC01-Future接口、CompletableFuture异步任务、Java8函数式接口和Stream流式编程</a><br><a href="https://blog.csdn.net/m0_62176282/article/details/131746356?spm=1001.2014.3001.5501">JUC02-多线程锁、线程中断机制、LockSupport线程间通信</a><br><a href="https://blog.csdn.net/m0_62176282/article/details/131843214?spm=1001.2014.3001.5502">JUC03-JMM、volatile</a><br><a href="https://editor.csdn.net/md/?articleId=131843249">JUC04– CAS自旋 、CAS自旋锁、ABA问题及解决办法、18大原子类</a><br><a href="http://t.csdn.cn/jCb0R">JUC05-ThreadLocal、ThreadLocal底层与Thead、ThreadLocalMap之间的关系、Java对象内存布局</a><br><a href="http://t.csdn.cn/7SQoC">JUC06-无锁、偏向锁、轻量级锁、重量级锁，synchronized锁升级</a><br><a href="http://t.csdn.cn/bEwny">JUC07-AQS（AbstractQueuedSynchronizer）及源码解读</a><br><a href="http://t.csdn.cn/7868S">JUC08- 读写锁ReentrantReadWriteLock、邮戳锁StampedLock、JUC总结</a></p><p><font color="red">更新完毕</font></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC08</title>
      <link href="/blog/JUC08/"/>
      <url>/blog/JUC08/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC08"><a href="#JUC08" class="headerlink" title="JUC08"></a>JUC08</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li>读写锁ReentrantReadWriteLock</li><li>邮戳锁StampedLock</li><li>JUC总结</li></ul><h1 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h1><h2 id="读写锁的意义和特点"><a href="#读写锁的意义和特点" class="headerlink" title="读写锁的意义和特点"></a>读写锁的意义和特点</h2><p>读写锁定义为：<font color="cornflowerblue">一个资源能够被<font color="red">多个读线程</font>访问，或者被<font color="red">一个写线程</font>访问，但是线程间不能同时存在读写线程。</font></p><p><font color="red"><strong>读写互斥，读读共享，读没有完成时候其它线程写锁无法获得</strong></font></p><p><font color="red">它只允许读读共存，而读写和写写依然是互斥的</font>，大多实际场景是<font color="red">“读&#x2F;读”线程间并不存在互斥关系，</font></p><p>只有”读&#x2F;写”线程或”写&#x2F;写”线程间的操作需要互斥的。因此引入ReentrantReadWriteLock。</p><p>一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但不能同时存在写锁和读锁（<font color="cornflowerblue">切菜还是拍蒜选一个</font>）。</p><p>也即<font color="cornflowerblue">一个资源可以被多个读操作访问          或           一个写操作访问，</font>但两者不能同时进行。</p><p><font color="red">只有在读多写少情景之下，读写锁才具有较高的性能体现。</font></p><h2 id="读写锁缺点"><a href="#读写锁缺点" class="headerlink" title="读写锁缺点"></a>读写锁缺点</h2><p>缺点：</p><ul><li>写锁饥饿问题<ul><li>下面邮戳锁解决（StampedLock）</li></ul></li><li>注意锁降级</li></ul><h2 id="读写锁锁降级"><a href="#读写锁锁降级" class="headerlink" title="读写锁锁降级"></a>读写锁锁降级</h2><p>ReentrantReadWriteLock锁降级：将写入锁降级为读锁（类似Linux.文件读写权限理解，就像写权限要高于读权限一样），<font color="red">锁的严言程度变强叫做升级，反之叫做降级。</font></p><table><thead><tr><th>特性</th><th>特性说明</th></tr></thead><tbody><tr><td>公平性选择</td><td>支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</td></tr><tr><td>重进入</td><td>该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。<br>而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁</td></tr><tr><td>锁降级</td><td>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁</td></tr></tbody></table><p><font color="cornflowerblue">写锁的降级，降级成为了读锁</font></p><ul><li>1如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。</li><li>2规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序。</li><li>3如果释放了写锁，那么就完全转换为读锁。</li></ul><p>锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。</p><p>如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。</p><p><img src="https://www.hahhome.top/blog/JUC08/../../image/JUC08.assets/image-20230722160826863.png" alt="image-20230722160826863"></p><p><font color="red">重入还允许通过获取写入锁定，然后读取锁然后释放写锁从写锁到读取锁，<strong>但是，从读锁定升级到写锁是不可能</strong>的。</font></p><h3 id="锁降级的分析及好处"><a href="#锁降级的分析及好处" class="headerlink" title="锁降级的分析及好处"></a>锁降级的分析及好处</h3><p>以下面这段使用锁降级的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">                <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="cornflowerblue">锁降级的好处：</font></strong></p><p>1代码中声明了一个volatile类型的cacheValid变量，保证其可见性。</p><p>2首先获取读锁，如果cache不可用，则释放读锁。获取写锁，在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true，然后在<font color="red">释放写锁前<strong>立刻抢夺获取读锁</strong></font>；此时，cache中数据可用，处理cache中数据，最后释放读锁。这个过程就是一个完整的锁降级的过程，<font color="cornflowerblue"><strong>目的是保证数据可见性。</strong></font></p><p><strong>总结：一句话，同一个线程自己特有写锁时再去拿读锁，其本质相当于<font color="red">重入</font>。</strong></p><p><font color="red">如果违背锁降级的步骤，如果违背锁降级的步骤，如果违背锁降级的步骤</font></p><p>如果当前的线程C在修改完cache中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程D获取了写锁并修改了数据，那么C线程无法感知到数据已被修改，则数据出现错误。</p><p><font color="lightyellowgreen">如果遵循锁降级的步蹀</font></p><p>线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。</p><h2 id="写锁和读锁是互斥的"><a href="#写锁和读锁是互斥的" class="headerlink" title="写锁和读锁是互斥的"></a>写锁和读锁是互斥的</h2><p><font color="cornflowerblue">写锁和读锁是互斥的</font>（这里的互斥是<font color="red">指线程间的互斥</font>，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁)，这是因为读写锁要<font color="red">保持写操作的可见性</font>。因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作。</p><p>因此，分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：</p><p><font color="orange">读锁结束，写锁有望；写锁独占，读写全堵</font>（线程间，同一个线程可发生锁降级）</p><p>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即ReentrantReadWriteLock<font color="red">读的过程中不允许写</font>，<font color="cornflowerblue">只有等待线程都释放了读锁，当前线程才能获取</font><font color="red">写锁，也就是写入必须等待</font></p><p><font color="cornflowerblue">分析StampedLock（后面详细讲解）</font>，会发现它<strong>改进之处</strong>在于：</p><p><font color="red">读的过程中也允许获取写锁介入（相当牛B,读和写两个操作也让你“共享”（注意引号））</font>，这样会导致我们读的数据就可能不一致</p><p>所以，需要额外的方法来<font color="red">判断读的过程中是否有写入</font>，这是一种<font color="red">乐观的读锁，O(∩_∩)O哈哈~。</font></p><p>显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><h1 id="邮戳锁StampedLock"><a href="#邮戳锁StampedLock" class="headerlink" title="&#x3D;&#x3D;邮戳锁StampedLock&#x3D;&#x3D;"></a>&#x3D;&#x3D;邮戳锁StampedLock&#x3D;&#x3D;</h1><h2 id="分析邮戳锁的由来（锁的发展）"><a href="#分析邮戳锁的由来（锁的发展）" class="headerlink" title="分析邮戳锁的由来（锁的发展）"></a>分析邮戳锁的由来（锁的发展）</h2><p>注意区分：</p><ul><li>锁升级（synchronized）</li><li>锁发展和AQS（lock）</li></ul><p><img src="https://www.hahhome.top/blog/JUC08/../../image/JUC08.assets/image-20230722192651080.png" alt="image-20230722192651080"></p><p><strong>锁解饿问题</strong></p><p>ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，</p><p>假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了；<font color="red">因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写</font></p><p>如何解决锁解饿问题？</p><ul><li>采取公平锁的方式可以一定程度上缓解这个问题<ul><li>但是！！！公平锁是以牺牲系统吞吐量为代价的</li></ul></li><li><font color="red">StampedLock类的乐观读锁</font></li></ul><h2 id="邮戳锁的读写方式"><a href="#邮戳锁的读写方式" class="headerlink" title="邮戳锁的读写方式"></a>邮戳锁的读写方式</h2><ul><li>所有<font color="red">获取锁</font>的方法，都返回一个邮戳(Stamp),Stamp为零表示获取失败，其余都表示成功；</li><li>所有<font color="red">释放锁</font>的方法，都需要一个邮戳(Stamp),这个Stamp必须是<font color="cornflowerblue">和成功获取锁时得到的Stamp一致</font></li><li>StampedLock<font color="red">是不可重入的，危险</font>（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li><li>StampedLock有三种访问模式：<ul><li>①Reading(读模式悲观)：功能和ReentrantReadWriteLock的读锁类似</li><li>②Writing(写模式)：功能和ReentrantReadWriteLockl的写锁类似</li><li>**③Optimistic reading(乐观读模式)**：无锁机制，类似于数据库中的乐观锁，支持读写并发，<font color="red"><strong>很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式</strong></font></li></ul></li></ul><p><strong><font color="red">StampedLock &#x3D; ReentrantReadWriteLock（带戳记版） + 乐观读模式</font></strong></p><h2 id="邮戳锁的缺点"><a href="#邮戳锁的缺点" class="headerlink" title="邮戳锁的缺点"></a>邮戳锁的缺点</h2><ul><li>StampedLock<font color="red">不支持重入</font>，没有Re开头</li><li>StampedLock的悲观读锁和写锁都<font color="red">不支持条件变量(Condition)</font>,这个也需要注意。</li><li>使用StampedLock<font color="red">一定不要调用中断操作</font>，即不要调用interrupt()方法<ul><li>会影响性能和造成意外bug</li></ul></li></ul><h2 id="传统的读写方式"><a href="#传统的读写方式" class="headerlink" title="传统的读写方式"></a>传统的读写方式</h2><p>该方式和ReentrantReadWriteLock几乎一样，只是多了一个返回戳记的形式</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamped</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程准备修改&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程结束修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//悲观读，读没有完成时候写锁无法获得锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamped</span> <span class="operator">=</span> stampedLock.readLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; come in readlock code block，4 seconds continue...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; 正在读取中......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> number;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; 获得成员变量值result：&quot;</span>+result);</span><br><span class="line">            System.out.println(<span class="string">&quot;写线程没有修改成功，读锁时候写锁无法介入，传统的读写互斥&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读线程结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; finally value: &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StampedLockDemo</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLockDemo</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 传统版</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(resource::read,<span class="string">&quot;readThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">&quot;writeThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">4</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;number:&quot;</span> +number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乐观读功能"><a href="#乐观读功能" class="headerlink" title="乐观读功能"></a>乐观读功能</h2><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamped</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程准备修改&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程结束修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乐观读，读的过程中也允许获取写锁介入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamped</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> number;</span><br><span class="line">        <span class="comment">//故意间隔4秒钟，很乐观认为读取中没有其它线程修改过number值，具体靠判断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4秒前stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamped));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;正在读取... &quot;</span>+i+<span class="string">&quot; 秒&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;后stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamped));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamped))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人修改过------有写操作&quot;</span>);</span><br><span class="line">            stamped = stampedLock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;从乐观读 升级为 悲观读&quot;</span>);</span><br><span class="line">                result = number;</span><br><span class="line">                System.out.println(<span class="string">&quot;重新悲观读后result：&quot;</span>+result);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; finally value: &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StampedLockDemo</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLockDemo</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 乐观版</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(resource::tryOptimisticRead,<span class="string">&quot;readThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停6秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">4</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">&quot;writeThread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总回顾"><a href="#总回顾" class="headerlink" title="总回顾"></a>总回顾</h1><p><strong>注意区分：</strong></p><ul><li>锁升级（synchronized）</li><li>锁发展和AQS（lock）</li></ul><p><strong>锁的种类：</strong></p><ul><li>1.悲观锁</li><li>2.乐观锁</li><li>3.自旋锁</li><li>4.可重入锁（递归锁）</li><li>5.写锁（独占锁）&#x2F;读锁（共享锁）</li><li>6.公平锁&#x2F;非公平锁</li><li>7.死锁</li><li>8.偏向锁</li><li>9.轻量锁</li><li>10.重量锁</li><li>11.邮戳（票据）锁</li></ul><p><strong>所有知识点：</strong></p><ul><li>1.CompletableFuture异步任务</li><li>2.“锁”事儿<ul><li>上面列举的那么多锁</li></ul></li><li>3.JMM</li><li>4.synchronized及其锁升级</li><li>5.CAS</li><li>6.volatile</li><li>7.LockSupport和线程中断</li><li>8.AbstractQueuedSynchronizer</li><li>9.ThreadLocal</li><li>10.原子类Atomic及其增强类</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC07</title>
      <link href="/blog/JUC07/"/>
      <url>/blog/JUC07/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC07"><a href="#JUC07" class="headerlink" title="JUC07"></a>JUC07</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li><font color="red">AQS</font></li></ul><h1 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="&#x3D;&#x3D;AQS（AbstractQueuedSynchronizer）&#x3D;&#x3D;"></a>&#x3D;&#x3D;AQS（AbstractQueuedSynchronizer）&#x3D;&#x3D;</h1><h2 id="AQS理论知识"><a href="#AQS理论知识" class="headerlink" title="AQS理论知识"></a>AQS理论知识</h2><h3 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h3><p>since jdk1.5</p><p>字面意思：抽象的队列同步器</p><ul><li><font color="red">AQS字面意思时抽象队列同步器，他是用来实现锁和其它同步器组件的公共基础部分的抽象实现，是重量级基础框架和整个JUC体系的基石，解决了锁分配给谁的问题，使用CAS和volatile机制实现的锁模板，保证了代码的同步性和可见性，AQS封装了线程的阻塞等待挂起，和解锁唤醒其它线程的逻辑，它的子类只需要根据状态变量，判断是否可以获得锁，是否释放锁，使用LockSupport挂起、唤醒线程即可</font></li></ul><h3 id="锁和同步器的关系"><a href="#锁和同步器的关系" class="headerlink" title="锁和同步器的关系"></a>锁和同步器的关系</h3><ul><li>锁，面向锁的使用者<ul><li>定义了程序员和锁交互的依层APL，隐藏了实现细节，你调用即可。</li></ul></li><li>同步器，面向锁的实现者<ul><li>Java并发大神DougLee，提出统一规范并简化了锁的实现，<font color="red">将其抽象出来</font>屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的—<font color="red">公共基础部分</font></li></ul></li></ul><h3 id="技术解释"><a href="#技术解释" class="headerlink" title="技术解释"></a>技术解释</h3><p>​<strong>是用来实现锁或者其它同步器组件的公共基础部分的抽象实现</strong>，<font color="red">是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给”谁”的问题</font></p><p>​<font color="cornflowerblue"><strong>volatile+cas机制实现的锁模板，保证了代码的同步性和可见性，而AQS封装了线程阻塞等待挂起，解锁唤醒其他线程的逻辑。AQS子类只需根据状态变量，判断是否可获取锁，是否释放锁，使用LockSupport挂起、唤醒线程即可</strong></font></p><p>​<font color="red">通过内置的<strong>CLH</strong>（FIFO）队列的变体来完成资源获取线程的排队工作，将每条将要去抢占资源的线程封装成一个<strong>Node</strong>节点来实现锁的分配，有一个<strong>int类变量表示持有锁的状态</strong>(private volatile int state)，通过CAS完成对status值的修改(0表示没有，&gt;&#x3D;1表示阻塞)</font></p><p>​抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种<font color="red">排队等候机制</font>。抢占资源失败的线程继续去等待（类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去<font color="red">候客区排队等候</font>)，但等候线程仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务)。</p><p>既然说到了<font color="red">排队等候机制</font>，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>如果共享资源被占用，<font color="cornflowerblue">就需要一定的阻塞等待唤醒机制来保证锁分配</font>。这个机制主要用的是<strong>CLH队列的变体实现</strong>的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的结点对象(<font color="red"><strong>Node</strong></font>)，<font color="cornflowerblue">通过CAS、自旋以及LockSupport.park()的方式</font>，维护state变量的状态，使并发达到同步的效果。</p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720150934258.png" alt="image-20230720150934258"></p><h3 id="通过代码解释为什么JUC是最重要的基石"><a href="#通过代码解释为什么JUC是最重要的基石" class="headerlink" title="通过代码解释为什么JUC是最重要的基石"></a>通过代码解释为什么JUC是最重要的基石</h3><ul><li>和AQS有关的：</li></ul><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720151722007.png" alt="image-20230720151722007"></p><ul><li>举例其中一个：ReentrantLock</li></ul><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720152330592.png" alt="image-20230720152330592"></p><h2 id="AQS体系架构"><a href="#AQS体系架构" class="headerlink" title="AQS体系架构"></a>AQS体系架构</h2><h3 id="AQS内部架构图"><a href="#AQS内部架构图" class="headerlink" title="AQS内部架构图"></a>AQS内部架构图</h3><blockquote><p><strong>AQS内部架构图</strong></p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720155012947.png" alt="image-20230720160803799"></p><p>蓝色：继承线</p><p>红色：内部类</p><p>绿色：实现线</p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720155012948.png" alt="image-20230720155012948"></p></blockquote><h3 id="详解AQS内部代码有什么？"><a href="#详解AQS内部代码有什么？" class="headerlink" title="详解AQS内部代码有什么？"></a>详解AQS内部代码有什么？</h3><blockquote><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720155012949.png" alt="img"></p></blockquote><h3 id="双向CLH队列结构"><a href="#双向CLH队列结构" class="headerlink" title="双向CLH队列结构"></a>双向CLH队列结构</h3><blockquote><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720155642029.png" alt="image-20230720155642029"></p><p>AQS使用一个<font color="cornflowerblue">volatile的int类型</font>的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去枪占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。</p><p><font color="red">有阻塞就需要排队，实现排队必然需要队列</font>：state变量+CLH双端队列</p><p>双向链表中，<font color="red"><strong>第一个节点为虚节点（也叫哨兵节点）</strong></font>，<font color="cornflowerblue">其实并不存储任何信息，只是占位。<strong>首节点永远是虚拟节点</strong>，第一个虚拟节点被回收后，队列中抢到锁的节点就会被修改为虚拟节点继续作为首节点head</font><br><font color="red"><strong>真正的第一个有数据的节点，是从第二个节点开始的。</strong></font></p></blockquote><h3 id="Node类内部结构"><a href="#Node类内部结构" class="headerlink" title="Node类内部结构"></a>Node类内部结构</h3><blockquote><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720155642030.png" alt="img"></p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720161923356.png" alt="image-20230720161923356"></p></blockquote><h2 id="AQS源码解读"><a href="#AQS源码解读" class="headerlink" title="AQS源码解读"></a>AQS源码解读</h2><h3 id="AQS-ReentrantLock体系结构"><a href="#AQS-ReentrantLock体系结构" class="headerlink" title="AQS ReentrantLock体系结构"></a>AQS ReentrantLock体系结构</h3><p>ReentrantLock就是操作Sync这个继承于AQS的内部类，来对外展现两个分支：<strong>FiarSync</strong>和<strong>NonfairSync</strong></p><blockquote><p>从ReentrantLock开始解读源码：</p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720163310350.png" alt="image-20230720163310350"></p><p>通过ReentrantLock的源码来讲解公平锁和非公平锁</p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720164240591.png" alt="image-20230720164240591"></p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720165754761.png" alt="image-20230720165754761"></p><p><strong>公平锁与非公平锁的tryAcquire()方法的区别</strong></p><p><font color="red">可以明显看出公平锁与非公平锁的ock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：<br>hasQueuedPredecessors()</font><br><font color="cornflowerblue">hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line"> <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line"> <span class="comment">// thread is first in queue.</span></span><br><span class="line"> <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line"> <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line"> Node s;</span><br><span class="line"> <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">     ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">可以看出，ReentrantLock就是操作Sync这个继承于AQS的内部类，来对外展现两个分支：<strong>FiarSync</strong>和<strong>NonfairSync</strong></font></p></blockquote><h3 id="非公平锁的lock-方法"><a href="#非公平锁的lock-方法" class="headerlink" title="非公平锁的lock()方法"></a>非公平锁的lock()方法</h3><blockquote><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720173114488.png" alt="image-20230720173114488"></p><p><font color="cornflowerblue">无论是公平锁还是非公平锁</font>，<font color="red">调用lock()方法最终都会调用**acquire()**方法</font></p><p><strong>非公平锁的lock()方法源码：</strong></p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720174949264.png" alt="image-20230720174949264"></p></blockquote><h3 id="acquire-方法流程"><a href="#acquire-方法流程" class="headerlink" title="acquire()方法流程"></a>acquire()方法流程</h3><blockquote><p><strong>acquire()源码：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">     acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">     selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720175825373.png" alt="image-20230720175825373"></p><p><font color="cornflowerblue"><strong>acquire()三条流程</strong></font></p><ul><li><p>调用tryAcquire()</p><ul><li>尝试获得锁，或执行可重入操作</li></ul></li><li><p>调用addWaiter()           –&gt;           enq入队操作</p><ul><li>队列内无节点则创建哨兵节点后入队，有节点则直接入队</li></ul></li><li><p>调用acquireQueued()           –&gt;           调用cancelAcquire()</p><ul><li>再次尝试1 tryAcquire()，如果失败则修改它的前一个节点的waitState为SIGNAL（-1）后进入阻塞，等待被唤醒</li></ul></li></ul></blockquote><h3 id="三个线程从lock-方法开始源码分析"><a href="#三个线程从lock-方法开始源码分析" class="headerlink" title="三个线程从lock()方法开始源码分析"></a>三个线程从lock()方法开始源码分析</h3><p>一共三个线程A、B、C，<font color="red">即ABC形成等待队列</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁的lock()方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>  (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//第一条线程进来，进行if判断compareAndSetState，state是0，CAS修改state为1成功</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//修改占有锁的线程为当前线程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">//后来的线程执行acquire()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一条线程A进来，进行if判断compareAndSetState，state是0，CAS修改state为1成功，并且修改占有锁的线程为当前线程A</p></li><li><p>后来的线程B和C执行acquire(1)方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平锁和非公平锁的acquire()方法是同一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//acquire()方法有3个流程</span></span><br><span class="line"><span class="comment">//1 调用tryAcquire()</span></span><br><span class="line"><span class="comment">//2 调用addWaiter()           --&gt;           enq入队操作</span></span><br><span class="line"><span class="comment">//3 调用acquireQueued()           --&gt;           调用cancelAcquire()</span></span><br></pre></td></tr></table></figure><ul><li><strong><font color="cornflowerblue">1 调用tryAcquire(1)</font></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁的nonfairTryAcquire()方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果state==0，则自选修改state为1，并修改占有锁的线程为当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//判度胺当前占有锁的线程是否为当前线程，如果是，则将state+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>先获得当前状态state，如果state&#x3D;&#x3D;0，则自选修改state为1，并修改占有锁的线程为当前线程，返回true，acquire()方法结束</p></li><li><p>else if 判度胺当前占有锁的线程是否为当前线程，如果是，则将state+1并返回true，acquire()方法结束</p></li><li><p>前面两个条件都不满足，则tryAcquire()方法失败，返回false</p><ul><li><font color="red">（一般第一个线程A正在执行业务中，后来的线程该方法都是直接返回false）</font></li><li>在上一层acquire()方法中对tryAcquire()的返回值取反，得到true，继续执行下一流程调用addWaiter()       –&gt;         enq入队操作</li></ul></li><li></li><li><p><strong><font color="cornflowerblue">2 调用addWaiter(Node.EXCLUSIVE)     –&gt;      enq入队操作</font></strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入等待线程的方法</span></span><br><span class="line"><span class="comment">//参数Node.EXCLUSIVE的意思是独占锁，另一种锁位Node.SHARED共享锁</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);<span class="comment">//先new一个新的节点用来装当前线程，模式为独占模式</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;<span class="comment">//定义一个节点pred为当前队列的尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;<span class="comment">//不为null，说明不是第一个要进入等待队列的线程，第一个线程为null直接跳过执行下面的enq(node)</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);<span class="comment">//队列中无节点才会执行enq()方法</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部方法：enq(node)</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize//第一次入队时尾节点t为空</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))<span class="comment">//双向链表中，第一个节点为虚节点（也叫哨兵节点）</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//不是第一次入队，尾节点t不为空</span></span><br><span class="line">                node.prev = t;<span class="comment">//将当前线程的节点的前置节点设为之前的尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//CAS将当前队列的尾节点设置为当前线程的节点node</span></span><br><span class="line">                    t.next = node;<span class="comment">//设置之前的尾节点t的下一个节点为当前线程的节点node</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>先new一个新的节点用来装当前线程，模式为独占模式</p></li><li><p>定义一个节点pred为当前队列的尾节点</p></li><li><p>**<font color="cornflowerblue">第一次入队：</font>**我们先看pred即当前队列的尾节点为null的情况，即是第一个入队的线程B，直接跳到下面enq()方法</p></li><li><p>**<font color="cornflowerblue">第二次及后续入队：</font>**pred即当前队列的尾节点不为null，说明C不是第一个要进入等待队列的线程</p><ul><li>设置当前入队线程C的节点node的前置节点prev为当前队列的尾节点pred，也就是B</li><li>CAS更换队列的尾节点B为当前入队线程C的节点node</li><li>设置之前的尾节点pred的下一个节点为当前线程C的节点node</li><li>返回acquire()方法</li></ul></li><li></li><li><p>于是到了enq(node)入队操作：<font color="cornflowerblue"><strong>第一次入队</strong></font>，后续入队不会进入enq()方法了，已经返回了</p><ul><li><p>在一个for死循环中，先定义一个t节点为队列的尾节点</p></li><li><p>如果t尾节点是空，现在B是第一次入队，所以就是null，于是进入if语句</p><ul><li><p>CAS将当前队列的头节点设置为一个空节点，即<font color="red">虚拟节点（也叫哨兵节点）</font>,并设置尾节点也为这个虚节点</p></li><li><blockquote><p>双向链表中，<font color="red">第一个节点为虚节点（也叫哨兵节点）</font>，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的。</p></blockquote></li></ul></li><li><p>设置好队列头节点后，进入第二次for循环，第二次for循环将会进入else语句</p><ul><li>进入else之前会重新设置当前尾节点t，也就是if语句中设置的虚拟节点</li><li>将当前线程B的节点node的前置节点设为之前的尾节点即虚拟节点</li><li>CAS将当前队列的尾节点设置为当前线程B的节点node</li><li>设置之前的尾节点t的下一个节点为当前线程B的节点node</li></ul></li></ul></li><li></li><li><blockquote><p>第一个等待线程B入队：</p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720210956445.png" alt="image-20230720210956445"></p><p>第二次及后续入队：</p><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230720210956446.png" alt="image-20230720210939243"></p></blockquote></li><li></li><li><p><strong><font color="cornflowerblue">3 调用acquireQueued()           –&gt;           调用cancelAcquire()</font></strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//acquireQueued(node, 1)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//该方法为设置前置节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">//该方法是调用pork()方法阻塞线程</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部方法shouldParkAfterFailedAcquire()：设置当前节点的前置节点的waitState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)     <span class="comment">//等于-1才返回true      </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;        <span class="comment">//大于0的情况只有1，即CANCELED，撤销操作 </span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;           </span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><font color="cornflowerblue">当进入的node时B节点时：</font></strong></p><ul><li><p>先定义是否中断为false</p></li><li><p>第一次进入for死循环</p><ul><li>设置节点p为当前节点node的前置节点，即B的前置节点，为虚拟节点</li><li>if语句：p是否等于head，虚拟节点就是head节点，第二个判断是再次尝试tryAcquire()，一般也是false</li><li>第二个if：设置当前节点的前置节点的waitState，进入方法体：<ul><li>此时第一次for循环前置节点也就是虚拟节点的waitStatus&#x3D;0，此时会被设置为SIGNAL（-1），返回false</li></ul></li></ul></li><li><p>第二次for循环：</p><ul><li><p>第一个if一般为false</p></li><li><p>第二个if：设置当前节点的前置节点的waitState，进入方法体：</p><ul><li>此时第二次for循环前置节点也就是虚拟节点的waitStatus&#x3D; -1，返回true</li></ul></li><li><p>第二个if的第二个判断条件，进入方法体parkAndCheckInterrupt()，调用pork()方法阻塞线程</p><ul><li><p><strong><font color="red">由后一个节点设置它的前置节点的waitState为 -1</font></strong></p></li><li><blockquote><pre><code class="java">//内部方法parkAndCheckInterrupt：阻塞线程private final boolean parkAndCheckInterrupt() &#123;       //线程挂起，程序不会继续向下执行       LockSupport.park(this);       //根据park方法API猫述，程序在下述三种情沉会继续向下执行       //1.被unpark       //2.被中断(interrupt)       //3.其他术合逻每的返回才会继续向下行       //因上述三种清沉程序执行至此，返回当前线程的中断状态，并清空中断状态       //如果由于被中断，该方法会返回true       return Thread.interrupted();//一般被unpark返回false&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- **&lt;font color=&#x27;cornflowerblue&#x27;&gt;当进入的node时C节点时：&lt;/font&gt;**</span><br><span class="line"></span><br><span class="line"> - 和节点B时一致，只需将虚拟节点改为B，B节点改为C节点</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- &gt;B和C都被设置waitStatus为-1，且都被阻塞后：</span><br><span class="line"></span><br><span class="line"> &gt;![image-20230720224343766](image/JUC07.assets/image-20230720224343766.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第一个线程unlock()后第二个线程上位源码解析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**A线程unlock()**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//unlock()方法都一样</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">   sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></blockquote></li></ul></li></ul></li></ul></li><li><p>unlock()只调用一个release(1)方法，参数为1</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//release(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>if条件判断进入tryRelease(1)方法体：</p><ul><li><blockquote><pre><code class="java">//if中方法：tryRelease(1)protected final boolean tryRelease(int releases) &#123;       int c = getState() - releases;//定义变量c为当前state - 1，也就是0       if (Thread.currentThread() != getExclusiveOwnerThread())//不是当前线程解锁则抛出异常           throw new IllegalMonitorStateException();       boolean free = false;       if (c == 0) &#123;           free = true;           setExclusiveOwnerThread(null);       &#125;       setState(c);       return free;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> - 定义变量c为当前state - 1，也就是0</span><br><span class="line"> - 第一个if：不是当前线程解锁则抛出异常（一般不出现）</span><br><span class="line"> - 定义变量free=false</span><br><span class="line"> - 第二个if：c==0，进入if：</span><br><span class="line">   - 设置free=true</span><br><span class="line"> - 设置state=c=0，表示现在锁空闲，返回free=true</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- 所以进入release(1)的if语句：</span><br><span class="line"></span><br><span class="line"> - 定义节点h为头节点，这里的头节点时虚拟节点</span><br><span class="line"></span><br><span class="line"> - if语句：有等待线程的话，头节点都不为空，且等待节点的前置节点的waitState已经被设置为 -1，这里是B的前置节点虚拟节点</span><br><span class="line"></span><br><span class="line">   - unparkSuccessor(h)：</span><br><span class="line"></span><br><span class="line">     - &gt;```java</span><br><span class="line">       &gt;//内部方法unparkSuccessor()</span><br><span class="line">       &gt;private void unparkSuccessor(Node node) &#123;</span><br><span class="line">       int ws = node.waitStatus;</span><br><span class="line">       if (ws &lt; 0)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">       Node s = node.next;</span><br><span class="line">       if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">           s = null;</span><br><span class="line">           for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               if (t.waitStatus &lt;= 0)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       if (s != null)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">       &gt;&#125;</span><br></pre></td></tr></table></figure></code></pre></blockquote><ul><li>ws&lt;0：设置头节点的waitState为0</li><li>定义一个节点s为头节点的下一个节点，即等待的第一个节点，这里是B</li><li>s一般不为空，跳过一个if进入下一个if语句if (s !&#x3D; null)：<ul><li>接触节点s的线程阻塞，这里是解除B</li></ul></li></ul></li></ul></li><li></li><li><p><strong><font color="cornflowerblue">这里返回lock()步骤中的3 acquireQueued()</font></strong></p></li><li><blockquote><pre><code class="java">//lock()中的acquire()中的3 acquireQueued(node, 1)final boolean acquireQueued(final Node node, int arg) &#123;       boolean failed = true;       try &#123;           boolean interrupted = false;           for (;;) &#123;               final Node p = node.predecessor();//该方法为设置前置节点               if (p == head &amp;&amp; tryAcquire(arg)) &#123;                   setHead(node);//设置队列头节点为当前节点                   p.next = null; // help GC                   failed = false;                   return interrupted;               &#125;               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                   parkAndCheckInterrupt())//该方法是调用pork()方法阻塞线程                   interrupted = true;           &#125;       &#125; finally &#123;           if (failed)               cancelAcquire(node);       &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 这里的parkAndCheckInterrupt()会返回false，然后再次进入for循环</span><br><span class="line"></span><br><span class="line">- 此时，第一个if语句处：B的前置节点p就是为头节点并且这里尝试tryAcquire()将会成功</span><br><span class="line"></span><br><span class="line"> - 这里是进入**&lt;font color=&#x27;cornflowerblue&#x27;&gt;lock()步骤中的1 tryAcquire()&lt;/font&gt;**，state已经是0，所以尝试成功，返回true</span><br><span class="line"></span><br><span class="line">- 进入这个if的判断体：</span><br><span class="line"></span><br><span class="line"> - setHead(node)：设置队列头节点为当前节点B，并将B的thread设置为null，B的前置节点为null，即将B设置为新的虚拟头节点</span><br><span class="line"></span><br><span class="line">   - &gt;```java</span><br><span class="line">     &gt;private void setHead(Node node) &#123;</span><br><span class="line">       head = node;</span><br><span class="line">       node.thread = null;</span><br><span class="line">       node.prev = null;</span><br><span class="line">     &gt;&#125;</span><br></pre></td></tr></table></figure></code></pre></blockquote><ul><li><p>前置节点p的下一个节点为null（p即虚拟节点，帮助GC），此时虚拟节点已经没有引用了</p></li><li><p>failed &#x3D; false;，返回interrupted&#x3D;false，acquire()方法接收到false，无法进入if，方法结束，B成功上位</p></li></ul></li><li></li><li><blockquote><p><img src="https://www.hahhome.top/blog/JUC07/../../image/JUC07.assets/image-20230721001309714.png" alt="image-20230721001309714"></p></blockquote></li></ul><h3 id="cancelAcquire-撤销节点"><a href="#cancelAcquire-撤销节点" class="headerlink" title="cancelAcquire()撤销节点"></a>cancelAcquire()撤销节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 跳过所有已经是被撤销的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"><span class="comment">// 获取本被撤销节点  的前一个不是被撤销节点  的后一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line">    <span class="comment">// 设置当前节点的waitState为CANCELLED（1）</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"><span class="comment">// 如果本被撤销节点刚好是尾节点的话，设置尾节点为它的前一个不是被撤销节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);<span class="comment">//将pred的后一个节点设置为null，因为sCANCELLED节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 被撤销节点不是尾节点</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="comment">//要求本被撤销节点  的前一个不是被撤销节点 不是首节点和虚拟节点，且waitStatus能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//开始队列的删除本节点和连接前后节点操作</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//设置 的前一个不是被撤销节点  的后一个节点为本节点的后一个节点（去除了本节点之前的连续的被撤销节点）</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>找到本被撤销节点  的前一个不是被撤销节点pred<ul><li>如果本被撤销节点原本就是队列的tail，则设置pred为tail，cancel结束，队列等待唤醒</li><li>如果本被撤销节点 不是tail，则只要pred不是head且waitState能够 &lt; 0，则连接pred和node.next，cancel结束，队列等待唤醒<ul><li>pred是head，则进入unparkSuccessor()，该方法会唤醒传入节点的后一个waitState &lt; 0的节点，即唤醒node的后一个waitState &lt; 0的节点</li></ul></li></ul></li></ul><h2 id="源码解读小总结"><a href="#源码解读小总结" class="headerlink" title="源码解读小总结"></a>源码解读小总结</h2><p>整个ReentrantLock的加锁过程，可以分为三个阶段：</p><ul><li>1、尝试加锁；</li><li>2、加锁失败，线程入队烈</li><li>3、线程入队列后，进入阻塞状态。</li></ul><p>对应下面①②③三部分。</p><p>①</p><p>tryAcquire方法，尝试获取锁。以下几种情况，会导致获取锁失败：</p><ul><li>1、锁已经被其它线程获取：</li><li>2、锁没有被其他线程获取，但当前线程需要排队：</li><li>3、cas失败（可过程中已经有其他线程拿到锁了）</li></ul><p>锁为自由状态(c&#x3D;&#x3D;0)，并不能说明可以立刻执行cas获取锁，因为可能在当前线程获取锁之前，已经有其他线程在排队了</p><p>如果是公平锁，必须道循先来后到原则获取锁。所以还要调用**hasQueuedPredecessors()**方法，查看自己是否需要排队。</p><p>②</p><p>将当前线程封装成Nod对，并入排队队列中。<br>模据排队队列是否执行过初始化，执行1、2不同处理方式</p><ul><li>1：表示排队队列不为空，即之前己经初始化过了，此时只需将新的node加入排队队列床尾即阿。</li><li>2：表示排队队列为空，需执行队列初始化。enq会初始化一个空的Node,作为排队队列的head,然后将需要排队的线程，作为head的next节点插入。<ul><li>队列尚未初始化，调用这个eng()方法。该方法生成一个空的Node节点(new Node()，虚拟节点&#x2F;哨兵节点)，描入到AQS队列头部，然后将参数node，作为其后继节点，插入队列，方法执行完华。</li></ul></li></ul><p>③</p><p>整个aqs的核心和难点之一<br>注意这里使用了or()：<br>首先判新node的前辈节点，<font color="red">是不是head</font>，如果是，说明它是下一个可以获得锁的线程，则调用一次tryAcquire，尝试获取锁，</p><ul><li><p>若获取到，则将差表关系重新谁护下(node设置为head,之前的head从差表移出)，然后返回如果node的前节点不是head,</p></li><li><p>若获取锁失败，再判断复前辈节点的waitState，是不是SIGNAL,</p><ul><li><p>如果是，则兰前浅程调用Park,进入阻塞状态</p></li><li><p>如不是：</p><ul><li><p>1、&#x3D;&#x3D;0,则设置为SIGNAL；</p></li><li><p>2、&gt;0（&#x3D;&#x3D;1），则素示前蜚节点已经被取消了，将取消的节点，从队列移出，重新淮护下排队羡关系：</p></li></ul></li></ul></li><li><p>然后再次运入for循环，上面的操作重新执行一遍。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC06</title>
      <link href="/blog/JUC06/"/>
      <url>/blog/JUC06/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC06"><a href="#JUC06" class="headerlink" title="JUC06"></a>JUC06</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li><font color="red">synchronized锁升级</font></li></ul><h1 id="Synchronized锁升级"><a href="#Synchronized锁升级" class="headerlink" title="&#x3D;&#x3D;Synchronized锁升级&#x3D;&#x3D;"></a>&#x3D;&#x3D;Synchronized锁升级&#x3D;&#x3D;</h1><p>本章学习建议：从上往下看，发现看不懂时，找到下面最近的一个<code>我的理解</code>，然后根据我的理解中我概括的内容，再去看上面的东西</p><p>小结和本章最后最后都会有我的理解汇总</p><h2 id="本章路线总纲"><a href="#本章路线总纲" class="headerlink" title="本章路线总纲"></a>本章路线总纲</h2><p>synchronized相关基础知识点和字节码分析请看《JUC02》的多线程锁目录</p><blockquote><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。<strong>能用无锁数据结构，就不要用锁</strong>；<strong>能锁区块，就不要锁整个方法体</strong>；<strong>能用对象锁，就不要用类锁</strong>。</p><p>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</p><p>​——《阿里开发手册》</p></blockquote><p><strong>synchronized锁优化的背景</strong></p><p>用锁能够实现数据的<font color="red">安全性</font>，但是会带来<font color="red">性能下降。</font></p><p>无锁能够基于线程并行提升程序性能，但是会带来<font color="red">安全性下降。</font></p><p>所以我们要找一个平衡：</p><p>锁的升级过程：</p><blockquote><p>无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁</p></blockquote><p>synchronized锁：由对象头中的Mark Word根据锁标志位的不同而被复用及锁升级策略</p><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719144812388.png" alt="image-20230719144812388"></p><h2 id="锁的发展"><a href="#锁的发展" class="headerlink" title="锁的发展"></a>锁的发展</h2><h3 id="JDK5前只有重量级"><a href="#JDK5前只有重量级" class="headerlink" title="JDK5前只有重量级"></a>JDK5前只有重量级</h3><h4 id="重量级锁的实现"><a href="#重量级锁的实现" class="headerlink" title="重量级锁的实现"></a>重量级锁的实现</h4><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719145432020.png" alt="image-20230719145432020"></p><p>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要<font color="cornflowerblue">操作系统介入</font>，<font color="red">需要在用户态与核心态之间切换</font>，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p><p>在Java早期版本中，<font color="red">synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依懒于底层的操作系统的**Mutex Lock(系统互斥量)**来实现的</font>，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。Java6之后，为了减少获得锁和释放锁所带来的性能消耗，<font color="red">引入了轻量级锁和偏向锁</font></p><p><strong>我的理解：</strong></p><ul><li>JDK5之前，只有重量级锁</li><li>假如锁的竞争比较激烈的话，会导致性能下降</li><li>重量级锁是用户态和内核态之间切换，容易导致阻塞</li><li><font color="red"><strong>所以我们就是为了尽量的减少内核态和用户态之间的切换，减少阻塞</strong></font></li></ul><h4 id="markOop-hpp和Monitor"><a href="#markOop-hpp和Monitor" class="headerlink" title="markOop.hpp和Monitor"></a>markOop.hpp和Monitor</h4><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719150129397.png" alt="image-20230719150129397"></p><p>Monitor（监视器锁、管程，也就是锁）可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。<font color="red">Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做<strong>内部锁或者Monitor锁</strong>。</font></p><p><font color="cornflowerblue">Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font></p><p>JVM中的同步就是基于进入和退出管程(Monitor)对象实现的。每个对象实例都会有一个Monitor，Monitor可以和对象一起创建、销毁。<br>Monitor是由ObjectMonitor实现，而ObjectMonitor是由C++的ObjectMonitor.hpp文件实现，如下所示：</p><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719150607967.png" alt="image-20230719150607967"></p><h4 id="java对象和Monitor的关联方式"><a href="#java对象和Monitor的关联方式" class="headerlink" title="java对象和Monitor的关联方式"></a>java对象和Monitor的关联方式</h4><p><font color="cornflowerblue"><strong>Mutex Lock</strong></font>（系统互斥量）</p><p><font color="cornflowerblue">Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。</font><font color="red">所以synchronized是Java语言中的一个重量级操作。</font></p><p><font color="cornflowerblue"><strong>Monitor与java对象以及线程是如何关联？</strong></font></p><p>1.如果一个java对象被某个线程锁住，则该java对象的<font color="red"><strong>Mark Word</strong></font>字段中LockWord指向monitor的起始地址</p><p>2.Monitor的Owner字段会存放拥有相关联对象锁的线程id</p><p><strong>Mutex Lock的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。</strong></p><p><strong>我的理解：</strong></p><ul><li><font color="red">即通过对象头中的对象标记MarkWord来标记锁的信息</font></li><li>每个Java对象都可以成为一把锁，天生自带内部锁或者叫Monitor锁</li><li><font color="red">Monitor的本质是<strong>依赖于底层操作系统的Mutex Lock（系统互斥量）实现</strong>，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font></li><li>Monitor是由ObjectMonitor实现的，<font color="cornflowerblue">ObjectMonitor中的属性对应着对象头MarkWord中的部分信息</font></li><li>Monitor即重量级锁，即synchronized            <font color="red"> Monitor       &lt;&#x3D; &#x3D;&gt;       重量级锁        &lt;&#x3D; &#x3D;&gt;      synchronized</font></li></ul><h4 id="一张图搞定重量级锁和对象头的说明和总结"><a href="#一张图搞定重量级锁和对象头的说明和总结" class="headerlink" title="一张图搞定重量级锁和对象头的说明和总结"></a>一张图搞定重量级锁和对象头的说明和总结</h4><p>统计一下前面的我的理解：</p><ul><li>JDK5之前，只有重量级锁</li><li>假如锁的竞争比较激烈的话，会导致性能下降</li><li>重量级锁是用户态和内核态之间切换，容易导致阻塞</li><li><font color="red"><strong>所以我们就是为了尽量的减少内核态和用户态之间的切换，减少阻塞</strong></font></li><li></li><li><font color="red">即通过对象头中的对象标记MarkWord来标记锁的信息</font></li><li>每个Java对象都可以成为一把锁，天生自带内部锁或者叫Monitor锁</li><li><font color="red">Monitor的本质是<strong>依赖于底层操作系统的Mutex Lock（系统互斥量）</strong>实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font></li><li>Monitor是由ObjectMonitor实现的，<font color="cornflowerblue">ObjectMonitor中的属性对应着对象头MarkWord中的部分信息</font></li><li>Monitor即重量级锁，即synchronized       <font color="red"> Monitor       &lt;&#x3D; &#x3D;&gt;       重量级锁        &lt;&#x3D; &#x3D;&gt; 重量级synchronized</font></li></ul><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719151528990.png" alt="image-20230719151528990"></p><h3 id="JDK6开始优化synchronized"><a href="#JDK6开始优化synchronized" class="headerlink" title="JDK6开始优化synchronized"></a>JDK6开始优化synchronized</h3><p>Java6之后，为了减少获得锁和释放锁所带来的性能消耗，<font color="red">引入了轻量级锁和偏向锁</font></p><h2 id="synchronized锁种类和升级步骤"><a href="#synchronized锁种类和升级步骤" class="headerlink" title="synchronized锁种类和升级步骤"></a>synchronized锁种类和升级步骤</h2><h3 id="3种多线程访问情况"><a href="#3种多线程访问情况" class="headerlink" title="3种多线程访问情况"></a>3种多线程访问情况</h3><ul><li>只有一个线程来访问，有且唯一Only One</li><li>有多个线程(2线程A、B来交替访问)</li><li>竞争激烈，更多个线程来访问</li></ul><p>后面讲解这三种情况分别对应什么锁以及什么时候升级</p><p><strong>64位标记图再看：</strong></p><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719144812388.png" alt="image-20230719144812388"></p><h3 id="3种MarkWord锁指向"><a href="#3种MarkWord锁指向" class="headerlink" title="3种MarkWord锁指向"></a>3种MarkWord锁指向</h3><p>synchronized用的锁是存在Java对象头里的Mark Word中</p><p>锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位</p><ul><li>偏向锁：MarkWord存储的是偏向的线程ID;</li><li>轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针；</li><li>重量锁：MarkWord存储的是指向堆中的monitor对象的指针：</li></ul><h3 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h3><p>《JUC05》中说过的需要使用工具 JOL 进行测试：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">JAVA object layout</span></span><br><span class="line"><span class="comment">官网:http://openjdk.java.net/projects/code-tools/jol/</span></span><br><span class="line"><span class="comment">定位:分析对象在JVM的大小和分布</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无锁：初始状态（new），一个对象被实例化后，如果还没有被任何线程竞争锁，那么它就为<font color="red">无锁状态（001）</font></p><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719161133433.png" alt="image-20230719161133433"></p><p>查看顺序：整体从右下往左上，8位从左往右</p><p>对应64位标记图：</p><ul><li>前25位为unused，使用棕色框起来的</li><li>之后31位为hashCode（如果调用了），为蓝色框起来的（上图打印的2进制结果最前面补一个0，因为最前面是0被省略了）</li><li>最后3位为001，代表无锁状态，红色框起来的</li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>JDK6-JDK14默认开启，JDK15开始逐渐废弃</p><h4 id="定义和作用"><a href="#定义和作用" class="headerlink" title="定义和作用"></a>定义和作用</h4><p><strong>是什么？</strong></p><p><font color="cornflowerblue">偏向锁：单线程竞争，一个时间点只会有一个线程使用锁或另一个线程第一次竞争锁就成功</font></p><p>当线程A第一次竞争到锁时，通过操作修改Mark Word中的偏向线程ID、偏向模式。</p><p>如果不存在其他线程竞争，那么持有偏向锁的线程<font color="red">将永远不需要进行同步。</font></p><p><strong>主要作用：</strong></p><p><font color="red">当一段同步代码一直被同一个线程多次访问，由于只有一个线程访问锁，那么该线程在后续访问时便会自动获得锁</font>（加锁了但是只有一个线程访问或者只有一个线程抢到锁）</p><p>同一个老顾客来访，直接老规矩行方便</p><p>看看多线程卖票，一个线程获得体会一下：几乎所有的票都是由卖出第一张票的线程卖出的</p><p><strong>小结论：</strong></p><p>Hotspot的作者经过研究发现，大多数情况下：</p><p>多线程的情况下，锁不仅不存在多线程竞争，还存在<font color="cornflowerblue">锁由同一个线程多次获得的情况，</font></p><p>偏向锁就是在这种情况下出现的，它的出现是为了解决<font color="red">只有在一个线程执行同步时提高性能。</font></p><p><font color="cornflowerblue">备注：</font></p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也即<font color="red">偏向锁在资源没有竞争情况下消除了同步语句</font>，懒的连CAS操作都不做了，直接提高程序性能</p><p><font color="cornflowerblue">所以最后64位标记<strong>前54位存储偏向线程ID</strong>，最后三位从无锁的<strong>001改为了</strong></font><font color="red"><strong>101</strong></font></p><h4 id="偏向锁的竞争"><a href="#偏向锁的竞争" class="headerlink" title="偏向锁的竞争"></a>偏向锁的竞争</h4><p><strong><font color="cornflowerblue">理论落地：</font></strong></p><p>​在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说<font color="red">锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</font></p><p>​那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁（后续这个线程进入和退出这段加了同步锁的代码块时，<font color="red">不需要再次加锁和释放锁</font>。而是直接会去检查锁的MarkWord里面是不是放的自己的线程ID)。</p><ul><li><font color="red">如果相等</font>，表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。<font color="red"><strong>如果自始至终使用锁的线程只有一个</strong></font>，<font color="red">很明显偏向锁几乎没有额外开销，性能极高。</font></li><li><font color="red">如果不等</font>，表示发生了竞争，锁己经不是总是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线<br>程的ID,<ul><li><font color="red">竞争成功</font>，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</li><li><font color="red">竞争失败</font>，<strong>这时候会发生偏向锁的撤销，可能需要升级变为轻量级锁</strong>，才能保证线程间公平竞争锁。</li></ul></li></ul><p><font color="cornflowerblue">注意，偏向锁只有遇到其他线程尝试<strong>竞争偏向锁时，持有偏向锁的线程才会释放锁</strong>，线程是不会主动释放偏向锁的</font></p><p><strong>我的理解：</strong></p><ul><li>偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（<font color="red"><strong>偏向锁中竞争一次失败后要么无锁，要么轻量锁</strong></font>）<ul><li>偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁</li></ul></li></ul><h4 id="偏向锁实现"><a href="#偏向锁实现" class="headerlink" title="偏向锁实现"></a>偏向锁实现</h4><p><strong><font color="cornflowerblue">技术实现：</font></strong></p><p>一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用**<font color="cornflowerblue">前54位来存储线程指针作为标识</font>**。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word中去判断一下是否有偏向锁指向本身的ID，无需再进入Monitor去竞争对象了。</p><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719170223538.png" alt="image-20230719170223538"></p><p>​偏向锁的操作<font color="red"><strong>不用直接捅到操作系统，不涉及用户到内核转换</strong></font>，不必要直接升级为最高级</p><p>​这时线程获得了锁，可以执行同步代码块。当该线程第二次到达同步代码块时会判断此时持有锁的线程是否还是自己（持有锁的线程D也在对象头里)，JVM通过account对象的Mark Word判断：当前线程ID还在，说明还持有着这个对象的锁，就可以继续进入临界区工作。<font color="red">由于之前没有释放锁，这里也就不需要重新加锁。<strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高</strong>。</font></p><p><font color="cornflowerblue">结论：</font><strong>JVM不用和操作系统协商设置Mutex(争取内核</strong>)，它只需要记录下线程ID就标示自己获得了当前锁，不用操作系统接入。</p><p><font color="orange">上述就是偏向锁</font>：在没有其他线程竞争的时候，一直偏同编心当前线程，当前线程可以一直执行。</p><h4 id="开启关闭偏向锁"><a href="#开启关闭偏向锁" class="headerlink" title="开启关闭偏向锁"></a>开启关闭偏向锁</h4><p>使用命令java -XX:+PrintFlagsInitial | grep BiasedLock*   在控制台查看偏向锁的开启情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial |grep BiasedLock*</span><br><span class="line">     intx BiasedLockingBulkRebiasThreshold          = 20                                  &#123;product&#125;</span><br><span class="line">     intx BiasedLockingBulkRevokeThreshold          = 40                                  &#123;product&#125;</span><br><span class="line">     intx BiasedLockingDecayTime                    = 25000                               &#123;product&#125;</span><br><span class="line">     intx BiasedLockingStartupDelay                 = 4000                                &#123;product&#125;</span><br><span class="line">     bool TraceBiasedLocking                        = false                               &#123;product&#125;</span><br><span class="line">     bool UseBiasedLocking                          = true                                &#123;product&#125;</span><br></pre></td></tr></table></figure><p>实际上病向锁在JDK1.6之后是激认开启的，但是启动时间有延迟，延迟默认是4s，程序启动前sleep 4秒就可以</p><p>所以需要添加参数-XX:BiasedLockingStartupDelay&#x3D;0，让其在程序启动时立刻启动。</p><ul><li>开启偏向锁：<ul><li>-XX:+UseBiasedLocking（JDK6后默认） -XX:BiasedLockingStartupDelay&#x3D;0</li></ul></li><li>关闭偏向锁：<ul><li><font color="red">关闭之后程序默认会直接进入——————————–&gt;&gt;&gt;&gt;&gt;&gt;&gt;经量级锁状态。</font></li><li>-XX:-UseBiasedLocking</li></ul></li></ul><p>演示时，若未指定-XX:BiasedLockingStartupDelay&#x3D;0，那么将看不到101标志位的效果，需要设置该参数后才可以</p><p>特殊情况：若没有加同步代码块状态下也为101是因为此时锁是可偏向的状态（线程睡了5秒），<strong>但是记录线程id的位数全都为0000000</strong></p><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719174657636.png" alt="image-20230719174657636"></p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p><strong>偏向锁的撤销：</strong></p><p>偏向锁使用一种等到<font color="red">竞争出现才释放锁</font>的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。</p><p><font color="cornflowerblue">竞争线程尝试CAS更新对象头失败时，</font><font color="red">原持有锁的线程会到达全局安全点，发生STW（该时间点上没有代码正在执行，即会暂停原持有锁的线程）</font>，检查持有偏向锁的线程是否还在执行：</p><ul><li>①第一个线程正在执行synchronized方法（<font color="red">处于同步块</font>），它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现<font color="red">锁升级</font>。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li><li>②第一个线程执行完成synchronized方法（<font color="red">退出同步块</font>），则将对象头设置成无锁状态并撤销偏向锁，重新偏向。</li></ul><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719201605132.png" alt="image-20230719201605132"></p><p><strong>我的理解：</strong></p><ul><li>偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（<font color="red"><strong>偏向锁中竞争一次失败后要么无锁，要么轻量锁</strong></font>）<ul><li>偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁</li></ul></li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><font color="cornflowerblue">轻量级锁：多线程竞争，但是任意时刻最多只有一个线程竞争</font>，即不存在锁竞争太过激烈的情况，也就没有线程阻塞。</p><ul><li>有线程来参与锁的竞争，但是获取锁的冲突时间极短</li><li>本质就是自旋锁CAS</li></ul><h4 id="升级为轻量级锁"><a href="#升级为轻量级锁" class="headerlink" title="升级为轻量级锁"></a>升级为轻量级锁</h4><p>轻量级锁是为了在线程<font color="red">近乎交替（很小的重叠）</font>执行同步块时提高性能。</p><p>主要目的：在没有多线程竞争的前提下，<font color="red">通过CAS减少</font>重量级锁使用操作系统互斥量产生的性能消耗，说白了<font color="red">先自旋，不行才升级阻塞。</font></p><p>升级时机：</p><ul><li><strong>1 关闭偏向锁功能</strong></li><li><strong>2 多线程竞争偏向锁</strong></li><li><strong>特殊情况：无锁状态下调用过hashCode，加锁时将会直接升级到轻量级锁</strong></li></ul><p>假如线程A己经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁己经被线程A拿到，当前该锁己是<strong>偏向锁</strong>了。</p><p>而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。</p><p><strong><font color="red">此时线程B操作中有两种情况：</font></strong></p><ul><li><font color="cornflowerblue"><strong>如果锁获取成功</strong></font>，直接替换Mark Word中的线程ID为B自己的ID(A→B),重新偏向于其他线程（即将偏向锁交给其他线程，相当于当前线程”被”释了锁)，该锁会继续保持偏向锁状态，A线程Over，B线程上位；</li><li><font color="cornflowerblue"><strong>如果锁获取失败</strong></font>，<strong>成功经过偏向锁的撤销后，偏向锁升级为轻量级锁</strong>（设置偏向锁标识为0并设置锁标志位为00），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</li></ul><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719212517502.png" alt="image-20230719212517502"></p><p>有人跟持有轻量级锁的线程竞争时，若是竞争失败，<font color="red">CAS自旋达到一定次数还未获得锁的话</font>，将会再次进行锁升级为重量级锁</p><p><strong>我的理解：</strong></p><ul><li>偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（**<font color="red">偏向锁中竞争一次失败后要么无锁，要么轻量锁</font>**）<ul><li>偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁</li></ul></li><li>如果轻量锁还出现竞争，且自旋达到一定次数后仍然未得到锁，则升级为重量级锁</li></ul><h4 id="轻量级锁升级为重量级锁的自旋次数"><a href="#轻量级锁升级为重量级锁的自旋次数" class="headerlink" title="轻量级锁升级为重量级锁的自旋次数"></a>轻量级锁升级为重量级锁的自旋次数</h4><p>有人跟持有轻量级锁的线程竞争时，若是竞争失败，<font color="red">CAS自旋达到一定次数还未获得锁的话</font>，将会再次进行锁升级为重量级锁</p><ul><li>JDK6之前<ul><li>默认启用，默认情况下自旋的<strong>次数</strong>是10次，或者自旋<strong>线程数</strong>超过CPU核数一半</li><li>-XX:PreBlockSpin&#x3D;10</li></ul></li><li><strong>JDK6之后</strong><ul><li>自适应自旋锁</li><li>线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也很大概率会成功。<br>反之，如果很少会自旋成功，那么下次会减少自旋的次数其至不自旋，避免CPU空转。</li><li><strong>自适应意味着自旋的次数不是固定不变的</strong>，而是根据：同一个锁上一次自旋的时间。拥有锁线程的状态来决定。</li></ul></li></ul><p><strong>和偏向锁的区别：</strong></p><p>争夺轻量级锁失败时，自旋尝试抢占锁</p><p>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</p><h4 id="轻量级锁的加锁和释放"><a href="#轻量级锁的加锁和释放" class="headerlink" title="轻量级锁的加锁和释放"></a>轻量级锁的加锁和释放</h4><p><font color="cornflowerblue">轻量级锁的加锁</font></p><p>JVM会为每个线程在当前线程的<strong>栈帧</strong>中创建用于存储锁记录的空间，官方成为Displaced Mark Word。若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。自旋CAS:不断尝试去获取锁，能不升级就不往上捅，尽量不要阻塞</p><p><font color="cornflowerblue">轻量级锁的释放</font></p><p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程</p><p>总结：<font color="cornflowerblue">升级为轻量级锁时</font>，JVM会<font color="red">在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝</font>，该拷贝中可以包含identity hash code，所以<font color="red">轻量级锁可以和identity hash code共存</font>，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><h4 id="重量级锁原理"><a href="#重量级锁原理" class="headerlink" title="重量级锁原理"></a>重量级锁原理</h4><p>Java中synchronized的重量级锁，是<font color="red">基于进入和退出Monitor对象实现的</font>。在编译时会将同步块的开始位置插入<strong>monitor enter</strong>指令，在结束位置插入<strong>monitor exit</strong>指令。</p><p>当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即<font color="red">获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor</font>。</p><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719223233660.png" alt="image-20230719223233660"></p><blockquote><p>重量级锁的详细实现查看前面锁的发展中的JDK5之前部分</p><p>字节码层面的monitor enter看JUC02中的多线程锁部分</p></blockquote><h3 id="锁升级后没有存放hash值的标志位怎么办？"><a href="#锁升级后没有存放hash值的标志位怎么办？" class="headerlink" title="锁升级后没有存放hash值的标志位怎么办？"></a>锁升级后没有存放hash值的标志位怎么办？</h3><p>锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，己经没有位置再保存哈希码，GC年龄了，那么这些信息被移动到哪里去了呢？</p><p>​                                                                                                                                                                                                                  </p><p>用书中的一段话来描述锁和hashcode之前的关系</p><blockquote><p>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode0方法按自己的意愿返回哈希码)，否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object:hashCode)方法，返回的是对象的一致性哈希码(Identity Hash Code),这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，<font color="red">当一个对象<strong>已经计算过一致性哈希码后，它就再也无法进入偏向锁状态</strong>了；而当一个对象当前<strong>正处于偏向锁状态</strong>，又收到需要计算其一致性哈希码请求时，它的<strong>偏向状态会被立即撤销，并且锁会膨胀为重量级锁</strong>。在重量级锁的实现中，对象头指向了重量级锁的位置，代表<strong>重量级锁的Object Monitor类里有字段可以记录非加锁状态（标志位为“0I”)下的Mark Word</strong>，其中自然可以存储原来的哈希码</font></p></blockquote><ul><li><p><font color="cornflowerblue">在无锁状态下</font>，Mark Word中可以存储对象的identity hash code值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。</p></li><li><p><font color="cornflowerblue">对于偏向锁</font>，在线程获取偏向锁时，会用Thread ID和epoch值覆盖identity hash code所在的位置。<font color="red">如果一个对象的hashCode()方法己经被调用过一次之后，这个对象不能被设置偏向锁，将直接升级为轻量级锁</font>。因为如果可以的话，那Mark Word中的identity hash code必然会被偏向线程ld给覆盖，这就会造成同一个对象前后两次调用hashCode()方法得到的结果不一致。<font color="red">已经是偏向锁后计算哈希值，那么会直接升级为重量级锁</font>，因为hash的标志位已经被覆盖，轻量级锁是复制原MarkWord，但是此时原MarkWord已经没有hash标志位了</p></li><li><p><font color="cornflowerblue">升级为轻量级锁时</font>，JVM会<font color="red">在当前线程的<strong>栈帧</strong>中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝</font>，该拷贝中可以包含identity hash code，所以<font color="red">轻量级锁可以和identity hash code共存</font>，哈希码和GC年龄自然保存在此，<strong>释放锁后会将这些信息写回到对象头。</strong></p></li><li><p><font color="cornflowerblue">升级为重量级锁后</font>，Mark Word保存的重量级锁指针，代表<font color="red">重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Word</font>，<strong>锁释放后也会将信息写回到对象头</strong></p></li></ul><p><strong>代码测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">/*//先睡眠5秒，保证开启偏向锁</span></span><br><span class="line"><span class="comment">    try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Object o = new Object();</span></span><br><span class="line"><span class="comment">    System.out.println(&quot;本应是偏向锁&quot;);</span></span><br><span class="line"><span class="comment">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    o.hashCode();//没有重写，一致性哈希，重写后无效,当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    synchronized (o)&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;本应是偏向锁，但是由于计算过一致性哈希，会直接升级为轻量级锁&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先睡眠5秒，保证开启偏向锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        o.hashCode();<span class="comment">//没有重写，一致性哈希，重写后无效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;偏向锁过程中遇到一致性哈希计算请求，立马撤销偏向模式，膨胀为重量级锁&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3种锁小总结"><a href="#3种锁小总结" class="headerlink" title="3种锁小总结"></a>3种锁小总结</h3><p><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719230958459.png" alt="image-20230719230958459"></p><p>synchronized锁升级过程总结：<font color="red">一句话，就是先自旋，不行再阻塞。</font></p><p>实际上是把之前的悲观锁（重量级锁）变成在一定条件下使用偏向锁以及使用轻量级（自旋锁CAS)的形式</p><p>synchronized.在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。</p><p>JDK1.6之前synchronized使用的是重量级锁，<font color="red">JDK1.6之后进行了优化，拥有了无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程，而不是无论什么情况都使用重量级锁。</font></p><p><font color="cornflowerblue">偏向锁</font>：适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法代码块则使用偏向锁。</p><p><font color="cornflowerblue">轻量级锁</font>：适用于竞争较不激烈的情况（这和乐观锁的使用范围类似），存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法&#x2F;代码块执行时间很短的话，采用轻量级锁虽然会占用cu资源但是相对比使用重量级锁还是更高效。</p><p><font color="cornflowerblue">重量级锁</font>：适用于竞争激烈的情况，如果同步方法&#x2F;代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁</p><p><strong>我的理解：</strong></p><ul><li><p>偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（**<font color="red">偏向锁中竞争一次失败后要么无锁，要么轻量锁</font>**）</p><ul><li>偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁</li></ul></li><li><p>如果轻量锁还出现竞争，且自旋达到一定次数后仍然未得到锁，则升级为重量级锁</p></li></ul><h3 id="锁升级总流程图"><a href="#锁升级总流程图" class="headerlink" title="锁升级总流程图"></a>锁升级总流程图</h3><img src="https://www.hahhome.top/blog/JUC06/../../image/JUC06.assets/image-20230719230958460.jpeg" alt="img" style="zoom:150%;"><h2 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h2><p><strong>缩消除（即逃逸分析里的同步省略）</strong></p><p>如下面这段代码：锁加了与没加的作用是一样的，没有任何作用，所以JIT编译器就会替我们无视这把锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;come in synchronized + \t&quot;</span> + o.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(Main::m1,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过JIT编译器优化后的m1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;come in synchronized + \t&quot;</span> + o.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>锁粗化</strong></p><p>假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;222222&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;333333&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;444444&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;222222&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;333333&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;444444&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本章我的所有理解汇总"><a href="#本章我的所有理解汇总" class="headerlink" title="本章我的所有理解汇总"></a>本章我的所有理解汇总</h2><ul><li>JDK5之前，只有重量级锁</li><li>假如锁的竞争比较激烈的话，会导致性能下降</li><li>重量级锁是用户态和内核态之间切换，容易导致阻塞</li><li><font color="red"><strong>所以我们就是为了尽量的减少内核态和用户态之间的切换，减少阻塞</strong></font></li><li></li><li><font color="red">即通过对象头中的对象标记MarkWord来标记锁的信息</font><ul><li>偏行锁MarkWord指向的是偏向线程ID</li><li>轻量级锁MarkWord指向的是原MarkWord的拷贝LocalRecord</li><li>重量级锁MarkWord指向的是ObjectMonitor对象的地址</li></ul></li><li>每个Java对象都可以成为一把锁，天生自带内部锁或者叫Monitor锁</li><li><font color="red">Monitor的本质是<strong>依赖于底层操作系统的Mutex Lock（系统互斥量）</strong>实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font></li><li>Monitor是由ObjectMonitor实现的，<font color="cornflowerblue">ObjectMonitor中的属性对应着对象头MarkWord中的部分信息</font></li><li>Monitor即重量级锁，即synchronized                  <font color="red"> Monitor       &lt;&#x3D; &#x3D;&gt;       重量级锁        &lt;&#x3D; &#x3D;&gt; 重量级synchronized</font></li><li></li><li>偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（**<font color="red">偏向锁中竞争一次失败后要么无锁，要么轻量级锁</font>**）<ul><li>偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁</li></ul></li><li>如果轻量锁还出现竞争，且自旋达到一定次数后仍然未得到锁，则升级为重量级锁</li><li></li><li><font color="cornflowerblue">已求过hashCode</font>，直接升级为轻量级锁</li><li><font color="cornflowerblue">偏行锁时求hashCode</font>，直接升级为重量级锁</li><li></li><li>只有偏向锁是出现竞争才释放锁，<font color="red">轻量级锁和重量级锁都是用完锁就释放，释放锁时会将MarkWord信息写回对象头</font></li></ul><p><font color="red"><strong>所有理解只是概念性总结，详细还得去上面看</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC05</title>
      <link href="/blog/JUC05/"/>
      <url>/blog/JUC05/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC05"><a href="#JUC05" class="headerlink" title="JUC05"></a>JUC05</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li><p>ThreadLocal</p><ul><li><font color="red">ThreadLocal底层与Thead、ThreadLocalMap之间的关系</font></li></ul></li><li><p>内存布局</p></li></ul><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="定义和作用"><a href="#定义和作用" class="headerlink" title="定义和作用"></a>定义和作用</h2><p><strong>是什么？</strong></p><p>ThreadLocal提供线程局部变量。这些变量<font color="red">与正常的变量不同</font>，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）<font color="red">都有自己的、独立初始化的变量副本</font>。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务D)与线程关联起来。</p><p><strong>能干嘛？</strong></p><p>实现<font color="red"><strong>每一个线程都有自己专属的独立初始化的本地变量副本</strong></font>（自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份）：</p><p><font color="cornflowerblue">主要解决了让每个线程绑定自己的值</font>，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值<font color="red">从而避免了线程安全问题</font>，比如我们之前讲解的8锁案例，资源类是使用同一部手机，多个线程抢夺同一部手机使用，假如人手一份是不是天下太平？？</p><p>我的理解：</p><ul><li>不是前面JMM中的本地内存，前面的本地内存是共享主内存中的拷贝，这里的是每个线程独有的一份不一致的变量，不是拷贝来的副本，是本来就是自己的</li></ul><p><strong>常用API</strong></p><ul><li><p>protected T initialValue()</p><ul><li><p>返回此线程局部变量的当前线程的“初始值”。</p></li><li><p>不推荐使用这个方法初始化，因为要使用匿名内部类的方式重写此方法</p></li><li><pre><code class="java">ThreadLocal&lt;Integer&gt; saleVolume = new ThreadLocal&lt;Integer&gt;()&#123;    @Override    protected Integer initialValue() &#123;        return 0;    &#125;&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- static &lt; S&gt; ThreadLocal&lt; S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</span><br><span class="line"></span><br><span class="line">  - 创建一个线程局部变量。</span><br><span class="line"></span><br><span class="line">  - 推荐使用此方法初始化，jdk1.8新增的静态方法，可使用函数式接口</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    ThreadLocal&lt;Integer&gt; saleVolume = ThreadLocal.withInitial(() -&gt; 0);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>T get()</p><ul><li>返回当前线程的此线程局部变量副本中的值。</li></ul></li><li><p>void remove()</p><ul><li>删除此线程局部变量的当前线程值。</li></ul></li><li><p>void set(T value)</p><ul><li>将此线程局部变量的当前线程副本设置为指定值。</li></ul></li></ul><h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><blockquote><p>6【强制】<strong>必须回收自定义的ThreadLocal变量</strong>，尤其在<font color="red">线程池场景下，线程经常会被复用</font>，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和<font color="red">造成内存泄露等</font>问题。尽量在代理中使用try-finally块进行回收。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objectThreadLocal.set(userlnfo);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">objectThreadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><font color="red">按照阿里开发手册，我们要养成习惯，必须在finally中回收remove掉threadLocal变量</font></p><h3 id="使用场景案例："><a href="#使用场景案例：" class="headerlink" title="使用场景案例："></a>使用场景案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求1： 5个销售卖房子，集团高层只关心销售总量的准确统计数。</span></span><br><span class="line"><span class="comment"> * 需求2： 5个销售卖完随机数房子，各自独立销售额度，自己业绩按提成走，分灶吃饭，各个销售自己动手，丰衣足食</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">saleCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需求1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        ++saleCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需求2</span></span><br><span class="line">    <span class="comment">//初始化方法1，非常不方便</span></span><br><span class="line">    <span class="comment">/*ThreadLocal&lt;Integer&gt; saleVolume = new ThreadLocal&lt;Integer&gt;()&#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        protected Integer initialValue() &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化方法2，推荐</span></span><br><span class="line">    ThreadLocal&lt;Integer&gt; saleVolume = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleVolumeByThreadLocal</span><span class="params">()</span>&#123;</span><br><span class="line">        saleVolume.set(<span class="number">1</span> + saleVolume.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= size ; j++) &#123;</span><br><span class="line">                        house.saleHouse();</span><br><span class="line">                        house.saleVolumeByThreadLocal();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;号销售卖出：&quot;</span>+house.saleVolume.get());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    house.saleVolume.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;共计卖出多少套： &quot;</span>+house.saleCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遵守阿里规范案例："><a href="#遵守阿里规范案例：" class="headerlink" title="遵守阿里规范案例："></a>遵守阿里规范案例：</h3><p>使用线程池的时候，会复用线程池中的线程，于是第二次调用ThreadLocal变量的时候，将会从之前调用过的基础上进行相加，所以每次调用线程池后都应该remove掉该线程加上的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【强制】必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理</span></span><br><span class="line"><span class="comment"> * 自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用</span></span><br><span class="line"><span class="comment"> * try-finally 块进行回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        threadLocal.set(<span class="number">1</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">beforeInt</span> <span class="operator">=</span> myData.threadLocal.get();</span><br><span class="line">                        myData.add();</span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">afterInt</span> <span class="operator">=</span> myData.threadLocal.get();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;beforeInt:&quot;</span>+beforeInt+<span class="string">&quot;\t afterInt: &quot;</span>+afterInt);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        myData.threadLocal.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><ul><li><p>加上remove</p></li><li><pre><code>pool-1-thread-3beforeInt:0 afterInt: 1pool-1-thread-1beforeInt:0 afterInt: 1pool-1-thread-2beforeInt:0 afterInt: 1pool-1-thread-3beforeInt:0 afterInt: 1pool-1-thread-2beforeInt:0 afterInt: 1pool-1-thread-1beforeInt:0 afterInt: 1pool-1-thread-1beforeInt:0 afterInt: 1pool-1-thread-3beforeInt:0 afterInt: 1pool-1-thread-2beforeInt:0 afterInt: 1pool-1-thread-1beforeInt:0 afterInt: 1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 未加remove</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  pool-1-thread-1beforeInt:0 afterInt: 1</span><br><span class="line">  pool-1-thread-3beforeInt:0 afterInt: 1</span><br><span class="line">  pool-1-thread-2beforeInt:0 afterInt: 1</span><br><span class="line">  pool-1-thread-1beforeInt:1 afterInt: 2</span><br><span class="line">  pool-1-thread-2beforeInt:1 afterInt: 2</span><br><span class="line">  pool-1-thread-3beforeInt:1 afterInt: 2</span><br><span class="line">  pool-1-thread-1beforeInt:2 afterInt: 3</span><br><span class="line">  pool-1-thread-1beforeInt:3 afterInt: 4</span><br><span class="line">  pool-1-thread-3beforeInt:2 afterInt: 3</span><br><span class="line">  pool-1-thread-2beforeInt:2 afterInt: 3</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="&#x3D;&#x3D;ThreadLocal源码分析&#x3D;&#x3D;"></a>&#x3D;&#x3D;ThreadLocal源码分析&#x3D;&#x3D;</h2><h3 id="Thread、ThreadLocal、ThreadLocalMap这三个类之间的关系？"><a href="#Thread、ThreadLocal、ThreadLocalMap这三个类之间的关系？" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap这三个类之间的关系？"></a>Thread、ThreadLocal、ThreadLocalMap这三个类之间的关系？</h3><ul><li>Thread类中包含一条属性是ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</li><li>然后ThreadLocalMap是ThreadLocal中的一个静态内部类</li><li>threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t,T firstvalue)</span>&#123;</span><br><span class="line">t.threadLocals <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</p><p><strong>近似的可以理解为：</strong></p><p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key),不过是经过了两层包装的ThreadLocal对象：</p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718162024396.png" alt="image-20230718162024396"></p><p><font color="red">JVM内部维护了一个线程版的Map&lt;ThreadLocal, Value&gt;</font>(<font color="cornflowerblue">通过ThreadLocalx对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中</font>)，每个线程要用到这个T的时候，用当前的线程去Map里面获取，<font color="red">通过这样让每个线程都拥有了自己独立的变量</font>，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p><p>自己的理解：</p><ul><li>一个线程可能有多个线程局部变量，就放在entry中，key为当前threadLocal实例，value为值</li><li>即同一个线程多个ThreadLocal 都是保存到同一个ThreadLocalMap里面</li></ul><h3 id="ThreadLocal为什么使用弱引用？为什么还会内存泄露？"><a href="#ThreadLocal为什么使用弱引用？为什么还会内存泄露？" class="headerlink" title="ThreadLocal为什么使用弱引用？为什么还会内存泄露？"></a>ThreadLocal为什么使用弱引用？为什么还会内存泄露？</h3><p><font color="cornflowerblue"><strong>ThreadLocalMap与WeakReference</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map（以ThreadLocal为Key），不过是经过了两层包装的ThreadLocal对象</p><ul><li><p>(1)第一层包装是使用WeakReference&lt;ThreadLocal&lt;?&gt;&gt;将ThreadLocal对象变成一个弱引用的对象</p></li><li><p>(2)第二层包装是定义了一个专门的类Entry来扩展WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</p></li></ul><p>ThreadLocal是一个壳子，真正的存储结构是ThreadLocal里有ThreadLocalMap.这么个内部类，每个Thread对象维护着一个ThreadLocalMap的引用，ThreadLocalMap是ThreadLocalf的内部类，用Entry来进行存储。</p><ul><li>1)调用ThreadLocalf的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象</li><li>2)调用ThreadLocalf的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li></ul><p>ThreadLocal本身并不存储值(ThreadLocal是一个壳子)，它只是自己作为一个key来让线程从ThreadLocalMap获取vaue。</p><p>正因为这个原理，所以ThreadLocali能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响</p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718171703585.png" alt="image-20230718171703585"></p><p><font color="cornflowerblue">为什么源代码用弱引用？</font></p><p>当functione01方法执行完毕后，栈帧销毁强引用t!也就没有了。但此时线程的ThreadLocalMap.里某个entry的key引用还指向这个对象</p><ul><li>若这个key引用是<font color="cornflowerblue">强引用</font>，就会导致key指向的ThreadLocal对象及v指向的对象不能被gc回收，造成内存泄漏；</li><li>若这个key引用是<font color="cornflowerblue">弱引用</font>，就<font color="red">大概率</font>会减少内存泄漏的问题（<font color="red">还有一个key为null的雷，第2个坑后面讲</font>）。</li></ul><p>使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的<font color="red">key引用指向为null</font>。</p><p>当前栈帧出栈，当前栈帧对应的threadlocal对象也应当被销毁，如果是强引用，该threadlocal对象就不会被回收，从而发生内存泄漏</p><p><font color="cornflowerblue">使用弱引用为什么还会内存泄露？</font></p><ul><li>1当我们为threadLocal变量赋值，实际上就是当前的Entry（threadLocal实例为key，值为value）往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null（tl&#x3D;null），那么系统GC的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收。这样一来，<font color="red">ThreadLocalMap中就会出现key为null的Entry，<strong>就没有办法访问这些key为nul的Entry的value</strong>。</font><ul><li><font color="red">如果当前线程再迟迟不结束的话（比如正好在使用<strong>线程池</strong>），这些key为null的Entry的value就会一直存在一条强引用链：   Thread Ref-&gt;Thread-&gt;ThreaLocalMap-&gt;Entry-&gt;value永远无法回收，造成内存泄漏。</font></li></ul></li><li>2当然，<strong>如果当前thread运行结束</strong>，threadLocal,threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。</li><li>3但在实际使用中<font color="cornflowerblue">我们有时候会用线程池</font>去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们小心</li></ul><p>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，<font color="red">因此弱引用不能100%保证内存不泄露</font>。<font color="red"><strong>我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它</strong></font>，尤其是在线程池中，不仅仅是内存泄露的问题，<font color="cornflowerblue">因为线程池中的线程是重复使用的</font>，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug</p><p>（对应阿里开发手册要求必须调用remove方法）</p><p>线程池线程复用调用get、set方法可能复用key为null的entry对象，所以需要手动执行remove</p><h2 id="ThreadLocal小总结"><a href="#ThreadLocal小总结" class="headerlink" title="ThreadLocal小总结"></a>ThreadLocal小总结</h2><ul><li><p>记得初始化ThreadLocal，使用ThreadLocal.withInitial(() -&gt; 0);</p></li><li><p>建议把ThreadLocal设置为static，只是建议</p><ul><li><blockquote><p>19.【参考】ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题。说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操控这个变量。</p><p>ThreadLocali能实现了线程的数据隔离，不在于它自己本身，而在于Thread的ThreadLocalMap<br>所以，ThreadLocal可以只初始化一次，只分配一块存储空间就足以了，没必要作为成员变量多次被初始化。</p></blockquote></li></ul></li><li><p><font color="red">用完记得手动remove</font></p><ul><li><blockquote><p>6【强制】<strong>必须回收自定义的ThreadLocal变量</strong>，尤其在<font color="red">线程池场景下，线程经常会被复用</font>，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和<font color="red">造成内存泄露等</font>问题。尽量在代理中使用try-finally块进行回收。</p></blockquote></li></ul></li></ul><h2 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h2><ul><li>ThreadLocal中ThreadLocalMap的数据结构和关系？<ul><li>ThreadLocalMap是ThreadLocal的一个静态内部类，threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。不过是经过了两层包装的ThreadLocal对象<ul><li>(1)第一层包装是使用WeakReference&lt;ThreadLocal&lt;?&gt;&gt;将ThreadLocal对象变成一个弱引用的对象</li><li>(2)第二层包装是定义了一个专门的类Entry来扩展WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</li></ul></li></ul></li><li>ThreadLocal的key是弱引用，这是为什么？<ul><li>准确的说应该是Entry对象的key为弱引用，因为如果Entry的key是强引用的话，当当前方法的栈帧出栈以后，栈帧对threadLocal实例的强引用解除了，但是仍然有Entry对象的key强引用ThreadLocal实例，导致threadLocal实例不能被回收</li><li>若是使用弱引用，就可以顺利回收掉threadLocal实例对象，但是还需要手动调用remove方法清除key为null的Entry对象和value对象，因为Entry对象的v也有一条强引用链指向value对象，否则线程池中容易线程复用value对象，造成内存泄露</li></ul></li><li>ThreadLocal内存泄露问题你知道吗？<ul><li>Entry对象key为弱引用</li><li>需要手动remove</li></ul></li><li>hreadLocal中最后为什么要加remove方法？<ul><li>用弱引用，就可以顺利回收掉threadLocal实例对象，但是还需要手动调用remove方法清除key为null的Entry对象，因为Entry对象的v也有一条强引用链指向value对象，否则线程池中容易线程复用value对象，造成内存溢出</li></ul></li></ul><h1 id="对象内存布局与对象头"><a href="#对象内存布局与对象头" class="headerlink" title="对象内存布局与对象头"></a>对象内存布局与对象头</h1><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718221207307.png" alt="image-20230718221207307"></p><p>在HotSpot)虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p><ul><li>对象头（Header）<ul><li>对象标记MarkWord（运行时元数据）<ul><li>哈希值（HashCode）</li><li>GC标志</li><li>GC次数</li><li>同步锁标记</li><li>所偏向持有者</li><li>……</li></ul></li><li>类元信息（类型指针）<ul><li>指向方法区中类元数据InstanceKlass，确定该对象所属的类型</li><li><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718221608733.png" alt="image-20230718221608733"></li></ul></li></ul></li><li>实例数据（Instance Data）<ul><li>存放类的属性(Field)数据信息，包括父类的属性信息</li></ul></li><li>对齐填充<ul><li>不是必须的，虚拟机要求对象起始地址必须是<strong>8字节的整数倍</strong>。填充数据不是必须存在的：仅仅是为了字节对齐这部分内存按8字节补充对齐</li></ul></li></ul><h2 id="64位虚拟机MarkWord都存储什么"><a href="#64位虚拟机MarkWord都存储什么" class="headerlink" title="64位虚拟机MarkWord都存储什么"></a>64位虚拟机MarkWord都存储什么</h2><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718221805743.png" alt="image-20230718221805743"></p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718222055954.png" alt="image-20230718222055954"></p><p><font color="cornflowerblue">可以看到，在64位系统中，Mark Word占了8个字节，类型指针占了8个字节（忽略压缩指针），那么整个对象头就占了16个字节</font></p><p><strong>markOop.hpp</strong></p><p>hash: 保存对象的哈希码<br>age: 保存对象的分代年龄<br>biased_lock: 偏向锁标识位<br>lock: 锁状态标识位<br>JavaThread* :保存持有偏向锁的线程ID<br>epoch: 保存偏向时间戳</p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718222331258.png" alt="image-20230718222331258"></p><h2 id="对象头以及对象大小计算"><a href="#对象头以及对象大小计算" class="headerlink" title="对象头以及对象大小计算"></a>对象头以及对象大小计算</h2><p>虚拟机要求对象起始地址必须是<strong>8字节的整数倍</strong></p><p>在上面图中可以找到：<font color="cornflowerblue">在64位系统中，Mark Word占了8个字节，类型指针占了8个字节（忽略压缩指针），那么整个对象头就占了16个字节</font></p><p>我们先简单估算一下下面这个类的对象大小：</p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718222531441.png" alt="image-20230718222531441"></p><p>应该是有24个字节的</p><ul><li>对象头为 8+8&#x3D;16字节</li><li>int类型32位4个字节，boolean类型8位1个字节</li><li>对齐填充为8的倍数，3个字节</li></ul><p><strong>代码演示</strong></p><p>我们要用到一个工具JOL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">JAVA object layout</span></span><br><span class="line"><span class="comment">官网:http://openjdk.java.net/projects/code-tools/jol/</span></span><br><span class="line"><span class="comment">定位:分析对象在JVM的大小和分布</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简单演示JOL的使用：</p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718222857403.png" alt="image-20230718222857403"></p><p>测试中打印数据可参数的解释：</p><table><thead><tr><th>OFFSET</th><th>偏移量，也就是到这个字段位置所占用的byte数</th></tr></thead><tbody><tr><td>SIZE</td><td>后面类型的字节大小</td></tr><tr><td>TYPE</td><td>是Class中定义的类型</td></tr><tr><td>DESCRIPTION</td><td>DESCRIPTION是类型的描述</td></tr><tr><td>VALUE</td><td>VALUE是TYPE在内存中的值</td></tr></tbody></table><p>测试new一个Object类：</p><p>可以看到最终大小是 8字节MarkWord + 4字节类型指针（因为指针压缩）+ 2字节对齐填充 &#x3D; 16字节（8的倍数）</p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718223059912.png" alt="image-20230718223059912"></p><p>测试一个自己写的Customer类：</p><p>可以看到最终大小是 8字节MarkWord + 4字节类型指针（因为指针压缩）+ 4字节int + 1字节boolean + 7字节对齐填充 &#x3D; 24字节（8的倍数）</p><p><img src="https://www.hahhome.top/blog/JUC05/../../image/JUC05.assets/image-20230718223326681.png" alt="image-20230718223326681"></p><h2 id="GC分代年龄测试和指针压缩"><a href="#GC分代年龄测试和指针压缩" class="headerlink" title="GC分代年龄测试和指针压缩"></a>GC分代年龄测试和指针压缩</h2><p>在64位虚拟机MarkWord存储表中可以看到：<font color="red">GC年龄采用4位bit存储，最大为15</font>，例如MaxTenuringThreshold参数默认值就是15</p><p>如果设置参数-XX:MaxTenuringThreshold&#x3D;16的话，将会报异常</p><p><strong>指针压缩</strong></p><ul><li>虚拟机默认开启了指针压缩，将类型指针的大小从8字节压缩为4字节，对应虚拟机参数：-XX:+UseCmopressedClassPointers</li><li>可使用参数：-XX:+PrintCommandLineFlags打印虚拟机使用到的所有参数，查看对应压缩指针的参数是否被使用</li><li>若手动关闭指针压缩：-XX:-UseCmopressedClassPointers</li><li>那么再次使用JOL测试将会发现类型指针为8个字节</li></ul><h2 id="一些面试题-1"><a href="#一些面试题-1" class="headerlink" title="一些面试题"></a>一些面试题</h2><p>12、你觉得目前面试，你还有那些方面理解的比较好，我没问到的，我说了juc和jvm以及同步锁机制<br>13、那先说juc吧，说下aqs的大致流程<br>14、cas自旋锁，是获取不到锁就一直自旋吗？cas和synchronized区别在哪里，为什么cas好，具体优势在哪里，我说cas避免cpu切换线程的开销，又问我在自旋的这个线程能保证一直占用cpu吗？假如cpu放弃这个线程，不是还要带来线程再次抢占cpu的开销？<br>15、synchronized底层如何实现的，实现同步的时候用到cas了吗？具体哪里用到了<br>16、我说上个问题的时候说到了对象头，问我对象头存储哪些信息，长度是多少位存储</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC04</title>
      <link href="/blog/JUC04/"/>
      <url>/blog/JUC04/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC04"><a href="#JUC04" class="headerlink" title="JUC04"></a>JUC04</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li>CAS自旋<ul><li><font color="red">CAS自旋锁</font></li><li><font color="red">ABA问题及解决办法</font></li></ul></li><li>18大原子类<ul><li><font color="red">原子增强类以及它为什么快</font></li></ul></li></ul><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="CAS原理简介"><a href="#CAS原理简介" class="headerlink" title="CAS原理简介"></a>CAS原理简介</h2><h3 id="CAS发展："><a href="#CAS发展：" class="headerlink" title="CAS发展："></a>CAS发展：</h3><p>java.util.concurrent.atomic包下的类是使用CAS+自旋实现的</p><ul><li>没有CAS之前：多线程环境不使用原子类保证线程安全++（基本数据类型）<ul><li>使用synchronized或lock（都是悲观锁）</li></ul></li><li>使用CAS之后：多线程环境    使用原子类保证线程安全++（基本数据类型）<ul><li>类似于<font color="red">乐观锁</font>，比较后不对再次尝试</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//利用volatile保证读取操作的可见性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;</span><br><span class="line">    value++;<span class="comment">//利用synchronized保证复合操作的原子性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------CAS----------------------</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();<span class="comment">//默认0开始</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;</span><br><span class="line">    atomicInteger.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要使用辅助类CountDownLatch来保证线程计算完毕才获取计算结果</span></span><br><span class="line"><span class="comment">//完整案例查看原子类部分的基本类型原子类中的使用案例</span></span><br></pre></td></tr></table></figure><h3 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h3><p>compare and swap的缩写，中文翻译成<font color="red">比较并交换</font>，实现并发算法时常用到的一种技术</p><p>它包含三个操作数一一位置内存值、预期原值及更新值。</p><p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p><ul><li>如果<font color="red">相匹配</font>，那么处理器会自动将该位置值更新为新值，</li><li>如果<font color="red">不匹配</font>，处理器不做任何操作，多个线程同时执行CAS操作<font color="red">只有一个会成功</font>。</li></ul><h3 id="CAS原理："><a href="#CAS原理：" class="headerlink" title="CAS原理："></a>CAS原理：</h3><p>CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。</p><p><font color="cornflowerblue">当且仅当旧的预期值A和内存值V相同时</font>，将内存值V修改为B,否则什么都不做或重来</p><p><font color="red">当它重来重试的这种行为称为-自旋！！</font></p><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230716172303473.png" alt="image-20230716172303473"></p><p><strong>代码举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">2023</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());</span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">2023</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true2023</span><br><span class="line">false2023</span><br></pre></td></tr></table></figure><h3 id="CAS优点："><a href="#CAS优点：" class="headerlink" title="CAS优点："></a>CAS优点：</h3><p>CAS是JDK提供的<font color="cornflowerblue">非阻塞</font>原子性操作，它通过<font color="cornflowerblue">硬件保证</font>了比较-更新的原子性。</p><p>它是非阻塞的且自身具有原子性，也就是说这玩意<strong>效率更高且通过硬件保证，说明这玩意更可靠</strong>。</p><p>CAS是一条CPU的原子指令<font color="red">(cmpxchg指令</font>)，不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX)底层实现即为CPU指令cmpxchg。</p><p>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，<font color="red">也就是说CAS的原子性实际上是<strong>CPU实现独占的</strong></font>，比起用synchronized重量级锁，这里的<font color="cornflowerblue">排他时间要短很多</font>，所以在多线程情况下<strong>性能会比较好</strong>。</p><h2 id="CAS底层实现-引出Unsafe类"><a href="#CAS底层实现-引出Unsafe类" class="headerlink" title="CAS底层实现-引出Unsafe类"></a>CAS底层实现-引出Unsafe类</h2><p><strong>compareAndSet()方法底层源码：</strong></p><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230716194303644.png" alt="image-20230716194303644"></p><ul><li><p><strong>1 Unsafe：</strong></p><ul><li>是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。<font color="red">Unsafe类存在于sun.misc</font>包中，其内部方法操作可以像C的<font color="red">指针</font>一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</li><li><font color="red">注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接湖用操作系统底层资源执行相应任务</font></li></ul></li><li><p><strong>2 变量valueOffset：</strong></p><ul><li>表示该变量值在内存中的<strong>偏移地址</strong>，因为Unsafe就是根据内存偏移地址获取数据的。</li></ul></li><li><p>3 <strong>变量value</strong>用volatile修饰，保证了多线程之间的内存可见性。</p></li></ul><p><strong>我们知道i++线程不安全的，那atomiclnteger.getAndIncrement()是如何实现的？</strong></p><p>AtomicInteger类主要利用<strong>CAS</strong>(compare and swap)+<strong>volatile</strong>和<strong>native</strong>方法来保证原子操作，从而避免synchronized的高开销，执行效率大为提升。</p><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230716200611011.png" alt="image-20230716200611011"></p><p>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出<font color="cornflowerblue">CAS汇编指令</font>。这是一种完全依赖于<font color="red">硬件</font>的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，<font color="red">并且原语的执行必须<strong>是连续的</strong>，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</font></p><h2 id="CAS自旋实现个人总结"><a href="#CAS自旋实现个人总结" class="headerlink" title="&#x3D;&#x3D;CAS自旋实现个人总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;CAS自旋实现个人总结&#x3D;&#x3D;</h2><p>即上面所有内容的简洁版（面试版）</p><ul><li>CAS是从<strong>硬件</strong>提升效率，最底层是交给硬件和volatile来保证原子性（CPU独占）和可见性（volatile）</li><li>底层是基于<strong>Unsafe</strong>类，实现方式是基于硬件平台的汇编指令，在intel的CPU中（X86机器上），使用的汇编指令是<strong>cmpxchg</strong>指令</li><li>核心思想就是：比较要更新变量的值V和预期值E(compare)，相等才会将V的值设为新值N(swap)，如果不相等自旋再来。</li><li><strong>原子性是一个CPU独占的实现的</strong>，但多个CPU的多个线程依旧会发生线程安全问题</li></ul><h2 id="AtomicReference原子引用"><a href="#AtomicReference原子引用" class="headerlink" title="AtomicReference原子引用"></a>AtomicReference原子引用</h2><p>java.util.concurrent.atomic包下抓门用来处理<strong>自写类</strong>的一个原子类</p><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">li4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;li4&quot;</span>,<span class="number">28</span>);</span><br><span class="line">        </span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3,li4) + <span class="string">&quot;\t&quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS自旋锁（手写）"><a href="#CAS自旋锁（手写）" class="headerlink" title="&#x3D;&#x3D;CAS自旋锁（手写）&#x3D;&#x3D;"></a>&#x3D;&#x3D;CAS自旋锁（手写）&#x3D;&#x3D;</h2><p><font color="cornflowerblue">自旋锁(spinlock)</font></p><p>CAS是实现自旋锁的基础，CAS利用CPU指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转。是指尝试获取锁的线程不会立即阻塞，而是<font color="red">采用<strong>循环的方式</strong>去尝试获取锁</font>，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的<font color="cornflowerblue"><strong>好处</strong>是减少线程上下文切换的消耗，<strong>缺点</strong>是循环会消耗CPU</font></p><p><strong>所以CAS类似于乐观锁，适用于读取多的场景，悲观锁适用于写多的场景</strong></p><p><font color="cornflowerblue">OpenJDK源码里面查看下Unsafe.java</font></p><p>CAS是实现自旋锁的基础，自旋翻译成人话就是循环，一般是用一个无限循环实现。这样一来，一个无限循环中，执行一个CAS操作，</p><ul><li>当操作成功返回true时，循环结束；</li><li>当返回false时，接着执行循环，继续尝试CAS操作，直到返回true。</li></ul><p><strong>底层getAndAddInt方法自旋实现源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>自写自旋锁</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自写一个自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>,thread))&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-------lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(thread,<span class="literal">null</span>))&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---------task over  ,unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">lockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lockDemo.lock();</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            lockDemo.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//暂停500ms，让线程A先启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lockDemo.lock();</span><br><span class="line">            </span><br><span class="line">            lockDemo.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A------come in</span><br><span class="line">A-------lock</span><br><span class="line">B------come in</span><br><span class="line">A---------task over  ,unlock</span><br><span class="line">B-------lock</span><br><span class="line">B---------task over  ,unlock</span><br></pre></td></tr></table></figure><h2 id="CAS两大缺点："><a href="#CAS两大缺点：" class="headerlink" title="CAS两大缺点："></a>CAS两大缺点：</h2><ul><li><p>循环时间开销很大</p></li><li><p>CAS会导致”ABA问题”</p><ul><li><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个<font color="red">时间差</font>类会导致数据的变化。</p></li><li><p>比如说一个线程1从内存位置V中取出A,这时候另一个线程2也从内存中取出A,并且线程2进行了一些操作将值变成了B,然后线程2又将V位置的数据变成A,这时候线程1进行CAS操作发现内存中仍然是A,预期OK,然后线程1操作成功。</p></li><li><p><font color="red">尽管线程1的CAS操作成功，但是不代表这个过程就是没有问题的。</font></p></li></ul></li></ul><p>ABA 问题的案例以及解决方法：看AtomicStampedReference</p><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><p>在普通自旋的基础上再加上一个版本号的判断</p><ul><li>若版本号也一致，修改成功</li><li>若版本号不一致，修改失败，继续自旋</li></ul><h3 id="单线程普通使用案例"><a href="#单线程普通使用案例" class="headerlink" title="单线程普通使用案例"></a>单线程普通使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String bookName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">javaBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>,<span class="string">&quot;javaBook&quot;</span>);</span><br><span class="line">        AtomicStampedReference&lt;Book&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(javaBook,<span class="number">1</span>);</span><br><span class="line">        System.out.println(stampedReference.getReference() + <span class="string">&quot;\t&quot;</span> + stampedReference.getStamp());</span><br><span class="line">        </span><br><span class="line">        <span class="type">Book</span> <span class="variable">mysqlBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2</span>,<span class="string">&quot;mysqlBook&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        b = stampedReference.compareAndSet(javaBook,mysqlBook,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(b + <span class="string">&quot;\t&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t&quot;</span> + stampedReference.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程ABA问题演示及解决案例"><a href="#多线程ABA问题演示及解决案例" class="headerlink" title="&#x3D;&#x3D;多线程ABA问题演示及解决案例&#x3D;&#x3D;"></a>&#x3D;&#x3D;多线程ABA问题演示及解决案例&#x3D;&#x3D;</h3><p><strong>ABA问题案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ABA问题的发生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">abaHappen</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//等待ABA问题的发生</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">2022</span>)+<span class="string">&quot;\t&quot;</span>+atomicInteger.get());</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决ABA问题演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用AtomicStampedReference可以避免ABA问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;首次版本号：&quot;</span>+stamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停500毫秒,保证后面的t4线程初始化拿到的版本号和我一样</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        </span><br><span class="line">        stampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,stampedReference.getStamp(),stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;2次流水号：&quot;</span>+stampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        stampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,stampedReference.getStamp(),stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;3次流水号：&quot;</span>+stampedReference.getStamp());</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停1秒钟线程,等待上面的t3线程，发生了ABA问题</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>,<span class="number">2023</span>,stamp,stamp + <span class="number">1</span>);</span><br><span class="line">        System.out.println(b+<span class="string">&quot;\t&quot;</span>+stampedReference.getReference()+<span class="string">&quot;\t&quot;</span>+stampedReference.getStamp());</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18大原子类"><a href="#18大原子类" class="headerlink" title="18大原子类"></a>18大原子类</h1><p>介绍位于java.util.concurrent.atomic包下的所有类</p><p>原子类使用的原理是CAS自旋</p><h2 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h2><p><strong>包含</strong></p><ul><li>AtomicInteger</li><li>AtomicBoolean</li><li>AtomicLong</li></ul><p><strong>常用API</strong></p><ul><li>public final int get()&#x2F;&#x2F;获取当前的值</li><li>public final int getAndSet(int newValue)&#x2F;&#x2F;获取当前的值，并设置新的值</li><li>public final int getAndIncrement()&#x2F;&#x2F;获取当前的值，并自增</li><li>public final int getAndDecrement()&#x2F;&#x2F;获取当前的值，并自减</li><li>public final int getAndAdd(int delta)&#x2F;&#x2F;获取当前的值，并加上预期的值</li><li>boolean compareAndSet(int expect,int update)&#x2F;&#x2F;如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</li></ul><p><strong>案例：</strong></p><p>注意：不能直接在主线程中获取计算结果，否则可能前面线程还没计算完成就打印出结果了</p><p><font color="red">需要使用辅助类CountDownLatch来阻塞线程</font></p><p>开发中不能使用等待几秒的方式，因为等待时间不准确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPlusPlus</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        myNumber.setPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞2秒等待计算完成，可是并不知道具体等待时间</span></span><br><span class="line"><span class="comment">//        try &#123;TimeUnit.SECONDS.sleep(2);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//阻塞等待前面线程已经计算完成</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t result : &quot;</span> + myNumber.atomicInteger.get());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h2><p><strong>包含</strong></p><ul><li>AtomicIntegetArray</li><li>AtomicBooleanArray</li><li>AtomicReferenceArray</li></ul><p><strong>常用API</strong></p><ul><li>public final int get(int offset)&#x2F;&#x2F;获取当前的值</li><li>public final int getAndSet(int offset, int newValue)&#x2F;&#x2F;获取当前的值，并设置新的值</li><li>public final int getAndIncrement(int offset)&#x2F;&#x2F;获取当前的值，并自增</li><li>public final int getAndDecrement(int offset)&#x2F;&#x2F;获取当前的值，并自减</li><li>public final int getAndAdd(int offset, int delta)&#x2F;&#x2F;获取当前的值，并加上预期的值</li><li>boolean compareAndSet(int offset, int expect,int update)&#x2F;&#x2F;如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</li></ul><h2 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h2><ul><li>AtomicReference</li><li>AtomicStampedReference<ul><li>前面CAS解决ABA问题使用过</li><li>加上的是版本号version</li><li>解决修改过几次</li></ul></li><li>AtomicMarkableReference<ul><li>加上的是标记为mark</li><li>一次性使用，若被修改过，则版本号不对，修改失败</li><li>解决是否被修改过</li></ul></li></ul><p><strong>AtomicMarkableReference使用案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicMarkableReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicMarkableReference&lt;Integer&gt; markableReference = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="number">100</span>,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + markableReference.isMarked());</span><br><span class="line">            <span class="comment">//保证t2线程也拿到和我相同的mark值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            markableReference.compareAndSet(<span class="number">100</span>,<span class="number">1000</span>,markableReference.isMarked(),!markableReference.isMarked());</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + markableReference.isMarked());</span><br><span class="line">            <span class="comment">//保证t1先修改</span></span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> markableReference.compareAndSet(<span class="number">100</span>,<span class="number">2000</span>,markableReference.isMarked(),!markableReference.isMarked());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改结果：&quot;</span> + b);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + markableReference.isMarked());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + markableReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性修改原子类"><a href="#属性修改原子类" class="headerlink" title="属性修改原子类"></a>属性修改原子类</h2><ul><li>AtomicIntegerFieldUpdater<ul><li>原子更新对象中int类型字段的值</li></ul></li><li>AtomicLongFieldUpdater<ul><li>原子更新对象中Long类型字段的值</li></ul></li><li>AtomicReferenceFieldUpdater<ul><li>原子更新引用类型字段的值</li></ul></li></ul><p><font color="red">使用目的：以一种线程安全的方式操作非线程安全对象内的某些字段</font></p><ul><li>并不是整个对象都需要原子操作，可能只是其中的某一个字段需要保证线程安全</li><li>所以采用更细粒度的方式，只对某个对象的需要线程安全的某些字段进行操作</li></ul><p><font color="red">使用要求：</font></p><ul><li>更新的对象属性必须使用public <strong>volatile</strong>修饰符。</li><li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类的字段</li></ul><blockquote><p>volatile使用场景：AtomicReferenceFieldUpdater、双端锁</p></blockquote><h3 id="AtomicIntegerFieldUpdater使用案例"><a href="#AtomicIntegerFieldUpdater使用案例" class="headerlink" title="AtomicIntegerFieldUpdater使用案例"></a>AtomicIntegerFieldUpdater使用案例</h3><p>i++案例到目前一共有四种实现方式：（后面还有两种）</p><p>按照学习先后顺序：</p><ul><li>synchronized或lock重量级锁保证符合操作的原子性</li><li>volatile写锁策略，只有写操作才加锁（只能是一写），多写时需要用上面或下面两种</li><li>AtomicInteger原子类</li><li>AtomicIntegerFieldUpdater属性修改器</li></ul><p>这里演示第一种和第四种，第四种和第三种差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> * 10个线程，</span></span><br><span class="line"><span class="comment"> * 每个线程转账1000，</span></span><br><span class="line"><span class="comment"> * 不使用synchronized,尝试使用AtomicIntegerFieldUpdater来实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">bankName</span> <span class="operator">=</span> <span class="string">&quot;CCB&quot;</span>;</span><br><span class="line"><span class="comment">//    int money = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//AtomicIntegerFieldUpdater更新的对象属性必须使用 public volatile 修饰符。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通synchronize方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        money++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</span></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;BankAccount&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,<span class="string">&quot;money&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不加synchronized，保证高性能原子性，局部微创小手术</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        fieldUpdater.getAndIncrement(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">BankAccount</span> <span class="variable">bankAccount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">//bankAccount.add();</span></span><br><span class="line">                        bankAccount.transMoney();      <span class="comment">//使用属性修改器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tresult: &quot;</span> + bankAccount.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicReferenceFieldUpdater使用案例"><a href="#AtomicReferenceFieldUpdater使用案例" class="headerlink" title="AtomicReferenceFieldUpdater使用案例"></a>AtomicReferenceFieldUpdater使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统初始化案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVar</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">isInit</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">    </span><br><span class="line">    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; fieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,<span class="string">&quot;isInit&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fieldUpdater.compareAndSet(<span class="built_in">this</span>,Boolean.FALSE,Boolean.TRUE))&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t------------start init,needs 2 seconds&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t------------init over&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t----------- already have other thread is initing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceFieldUpdaterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">sa</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(myVar::init,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子操作增强类"><a href="#原子操作增强类" class="headerlink" title="&#x3D;&#x3D;原子操作增强类&#x3D;&#x3D;"></a>&#x3D;&#x3D;原子操作增强类&#x3D;&#x3D;</h2><p><strong>包含两种四个</strong></p><ul><li><font color="red">DoubleAccumulator</font></li><li><font color="cornflowerblue">DoubleAdder</font></li><li><font color="red">LongAccumulator</font></li><li><font color="cornflowerblue">LongAdder</font></li></ul><p><strong>LongAdder常用API</strong></p><ul><li>void add(long x)<ul><li>将当前的value加x</li></ul></li><li>void increment(<ul><li>将当前的value加1</li></ul></li><li>void decrement()<ul><li>将当前的value减1</li></ul></li><li>long sum()<ul><li><font color="red">返回当前值。待别注意，在没有并发更新value的情况下，sum会返回一个精确值，在存在并发的情况下，sum不保证返回精确值</font></li></ul></li><li>void reset()<ul><li>将value重置为0，可用于替代重新new一个LongAdder，但此方法只可以在没有并发更新的情况下使用。</li></ul></li><li>long sumThenReset(<ul><li>获取当前value,并将value重置为0</li></ul></li></ul><p><strong>LongAccumulator常用API</strong></p><ul><li>void accumulate(long x)<ul><li>将当前值加上x</li></ul></li><li>long get()<ul><li>返回当前值</li></ul></li></ul><p>​</p><p>当多个线程更新用于收集统计信息但不用于细粒度同步控制的目的的公共和时，<strong>使用LongAdder通常优于AtomicLong</strong>。在<strong>低更新</strong>争用下，这两个类具有相似的特征。但在<strong>高争用</strong>的情况下，这一类的预期吞吐量明显更高，但代价是<strong>空间消耗更高</strong></p><ul><li>LongAdder只能用来计算加法，且从零开始计算</li><li>LongAccumulator提供了<strong>自定义的函数操作</strong></li></ul><blockquote><p>17.【参考】volatile解决多线程内存不可见问题对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</p><p>说明：如果是count++操作，使用如下类实现：<br>Atomiclnteger count new Atomiclnteger();<br>count.addAndGet(1);</p><p><font color="red">如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）</font></p><p>​——《阿里Java开发手册》</p></blockquote><p>阿里题目：（即后面讲到的i++点赞案例）</p><p>1 热点商品点赞计算器，点赞数加加统计，不要求实时精确<br>2 一个很大的list，里面都是int类型，如何实现加加，说说思路</p><p><strong>使用案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        </span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line"></span><br><span class="line">        System.out.println(longAdder.sum());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x,y) -&gt; x + y,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">        longAccumulator.accumulate(<span class="number">3</span>);<span class="comment">//4</span></span><br><span class="line">        System.out.println(longAccumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="i-点赞累加问题解决办法汇总对比"><a href="#i-点赞累加问题解决办法汇总对比" class="headerlink" title="i++点赞累加问题解决办法汇总对比"></a>i++点赞累加问题解决办法汇总对比</h3><p>阿里题目：</p><p>1 热点商品点赞计算器，点赞数加加统计，不要求实时精确<br>2 一个很大的list，里面都是int类型，如何实现加加，说说思路</p><p><strong>解决思路：</strong></p><ul><li>1 synchronized或lock读写<ul><li>写锁策略：volatile读，synchronized写（只适合一写多读场景）</li></ul></li><li>2 AtomicInteger &#x2F; AtomicLong</li><li>3 AtomicIntegerFieldUpdater &#x2F; AtomicLongFieldUpdate</li><li>4 <font color="red">LongAdder</font></li><li>5 <font color="red">LongAccumulator</font></li></ul><p><strong>高争用</strong>的情况下，LongAdder和LongAccumulator预期吞吐量明显更高，但代价是<strong>空间消耗更高</strong></p><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i++点赞各实现方法比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClickNumber</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 使用synchronized</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clickBySynchronized</span><span class="params">()</span>&#123;number++;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 使用AtomicLong</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByAtomicLong</span><span class="params">()</span>&#123;atomicLong.getAndIncrement();&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3 使用AtomicLongFieldUpdater</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    AtomicLongFieldUpdater&lt;ClickNumber&gt; fieldUpdater = AtomicLongFieldUpdater.newUpdater(ClickNumber.class,<span class="string">&quot;number2&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByAtomicLongFieldUpdater</span><span class="params">()</span>&#123; fieldUpdater.getAndIncrement(<span class="built_in">this</span>); &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4 使用LongAdder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAdder</span><span class="params">()</span>&#123;longAdder.increment(); &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5 使用LongAccumulator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x,y) -&gt; x + y,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAccumulator</span><span class="params">()</span>&#123; longAccumulator.accumulate(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccumulatorCompareDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1W</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ClickNumber</span> <span class="variable">clickNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClickNumber</span>();</span><br><span class="line">        <span class="type">long</span> startTime;</span><br><span class="line">        <span class="type">long</span> endTime;</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadNumber);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=<span class="number">100</span> * _1W; j++) &#123;</span><br><span class="line">                        clickNumber.clickBySynchronized();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch1.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch1.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickBySynchronized: &quot;</span>+clickNumber.number);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++)&#123;</span><br><span class="line">                        clickNumber.clickByAtomicLong();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch2.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByAtomicLong: &quot;</span>+clickNumber.atomicLong.get());</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++)&#123;</span><br><span class="line">                        clickNumber.clickByAtomicLongFieldUpdater();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch3.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByAtomicLongFieldUpdater: &quot;</span>+clickNumber.number2);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++)&#123;</span><br><span class="line">                        clickNumber.clickByLongAdder();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch4.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch4.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByLongAdder: &quot;</span>+clickNumber.longAdder.sum());</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= threadNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++)&#123;</span><br><span class="line">                        clickNumber.clickByLongAccumulator();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch5.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch5.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByLongAccumulator: &quot;</span>+clickNumber.longAccumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----costTime: 2956 毫秒 clickBySynchronized: 50000000</span><br><span class="line">----costTime: 781 毫秒 clickByAtomicLong: 50000000</span><br><span class="line">----costTime: 1253 毫秒 clickByAtomicLongFieldUpdater: 50000000</span><br><span class="line">----costTime: 183 毫秒 clickByLongAdder: 50000000</span><br><span class="line">----costTime: 88 毫秒  clickByLongAccumulator: 50000000</span><br></pre></td></tr></table></figure><h3 id="LongAdder为什么快？源码分析"><a href="#LongAdder为什么快？源码分析" class="headerlink" title="LongAdder为什么快？源码分析"></a>LongAdder为什么快？源码分析</h3><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230717201713406.png" alt="image-20230717201713406"></p><p>18个原子类，上面一共介绍了16个，还有两个隐藏的就是，Number类和Striped64</p><p>LongAdder是继承于Striped64的</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>LongAdder的基本思路就是<font color="red">分散热点</font>，将value值分散到一个<font color="red">Cell数组</font>中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p><p>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><p><strong>如图：</strong></p><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230717203747234.png" alt="image-20230717203747234"></p><h4 id="add-源码详解"><a href="#add-源码详解" class="headerlink" title="add()源码详解"></a>add()源码详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LongAdder.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line"><span class="comment">//as是striped64中的cells数组属性</span></span><br><span class="line"><span class="comment">//b是striped64中的base属性</span></span><br><span class="line"><span class="comment">//v是当前线程hash到的cell中存储的值</span></span><br><span class="line"><span class="comment">//m是cells的长度减1,hash时作为掩码使用</span></span><br><span class="line"><span class="comment">//a时当前线程hash到的cell</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">首次首线程(as = cells) != null)一定是false,此时走casBase方法,以CAS的方式更新base值,</span></span><br><span class="line"><span class="comment">且只有当cas失败时,才会走到if中</span></span><br><span class="line"><span class="comment">条件1:cells不为空,说明出现过竞争,cell[]已创建</span></span><br><span class="line"><span class="comment">条件2:cas操作base失败,说明其他线程先一步修改了base正在出现竞争</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line"><span class="comment">//true无竞争 fasle表示竞争激烈,多个线程hash到同一个cell,可能要扩容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">条件1:cells为空,说明正在出现竞争,上面是从条件2过来的,说明!casBase(b = base, b + x))=true</span></span><br><span class="line"><span class="comment">  会通过调用longAccumulate(x, null, uncontended)新建一个数组,默认长度是2</span></span><br><span class="line"><span class="comment">条件2:默认会新建一个数组长度为2的数组,m = as.length - 1) &lt; 0 应该不会出现,</span></span><br><span class="line"><span class="comment">条件3:当前线程所在的cell为空,说明当前线程还没有更新过cell,应初始化一个cell。</span></span><br><span class="line"><span class="comment">  a = as[getProbe() &amp; m]) == null,如果cell为空,进行一个初始化的处理</span></span><br><span class="line"><span class="comment">条件4:更新当前线程所在的cell失败,说明现在竞争很激烈,多个线程hash到同一个Cell,应扩容</span></span><br><span class="line"><span class="comment">  (如果是cell中有一个线程操作,这个时候,通过a.cas(v = a.value, v + x)可以进行处理,返回的结果是true)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">    <span class="comment">//getProbe( )方法返回的时线程中的threadLocalRandomProbe字段</span></span><br><span class="line"><span class="comment">//它是通过随机数生成的一个值,对于一个确定的线程这个值是固定的(除非刻意修改它)</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line"><span class="comment">//调用Striped64中的方法处理</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>add()方法总结：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="red"><strong>1如果Cells表为空，尝试用CAS更新base字段，成功则退出</strong></font></li><li><font color="red"><strong>2如果Cells表为空，CAS更新base字段失败，出现竞争，uncontended为true，调用longAccumulate()</strong></font>（尝试执行CASE2，其他线程正在执行则执行CASE3）</li><li><font color="red"><strong>3如果Cells表非空，但当前线程映射的槽为空，uncontended为true，调用longAccumulate()</strong></font>（尝试执行CASE1.1）</li><li><font color="red"><strong>4如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，uncontended设为false，调用longAccumulate()</strong></font>（尝试循环执行CASE1.2-1.6）</li></ul><h4 id="longAccumulate-源码详解"><a href="#longAccumulate-源码详解" class="headerlink" title="longAccumulate()源码详解"></a>longAccumulate()源码详解</h4><ul><li>Striped64中一些变量或方法的定义：</li></ul><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230717223702312.png" alt="image-20230717223702312"></p><ul><li>首先存储线程的probe（hash）值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">  <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line"><span class="comment">//存储线程的probe值</span></span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">//如果getProbe()方法返回0,说明随机数未初始化</span></span><br><span class="line"><span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123; <span class="comment">//这个if相当于给当前线程生成一个非0的hash值</span></span><br><span class="line"><span class="comment">//使用ThreadLocalRandom为当前线程重新计算一个hash值,强制初始化</span></span><br><span class="line">ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line"><span class="comment">//重新获取probe值,hash值被重置就好比一个全新的线程一样,所以设置了wasUncontended竞争状态为true</span></span><br><span class="line">h = getProbe();</span><br><span class="line"><span class="comment">//重新计算了当前线程的hash后认为此次不算是一次竞争,都未初始化,肯定还不存在竞争激烈</span></span><br><span class="line"><span class="comment">//wasUncontended竞争状态为true</span></span><br><span class="line">wasUncontended = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for( ; ; )大循环一共分为三个部分</li></ul><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230717223107206.png" alt="image-20230717223107206"></p><ul><li>CASE2：cells[]首次初始化时：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CASE2:cells没有加锁且没有初始化,则尝试对它进行加锁,并初始化cells数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cellsBusy:初始化cells或者扩容cells需要获取锁,0表示无锁状态,1表示其他线程已经持有了锁</span></span><br><span class="line"><span class="comment">cells == as == null  是成立的</span></span><br><span class="line"><span class="comment">casCellsBusy:通过CAS操作修改cellsBusy的值,CAS成功代表获取锁,</span></span><br><span class="line"><span class="comment">返回true,第一次进来没人抢占cell单元格,肯定返回true</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line">    <span class="comment">//是否初始化的标记</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table(新建cells)</span></span><br><span class="line"><span class="comment">// 前面else if中进行了判断,这里再次判断,采用双端检索的机制</span></span><br><span class="line">           <span class="comment">//不double check，就会再次new一个cell数组，另一个先于本线程操作的线程中对应数组的值就会被篡改</span></span><br><span class="line"><span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line"><span class="comment">//如果上面条件都执行成功就会执行数组的初始化及赋值操作，Cell[] rs = new Cell[2]表示数组的长度为2，</span></span><br><span class="line">Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//rs[h &amp; 1] = new Cell(x)表示创建一个新的Cell元素，value是x值，默认为1</span></span><br><span class="line"><span class="comment">//h &amp; 1类似于我们之前HashMap常用到的计算散列桶index的算法</span></span><br><span class="line"><span class="comment">//通常都是hash&amp;(table.len-1)，同hashmap一个意思</span></span><br><span class="line"><span class="comment">//看这次的value是落在0还是1</span></span><br><span class="line">rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">cells = rs;</span><br><span class="line">init = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CASE3：兜底操作，CASE1判断cells为空，CASE2判断时被其它线程抢先初始化cells时会尝试修改base值（多个线程尝试CAS修改失败的线程会走这个分支）（<strong>其他线程正在进行初始化cells数组时，走这个CASE3</strong>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CASE3:cells正在被其它线程进行初始化,本线程则尝试直接在基数base上进行累加操作</span></span><br><span class="line"><span class="comment">//这种情况是cell中都CAS失败了,有一个兜底的方法</span></span><br><span class="line"><span class="comment">//该分支实现直接操作base基数,将值累加到base上,</span></span><br><span class="line"><span class="comment">//也即其他线程正在初始化,多个线程正在更新base的值</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">fn.applyAsLong(v, x))))</span><br><span class="line"><span class="keyword">break</span>;     </span><br></pre></td></tr></table></figure><ul><li>CASE1.1：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// CASE1:cells已经初始化了</span></span><br><span class="line">    <span class="comment">// 当前线程的hash值运算后映射得到的Cell单元为null,说明该Cell没有被使用</span></span><br><span class="line"><span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//Cell[]数组没有正在扩容</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line"><span class="comment">//先创建一个Cell单元格</span></span><br><span class="line"><span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"><span class="comment">//尝试加锁,加锁后cellsBusy=1</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line"><span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">Cell[] rs; <span class="type">int</span> m, j; </span><br><span class="line"><span class="comment">//在有锁的情况下再检测一遍之前的判断 </span></span><br><span class="line"><span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">rs[j] = r;<span class="comment">//将cell单元附到Cell[]数组上</span></span><br><span class="line">created = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (created)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//上面代码判断当前线程hash后指向的数据位置元素是否为空，</span></span><br><span class="line"><span class="comment">//如果为空则将Cell数据放入数组中，跳出循环。</span></span><br><span class="line"><span class="comment">//如果不空则继续循环。</span></span><br></pre></td></tr></table></figure><ul><li>CASE1.2：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">wasUncontended表示cells初始化后,当前线程竞争修改失败</span></span><br><span class="line"><span class="comment">wasUncontended=false,表示竞争激烈,需要扩容,这里只是重新设置了这个值为true,</span></span><br><span class="line"><span class="comment">紧接着执行advanceProbe(h)重置当前线程的hash,重新循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">...</span><br><span class="line">      h = advanceProbe(h);</span><br></pre></td></tr></table></figure><ul><li>CASE1.3：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明当前线程对应的数组中有了数据,也重置过hash值</span></span><br><span class="line"><span class="comment">//这时通过CAS操作尝试对当前数中的value值进行累加x操作,x默认为1,如果CAS成功则直接跳出循环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line"> fn.applyAsLong(v, x))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">      h = advanceProbe(h);</span><br></pre></td></tr></table></figure><ul><li>CASE1.4：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果n大于CPU最大数量,不可扩容,</span></span><br><span class="line"><span class="comment">//并通过下面的h=advanceProbe(h)方法修改线程的probe再重新尝试</span></span><br><span class="line"><span class="comment">//若线程数已经最大，那么将会一直for循环，一直执行上一步的a.cas而不会进入下面步骤</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">      h = advanceProbe(h);</span><br></pre></td></tr></table></figure><ul><li>CASE1.5：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果扩容意向collide是false则修改它为true,然后重新计算当前线程的hash值继续循环</span></span><br><span class="line"><span class="comment">//如果下一次循环当前数组的长度已经大于了CPU的核数，就会再次设置扩容指向collide=false(在上一步截止)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!collide) </span><br><span class="line">collide = <span class="literal">true</span>;</span><br><span class="line">...</span><br><span class="line">      h = advanceProbe(h);</span><br></pre></td></tr></table></figure><ul><li>CASE1.6：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁状态为0并且将锁状态修改为1(持有锁) </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line"><span class="comment">//按位左移1位来操作,扩容大小为之前容量的两倍</span></span><br><span class="line">Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="comment">//扩容后将之前数组的元素拷贝到新数组中</span></span><br><span class="line">rs[i] = as[i];</span><br><span class="line">cells = rs; </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放锁设置cellsBusy=0,设置扩容状态,然后继续循环执行</span></span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">&#125;</span><br><span class="line">h = advanceProbe(h);</span><br></pre></td></tr></table></figure><ul><li>longAccumulate()方法图示：</li></ul><p><img src="https://www.hahhome.top/blog/JUC04/../../image/JUC04.assets/image-20230717232607820.png" alt="image-20230717232607820"></p><p><strong>我的理解：</strong></p><ul><li>当cells&#x3D;&#x3D;null时，执行CASE2</li><li>CASE1判断cells为空，到CASE2判断时被其它线程抢先初始化cells时，会执行兜底操作CASE3，对base进行CAS</li><li>cells!&#x3D;null时，CASE1会从上到下进行判断，线程对应的hash值只能映射到仅有的槽位</li><li>CASE1.1：若是刚刚初始化的槽位还没有线程占用放过值，那么会进行CASE1.1，new一个cell存放值，之后的线程hash到该槽位时，CASE1.1将会判断失败，wasUncontended值为false，往下走</li><li>CASE1.2：如果是有竞争的，即wasUncontended值为false，将其修改为true，修改后即可往下走，否则若是没竞争，将无法继续往下走</li><li>CASE1.3：前面两步将会连续判断失败，此时会尝试在有竞争的槽位进行CAS自旋，若自旋成功，则跳出，若失败，则继续往下走</li><li>CASE1.4：第1、2步连续判断失败，第三步本次循环失败的话，会到第4步，判断槽位是否达到最大值（CPU个数），若达到最大个数后，设置collide为false，表示不可扩容，将会止步CASE1.4，导致永远不可能到达第6步进行扩容，只能一直无限循环在for循环内，无限进行第3步尝试CAS自旋直到成功</li><li>CASE1.5：扩容前的最后一步，修改扩容意向collide为false，下次循环将会不再进入CASE1.5，将会到达下一步进行扩容</li><li>CASE1.6：前面两步将会连续判断失败后，并且该次循环CAS失败，并且没达到最大槽位，执行扩容操作</li></ul><h4 id="sum-源码详解"><a href="#sum-源码详解" class="headerlink" title="sum()源码详解"></a>sum()源码详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum( )会将所有Cell数组中的value和base累加作为返回值</span></span><br><span class="line"><span class="comment">//核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去,从而降级更新热点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为啥高并发下sum的值不精确？</p><ul><li>sum执行时,并没有限制对base和cells的更新(一句要命的话)。<font color="red">所以LongAdder不是强一致性，它是最终一致性的</font></li><li>首先,最终返回的sum局部变量,初始被赋值为base,而最终返回时,很可能base已经被更新了,而此时局部变量sum不会更新,造成不一致</li><li>其次,这里对cell的读取也<strong>无法保证是最后一次写入的值</strong>。所以,sum方法在没有并发的情况下,可以获得正确的结果</li></ul><p><font color="red">一句话：调用sum方法时，累加操作还在进行，所以返回时累加值已经变了，不是强一致性，而是最终一致性的</font></p><h4 id="LongAdder源码解析总结"><a href="#LongAdder源码解析总结" class="headerlink" title="LongAdder源码解析总结"></a>LongAdder源码解析总结</h4><p>总结：LongAdder的基本思路就是<font color="red">分散热点</font>，内部有一个base变量，一个Cell数组。</p><ul><li><font color="red">base变量：低并发，直接累加到该变量上</font></li><li><font color="red">Cell[]数组：高并发，累加进各个线程自己的槽cell[i]中</font></li><li>最后：Value &#x3D; Base + ∑(i&#x3D;1~n) Cell[i]</li></ul><p>LongAdder在无竞争的情况，跟AtomicLong一样，对<font color="red">同一个base</font>进行操作，当出现竞争关系时则是采用<font color="red">化整为零分散热点</font>的做法，<font color="cornflowerblue">用空间换时间</font>，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，<strong>可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标</strong>，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和base都加起来作为最终结果</p><h3 id="AtomicLong和LongAdder对比总结"><a href="#AtomicLong和LongAdder对比总结" class="headerlink" title="AtomicLong和LongAdder对比总结"></a>AtomicLong和LongAdder对比总结</h3><p><strong>AtomicLong</strong></p><ul><li>原理：<ul><li>CAS+自旋</li><li>AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全问题</li><li>AtomicLong是多个线程针对单个热点值value进行原子操作</li></ul></li><li>场景：<ul><li>低并发下的全局计算</li><li>保证精度，性能代价</li><li>线程安全，可允许一些性能损耗，要求高精度时可使用</li></ul></li><li>缺陷：<ul><li>高并发后性能急剧下降</li><li>why？AtomicLong的自旋会成为瓶颈<ul><li>N个线程CAS操作修改线程的值，每次只有一个成功过，其它N-1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。</li></ul></li></ul></li></ul><p><strong>LongAdder</strong></p><ul><li>原理：<ul><li>CAS+Base+CeIl数组分散</li><li>空间换时间并分散了热点数据</li><li>LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作</li><li>但最多只能存在CPU个数那么多个槽，因为需要CPU独占实现原子性</li></ul></li><li>场景：<ul><li>高并发下的全局计算</li><li>保证性能，精度代价</li><li>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</li></ul></li><li>缺陷：<ul><li>sum求和后还有计算线程修改结果的话，最后结果不够准确</li></ul></li></ul><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="附件：Striped64-java和LongAdder-java源码"><a href="#附件：Striped64-java和LongAdder-java源码" class="headerlink" title="附件：Striped64.java和LongAdder.java源码"></a>附件：Striped64.java和LongAdder.java源码</h3><h4 id="Striped64-java"><a href="#Striped64-java" class="headerlink" title="Striped64.java"></a>Striped64.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">Striped64.java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.LongAdder继承了Striped64类，来实现累加功能，它是实现高并发累加的工具类</span></span><br><span class="line"><span class="comment">2.Striped64的设计核心思路就是通过内部的分散计算来避免竞争</span></span><br><span class="line"><span class="comment">3.Striped64内部包含一个base和一个Cell[] cells数组,又叫hash表</span></span><br><span class="line"><span class="comment">4.没有竞争的情况下，要累加的数通过cas累加到base上；如果有竞争的话，</span></span><br><span class="line"><span class="comment">会将要累加的数累加到Cells数组中的某个cell元素里面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Striped64</span> <span class="keyword">extends</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="comment">//CPU数量,即Cells数组的最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//存放Cell的hash表，大小为2的幂</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.在开始没有竞争的情况下,将累加值累加到base；</span></span><br><span class="line"><span class="comment">2.在cells初始化的过程中，cells处于不可用的状态，这时候也会尝试将通过cas操作值累加到base</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cellsBusy,它有两个值0或1,它的作用是当要修改cells数组时加锁,</span></span><br><span class="line"><span class="comment">防止多线程同时修改cells数组(也称cells表)，0为无锁，1位加锁，加锁的状况有三种:</span></span><br><span class="line"><span class="comment">(1). cells数组初始化的时候；</span></span><br><span class="line"><span class="comment">    (2). cells数组扩容的时候；</span></span><br><span class="line"><span class="comment">    (3).如果cells数组中某个元素为null，给这个位置创建新的Cell对象的时候；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//低并发状态,还没有新建cell数组且写入进入base,刚好够用</span></span><br><span class="line"><span class="comment">//base罩得住,不用上cell数组</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casBase</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line"><span class="comment">//当前对象,在base位置上,将base(类似于AtomicLong中全局的value值),将base=0(cmp)改为1(value)</span></span><br><span class="line"><span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">  <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line"><span class="comment">//存储线程的probe值</span></span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">//如果getProbe()方法返回0,说明随机数未初始化</span></span><br><span class="line"><span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123; <span class="comment">//这个if相当于给当前线程生成一个非0的hash值</span></span><br><span class="line"><span class="comment">//使用ThreadLocalRandom为当前线程重新计算一个hash值,强制初始化</span></span><br><span class="line">ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line"><span class="comment">//重新获取probe值,hash值被重置就好比一个全新的线程一样,所以设置了wasUncontended竞争状态为true</span></span><br><span class="line">h = getProbe();</span><br><span class="line"><span class="comment">//重新计算了当前线程的hash后认为此次不算是一次竞争,都未初始化,肯定还不存在竞争激烈,wasUncontended竞争状态为true</span></span><br><span class="line">wasUncontended = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果hash取模映射得到的Cell单元不是null,则为true,此值也可以看作是扩容意向</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line"><span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// CASE1:cells已经初始化了</span></span><br><span class="line">    <span class="comment">// 当前线程的hash值运算后映射得到的Cell单元为null,说明该Cell没有被使用</span></span><br><span class="line"><span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//Cell[]数组没有正在扩容</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line"><span class="comment">//先创建一个Cell</span></span><br><span class="line"><span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"><span class="comment">//尝试加锁,加锁后cellsBusy=1</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line"><span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">Cell[] rs; <span class="type">int</span> m, j; <span class="comment">//将cell单元赋值到Cell[]数组上</span></span><br><span class="line"><span class="comment">//在有锁的情况下再检测一遍之前的判断 </span></span><br><span class="line"><span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">(m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">rs[j] = r;</span><br><span class="line">created = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (created)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">wasUncontended表示cells初始化后,当前线程竞争修改失败</span></span><br><span class="line"><span class="comment">wasUncontended=false,表示竞争激烈,需要扩容,这里只是重新设置了这个值为true,</span></span><br><span class="line"><span class="comment">紧接着执行advanceProbe(h)重置当前线程的hash,重新循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"><span class="comment">//说明当前线程对应的数组中有了数据,也重置过hash值</span></span><br><span class="line"><span class="comment">//这时通过CAS操作尝试对当前数中的value值进行累加x操作,x默认为1,如果CAS成功则直接跳出循环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line"> fn.applyAsLong(v, x))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//如果n大于CPU最大数量,不可扩容,并通过下面的h=advanceProbe(h)方法修改线程的probe再重新尝试</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">collide = <span class="literal">false</span>;    <span class="comment">//扩容标识设置为false,标识永远不会再扩容</span></span><br><span class="line"><span class="comment">//如果扩容意向collide是false则修改它为true,然后重新计算当前线程的hash值继续循环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!collide) </span><br><span class="line">collide = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//锁状态为0并且将锁状态修改为1(持有锁) </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line"><span class="comment">//按位左移1位来操作,扩容大小为之前容量的两倍</span></span><br><span class="line">Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="comment">//扩容后将之前数组的元素拷贝到新数组中</span></span><br><span class="line">rs[i] = as[i];</span><br><span class="line">cells = rs; </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放锁设置cellsBusy=0,设置扩容状态,然后进行循环执行</span></span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">&#125;</span><br><span class="line">h = advanceProbe(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CASE2:cells没有加锁且没有初始化,则尝试对它进行加锁,并初始化cells数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cellsBusy:初始化cells或者扩容cells需要获取锁,0表示无锁状态,1表示其他线程已经持有了锁</span></span><br><span class="line"><span class="comment">cells == as == null  是成立的</span></span><br><span class="line"><span class="comment">casCellsBusy:通过CAS操作修改cellsBusy的值,CAS成功代表获取锁,返回true,第一次进来没人抢占cell单元格,肯定返回true</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line">    <span class="comment">//是否初始化的标记</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table(新建cells)</span></span><br><span class="line"><span class="comment">// 前面else if中进行了判断,这里再次判断,采用双端检索的机制</span></span><br><span class="line"><span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line"><span class="comment">//如果上面条件都执行成功就会执行数组的初始化及赋值操作,Cell[] rs = new Cell[2]标识数组的长度为2</span></span><br><span class="line">Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//rs[h &amp; 1] = new Cell(x)表示创建一个新的cell元素,value是x值,默认为1</span></span><br><span class="line"><span class="comment">//h &amp; 1 类似于我们之前hashmap常用到的计算散列桶index的算法,通常都是hash&amp;(table.len-1),同hashmap一个意思</span></span><br><span class="line">rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">cells = rs;</span><br><span class="line">init = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CASE3:cells正在进行初始化,则尝试直接在基数base上进行累加操作</span></span><br><span class="line"><span class="comment">//这种情况是cell中都CAS失败了,有一个兜底的方法</span></span><br><span class="line"><span class="comment">//该分支实现直接操作base基数,将值累加到base上,也即其他线程正在初始化,多个线程正在更新base的值</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">fn.applyAsLong(v, x))))</span><br><span class="line"><span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LongAdder-java"><a href="#LongAdder-java" class="headerlink" title="LongAdder.java"></a>LongAdder.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">   LongAdder.java</span><br><span class="line">(<span class="number">1</span>).baseOK,直接通过casBase进行处理</span><br><span class="line">(<span class="number">2</span>).base不够用了,开始新建一个cell数组,初始值为<span class="number">2</span></span><br><span class="line">   (<span class="number">3</span>).当多个线程竞争同一个Cell比较激烈时,可能就要对Cell[ ]扩容</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line"><span class="comment">//as是striped64中的cells数组属性</span></span><br><span class="line"><span class="comment">//b是striped64中的base属性</span></span><br><span class="line"><span class="comment">//v是当前线程hash到的cell中存储的值</span></span><br><span class="line"><span class="comment">//m是cells的长度减1,hash时作为掩码使用</span></span><br><span class="line"><span class="comment">//a时当前线程hash到的cell</span></span><br><span class="line">       Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">首次首线程(as = cells) != null)一定是false,此时走casBase方法,以CAS的方式更新base值,</span></span><br><span class="line"><span class="comment">且只有当cas失败时,才会走到if中</span></span><br><span class="line"><span class="comment">条件1:cells不为空,说明出现过竞争,cell[]已创建</span></span><br><span class="line"><span class="comment">条件2:cas操作base失败,说明其他线程先一步修改了base正在出现竞争</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line"><span class="comment">//true无竞争 fasle表示竞争激烈,多个线程hash到同一个cell,可能要扩容</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">条件1:cells为空,说明正在出现竞争,上面是从条件2过来的,说明!casBase(b = base, b + x))=true</span></span><br><span class="line"><span class="comment">  会通过调用longAccumulate(x, null, uncontended)新建一个数组,默认长度是2</span></span><br><span class="line"><span class="comment">条件2:默认会新建一个数组长度为2的数组,m = as.length - 1) &lt; 0 应该不会出现,</span></span><br><span class="line"><span class="comment">条件3:当前线程所在的cell为空,说明当前线程还没有更新过cell,应初始化一个cell。</span></span><br><span class="line"><span class="comment">  a = as[getProbe() &amp; m]) == null,如果cell为空,进行一个初始化的处理</span></span><br><span class="line"><span class="comment">条件4:更新当前线程所在的cell失败,说明现在竞争很激烈,多个线程hash到同一个Cell,应扩容</span></span><br><span class="line"><span class="comment">  (如果是cell中有一个线程操作,这个时候,通过a.cas(v = a.value, v + x)可以进行处理,返回的结果是true)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">           <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">    <span class="comment">//getProbe( )方法返回的时线程中的threadLocalRandomProbe字段</span></span><br><span class="line"><span class="comment">//它是通过随机数生成的一个值,对于一个确定的线程这个值是固定的(除非刻意修改它)</span></span><br><span class="line">               (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">               !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line"><span class="comment">//调用Striped64中的方法处理</span></span><br><span class="line">               longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">Striped64.java</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Striped64</span> <span class="keyword">extends</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"><span class="comment">//低并发状态,还没有新建cell数组且写入进入base,刚好够用</span></span><br><span class="line"><span class="comment">//base罩得住,不用上cell数组</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casBase</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line"><span class="comment">//当前对象,在base位置上,将base(类似于AtomicLong中全局的value值),将base=0(cmp)改为1(value)</span></span><br><span class="line"><span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC03</title>
      <link href="/blog/JUC03/"/>
      <url>/blog/JUC03/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC03"><a href="#JUC03" class="headerlink" title="JUC03"></a>JUC03</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li>JMM（Java内存模型）<ul><li><font color="red">happendss-before先行发生原则</font></li></ul></li><li>volatile关键字<ul><li><font color="red">内存屏障</font></li></ul></li></ul><h1 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h1><h2 id="JMM定义和作用"><a href="#JMM定义和作用" class="headerlink" title="JMM定义和作用"></a>JMM定义和作用</h2><p><strong>定义</strong></p><p>JMM(Java内存模型Java Memory Model,简称JMM)本身是一种<font color="orange">抽象的</font>概念<font color="red">并不真实存在</font><font color="cornflowerblue">它仅仅描述的是一组约定或规范</font>，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入以及如何变成对另一个线程可见，关键技术点都是围绕多线程的<font color="red">原子性、可见性和有序性</font>展开的。</p><p>原则：</p><p>JMM的关键技术点都是围绕多线程的<font color="red">原子性、可见性和有序性展开的</font></p><p><strong>作用</strong></p><p><font color="red">能干嘛？</font></p><p>1通过JMM来实现<font color="red">线程和主内存之间的抽象关系。</font></p><p>2<font color="red">屏蔽各个<font color="cornflowerblue">硬件平台</font>和<font color="cornflowerblue">操作系统</font>的内存访问差异</font>以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><p><strong>通俗解释</strong></p><p>电脑读写速度：</p><p>CPU寄存器 &gt; CPU缓存 &gt; 主存 &gt; 硬盘 &gt; 网络</p><p>因为有这么多级的缓存（cpu和物理主内存的速度不一致的），</p><p>CPU的运行并<font color="red">不是直接操作内存而是先把内存里边的数据读到缓存</font>，而内存的读和写操作的时候就会造成不一致的问题</p><p>JVM规范中试图定义一种Java内存模型(java Memory Model,简称JMM)来<font color="red">屏蔽掉各种硬件和操作系统的内存访问差异</font>，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><p>所以，推导出我们需要知道JMM</p><h2 id="JMM三大特性"><a href="#JMM三大特性" class="headerlink" title="JMM三大特性"></a>JMM三大特性</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><font color="red">是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更</font>，JMM规定了所有的变量都存储在<font color="red">主内存</font>。</p><p><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230715144410262.png" alt="image-20230715144410262"></p><p>系统主内存<font color="red">共享变量</font>数据修改被写入的时机是不确定的，<font color="cornflowerblue">多线程并发下很可能出现”脏读”</font>，所以每个线程都有自己的<font color="red">工作内存</font>，线程自己的工作内存中保存了该线程使用到的变量的<font color="red">主内存副本拷贝</font>，线程对变量的所有操作（读取，赋值等）都必需<strong>在线程自己的工作内存中进行，而不能够直接读写主内存中的变量</strong>。不同线程之间也无法直接访问对方工作内存中的变量，<font color="red">线程间变量值的传递均需要通过主内存来完成</font></p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>即是否指令重排</p><p><strong>是什么</strong></p><p>重排序是指编译器和处理器为了<strong>优化程序性能</strong>而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序</p><ul><li>不存在数据依赖关系，可以重排序；</li><li><font color="red">存在数据依赖关系，禁止重排序</font></li></ul><p>但重排后的指令绝对不能改变原有的串行语义！<font color="red">这点在并发设计中必须要重点考虑！</font></p><p><font color="cornflowerblue">数据依赖性：</font>若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</p><p>案例：</p><p><font color="red">不存在</font>数据依赖关系，可以重排序&#x3D;&#x3D;&#x3D;&gt;<font color="cornflowerblue">重排序OK。</font></p><p><strong>优缺点</strong></p><p>JVM能根据处理器特性(CPU多级缓存系统、多核处理器等)适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，</p><p>指令重排可以<font color="red">保证串行语义一致</font>，但<font color="red">没有义务保证多线程间的语义也一致</font>（即可能产生”脏读”），简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，<font color="cornflowerblue">不见得是从上到下顺序执行，执行顺序</font><font color="red">会被优化。</font></p><p><strong>从源码到最终执行示例图：</strong></p><p><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230715150401023.png" alt="image-20230715150401023"></p><p><font color="cornflowerblue"><strong>单线程</strong>环境里面确保程序最终执行结果和代码顺序执行的<strong>结果一致</strong>。</font></p><p>处理器在进行重排序时<font color="red">必须要考虑</font>指令之间的<font color="red"><strong>数据依赖性</strong></font></p><p><font color="cornflowerblue"><strong>多线程</strong>环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，<strong>结果无法预测</strong>。</font></p><p>总结：</p><ul><li>单线程指令重排后和代码顺序执行的结果一致</li><li>多线程不确定</li></ul><h2 id="多线程对变量的读写过程"><a href="#多线程对变量的读写过程" class="headerlink" title="多线程对变量的读写过程"></a>多线程对变量的读写过程</h2><p>由于JVM运行程序的实体是线程，而每个线程创建时JMM都会为其创建一个工作内存（有些地方称为栈空闻），工作内存是每个线程的和有数据区域，而Jva内存模型中规定所有变量都存储在<font color="red">主内存</font>，主内存是共享内存区域，所有线程都可以访问，<font color="red">但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存考贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</font>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的<font color="cornflowerblue">变量副本拷贝</font>，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：</p><p><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230715150900855.png" alt="image-20230715150900855"></p><p><font color="cornflowerblue">JMM定义了线程和主内存之间的抽象关系</font></p><ol><li>线程之间的共享变量存储在主内存中（从硬件角度来说就是内存条）</li><li>每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读&#x2F;写共享变量的副本（从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等）</li></ol><p><strong>小总结</strong></p><ul><li>我们定义的所有共享变量都储存在<font color="red">物理主内存</font>中</li><li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li><li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）</li><li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）</li><li><font color="red">操作volatile关键字修饰的变量，使用内存屏障修改后直接刷新到主内存中，让其他本地内存中的数据失效，必须重新到主内存中读取</font></li></ul><h2 id="多线程先行发生原则happens-before"><a href="#多线程先行发生原则happens-before" class="headerlink" title="多线程先行发生原则happens-before"></a>多线程先行发生原则happens-before</h2><p>在JMM中，如果一个操作<font color="red">执行的结果</font>需要对另一个操作拥有<font color="cornflowerblue">可见性</font>，或者<font color="cornflowerblue">代码重排序(有序性)</font>，那么这两个操作之间必须存在happens-before(先行发生)原则。拥有逻辑上的先后关系</p><p><strong>先行发生原则说明</strong></p><p>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。</p><p><font color="red">我们没有<font color="cornflowerblue">时时、处处、次次</font>，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”(Happens-Before)的原则限制和规矩，给你立好了规矩！</font></p><p><font color="red">这个原则非常重要：</font></p><p>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子<font color="cornflowerblue">解决并发环境下两个操作之间是否可能存在冲突的所有问题</font>，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。</p><h3 id="happends-before总原则"><a href="#happends-before总原则" class="headerlink" title="&#x3D;&#x3D;happends-before总原则&#x3D;&#x3D;"></a>&#x3D;&#x3D;happends-before总原则&#x3D;&#x3D;</h3><ul><li>如果一个操作happens-before另一个操作，<strong>那么第一个操作的执行结果将对第二个操作可见</strong>，而且第一个操作的执行顺序排在第二个操作之前。<ul><li>即满足hapens-before前提下，操作满足可见性和有序性</li></ul></li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的<font color="red">结果一致</font>，那么这种重排序<font color="red">并不非法</font>。<ul><li>若发生了指令重排，只要结果一致，就合法，不一致就会被阻止</li></ul></li></ul><h3 id="happends-befre细分8条原则"><a href="#happends-befre细分8条原则" class="headerlink" title="happends-befre细分8条原则"></a>happends-befre细分8条原则</h3><p>掌握总原则即可，8条尽你所能</p><p><font color="red"><strong>理所当然的语法顺序，就是happend-before</strong></font></p><ol><li>次序规则：<ul><li><font color="red">一个线程内</font>，按照代码顺序，写在前面的操作先行发生于写在后面的操作；</li><li>前一个操作的结果可以被后续的操作获取。深说明讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经娈成了1。</li></ul></li><li>锁定规则：<ul><li>一个unLock操作<font color="red">先行发生于</font>后面(（这里的“后面”是指时间上的先后）)对同一个锁的Iock操作；</li></ul></li><li>volatile变量规则：<ul><li>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<font color="red">前面的写对后面的读是可见的</font>，这里的“后面”同样是指时间上的先后。</li></ul></li><li>传递规则：<ul><li>如果操作A先行发生于操作B,而操作B又先行发生于操作C,则可以得出操作A先行发生于操作C</li></ul></li><li>线程启动规则(Thread Start Rule):<ul><li>Thread对象的start)方法先行发生于此线程的每一个动作，先start才能执行线程内的内容</li></ul></li><li>线程中断规则(Thread Interruption Rule):<ul><li>对线程interrupt)方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>可以通过Thread.interrupted()检测到是发生中断</li><li>也就是说你要先调用interrupt(()方法设置过中断标志位，我才能检测到中断发送</li></ul></li><li>线程终止规则(Thread Termination Rule):<ul><li>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过isAlive等手段检测线程是否已经终止执行。</li></ul></li><li>对象终结规则(Finalizer Rule):<ul><li>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</li></ul></li></ol><h3 id="happens-before-小总结"><a href="#happens-before-小总结" class="headerlink" title="happens-before-小总结"></a>happens-before-小总结</h3><p>在Java语言里面，Happens-Before的语义本质上是一种<font color="cornflowerblue">可见性</font></p><p>A Happens-Before B意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里。</p><p><font color="red">可见性以及在结果相同的情况下允许重排</font></p><p>JMM的设计分为两部分：</p><ul><li>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了。</li><li>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提高性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序。我们只需要关注前者就好了，也就是理解happens-before规则即可，其它繁杂的内容有JMM规范结合操作系统给我们搞定，我们只写好代码即可。</li></ul><h2 id="happens-before案例引出volatile"><a href="#happens-before案例引出volatile" class="headerlink" title="happens-before案例引出volatile"></a>happens-before案例引出volatile</h2><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设存在线程A和B，线程A先（时间上的先后）调用了setValue()，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值<br>是什么？</p><p><strong>分析过程：</strong></p><p>我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8可以忽略，因为他们和这段代码毫无关系）：</p><ul><li>1由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则：</li><li>2两个方法都没有使用锁，所以不满足锁定规则：</li><li>3变量不是用volatile修饰的，所以volatile变量规则不满足；</li><li>4传递规则肯定不满足；</li></ul><p>所以我们<strong>无法通过happens-before原则推导出线程A happens-before线程B</strong>，虽然可以确认在时间上线程A优先于线程B指定，但就是无法确认线程B获得的结果是什么，所以<strong>这段代码不是线程安全的</strong>。那么怎么修复这段代码呢？</p><p><strong>解决办法：</strong></p><ul><li>把getter和setter方法都定义为synchronized方法<ul><li>但是锁太重，虽然保证了程序的安全性，但是极大的影响了并发量</li><li>把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用：把value定义为volatile变量，由于setter方法对value的修政不依赖value的原值，满足volatile关健字使用场景</span></span><br><span class="line"><span class="comment"> * 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性结合使用锁和volatile变量来减少同步的开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//利用volatile保证读取操作的可见性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++value;<span class="comment">//利用synchronized保证复合操作的原子性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h2><p>都是自己的回答</p><ul><li>你知道什么是Java内存模型JMM吗？<ul><li>java内存模型JMM是一组抽象的概念，是并不真实存在的一组约定或规范，通过这组规范定义了各个变量的读写访问方式以及一个线程对共享变量的修改以及何时对另一个线程可见</li></ul></li><li>JMM与volatile它们两个之间的关系？（下一章详细讲解）<ul><li>volatile底层是借助JMM插入内存屏障实现可见性和有序性的，但是volatile并不满足原子性</li></ul></li><li>JMM有哪些特性？它的三大特性是什么？<ul><li>可见性、原子性、有序性</li></ul></li><li>为什么要有JMM,它为什么出现？作用和功能是什么？<ul><li>因为CPU和主内存的访问速度不一致，所以通过JMM实现线程和主内存之间的抽象模型，并且屏蔽掉各硬件平台和操作系统的内存访问差异，让Java程序能够在各平台上达到一致的内存访问效果</li></ul></li><li>happens-before先行发生原则你有了解过吗？<ul><li>如果一个操作先行发生于另一个操作，那么先发生的这个操作的执行结果对另一个操作是可见的，并且它的执行顺序在另一个操作的前面</li><li>但是执行顺序也不是一定的，若是重排序后的执行结果和遵循先行发生原则制定的执行顺序的执行结果一致的话，那么这个重排序并不非法</li></ul></li></ul><h1 id="volatile与JMM"><a href="#volatile与JMM" class="headerlink" title="volatile与JMM"></a>volatile与JMM</h1><h2 id="volatile只满足两大特性"><a href="#volatile只满足两大特性" class="headerlink" title="volatile只满足两大特性"></a>volatile只满足两大特性</h2><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><ul><li><strong>当写一个volatile变量时</strong>，JMM会把该线程对应的本地内存中的共享变量值<font color="red">立即刷新回主内存</font>中。<ul><li>实现：写完后，加上写屏障，强制刷新到主内存中</li></ul></li><li><strong>当读一个volatile变量时</strong>，JMM会把该线程对应的<font color="red">本地内存设置为无效，重新回到主内存中读取最新共享变量</font><ul><li>实现：读前，加上读屏障，保证屏障后的读取能读到最新值</li></ul></li><li><font color="cornflowerblue">所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</font></li></ul><h3 id="有序性（禁重排）"><a href="#有序性（禁重排）" class="headerlink" title="有序性（禁重排）"></a>有序性（禁重排）</h3><ul><li><font color="red">即volatile禁止重排</font></li></ul><p>可见性和有序性的定义看前面的JMM部分中的详细说明</p><h3 id="字节码分析volatile为什么可以保证可见性和有序性？"><a href="#字节码分析volatile为什么可以保证可见性和有序性？" class="headerlink" title="字节码分析volatile为什么可以保证可见性和有序性？"></a>字节码分析volatile为什么可以保证可见性和有序性？</h3><p><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230716162542528.png" alt="image-20230716162542528"></p><p>底层使用<font color="red">内存屏障Memory Barrier</font>指令实现，内存屏障部分细讲</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="&#x3D;&#x3D;内存屏障&#x3D;&#x3D;"></a>&#x3D;&#x3D;内存屏障&#x3D;&#x3D;</h2><p>写完后立即刷新回主内存并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见</p><p>有序（禁重排）<br>重排序<br>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序<br>不存在数据依赖关系，可以重排序；<br><font color="red">存在数据依赖关系，禁止重排序</font><br>但重排后的指令绝对不能改变原有的串行语义！<font color="red">这点在并发设计中必须要重点考虑！</font></p><h3 id="内存屏障是什么？"><a href="#内存屏障是什么？" class="headerlink" title="内存屏障是什么？"></a>内存屏障是什么？</h3><p>内存屏障：是<strong>一种屏障指令</strong>，它使得CPU或编译器对<strong>屏障指令的前</strong> 和 <strong>后</strong>所发出的内存操作执行一个排序的约束。也叫内存栅栏或栅栏指令，避免了代码重排序。</p><p>内存屏障其实就是一种JVM指令，Java内存模型的重排规则会<font color="red">要求Java编译器在生成JVM指令时插入特定的内存屏障指令</font>，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性（禁重排），<font color="red">但volatile无法保证原子性。</font></p><h3 id="写屏障与读屏障"><a href="#写屏障与读屏障" class="headerlink" title="写屏障与读屏障"></a>写屏障与读屏障</h3><p><strong>粗分读写两种：</strong></p><ul><li><font color="cornflowerblue">读屏障(Load Barrier)</font><ul><li>在<strong>读指令之前</strong>插入读屏障，<strong>让工作内存或CPU高速缓存当中的缓存数据失效</strong>，重新回到主内存中获取最新数据</li></ul></li><li><font color="cornflowerblue">写屏障(Store Barrier）</font><ul><li>在<strong>写指令之后</strong>插入写屏障，<strong>强制把写缓冲区的数据刷回到主内存中</strong></li></ul></li></ul><p><strong>细分四种：</strong></p><table><thead><tr><th>LoadLoad</th><th>Load1;LoadLoad;Load2</th><th>保证load1的读取操作在load2及后续读取操作之前执行</th></tr></thead><tbody><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在store.2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在stroe2及其后的写操作执行前，保证load1的读操作已读取结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td></tr></tbody></table><p>底层又追溯到UnSafe.cpp和汇编语言，不多赘述</p><h3 id="为什么能保证可见性？"><a href="#为什么能保证可见性？" class="headerlink" title="为什么能保证可见性？"></a>为什么能保证可见性？</h3><p><strong>内存屏障包括写屏障和读屏障</strong></p><p><font color="cornflowerblue">内存屏障之<strong>前</strong></font>的所有<font color="red"><em><strong>写操作</strong></em></font>都要<font color="red">回写到主内存，</font></p><p><font color="cornflowerblue">内存屏障之<strong>后</strong></font>的所有<font color="red"><em><strong>读操作</strong></em></font>都能<font color="red">获得</font>内存屏障之前的所有写操作的<font color="red">最新结果</font>（实现了可见性）。</p><ul><li><font color="cornflowerblue">读屏障(Load Barrier)</font><ul><li>在<strong>读指令之前</strong>插入读屏障，<strong>让工作内存或CPU高速缓存当中的缓存数据失效</strong>，重新回到主内存中获取最新数据</li></ul></li><li><font color="cornflowerblue">写屏障(Store Barrier）</font><ul><li>在<strong>写指令之后</strong>插入写屏障，<strong>强制把写缓冲区的数据刷回到主内存中</strong></li></ul></li></ul><p><strong>看下图，内存屏障将写操作和读操作分隔开了</strong>，因此重排序时，<font color="cornflowerblue">不允许把内存屏障之后的指令重排序到内存屏障之前</font>。一句话：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读。</p><p><strong>图示：</strong></p><p><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230715233142140.png" alt="image-20230715233142140"></p><p><strong>volatile变量读写过程图示：</strong></p><p><strong><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230716001532715.png" alt="image-20230716001532715"></strong></p><blockquote><p>可见，写屏障前，强制刷新内存时，因为不能保证原子性所以<font color="red">对变量的写操作必须加锁</font>，而<strong>加锁会清空工作线程中副本变量的值</strong>，导致需要重新加载，这就是为什么读屏障后本地缓存失效的原因，因此才能读到最新值</p></blockquote><h3 id="为什么能保证有序性？"><a href="#为什么能保证有序性？" class="headerlink" title="为什么能保证有序性？"></a>为什么能保证有序性？</h3><ul><li><font color="red">当第一个操作为volatile读</font>时，不论第二个操作是什么，都<font color="red">不能重排序</font>。<font color="cornflowerblue">volatile读之后的操作，都禁止重排序到volatile之前</font><ul><li>在每个volatile读操作的后面插入一个<strong>LoadLoad</strong>屏障，禁止处理器把上面的volatile读与下面的普通读重排序。</li><li>在每个volatile读操作的后面再插入一个<strong>LoadStore</strong>屏障，禁止处理器把上面的volatile读与下面的普通写重排序。</li></ul></li><li><font color="red">当第二个操作为volatile写</font>时，不论第一个操作是什么，都<font color="red">不能重排序</font>。<font color="cornflowerblue">volatile写之前的操作，都禁止重排序到volatile之后</font></li><li>在每个volatile写操作的前面插入一个<strong>StoreStore</strong>屏障，保证在volatile写之前其前面的所有普通写操作都已经刷新到主内存中。<ul><li>在每个volatile写操作的后面插入一个<strong>StoreLoad</strong>屏障，避免volatile写与后面可能有的volatile读&#x2F;写操作重排序</li></ul></li></ul><p><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230716151531907.png" alt="image-20230716151531907"></p><ul><li><font color="red">当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</font><ul><li>已在 为什么能保证可见性 部分中的 第一张图示 前说到、</li></ul></li><li>除上面三种情况外，即除第一个操作是volatile读、第二个操作是volatile写、volatile写读这三种情况外，其他情况都允许重排</li></ul><h3 id="为什么不能保证原子性？"><a href="#为什么不能保证原子性？" class="headerlink" title="为什么不能保证原子性？"></a>为什么不能保证原子性？</h3><p><strong>代码案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="comment">//共享数据，是存储在共享主内存中的</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNumber</span><span class="params">()</span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myNumber.addNumber();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(myNumber.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JUC03/../../image/JUC03.assets/image-20230716140721781.png" alt="image-20230716140721781"></p><p>对于volatile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，<font color="red">也仅是数据加载时是最新的</font>。但是多线程环境下，”数据计算”和”数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存中的操作将会作废去读主内存最新值，操作出现写丢失问题。即<font color="red"><strong>各线程私有内存和主内存公共内存中变量不同步</strong></font>，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，<font color="red">但无法保证原子性，对于多线程修改主内存共享变量的场景必须使用加锁同步。</font></p><p><strong>我的理解：</strong></p><ul><li>number++操作反编译出的指令中<strong>一共有三条指令</strong>来完成这个操作</li><li>而volatile因为满足可见性，所以这三条指令中的第一条指令拿到的值一定是最新的</li><li>可是因为有多条指令，本线程执行到第二条或者第三条指令的时候，其他线程已经提交了一次修改到共享主内存中</li><li>所以有序性使得本线程的工作内存中的正在执行的数据失效，造成本次循环失效</li><li>本线程重新从共享主内存加载新的数据，开始下一次循环操作，造成写丢失</li></ul><p>可见性只是读取的时候从主内存中读最新的，已经读到后进行后续操作的过程中主内存可能有更新了，造成一次循环失效</p><p><strong>number++字节码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field number:I//拿到原始值</span></span><br><span class="line"><span class="number">5</span>: iconst_1</span><br><span class="line"><span class="number">6</span>: iadd<span class="comment">//+1</span></span><br><span class="line"><span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field number:I//写回</span></span><br></pre></td></tr></table></figure><p><strong>volatile变量不适合参与到依赖当前值的运算</strong>，如：i&#x3D;i+1；i++;之类的</p><p><strong>那么依靠可见性的特点volatile可以用在哪些地方呢？</strong></p><p><font color="red">通常volatile用做保存某个状态的boolean值or int值。</font></p><blockquote><p>《深入理解Java虚拟机》提到：</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized、java.util.concurrent中的锁或原子类)来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul></blockquote><h2 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h2><ul><li><p>单一赋值可以，but含复合运算赋值不可以(i++之类)</p><ul><li>volatile int a &#x3D; 10;或volatile boolean flag &#x3D; false;</li></ul></li><li><p>状态标志判断业务是否结束</p><ul><li>作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束</li><li>类似于JUC02中使用volatile实现线程中断停止</li></ul></li><li><p>开销较低的读，写锁策略</p><ul><li>当读远多于写，结合使用内部锁和volatile变量来减少同步的开销</li><li>用volatile保证读取操作的可见性；利用synchronized或lock保证复合操作的原子性</li><li>即前面的happens-before案例引出volatile 中的案例</li></ul></li><li><p>AtomicReferenceFieldUpdater属性修改原子类中要更新的属性必须是public volatile修饰的（JUC04中原子类中讲解）</p></li><li><p>单例模式双端锁</p><ul><li><p>对象的创建过程有多个步骤，详情看我的JVM笔记-《对象的创建和执行引擎》，多个步骤之间可能被重排</p></li><li><pre><code class="java">/** * 单例模式双端锁需要使用volatile */public class SafeDoubleCheckSingleton &#123;    //通过volatile声明，实现线程安全的延迟初始化。    private volatile static SafeDoubleCheckSingleton singleton;    //私有化构造方法    private SafeDoubleCheckSingleton()&#123;&#125;    /**     * 其中实例化Singleton分多步执行（分配内存空间、初始化对象、将对象指向分配     * 的内存空间)，某些编译器为了性能原因，会将第二步和第三步进行重排序（分配内存空     * 间、将对象指向分配的内存空间、初始化对象)。这样，某个线程可能会获得一个未完全     * 初始化的实例。     */    //双重锁设计    public static SafeDoubleCheckSingleton getInstance()&#123;        if (singleton == null)&#123;            //1.多线程并发剑建对象时，会通过加锁保证只有一个线程能创建对象            synchronized (SafeDoubleCheckSingleton.class)&#123;                if (singleton == null)&#123;                    //隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取                    //解决隐患原理：利用volatile，禁止&quot;初始化对象&quot;和&quot;设置singleton:指向内存空间&quot;的重排序                    singleton = new SafeDoubleCheckSingleton();                &#125;            &#125;        &#125;        //2.对象刻建完毕，执行getInstance()将不需要茨取锁，直接返回创建对象        return singleton;    &#125;&#125;</code></pre></li></ul></li></ul><h2 id="volatile使用内存屏障实现小总结"><a href="#volatile使用内存屏障实现小总结" class="headerlink" title="volatile使用内存屏障实现小总结"></a>volatile使用内存屏障实现小总结</h2><p>volatile底层使用内存屏障实现可见性和有序性，当字节码生成机器码时，发现ACC_VOLATILE时，会根据JMM规范，在相应位置插入内存屏障：</p><ul><li>volatile读之后的操作，都禁止重排序到volatile之前</li><li>volatile写之前的操作，都禁止重排序到volatile之后</li><li>volatile写之后volatile读，禁止重排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC02</title>
      <link href="/blog/JUC02/"/>
      <url>/blog/JUC02/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC02"><a href="#JUC02" class="headerlink" title="JUC02"></a>JUC02</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li><p>多线程锁各种锁的概览</p><ul><li><font color="red">获得所得流程</font></li></ul></li><li><p><font color="red">线程中断机制</font></p></li><li><p><font color="red">LockSupport的pork替换wait和await方法</font></p></li></ul><h1 id="多线程锁"><a href="#多线程锁" class="headerlink" title="多线程锁"></a>多线程锁</h1><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><ul><li><p><strong>悲观锁</strong></p><ul><li><p>显式的<font color="red">锁定之后再操作同步资源</font></p></li><li><p>适合<strong>写操作多</strong>的场景，先加锁可以保证写操作时数据正确。</p></li><li><p><font color="cornflowerblue">synchronized</font>关键字和<font color="cornflowerblue">lock</font>的实现类都是采用悲观锁</p></li></ul></li><li><p><strong>乐观锁</strong></p></li><li><p>认为自己在使用数据时<font color="red">不会有别的线程修改数据或资源</font>，所以不会添加锁。</p></li><li><p>在Java中是通过使用<font color="cornflowerblue">无锁编程</font>来实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。</p><ul><li><p>如果这个数据没有被更新，当前线程将自己修改的数据成功写入。</p></li><li><p>如果这个数据己经被其它线程更新，则根据不同的实现方式执行不同的操作，比如放弃修改、重试抢锁等等</p></li></ul></li><li><p>判断规则</p><ul><li><p>1 版本号机制Version</p></li><li><p>2<font color="red"> 最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</font></p></li></ul></li><li><p>适合<strong>读操作多</strong>的场景，不加锁的特点能够使其读操作的性能大幅提升。</p></li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized-8锁案例演示"><a href="#synchronized-8锁案例演示" class="headerlink" title="synchronized 8锁案例演示"></a>synchronized 8锁案例演示</h3><p>阿里开发手册：</p><blockquote><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。<strong>能用无锁数据结构，就不要用锁</strong>；<strong>能锁区块，就不要锁整个方法体</strong>；<strong>能用对象锁，就不要用类锁</strong>。</p><p>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</p></blockquote><p>先说结论：</p><ul><li>作用于<font color="cornflowerblue">实例方法</font>，当前实例加锁，进入同步代码前要获得当前实例的锁；</li><li>作用于<font color="cornflowerblue">代码块</font>，对括号里配置的对象加锁。</li><li>作用于<font color="cornflowerblue">静态方法</font>，当前类加锁，进去同步代码前要获得当前类对象的锁；</li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：谈谈你对多线程锁的理解,8锁案例说明</span></span><br><span class="line"><span class="comment"> * 口诀：线程   操作  资源类</span></span><br><span class="line"><span class="comment"> * 8锁案例说明：</span></span><br><span class="line"><span class="comment"> * 1 标准访问有ab两个线程，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 2 sendEmail方法中加入暂停3秒钟，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 3 添加一个普通的hello方法，请问先打印邮件还是hello</span></span><br><span class="line"><span class="comment"> * 4 有两部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 5 有两个静态同步方法，有1部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 6 有两个静态同步方法，有2部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 7 有1个静态同步方法，有1个普通同步方法,有1部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 8 有1个静态同步方法，有1个普通同步方法,有2部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 笔记总结：</span></span><br><span class="line"><span class="comment"> * 1-2</span></span><br><span class="line"><span class="comment"> * 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span></span><br><span class="line"><span class="comment"> * 其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法</span></span><br><span class="line"><span class="comment"> * 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span></span><br><span class="line"><span class="comment"> * 3-4</span></span><br><span class="line"><span class="comment"> * 加个普通方法后发现和同步锁无关</span></span><br><span class="line"><span class="comment"> * 换成两个对象后，不是同一把锁了，情况立刻变化。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 5-6 都换成静态同步方法后，情况又变化</span></span><br><span class="line"><span class="comment"> * 三种 synchronized 锁的内容有一些差别:</span></span><br><span class="line"><span class="comment"> * 对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——&gt;实例对象本身，</span></span><br><span class="line"><span class="comment"> * 对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板</span></span><br><span class="line"><span class="comment"> * 对于同步方法块，锁的是 synchronized 括号内的对象</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 7-8</span></span><br><span class="line"><span class="comment"> * 当一个线程试图访问同步代码时它首先必须得到锁，正常退出或抛出异常时必须释放锁。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this</span></span><br><span class="line"><span class="comment"> * 也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class</span></span><br><span class="line"><span class="comment"> * 具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的</span></span><br><span class="line"><span class="comment"> * 但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span> &#123;</span><br><span class="line">    <span class="comment">//一切程序的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒,保证a线程先启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//phone.sendSMS();</span></span><br><span class="line">            <span class="comment">//phone.hello();</span></span><br><span class="line">            phone2.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized字节码分析"><a href="#synchronized字节码分析" class="headerlink" title="synchronized字节码分析"></a>synchronized字节码分析</h3><p>编译后找到项目下out文件夹，从需要反编译的文件处打开终端，使用以下命令进行反编译 .class 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javap -c ****.class</span><br><span class="line"></span><br><span class="line">//假如你需要更多信息</span><br><span class="line">javap -v ****.class</span><br></pre></td></tr></table></figure><p><strong>1 synchronized同步代码块</strong></p><ul><li><p>实现使用的是<strong>monitorenter</strong>和<strong>monitorexit</strong>指令</p></li><li><p>一般情况就是1个enter对应2个exit</p><ul><li>当正常处理时会有一个monitorexit，考虑到当发生异常时，也应该有一个monitorexit</li></ul></li><li><p>极端情况下：m1方法里面自己添加一个异常，只会有一个exit</p></li></ul><p><strong>一般情况下：</strong></p><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714154848428.png" alt="image-20230714154848428"></p><p><strong>自己添加异常</strong></p><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714154932879.png" alt="image-20230714154932879"></p><p><strong>2 synchronized普通同步方法</strong></p><ul><li>调用指令将会检查方法的<strong>ACC_SYNCHRONIZED</strong>访问标志是否被设置如果设置了，执行线程会将先持有monitor锁，然后再执行方法，<strong>最后在方法完成（无论是正常完成还是非正常完成）时释放monitor</strong></li></ul><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714155624251.png" alt="image-20230714155624251"></p><p><strong>3 synchronized静态同步方法</strong></p><ul><li>调用指令将会检查方法的<strong>ACC_STATIC</strong>和<strong>ACC_SYNCHRONIZED</strong>访问标志是否被设置如果设置了</li></ul><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714155833992.png" alt="image-20230714155833992"></p><h3 id="为什么任何一个对象都可以成为一个锁？"><a href="#为什么任何一个对象都可以成为一个锁？" class="headerlink" title="为什么任何一个对象都可以成为一个锁？"></a>为什么任何一个对象都可以成为一个锁？</h3><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714165537334.png" alt="image-20230714165537334"></p><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714161122065.png" alt="image-20230714161122065"></p><p>Java中的锁是通过对象的内部监视器（也称为内置锁或监视器锁）来实现的。每个对象都有一个与之关联的内部监视器，这个监视器在多线程环境下用于控制对对象的访问。当一个线程希望获取一个对象的锁时，它会尝试进入该对象的同步代码块或同步方法。如果锁没有被其他线程持有，那么这个线程就会成功获取锁，否则它将被阻塞，直到锁被释放为止。</p><p>由于每个对象都有一个内部监视器，所以任何对象都可以用作锁。这意味着你可以使用任何对象来实现同步，只要它在多个线程之间共享并且是唯一的。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul><li><p>公平锁</p><ul><li><p>是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买后来的人在队尾排着，这是公平的</p></li><li><p>Lock lock&#x3D;new ReentrantLock(true);&#x2F;&#x2F;true<font color="red">表示公平锁，先来先得</font></p></li></ul></li><li><p>非公平锁</p><ul><li>多个线程抢占锁，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，<strong>有可能造成优先级翻转或者饥饿的状态</strong>（某个线程一直得不到锁）</li><li>Lock lock&#x3D;new ReentrantLock(false);&#x2F;&#x2F;false<font color="red">表示非公平锁，后来的也可能先获得锁</font></li><li>Lock lock&#x3D;new ReentrantLock();&#x2F;&#x2F;默认非公平锁</li></ul></li></ul><h4 id="为什么会有公平锁-非公平锁的设计？为什么默认非公平？"><a href="#为什么会有公平锁-非公平锁的设计？为什么默认非公平？" class="headerlink" title="为什么会有公平锁&#x2F;非公平锁的设计？为什么默认非公平？"></a>为什么会有公平锁&#x2F;非公平锁的设计？为什么默认非公平？</h4><p>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。</p><p>所以<font color="red">非公平锁能更充分的利用CPU的时间片，尽量<strong>减少CPU空闲状态时间</strong></font>。</p><p>使用多线程很重要的考量点是<strong>线程切换的开销</strong>，当采用非公平锁时，<font color="red">当1个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就<strong>减少了线程的开销</strong>。</font></p><h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2><p><strong>可重入锁又名递归锁</strong></p><ul><li>是指在<font color="cornflowerblue">同一个线程</font>在外层方法获取锁的时候，再进入该线程的内层方法会<font color="cornflowerblue">自动获取锁</font>（<strong>前提，锁对象得是同一个对象</strong>），不会因为之前已经获取过还没释放而阻塞。</li><li>如果是1个有synchronized修饰的递归调用方法，<font color="cornflowerblue">程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。</font></li><li>所以<font color="red">Java中ReentrantLock和synchronized都是可重入锁</font>，可重入锁的一个优点是可一定程度避免死锁。</li></ul><p><strong>隐式锁：即synchronized使用的锁</strong></p><ul><li>指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。</li><li>简单的来说就是：<font color="red">在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</font></li></ul><p><strong>显式锁：即ReentrantLock</strong></p><ul><li><p>需要显示指定</p></li><li><p>lock几次，就需要unlock几次，否则会让其他线程无法获得锁造成卡死</p></li></ul><p><strong>Synchronized的重入的实现机理</strong></p><ul><li><font color="red">每个锁对象拥有一个<strong>锁计数器（_count 和 _recursions）</strong>和一个指向持有该锁的线程的<strong>指针（_owner）</strong>。</font>（记录在对象的对象头中）</li><li>当执行monitorenterl时，如果目标锁对象的_count 为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</li><li>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器_count 和 _recursions加1，否则需要等待，直至持有线程释放该锁。</li><li>当执行monitorexit指令时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li></ul><p>具体全部过程可在小总结中查看</p><p><strong>可重入锁案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可重入锁（递归锁）：多层锁机制只需要同一把锁即可自由出入</span></span><br><span class="line"><span class="comment">         * synchronized(隐式)    lock(显式)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//synchronized可重入锁演示1：</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;外层&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;中层&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;内层&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//synchronized可重入锁演示2：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SyncLockDemo</span>().add();   <span class="comment">//将会报栈内存溢出，证明可以递归调用add方法自己，是可重入锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock演示可重入锁       递归使用锁必须一上锁对应一解锁，加入内部锁上锁了不解锁，自己线程使用会没问题，但是会影响其它线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 外层&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//上锁</span></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种<font color="red">互相等待的现象</font>，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><blockquote><p>死锁的构成条件等，可以在《MySQL事务篇》中详细查看</p><ol><li>资源互斥</li><li>持有和保持</li><li>不可被剥夺</li><li>循环等待</li></ol><p>打破死锁：只需要以上四个条件不满足其一就可防止构成死锁</p></blockquote><p><strong>排查死锁</strong></p><ul><li><pre><code>jps -ljstack 进程id<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用jconsole -&gt; 线程 -&gt; 检测死锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20230711160927379](image/JUC02.assets/image-20230714161122066.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**手写一个死锁案例**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 死锁：两个或者两个以上进程在执行过程中，因为争夺资源而造成一种互相等待的现象，如果设有外力干涉，他们无法再执行下去</span><br><span class="line"> * </span><br><span class="line"> * 死锁的验证方式：第一步：jps  第二步：jstack 进程号</span><br><span class="line"> *              方式2：jvisual VM</span><br><span class="line"> */</span><br><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    </span><br><span class="line">    //先创建两个对象充当两把锁</span><br><span class="line">    static Object a = new Object();</span><br><span class="line">    static Object b = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (a)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;持有锁a，试图获取锁b&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (b)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;获取锁b&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (b)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;持有锁b，试图获取锁a&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (a)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;获取锁a&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="小总结：获得锁的全流程（重要）"><a href="#小总结：获得锁的全流程（重要）" class="headerlink" title="&#x3D;&#x3D;小总结：获得锁的全流程（重要）&#x3D;&#x3D;"></a>&#x3D;&#x3D;小总结：获得锁的全流程（重要）&#x3D;&#x3D;</h2><p>指针指向<strong>monitor对象</strong>（也称为<strong>管程或监视器锁</strong>）的起始地址。<strong>每个对象都存在着一个monitor与之关联</strong>，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由<strong>ObjectMonitor</strong>实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><p>ObjectMonitor.hpp在目录 <code>为什么任何一个对象都可以成为一个锁？</code> 中提到过</p><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714170452735.png" alt="image-20230714170452735"></p><h2 id="后续锁的知识"><a href="#后续锁的知识" class="headerlink" title="后续锁的知识"></a>后续锁的知识</h2><p>synchronized锁升级将在《JUC06》中讲解</p><p>lock QAS将在《JUC07》中讲解</p><p>lock锁的发展过程将在《JUC08》中讲解</p><h1 id="LockSupport与线程中断"><a href="#LockSupport与线程中断" class="headerlink" title="LockSupport与线程中断"></a>LockSupport与线程中断</h1><h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p><strong>什么是中断机制？</strong></p><p>首先</p><p>一个线程不应该由其他线程来强制中断或停止，而是<font color="red">应该由线程自己自行停止</font>，自己来决定自己的命运。</p><p>所以，<strong>Thread.stop,Thread.suspend,Thread.resume</strong>都己经被废弃了。</p><p>其次</p><p>在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。</p><p>因此，Java提供了一种用于停止线程的<font color="cornflowerblue">协商机制</font>——中断，也即<strong>中断标识协商机制</strong>。</p><p><font color="red">中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</font></p><p>若要中断一个线程，你需要手动调用该线程的interrupt方法，<font color="red">该方法也仅仅是将线程对象的<strong>中断标识设成true</strong>;</font></p><p>接着你需要自己写代码不断地检测当前线程的标识位，如果为tue,表示别的线程请求这条线程中断，</p><p>此时究竞该做什么需要你自己写代码实现。</p><p>每个线程对象中都有一个中断标识位，用于表示线程是否被中断；该标识位为tue表示中断，为false表示未中断：</p><p><font color="red"><strong>通过调用线程对象的interrupt方法将该线程的标识位设为true;可以在别的线程中调用，也可以在自己的线程中调用</strong></font>。</p><h2 id="中断机制API-的三大方法"><a href="#中断机制API-的三大方法" class="headerlink" title="中断机制API 的三大方法"></a>中断机制API 的三大方法</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><table><thead><tr><th>public void interrupt()</th><th><font color="cornflowerblue">实例方法</font>，Just to set the interrupt <br>实例方法interrupt()仅仅是<font color="red">设置线程的中断状态为true，发起一个协商而不会立刻停止线程</font></th></tr></thead><tbody><tr><td>public static boolean interrupted()</td><td><font color="cornflowerblue">静态方法</font>，Thread.interrupted();<br><font color="red">判断线程是否被中断并清除当前中断状态。</font><br>这个方法做了两件事：<br><font color="red">1返回当前线程的中断状态，测试当前线程是否已被中断</font><br><font color="red">2将当前线程的中断状态清零并重新设为false,清除线程的中断状态</font><br><br><font color="red">如果连续两次调用此方法，则第二次调用将返回false,因为连续调用两次的结果可能不一样</font></td></tr><tr><td>public boolean isInterrupted()</td><td><font color="cornflowerblue">实例方法</font>，<br>判断当前线程是否被中断（通过检查中断标志位）</td></tr></tbody></table><h3 id="interrupt-详解与演示"><a href="#interrupt-详解与演示" class="headerlink" title="interrupt()详解与演示"></a>interrupt()详解与演示</h3><p><font color="cornflowerblue">具体来说，当对一个线程，调用interrupt()时：</font></p><ul><li>①如果线程处于<font color="red"><strong>正常活动状态</strong></font>，那么会将该线程的中断标志设置为tue,<font color="red">仅此而已</font>。</li></ul><p>​<font color="red">被设置中断标志的线程将继续正常运行，不受影响。</font></p><p>​所以，interrupt并不能真正的中断线程，需要被调用的线程自己进行配合才行。</p><p>​<font color="red">若<strong>线程结束</strong>，中断标志会被重置，即false</font></p><p>​中断只是一种协商机制，修改中断标识位仅此而己，不是立刻stop打断</p><ul><li>②如果线程处于<font color="red"><strong>被阻塞状态</strong></font>（例如处于sleep,wait,join等状态），在别的线程中调用当前线程对象的interrupt方法，</li></ul><p>​那么线程将<font color="red">立即退出被阻塞状态，中断标志被清空为false，并抛出一个InterruptedException异常，导致无限循环</font>。</p><p>​需要在异常处理catch中再次调用interrupt()</p><p><strong>正常活动状态案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正常活动状态案例演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识02：&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程默认的中断标识：&quot;</span> + t1.isInterrupted());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t1.interrupt();<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识01：&quot;</span> + t1.isInterrupted());<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识03：&quot;</span> + t1.isInterrupted());<span class="comment">//????---false中断不活动的线程不会产生任何影响。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">t1线程调用interrupt()后的的中断标识01：true</span><br><span class="line">...</span><br><span class="line">t1线程调用interrupt()后的的中断标识02：true</span><br><span class="line">t1线程调用interrupt()后的的中断标识03：false</span><br></pre></td></tr></table></figure><p><strong>被阻塞状态案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 中断标志位，默认false</span></span><br><span class="line"><span class="comment"> * 2 t2 ----&gt; t1发出了中断协商，t2调用t1.interrupt()，中断标志位true</span></span><br><span class="line"><span class="comment"> * 3 中断标志位true，正常情况，程序停止，^_^</span></span><br><span class="line"><span class="comment"> * 4 中断标志位true，异常情况，InterruptedException，将会把中断状态将被清除，并且将收到InterruptedException 。中断标志位false</span></span><br><span class="line"><span class="comment"> *    导致无限循环</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5 在catch块中，需要再次给中断标志位设置为true，2次调用停止程序才OK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;中断标志位：&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot; 程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//设置线程为阻塞状态，即上述第4点</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();<span class="comment">//需要再次自己在catch中调用interrupt()，否则无限循环</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;----------hello InterruptDemo3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t1.interrupt(),<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interrupted-相较于isInterrupted"><a href="#interrupted-相较于isInterrupted" class="headerlink" title="interrupted()相较于isInterrupted()"></a>interrupted()相较于isInterrupted()</h3><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714211323669.png" alt="image-20230714211323669"></p><p>可以看到两个方法底层都是调用同一份native方法，“中断状态将会根据传入的<strong>Clearlnterrupted</strong>参数值确定是否重置”。</p><ul><li>所以，静态方法interrupted将会清除中断状态（传入的参数Clearlnterrupted为true),</li><li>实例方法isInterrupted则不会（传入的参数Clearlnterrupted.为false)。</li></ul><p><strong>案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，</span></span><br><span class="line">        <span class="comment">// 第二次再调用时中断状态已经被清除，将返回一个false。</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;----1&quot;</span>);</span><br><span class="line">        Thread.currentThread().interrupt();<span class="comment">// 中断标志位设置为true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----2&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + Thread.interrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="中断或停止运行中的线程的方法"><a href="#中断或停止运行中的线程的方法" class="headerlink" title="中断或停止运行中的线程的方法"></a>中断或停止运行中的线程的方法</h2><h3 id="通过volatile或AtomicBoolean实现停止"><a href="#通过volatile或AtomicBoolean实现停止" class="headerlink" title="通过volatile或AtomicBoolean实现停止"></a>通过volatile或AtomicBoolean实现停止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过volatile或AtomicBoolean实现中断停止线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicBoolean</span> <span class="variable">atomicBoolean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (atomicBoolean.get())&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t atomicBoolean 被修改未true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1---------hello atomicBoolean&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicBoolean.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1_volatile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isStop)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t isStop 被修改未true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1---------hello volatile&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            isStop = <span class="literal">true</span>;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过interrupt实现中断"><a href="#通过interrupt实现中断" class="headerlink" title="通过interrupt实现中断"></a>通过interrupt实现中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t isInterrupted() 被修改为true，程序停止&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1---------hello isInterrupted()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h2 id="如何中断或停止一个运行中的线程？"><a href="#如何中断或停止一个运行中的线程？" class="headerlink" title="&#x3D;&#x3D;如何中断或停止一个运行中的线程？&#x3D;&#x3D;"></a>&#x3D;&#x3D;如何中断或停止一个运行中的线程？&#x3D;&#x3D;</h2><p><img src="https://www.hahhome.top/blog/JUC02/../../image/JUC02.assets/image-20230714171511553.png" alt="image-20230714171511553"></p><p><strong>停止：</strong></p><ul><li>使用volatile或AtomicBoolean时，将他们的变量或实例设置为true，让线程中断</li><li>线程自己自行停止是否停止线程，自己来决定自己的命运。所以，<strong>Thread.stop,Thread.suspend,Thread.resume</strong>都己经被废弃了。</li></ul><p><strong>中断：</strong></p><ul><li>使用interrupt()方法设置中断标志为true，并由线程自己配合进行中断停止</li></ul><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport中的park()和unpark()的作用分别是阻塞线程和解除阻塞线程</p><h3 id="让线程等待和唤醒的方法"><a href="#让线程等待和唤醒的方法" class="headerlink" title="让线程等待和唤醒的方法"></a>让线程等待和唤醒的方法</h3><p>即实现线程间通信的方法</p><ul><li><font color="cornflowerblue">方式1：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</font><ul><li>wait方法和notify方法，两个都必须放在同步代码块内，否则抛出异常</li><li>先执行notify，再执行wait方法时，程序无法继续执行，wait线程无法被唤醒</li></ul></li><li><font color="cornflowerblue">方式2：使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</font><ul><li>await方法和signal方法，两个都必须放在同步代码块内，否则抛出异常</li><li>先执行signal，再执行await方法时，程序无法继续执行，wait线程无法被唤醒</li></ul></li><li><font color="red">方式3：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</font><ul><li>解决上面两种方法的问题</li><li>凭证最多只能有1个，累加无效，只能调用一对park()和unpark()</li><li>在同步方法中时，park()不会释放锁，而上面方法的wait()是会释放锁的</li></ul></li></ul><h3 id="使用Object和Condition的限制条件"><a href="#使用Object和Condition的限制条件" class="headerlink" title="使用Object和Condition的限制条件"></a>使用Object和Condition的限制条件</h3><ul><li>线程先要获得并持有锁，必须在锁块（synchronized或Iock）中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object的wait()演示：</span></span><br><span class="line"><span class="comment"> * 1 在同步代码块中先wait再notify：下程序正常运行</span></span><br><span class="line"><span class="comment"> * 2 没有同步代码块：报异常</span></span><br><span class="line"><span class="comment"> * 3 在同步代码块中先notify再wait：wait线程不能被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncWaitNotify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                objectLock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">            objectLock.notify();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Condition的await()演示：</span></span><br><span class="line"><span class="comment"> * 1 在同步代码块中先await再signal：下程序正常运行</span></span><br><span class="line"><span class="comment"> * 2 没有同步代码块：报异常</span></span><br><span class="line"><span class="comment"> * 3 在同步代码块中先ignal再await：await线程不能被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lockAwaitSignal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用LockSupport"><a href="#使用LockSupport" class="headerlink" title="&#x3D;&#x3D;使用LockSupport&#x3D;&#x3D;"></a>&#x3D;&#x3D;使用LockSupport&#x3D;&#x3D;</h3><p>LockSupport是基于<strong>Unsafe</strong>类，由JDK提供的线程操作工具类，主要作用就是挂起线程，唤醒线程。</p><p><strong>park()方法源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span> &#123;</span><br><span class="line">    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>permiti许可证默认没有不能放行，所以一开始调park()方法当前线程就会阻塞，直到别的线程给当前线程的发放permit,park方法才会被唤醒。</p><p><strong>unpark()方法源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用unpark(thread)方法后，就会将thread线程的许可证permit发放，会自动唤醒park线程，即之前阻塞中的LockSupport.park()方法会立即返回。</p><p><font color="red">LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</font></p><p>LockSupport是一个线程阻塞工具类，<strong>所有的方法都是静态方法</strong>，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根结底，LockSupporti调用的Unsafe中的native代码。</p><p><font color="cornflowerblue">LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程</font></p><p>LockSupport和每个使用它的线程都有一个许可(permit)关联：</p><p>每个线程都有一个相关的permit，<font color="cornflowerblue">线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。permiti最多只有一个，重复调用unpark也不会积累凭证</font>。</p><p><font color="cornflowerblue">当调用park()方法时</font></p><ul><li>如果有凭证，则会直接消耗掉这个凭证然后正常退出：</li><li>如果无凭证，就必须阻塞等待凭证可用：</li></ul><p><font color="cornflowerblue">而unpark()则相反</font>，它会增加一个凭证，但<font color="red">凭证最多只能有1个，累加无效。</font></p><p><strong>优缺点总结：</strong></p><ul><li>解决上面两种方法的问题</li><li>凭证最多只能有1个，累加无效，只能调用一对park()和unpark()</li><li><font color="red">在同步方法中时，park()不会释放锁，而上面方法的wait()是会释放锁的</font></li></ul><p><strong>为什么可以突破wait&#x2F;notify的原有调用顺序？</strong></p><p>因为unpark获得了一个凭证，之后再调用pak方法，就可以名正言顺的凭证消费，故不会阻塞。</p><p>先发放了凭证后续可以畅通无阻。</p><p><strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong></p><p>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；</p><p>而调用两次park却需要消费两个凭证，证不够，不能放行。</p><p><strong>案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockSupport的park()演示：</span></span><br><span class="line"><span class="comment"> * 解决其它两个办法的问题</span></span><br><span class="line"><span class="comment"> * 但是：</span></span><br><span class="line"><span class="comment"> *  凭证最多只能有1个，累加无效，只能调用一对park()和unpark()</span></span><br><span class="line"><span class="comment"> *  在同步方法中时，park()不会释放锁，而上面方法的wait()是会释放锁的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----come in&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC01</title>
      <link href="/blog/JUC01/"/>
      <url>/blog/JUC01/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC01"><a href="#JUC01" class="headerlink" title="JUC01"></a>JUC01</h1><h2 id="课程任务概览"><a href="#课程任务概览" class="headerlink" title="课程任务概览"></a>课程任务概览</h2><p><strong>本部分包含：</strong></p><ul><li>多线程的一些基本概念</li><li>Future接口复习</li><li><font color="red">CompletableFuture异步任务</font></li><li>Java8新语法介绍：函数式编程、Chain链式调用、<font color="red">Stream流式编程</font></li></ul><h1 id="多线程的一些概念"><a href="#多线程的一些概念" class="headerlink" title="多线程的一些概念"></a>多线程的一些概念</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p><strong>并发（Concurrent）：</strong></p><ul><li>是在一个实体上的多个事件</li><li>是在一台服务器上“同时”处理多个任务</li><li>同一时刻，其实是只有一个事件在发生</li><li>eg：抢票、秒杀商品</li></ul><p><strong>并行（Parallel）：</strong></p><ul><li>是在不同实体上的多个事件</li><li>是在多台处理器上同时处理多个任务</li><li>同一时刻，大家真的都在做事情，你做你的，我做我的，但是我们都在做</li><li>eg：泡方便面</li></ul><p><img src="https://www.hahhome.top/blog/JUC01/../../image/JUC01.assets/image-20230712195903638.png" alt="image-20230712195903638"></p><h2 id="进程、线程、管程"><a href="#进程、线程、管程" class="headerlink" title="进程、线程、管程"></a>进程、线程、管程</h2><p><strong>进程（Process）：</strong></p><p>简单的说，在系统中运行的一个应用程序就是一个进程，每一个进程都有它自己的内存空间和系统资源。</p><p><strong>线程（Thread）：</strong></p><p>也被称为<font color="red">轻量级进程</font>，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元</p><p>**管程&#x2F;Monitor(监视器)**，<font color="red">也就是我们平时所说的锁</font></p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象（Monitor，管程对象）来实现的，每个对象实例都会有一个Monitor对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object o <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p><blockquote><p>执行线程就要求朱成功持有管程，然后才能热行方法，最后当方法宗成（无论是正常完成还是非正常完成)时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程无法再获取到同一个管程。——JVM第三版</p></blockquote><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><p><strong>用户线程（User Thread）：</strong></p><ul><li>是系统的工作线程，它会完成这个程序需要完成的业务操作。</li><li>一般情况下不做特别说明配置，<font color="red">默认都是用户线程</font></li></ul><p><strong>守护线程（Daemon Thread）：</strong></p><ul><li>是一种特殊的线程<font color="red">为其它线程服务的</font>，在后台默默地完成一些系统性的服务，比如垃圾回收线程就是最典型的例子</li><li>守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，java虚拟机会自动退出。</li></ul><blockquote><p>可以使用 <code>isDaemon()</code>方法判断是否是守护线程，true代表是守护线程</p><p>可以使用<code>setDaemon(true)</code>方法设置为守护线程</p></blockquote><p><font color="red">如果用户线程全部结束，意味着程序需要完成的业务操作已经结束了，守护线程随着JVM一同结束工作</font></p><p><code>setDaemon(true)</code>方法<font color="cornflowerblue">必须在线程start()之前</font>，否则报IllegalThreadStateException</p><h2 id="wait-sleep-的区别"><a href="#wait-sleep-的区别" class="headerlink" title="wait&#x2F;sleep 的区别"></a>wait&#x2F;sleep 的区别</h2><p>1）sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都</p><p>能调用。</p><p>2）<strong>sleep 不会释放锁</strong>，它也不需要占用锁。<strong>wait 会释放锁</strong>，但调用它的前提</p><p>是当前线程占有锁(即代码要在 synchronized 中)。</p><p>3）后续在JUC02中会讲到LockSupport类的静态方法park()，<strong>park()不会释放锁</strong></p><p>4）它们都可以被 interrupt() 方法中断。</p><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="&#x3D;&#x3D;CompletableFuture&#x3D;&#x3D;"></a>&#x3D;&#x3D;CompletableFuture&#x3D;&#x3D;</h1><h2 id="Future接口复习"><a href="#Future接口复习" class="headerlink" title="Future接口复习"></a>Future接口复习</h2><p><strong>Future作用</strong></p><p>Future接口(FutureTask实现类)定义了操作<font color="red"><strong>异步任务</strong>执行一些方法</font>，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p>比如<font color="cornflowerblue">主线程</font>让一个<font color="cornflowerblue">子线程</font>去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙其它事情或者先执行完，过了一会才去获取子任务的执行结果或变更的任务状态。</p><p><font color="red">一句话：Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务。</font></p><p><strong>Future实现方式</strong></p><p>Future是Java5新加的一个接口，它提供了一种<font color="red">异步并行计算的功能</font>。</p><p>如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。</p><p>主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p><p>代码说话:</p><p>Runnable接口</p><p><strong>Callable接口</strong></p><p>Future接口和<strong>FutureTask</strong>实现类</p><p><font color="red">目的:异步多线程任务执行且返回有结果，三个特点:多线程&#x2F;有返回&#x2F;异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</font></p><p>Thread构造器中没有可传入Callable接口的构造器，但是有传入Future接口的构造器。</p><p><font color="cornflowerblue">所以异步任务我们选中Callable接口（有返回值）和<strong>FutureTask</strong>实现类（实现Future和可构造注入Callable）</font></p><h2 id="FutureTask实现类"><a href="#FutureTask实现类" class="headerlink" title="FutureTask实现类"></a>FutureTask实现类</h2><h3 id="Callable-FutureTask的入门调用"><a href="#Callable-FutureTask的入门调用" class="headerlink" title="Callable + FutureTask的入门调用"></a>Callable + FutureTask的入门调用</h3><p>知道如何使用Callable + FutureTask创建一个线程和得到它的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示FutureTask + Callable接口的入门调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----------come in call()&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;hello Callable&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用get()方法获取返回值</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Future接口优点"><a href="#Future接口优点" class="headerlink" title="Future接口优点"></a>Future接口优点</h3><p><strong>Future优点</strong>：<font color="red">Future+线程池<strong>异步</strong>多线程任务配合，能显著提高程序的执行效率。</font></p><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Future + ThreadPool异步任务耗时低演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//三个线程完成三个任务的耗时（即异步任务）</span></span><br><span class="line">        <span class="comment">//不调用get()：353 毫秒</span></span><br><span class="line">        <span class="comment">//调用get()： 865 毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task1 over&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.submit(futureTask1);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task2 over&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.submit(futureTask2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(futureTask1.get());</span></span><br><span class="line"><span class="comment">//        System.out.println(futureTask2.get());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime：&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----end&quot;</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//一个线程完成三个任务的耗时     耗时1125 毫秒</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime：&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，当一个线程完成三个任务的耗时  ：  耗时1125 毫秒，</p><p>三个线程完成三个任务的耗时（即异步任务）：<br>不调用get()：353 毫秒<br>调用get()： 865 毫秒</p><p>使用异步任务耗时都明显低于单线程执行</p><h3 id="Future接口缺点"><a href="#Future接口缺点" class="headerlink" title="Future接口缺点"></a>Future接口缺点</h3><p><strong>Future缺点：</strong></p><ul><li><strong>get()方法容易导致阻塞</strong><ul><li>一般建议放在程序后面，一且调用不见不散，非要等到结果才会离开，不管你是否计算完成，调用不当容易导致<font color="red">其它线程堵塞</font>。</li><li>假如我不愿意等待很长时间，我希望过时不候，可以自动离开。<strong>get()方法可以设置等待时间</strong>，若超过则直接抛出异常</li></ul></li><li><strong>isDone()轮询耗费CPU</strong><ul><li>轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果。</li><li>如果想要异步获取结果，<strong>通常都会以轮询的方式去获取结果</strong>尽量不要阻塞</li></ul></li></ul><p>结果：Future对于结果的获取不太友好</p><p><strong>案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缺点演示：1 get()容易导致线程阻塞</span></span><br><span class="line"><span class="comment"> *         2 isDone()轮询消耗CPU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureAPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;take over&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;take over&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        futureTask.get();   //会阻塞下面main线程的语句执行</span></span><br><span class="line">        futureTask.get(<span class="number">3</span>,TimeUnit.SECONDS); <span class="comment">//可设置等待时间</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在执行其它任务中&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (futureTask.isDone())&#123;</span><br><span class="line">                System.out.println(futureTask.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在等待get中&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture实现类引入"><a href="#CompletableFuture实现类引入" class="headerlink" title="CompletableFuture实现类引入"></a>CompletableFuture实现类引入</h2><p><strong>CompletableFuture为什么会出现？</strong></p><p>get()方法在Future计算完成之前会一直处在<font color="red">阻塞状态</font>下，</p><p>isDone()方法容易耗费CPU资源，</p><p>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果。</p><p><font color="red">阻塞的方式和异步编程的设计理念相违背，而轮询的方式会耗费无谓的CPU资源</font>。因此：</p><p>JDK8设计出CompletableFuture。</p><ul><li><strong>CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方</strong>。</li><li><strong>whenComplete()不用轮询，完成后直接获得返回值</strong></li></ul><p><strong>什么是CompletableFuture？</strong></p><ul><li>在Java8中，CompletableFuture提供了非常强大的<strong>Future的扩展功能</strong>，可以帮助我们<strong>简化异步编程的复杂性</strong>，并且<strong>提供了函数式编程的能力</strong>，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法。</li><li>它<font color="red">可能代表一个明确完成的Future,也有可能代表一个完成阶段</font>（CompletionStage)，它支持在计算完成以后触发一些函数或执行某些动作。<strong>它实现了Future和CompletionStage接口</strong></li></ul><h2 id="CompletableFuture的初步使用"><a href="#CompletableFuture的初步使用" class="headerlink" title="CompletableFuture的初步使用"></a>CompletableFuture的初步使用</h2><h3 id="创建一个CompletableFuture异步任务"><a href="#创建一个CompletableFuture异步任务" class="headerlink" title="创建一个CompletableFuture异步任务"></a>创建一个CompletableFuture异步任务</h3><p>一共有四种常用的创建CompletableFuture的方式：</p><ul><li><p>无返回值</p><ul><li><pre><code class="java">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>有返回值</p><ul><li><pre><code class="java">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>如果没有指定Executor的方法，直接使用默认的<strong>ForkJoinPool..commonPool()</strong><br>作为它的线程池执行异步代码。如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</p><p><font color="red">若使用默认线程池主线程不要立刻结束</font>，否则CompletableFuture默认使用的线程池会立刻关闭</p><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示CompletableFuture创建实例的四种方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureBuildDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//无返回值使用默认线程池   ForkJoinPool.commonPool</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//无返回值使用指定线程池</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;,threadPool);</span><br><span class="line">        System.out.println(completableFuture1.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有返回值使用默认线程池   ForkJoinPool.commonPool</span></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello supply&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有返回值使用指定线程池</span></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello supply&quot;</span>;</span><br><span class="line">        &#125;,threadPool);</span><br><span class="line">        System.out.println(completableFuture3.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture异步任务基本使用演示"><a href="#CompletableFuture异步任务基本使用演示" class="headerlink" title="CompletableFuture异步任务基本使用演示"></a>CompletableFuture异步任务基本使用演示</h3><p><strong>演示1</strong></p><p>先演示CompletableFuture能完成Future接口的工作，代表CompletableFuture能完全替代Future接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示CompletableFuture完成Future接口的任务</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFuture</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----1秒后出结果&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程先去忙其它任务了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>演示2</strong></p><p>主要包含两个方法：</p><ul><li>whenComplete(BiConsumer bc)</li><li>exceptionally(Function fn)</li></ul><p>再演示使用<font color="red">whenComplete</font>方法替换Future接口的isDone轮询，<font color="red">whenComplete()不用轮询</font></p><p>使用<font color="red">exceptionally</font>对异常进行处理</p><p><strong>注意：<font color="red">若使用默认线程池主线程不要立刻结束</font>，否则CompletableFuture默认使用的线程池会立刻关闭:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureUsesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;----1秒后出结果&quot;</span> + result);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;,threadPool).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----计算完成，更新系统UpdateValue：&quot;</span>+v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;异常情况：&quot;</span> + e.getCause() + <span class="string">&quot;\t&quot;</span> + e.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程先去忙其它任务了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若使用默认线程池主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture方法各类方法详解"><a href="#CompletableFuture方法各类方法详解" class="headerlink" title="CompletableFuture方法各类方法详解"></a>CompletableFuture方法各类方法详解</h3><h4 id="获得结果和触发计算"><a href="#获得结果和触发计算" class="headerlink" title="获得结果和触发计算"></a>获得结果和触发计算</h4><ul><li><strong>获得结果</strong><ul><li>public T get()        <ul><li>需要抛出异常</li></ul></li><li>public T get(long timeout, TimeUnit unit)       <ul><li>只愿意等多少时间，超过报异常</li></ul></li><li>public T join()        <ul><li>不需要抛出异常</li></ul></li><li>public T getNow(T ValueIfAbsent)          <ul><li>立即获取结果不阻塞：若计算完成，则返回计算结果，没算完，则返回设定值</li></ul></li></ul></li><li><strong>主动触发计算</strong><ul><li>public boolean complete(T value)<ul><li>被获取计算结果时，若计算完成，则返回给获取者计算结果，没算完，则返回设定值</li></ul></li></ul></li></ul><h4 id="对最终结果和异常进行处理"><a href="#对最终结果和异常进行处理" class="headerlink" title="对最终结果和异常进行处理"></a>对最终结果和异常进行处理</h4><ul><li>whenComplete(BiConsumer bc)</li><li>exceptionally(Function fn)</li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;whenComplete and exceptionally&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;whenComplete and exceptionally&quot;</span>;</span><br><span class="line">&#125;).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e ==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结果：&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">&quot;异常：&quot;</span> + e.getCause() + <span class="string">&quot;\t&quot;</span> + e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="对中间计算结果进行处理"><a href="#对中间计算结果进行处理" class="headerlink" title="对中间计算结果进行处理"></a>对中间计算结果进行处理</h4><ul><li><p>thenApply(Functuon f)</p><ul><li><p>对计算结果进行处理，计算结果之间存在依赖关系，这两个线程串行化</p></li><li><p><font color="red">由于存在依赖关系（当前步错，不走下一步），当前步聚有异常的话就停止执行抛出异常</font></p></li><li><pre><code class="java">/** * thenApply演示 */ThreadPoolExecutor threadPool = new ThreadPoolExecutor(        2,        5,        5,        TimeUnit.SECONDS,        new ArrayBlockingQueue&lt;&gt;(3),        Executors.defaultThreadFactory(),        new ThreadPoolExecutor.AbortPolicy());CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;    try &#123;TimeUnit.SECONDS.sleep(1);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;    System.out.println(&quot;111&quot;);    return 1;&#125;,threadPool).thenApply(f -&gt; &#123;    System.out.println(&quot;222&quot;);    return f + 2;&#125;).thenApply(f -&gt; &#123;    System.out.println(&quot;333&quot;);    return f + 3;&#125;).whenComplete((v,e) -&gt; &#123;    if(e == null)&#123;        System.out.println(&quot;----计算结果：&quot; + v);    &#125;&#125;).exceptionally(e -&gt; &#123;    e.printStackTrace();    System.out.println(&quot;异常： &quot; + e.getCause() + &quot;\t&quot; + e.getMessage());    return null;&#125;);threadPool.shutdown();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- handle(BiFunction &lt;v, e&gt; f)</span><br><span class="line"></span><br><span class="line">  - 对计算结果进行处理，计算结果之间存在依赖关系，这两个线程串行化</span><br><span class="line"></span><br><span class="line">  - &lt;font color=&#x27;red&#x27;&gt;但是：有异常也可以往下一步走，带着异常参数在最后exceptionally进行进一步处理&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    .handle((f,e) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;222&quot;);</span><br><span class="line">        int i = 10/0;</span><br><span class="line">        return f + 2;</span><br><span class="line">    &#125;).handle((f,e) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;333&quot;);</span><br><span class="line">        return f + 3;</span><br><span class="line">    &#125;).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">        if(e == null)&#123;</span><br><span class="line">            System.out.println(&quot;----计算结果：&quot; + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;异常： &quot; + e.getCause() + &quot;\t&quot; + e.getMessage());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadPool.shutdown();</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="对中间计算结果进行消费"><a href="#对中间计算结果进行消费" class="headerlink" title="对中间计算结果进行消费"></a>对中间计算结果进行消费</h4><ul><li>thenRun(Runnable runnable)<ul><li>任务A执行完执行B，并且B不需要A的结果</li></ul></li><li>thenAccept(Consumer consumer)<ul><li>任务A执行完执行B，B需要A的结果，但是任务B<font color="red">无返回值</font></li></ul></li><li>thenApply(Function fun)<ul><li>任务A执行完执行B，B需要A的结果，同时任务B<font color="red">有返回值</font></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示几种结果消费方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());</span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt;<span class="string">&quot;resultA&quot;</span>).thenAccept(System.out::println).join());</span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(f -&gt; f + <span class="string">&quot;resultB&quot;</span>).join());</span><br></pre></td></tr></table></figure><h4 id="线程池运行选择"><a href="#线程池运行选择" class="headerlink" title="线程池运行选择"></a>线程池运行选择</h4><p><strong>即上面的方法后面都加上Async</strong></p><p>eg：thenRun(Runnable runnable) 和 thenRunAsync(Runnable runnable)</p><ol><li>没有传入自定义线程池，都用默认线程池ForkJoinPool；</li><li>传入了一个<font color="red">自定义线程池</font>：如果你执行第一个任务的时候，传入了一个<font color="red">自定义线程池</font>：<ul><li>第一个任务肯定使用自定义线程池</li><li>调用thenRun方法执行后续任务时，则后续任务和第一个任务是共用同一个线程池。</li><li>调用thenRunAsync执行后续任务时，则第一个任务到调用thenRunAsync的任务使用的是你自己传入的线程池调用thenRunAsync开始使用的是ForkJoin线程池</li></ul></li><li>备注<ul><li>有可能处理太快，系统优化切换原则，直接使用main线程处理</li></ul></li></ol><p>其它如：thenAccept和thenAcceptAsync，thenApply.和thenApplyAsync等，它们之间的区别也是同理</p><p><font color="red">即同步的用的是同一个线程池，但是异步的话就需要使用不同的线程池了</font></p><p><font color="red">设置异步任务中的异步任务</font></p><p><strong>案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池选择演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;1号任务&quot;</span> + <span class="string">&quot;\t&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        &#125;,threadPool).thenRun(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;2号任务&quot;</span> + <span class="string">&quot;\t&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;).thenRunAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;3号任务&quot;</span> + <span class="string">&quot;\t&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;).thenRun(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;4号任务&quot;</span> + <span class="string">&quot;\t&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.get(<span class="number">2L</span>,TimeUnit.SECONDS));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">1号任务pool-1-thread-1</span><br><span class="line">2号任务pool-1-thread-1</span><br><span class="line">3号任务ForkJoinPool.commonPool-worker-1</span><br><span class="line">4号任务ForkJoinPool.commonPool-worker-1</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h4 id="对两个异步任务计算速度进行选用"><a href="#对两个异步任务计算速度进行选用" class="headerlink" title="对两个异步任务计算速度进行选用"></a>对两个异步任务计算速度进行选用</h4><ul><li>applyToEither(CompletionStage stage, Function fn)<ul><li>对两个异步任务的速度进行选择，选择速度更快的那个线程</li></ul></li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对速度进行选择</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;playA&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;playB&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt; f + <span class="string">&quot; is winner&quot;</span>);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A come in</span><br><span class="line">B come in</span><br><span class="line">playA is winner</span><br></pre></td></tr></table></figure><h4 id="对两个异步任务计算结果进行合并"><a href="#对两个异步任务计算结果进行合并" class="headerlink" title="对两个异步任务计算结果进行合并"></a>对两个异步任务计算结果进行合并</h4><ul><li>thenCombine(CompletionStage stage, BiFunction bf)<ul><li>对两个异步任务的结果进行合并</li></ul></li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对两个异步任务的结果进行合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----come in A&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----come in B&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(completableFuture1.thenCombine(completableFuture2,Integer::sum).join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----come in A</span><br><span class="line">----come in B</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="Mall实战案例"><a href="#Mall实战案例" class="headerlink" title="Mall实战案例"></a>Mall实战案例</h2><h3 id="Java8函数式编程、Chain链式调用、join-方法、Stream流式编程和案例需求说明"><a href="#Java8函数式编程、Chain链式调用、join-方法、Stream流式编程和案例需求说明" class="headerlink" title="&#x3D;&#x3D;Java8函数式编程、Chain链式调用、join()方法、Stream流式编程和案例需求说明&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java8函数式编程、Chain链式调用、join()方法、Stream流式编程和案例需求说明&#x3D;&#x3D;</h3><p><strong>函数式接口：</strong></p><p><img src="https://www.hahhome.top/blog/JUC01/../../image/JUC01.assets/image-20230713141445391.png" alt="image-20230713141445391"></p><p><strong>什么是函数式接口？</strong></p><p><font color="red">只定义了一个抽象方法的接口</font>都可以叫做函数式接口</p><p><font color="cornflowerblue">只有函数式接口才可以使用lambda表达式</font></p><p><strong>常用函数式接口</strong></p><p>生命在jdk1.8的 java.util.function包下</p><table><thead><tr><th>接口</th><th>对应的抽象方法</th></tr></thead><tbody><tr><td>消费型接口(一参)：Consumer<T></T></td><td>void accept(T t)</td></tr><tr><td>消费型接口(两参)：BiConsumer<T></T></td><td>void accept(T t, R r)</td></tr><tr><td>供给型接口(无返回值)：Runnable<T></T></td><td>void run()</td></tr><tr><td>供给型接口(有返回值)：Supplier<T></T></td><td>T get()</td></tr><tr><td>函数型接口：Function&lt;T,R&gt;</td><td>R apply(T t)</td></tr><tr><td>判断型接口：Predicate<T></T></td><td>boolean test(T t)</td></tr></tbody></table><ul><li>比如<font color="red">CompletableFuture实例的创建方法<strong>runAsync</strong>()</font>的参数就有<strong>Runnable</strong>接口，正好对应该方法是<strong>无参数无返回值</strong>的</li><li>比如<font color="red">CompletableFuture实例的创建方法<strong>supplyAsync</strong>()</font>的参数就有<strong>Supplier</strong>接口，正好对应该方法是<strong>无参数有返回值</strong>的</li><li>比如<font color="red">CompletableFuture实例的方法<strong>whenComplete</strong>()</font>的参数就有<strong>BiConsumer</strong>接口，正好对应该方法是<strong>两个参数无返回值</strong>的</li><li>比如<font color="red">CompletableFuture实例的方法<strong>exceptionally</strong>()</font>的参数就有<strong>Function</strong>接口，正好对应该方法是<strong>一个参数有返回值</strong>的</li></ul><p><strong>Chain链式调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureMallDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//链式调用</span></span><br><span class="line">        <span class="type">student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">        </span><br><span class="line">        student.setId(<span class="number">1</span>).setStudentName(<span class="string">&quot;zs&quot;</span>).setMajor(<span class="string">&quot;it&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line">    <span class="keyword">private</span> String major;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>join()和get()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureMallDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//join()方法与get()方法</span></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello 1234&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        System.out.println(completableFuture.get());      //需要抛出异常</span></span><br><span class="line">        System.out.println(completableFuture.join());       <span class="comment">//不用抛出异常，运行时出现异常就出异常就好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream流式编程"><a href="#Stream流式编程" class="headerlink" title="&#x3D;&#x3D;Stream流式编程&#x3D;&#x3D;"></a>&#x3D;&#x3D;Stream流式编程&#x3D;&#x3D;</h4><p><strong>什么是Stream</strong></p><p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p><p>Stream和Collection集合的区别：<font color="red">Collection是一种静态的内存数据结构，讲的是数据，而Stream是有关计算的，讲的是计算。</font>前者是主要面向内存，存储在内存中，后者主要是面向CPU,通过CPU实现计算。</p><blockquote><ul><li>Stream API关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。</li><li>集合关注的数据的存储，向下内存的。</li></ul><p><font color="red">Stream API之于集合，类似于SQL之于数据表的查询。</font></p><p>即用Stream API在集合中查找数据</p></blockquote><p><strong>使用说明：</strong></p><p>①Stream自己不会存储元素。</p><p>②Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p><p>③Stream操作是延迟执行的。这意味着他们<strong>会等到需要结果的时候才执行</strong>。即一旦<strong>执行终止操作，才执行中间操作链</strong>，并产生结果。</p><p>④Stream<strong>一旦执行了终止操作，就不能再调用其它中间操作或终止操作</strong>了。</p><p><strong>Stream使用的步骤</strong></p><ul><li><p>Stream的实例化</p><ul><li><p>方式一：通过集合</p><ul><li><pre><code class="java">List&lt;Employee&gt; list = Employee.getEmployees();//default Stream&lt;E&gt; stream() : 返回一个顺序流Stream&lt;Employee&gt; stream = list.stream();//default Stream&lt;E&gt; parallelStream() : 返回一个并行流Stream&lt;Employee&gt; stream1 = list.parallelStream();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 方式二：通过数组</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Integer[] arr = new Integer[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">    Stream&lt;Integer&gt; stream2 = Arrays.stream(arr);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>方式三：通过Stream的of()</p><ul><li><pre><code class="java">Stream&lt;String&gt; stream3 = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 一系列的中间操作</span><br><span class="line"></span><br><span class="line">  - 筛选与切片</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      /**</span><br><span class="line">       * 筛选与切片</span><br><span class="line">       */</span><br><span class="line">      //filter(Predicate p): 接收Lambda,从流中排除某些元素。</span><br><span class="line">      //练习：查询员工表中薪资大于7000的员工信息</span><br><span class="line">      List&lt;Employee&gt; list = Employee.getEmployees();</span><br><span class="line">      list.stream().filter(emp -&gt; emp.getSalary() &gt; 7000).forEach(System.out::println);</span><br><span class="line">      </span><br><span class="line">      System.out.println();</span><br><span class="line">      </span><br><span class="line">      //limit(n): 截断流，使其元素不超过给定数量.</span><br><span class="line">      //因为stream已经执行了终止操作，就不可以再调用其它的中间操作或终止操作了，所以需要重新获取流对象。</span><br><span class="line">      list.stream().limit(3).forEach(System.out::println);</span><br><span class="line">      </span><br><span class="line">      System.out.println();</span><br><span class="line">      </span><br><span class="line">      //skip(n): 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。</span><br><span class="line">      list.stream().skip(3).forEach(System.out::println);</span><br><span class="line">      list.stream().skip(10).forEach(System.out::println);    //返回空流</span><br><span class="line">      </span><br><span class="line">      System.out.println();</span><br><span class="line">      </span><br><span class="line">      //distinct(): 筛选，通过流所生成元素的hashCode()和equals()去除重复元素</span><br><span class="line">      list.add(new Employee(10,&quot;马斯克&quot;,50,21000.11));</span><br><span class="line">      list.add(new Employee(10,&quot;马斯克&quot;,50,21000.11));</span><br><span class="line">      list.add(new Employee(10,&quot;马斯克&quot;,50,21000.11));</span><br><span class="line">      list.add(new Employee(10,&quot;马斯克&quot;,50,21000.11));</span><br><span class="line">      </span><br><span class="line">      list.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>映射</p><ul><li><pre><code class="java">/** * 映射 *///map(Function f)：接收一个函数作为参数，将元素转换成其它形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素//练习：将字母转换为大写String[] arr = new String[]&#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;&#125;;//方式1：Arrays.stream(arr).map(str -&gt; str.toUpperCase()).forEach(System.out::println);//方式2：Arrays.stream((arr)).map(String::toUpperCase).forEach(System.out::println);//练习：获取员工姓名长度大于3的员工的姓名List&lt;Employee&gt; list = Employee.getEmployees();//获取员工姓名长度大于3的员工list.stream().filter(emp -&gt; emp.getName().length() &gt; 3).forEach(System.out::println);//方式1：list.stream().filter(emp -&gt; emp.getName().length() &gt; 3).map(Employee::getName).forEach(System.out::println);//方式2：list.stream().map(Employee::getName).filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 排序</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    /**</span><br><span class="line">     * 排序</span><br><span class="line">     */</span><br><span class="line">    //sorted(): 自然排序</span><br><span class="line">    Integer[] arr2 = new Integer[]&#123;312,24123,132,4323,12,23&#125;;</span><br><span class="line">    Arrays.stream(arr2).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>执行终止操作</p><ul><li><p>匹配与查找</p><ul><li><pre><code class="java">/** * 匹配与查找 *///allMatch(Predicate p): 检查是否匹配所有元素。//练习: 是否所有的员工的年龄都大于18List&lt;Employee&gt; list = Employee.getEmployees();System.out.println(list.stream().allMatch(emp -&gt; emp.getAge() &gt; 18));//anyMatch(Predicate p): 检查是否至少匹配一个元素。//练习: 是否存在年龄大于18岁的员工System.out.println(list.stream().anyMatch(emp -&gt; emp.getAge() &gt; 18));//findFirst一返回第一个元素System.out.println(list.stream().findFirst().get());//count(): 返回流的数量System.out.println(list.stream().filter(emp -&gt; emp.getSalary() &gt; 7000).count());//max(Comparator c): 返回流中最大值//返回工资最高的员工System.out.println(list.stream().max((e1,e2) -&gt; Double.compare(e1.getSalary(),e2.getSalary())));//返回最高的工资System.out.println(list.stream().map(Employee::getSalary).max(Double::compareTo));//min(Comparator c): 返回流中最小值System.out.println(list.stream().map(Employee::getSalary).min(Double::compareTo));//forEach(Consumer c): 内部迭代list.stream().forEach(System.out::println);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 归约</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    /**</span><br><span class="line">     * 归约</span><br><span class="line">     */</span><br><span class="line">    //reduce(T identity, BinaryOperator): 可以将流中元素反复结合起来，得到一个值。返回T</span><br><span class="line">    //练习1：计算1-10的自然数的和</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span><br><span class="line">    System.out.println(list.stream().reduce(0, (x1, x2) -&gt; x1 + x2));</span><br><span class="line">    System.out.println(list.stream().reduce(0, Integer::sum));//55</span><br><span class="line">    System.out.println(list.stream().reduce(10, Integer::sum));//65</span><br><span class="line">    </span><br><span class="line">    //reduce(BinaryOperator): 可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span><br><span class="line">    //练习2：计算公司所有员工工资的总和</span><br><span class="line">    List&lt;Employee&gt; list2 = Employee.getEmployees();</span><br><span class="line">    System.out.println(list2.stream().map(Employee::getSalary).reduce(Double::sum));</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>收集</p><ul><li><pre><code class="java">/** * 收集 *///collect(Collector c): 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法//练习1：查找工资大于6000的员工，结果返回为一个List或SetList&lt;Employee&gt; list = Employee.getEmployees();List&lt;Employee&gt; collect = list.stream().filter(emp -&gt; emp.getSalary() &gt; 6000).collect(Collectors.toList());collect.forEach(System.out::println);//练习2：按照员工的年龄进行排序，返回到一个新的List中List&lt;Employee&gt; collect1 = list.stream().sorted((e1, e2) -&gt; e1.getAge() - e2.getAge()).collect(Collectors.toList());collect1.forEach(System.out::println);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**案例说明**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 案例说明：电商比价需求，模拟如下情况：</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 1需求：</span><br><span class="line"> * 1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价;</span><br><span class="line"> * 1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 2输出：出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List&lt;String&gt;</span><br><span class="line"> * 《mysql》 in jd price is 88.05</span><br><span class="line"> * 《mysql》 in dangdang price is 86.11</span><br><span class="line"> * 《mysql》 in taobao price is 90.43</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 3 技术要求</span><br><span class="line"> * 3.1 函数式编程</span><br><span class="line"> * 3.2 链式编程</span><br><span class="line"> * 3.3 Stream流式计算</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><h3 id="不使用异步任务一步步实现"><a href="#不使用异步任务一步步实现" class="headerlink" title="不使用异步任务一步步实现"></a>不使用异步任务一步步实现</h3><p><strong>NetMall电商平台类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询该电商平台的售价</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一步步搜查的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * step by step 一家家搜查</span></span><br><span class="line"><span class="comment"> * List&lt;NetMall&gt; -----&gt;map------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式：《mysql》 in taobao price is 90.43</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">            .stream()</span><br><span class="line">            .map(netMall -&gt;</span><br><span class="line">                    String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                            netMall.getNetMallName(),</span><br><span class="line">                            netMall.calcPrice(productName)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main函数测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    List&lt;String&gt; list1 = getPrice(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String element : list1) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;----costTime：&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异步任务实现"><a href="#使用异步任务实现" class="headerlink" title="使用异步任务实现"></a>使用异步任务实现</h3><p><strong>异步任务方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List&lt;NetMall&gt; -----&gt;List&lt;CompletableFuture&lt;String&gt;&gt;------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">            .stream()</span><br><span class="line">            .map(netMall -&gt;</span><br><span class="line">                    CompletableFuture.supplyAsync(() -&gt;</span><br><span class="line">                            String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                                    netMall.getNetMallName(),</span><br><span class="line">                                    netMall.calcPrice(<span class="string">&quot;mysql&quot;</span>))))</span><br><span class="line">            .collect(Collectors.toList())</span><br><span class="line">            .stream()</span><br><span class="line">            .map(s -&gt; s.join())</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main函数测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    List&lt;String&gt; list2 = getPriceByCompletableFuture(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String price : list2) &#123;</span><br><span class="line">        System.out.println(price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;----costTime：&quot;</span> + (endTime2 - startTime2) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两种方法结合对比（完整代码）"><a href="#两种方法结合对比（完整代码）" class="headerlink" title="两种方法结合对比（完整代码）"></a>两种方法结合对比（完整代码）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例说明：电商比价需求，模拟如下情况：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1需求：</span></span><br><span class="line"><span class="comment"> * 1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价;</span></span><br><span class="line"><span class="comment"> * 1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 2输出：出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> * 《mysql》 in jd price is 88.05</span></span><br><span class="line"><span class="comment"> * 《mysql》 in dangdang price is 86.11</span></span><br><span class="line"><span class="comment"> * 《mysql》 in taobao price is 90.43</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 3 技术要求</span></span><br><span class="line"><span class="comment"> * 3.1 函数式编程</span></span><br><span class="line"><span class="comment"> * 3.2 链式编程</span></span><br><span class="line"><span class="comment"> * 3.3 Stream流式计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureMallDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdang&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taoabo&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * step by step 一家家搜查</span></span><br><span class="line"><span class="comment">     * List&lt;NetMall&gt; -----&gt;map------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式：《mysql》 in taobao price is 90.43</span></span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">                .stream()</span><br><span class="line">                .map(netMall -&gt;</span><br><span class="line">                        String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                                netMall.getNetMallName(),</span><br><span class="line">                                netMall.calcPrice(productName)))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List&lt;NetMall&gt; -----&gt;List&lt;CompletableFuture&lt;String&gt;&gt;------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">                .stream()</span><br><span class="line">                .map(netMall -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(() -&gt;</span><br><span class="line">                                String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                                        netMall.getNetMallName(),</span><br><span class="line">                                        netMall.calcPrice(<span class="string">&quot;mysql&quot;</span>))))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .stream()</span><br><span class="line">                .map(s -&gt; s.join())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list1 = getPrice(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : list1) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime：&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list2 = getPriceByCompletableFuture(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String price : list2) &#123;</span><br><span class="line">            System.out.println(price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime：&quot;</span> + (endTime2 - startTime2) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询该电商平台的售价</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql in jd price is 109.43</span><br><span class="line">mysql in dangdang price is 109.62</span><br><span class="line">mysql in taoabo price is 110.34</span><br><span class="line">mysql in pdd price is 110.01</span><br><span class="line">mysql in tmall price is 109.72</span><br><span class="line">----costTime：5085 毫秒</span><br><span class="line">----------------------------</span><br><span class="line">mysql in jd price is 110.60</span><br><span class="line">mysql in dangdang price is 110.07</span><br><span class="line">mysql in taoabo price is 109.15</span><br><span class="line">mysql in pdd price is 110.24</span><br><span class="line">mysql in tmall price is 109.89</span><br><span class="line">----costTime：1022 毫秒</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUCBase</title>
      <link href="/blog/JUCBase/"/>
      <url>/blog/JUCBase/</url>
      
        <content type="html"><![CDATA[<h1 id="课程内容概览"><a href="#课程内容概览" class="headerlink" title="课程内容概览"></a>课程内容概览</h1><p>• 1、什么是 JUC</p><p>• 2、Lock 接口</p><p>• 3、线程间通信</p><p>• 4、集合的线程安全</p><p>• 5、多线程锁</p><p>• 6、Callable 接口</p><p>• 7、JUC 三大辅助类: CountDownLatch CyclicBarrier Semaphore</p><p>• 8、读写锁: ReentrantReadWriteLock</p><p>• 9、阻塞队列</p><p>• 10、ThreadPool 线程池</p><p>• 11、Fork&#x2F;Join 框架</p><p>• 12、CompletableFuture</p><p><font color="red">该部分只是对JUC体系的大致了解，锁介绍内容偏向于了解和入门应用，更高级部分将在JUC01-08部分详细讲解</font></p><p>另外：JUC01-08部分，没有集合的线程安全、Callable接口、三大辅助类、阻塞队列、线程池、Fork&#x2F;Join部分的讲解，其他部分均有详细讲解以及更多其他内容的讲解</p><h1 id="1-什么是-JUC"><a href="#1-什么是-JUC" class="headerlink" title="1 什么是 JUC"></a>1 什么是 JUC</h1><h2 id="1-1-JUC-简介"><a href="#1-1-JUC-简介" class="headerlink" title="1.1 JUC 简介"></a>1.1 JUC 简介</h2><p>在 Java 中，线程部分是一个重点，本篇文章说的 JUC 也是关于线程的。JUC</p><p>就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包，JDK </p><p>1.5 开始出现的。</p><h2 id="1-2-进程与线程"><a href="#1-2-进程与线程" class="headerlink" title="1.2 进程与线程"></a>1.2 进程与线程</h2><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系</p><p>统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程</p><p>设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的</p><p>描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活</p><p>动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是</p><p>指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之</p><p>中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，</p><p><font color="red">一个进程中可以并发多个线程</font>，每条线程并行执行不同的任务</p><p><strong>总结来说:</strong></p><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—</p><p>—资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个</p><p>单元执行流。线程——程序执行的最小单位</p><h2 id="1-3-线程的状态"><a href="#1-3-线程的状态" class="headerlink" title="1.3 线程的状态"></a>1.3 线程的状态</h2><h3 id="1-3-1-线程状态枚举类"><a href="#1-3-1-线程状态枚举类" class="headerlink" title="1.3.1 线程状态枚举类"></a>1.3.1 线程状态枚举类</h3><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">NEW,(新建)</span><br><span class="line"></span><br><span class="line">RUNNABLE,（准备就绪）</span><br><span class="line"></span><br><span class="line">BLOCKED,（阻塞）</span><br><span class="line"></span><br><span class="line">WAITING,（不见不散）</span><br><span class="line"></span><br><span class="line">TIMED_WAITING,（过时不候）</span><br><span class="line"></span><br><span class="line">TERMINATED;(终结)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-wait-sleep-的区别"><a href="#1-3-2-wait-sleep-的区别" class="headerlink" title="1.3.2 wait&#x2F;sleep 的区别"></a>1.3.2 wait&#x2F;sleep 的区别</h3><p>1）sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都</p><p>能调用。</p><p>2）<strong>sleep 不会释放锁</strong>，它也不需要占用锁。<strong>wait 会释放锁</strong>，但调用它的前提</p><p>是当前线程占有锁(即代码要在 synchronized 中)。</p><p>3）它们都可以被 interrupt() 方法中断。</p><h2 id="1-4-并发与并行"><a href="#1-4-并发与并行" class="headerlink" title="1.4 并发与并行"></a>1.4 并发与并行</h2><h3 id="1-4-1-串行模式"><a href="#1-4-1-串行模式" class="headerlink" title="1.4.1 串行模式"></a>1.4.1 串行模式</h3><p>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能</p><p>运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步</p><p>骤，才能进行下一个步骤。</p><p><strong>串行是一次只能取得一个任务，并执行这个任务</strong></p><h3 id="1-4-2-并行模式"><a href="#1-4-2-并行模式" class="headerlink" title="1.4.2 并行模式"></a>1.4.2 并行模式</h3><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模</p><p>式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列</p><p>的长度。并行的效率从代码层次上强依赖于多进程&#x2F;多线程代码，从硬件角度上</p><p>则依赖于多核 CPU。</p><h3 id="1-4-3-并发"><a href="#1-4-3-并发" class="headerlink" title="1.4.3 并发"></a>1.4.3 并发</h3><p><strong>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可</strong></p><p><strong>以同时运行或者多指令可以同时运行</strong>。但这不是重点，在描述并发的时候也不</p><p>会去扣这种字眼是否精确，&#x3D;&#x3D;并发的重点在于它是一种现象&#x3D;&#x3D;, &#x3D;&#x3D;并发描述的是多&#x3D;&#x3D;</p><p>&#x3D;&#x3D;进程同时运行的现象&#x3D;&#x3D;。但实际上，对于单核心 CPU 来说，同一时刻</p><p>只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个</p><p>线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同</p><p>时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一</p><p>会停一会。</p><p><strong>要解决大并发问题，通常是将大任务分解成多个小任务</strong>, 由于操作系统对进程的</p><p>调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可</p><p>能会出现一些现象：</p><p>• 可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用</p><p>队列或类似的数据结构来存放各个小任务的成果</p><p>• 可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或</p><p>异步的方式，比如只有准备好产生了事件通知才执行某个任务。</p><p>• 可以多进程&#x2F;多线程的方式并行执行这些小任务。也可以单进程&#x2F;单线程执行这</p><p>些小任务，这时很可能要配合多路复用才能达到较高的效率</p><h3 id="1-4-4-小结-重点"><a href="#1-4-4-小结-重点" class="headerlink" title="1.4.4 小结(重点)"></a>1.4.4 小结(重点)</h3><p><strong>并发：</strong>同一时刻多个线程在访问同一个资源，多个线程对一个点</p><p>（一个CPU同一时间点是交替执行的）</p><p> 例子：春运抢票 电商秒杀…</p><p><strong>并行：</strong>多项工作一起执行，之后再汇总</p><p> 例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p><h2 id="1-5-管程"><a href="#1-5-管程" class="headerlink" title="1.5 管程"></a>1.5 管程</h2><p>管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同</p><p>一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行</p><p>JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程</p><p>(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁</p><p>执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方</p><p>法在执行时候会持有管程，其他线程无法再获取同一个管程</p><p><font color="cornflowerblue">管程即管理钥匙的人，会监视锁只能由一个人使用，管程就是锁</font></p><h2 id="1-6-用户线程和守护线程"><a href="#1-6-用户线程和守护线程" class="headerlink" title="1.6 用户线程和守护线程"></a>1.6 用户线程和守护线程</h2><p><strong>用户线程</strong>：平时用到的普通线程,自定义线程</p><p><strong>守护线程</strong>：运行在后台,是一种特殊的线程,比如垃圾回收</p><p><font color="red"><strong>当主线程结束后：用户线程还在运行,JVM存活</strong></font></p><p><font color="red"><strong>如果没有用户线程,都是守护线程,JVM结束</strong></font></p><p>使用thread.setDaemon(true)设置为守护线程</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Concept</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + Thread.currentThread().isDaemon());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        aa.setDaemon(true);</span></span><br><span class="line">        aa.start();</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Lock-接口"><a href="#2-Lock-接口" class="headerlink" title="2 Lock 接口"></a>2 Lock 接口</h1><h2 id="2-1-Synchronized"><a href="#2-1-Synchronized" class="headerlink" title="2.1 Synchronized"></a>2.1 Synchronized</h2><h3 id="2-1-1-Synchronized-关键字回顾"><a href="#2-1-1-Synchronized-关键字回顾" class="headerlink" title="2.1.1 Synchronized 关键字回顾"></a>2.1.1 Synchronized 关键字回顾</h3><p>synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}</li></ol><p>括起来的代码，作用的对象是调用这个代码块的对象；</p><ol start="2"><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用</li></ol><p>的对象是调用这个方法的对象；</p><p>o 虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定</p><p>义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方</p><p>法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这</p><p>个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上</p><p>synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方</p><p>法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，</p><p>子类的方法也就相当于同步了。</p><ol start="3"><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的</li></ol><p>所有对象；</p><ol start="4"><li>修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主</li></ol><p>的对象是这个类的所有对象。</p><p><font color="cornflowerblue">synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</font></p><p><font color="cornflowerblue">具体表现为以下3种形式：</font></p><ul><li><font color="cornflowerblue">对于普通同步方法，锁是当前实例对象。</font></li><li><font color="cornflowerblue">对于静态同步方法，锁是当前类的class对象。</font></li><li><font color="cornflowerblue">对于同步方法块，锁是Synchonized括号里配置的对象</font></li></ul><h3 id="2-1-2-售票案例"><a href="#2-1-2-售票案例" class="headerlink" title="2.1.2 售票案例"></a>2.1.2 售票案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">saleCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//操作方法：卖票</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出第&quot;</span> + (++saleCount) + <span class="string">&quot;张票，剩余：&quot;</span> + --number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执</p><p>行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里</p><p>获取锁的线程释放锁只会有两种情况：</p><p> 1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p><p> 2）线程执行发生异常，此时 JVM 会让线程自动释放锁。</p><p> 那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep</p><p>方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一</p><p>下，这多么影响程序执行效率。</p><p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等</p><p>待一定的时间或者能够响应中断），通过 <strong>Lock</strong> 就可以办到</p><h2 id="2-2-什么是-Lock"><a href="#2-2-什么是-Lock" class="headerlink" title="2.2 什么是 Lock"></a>2.2 什么是 Lock</h2><p>Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允</p><p>许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对</p><p>象。<strong>Lock 提供了比 synchronized 更多的功能</strong>。</p><p>Lock 与的 Synchronized 区别</p><p>• Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内</p><p>置特性。Lock 是一个类，通过这个类可以实现同步访问；</p><p>• Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户</p><p>去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，</p><p>系统会自动让线程释放对锁的占用；而 <strong>Lock 则必须要用户去手动释放锁，如</strong></p><p><strong>果没有主动释放锁，就有可能导致出现死锁现象</strong>。</p><h3 id="2-2-1-Lock-接口"><a href="#2-2-1-Lock-接口" class="headerlink" title="2.2.1 Lock 接口"></a>2.2.1 Lock 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来逐个讲述 Lock 接口中每个方法的使用</p><h3 id="2-2-2-Lock"><a href="#2-2-2-Lock" class="headerlink" title="2.2.2 Lock()"></a>2.2.2 Lock()</h3><p>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他</p><p>线程获取，则进行等待。</p><p>采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一</p><p>般来说，使用 Lock 必须在 try{}catch{}块中进行，并且将释放锁的操作放在</p><p>finally 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock</p><p>来进行同步的话，是以下面这种形式去使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">      <span class="comment">//上锁</span></span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//处理任务</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-newCondition"><a href="#2-2-3-newCondition" class="headerlink" title="2.2.3 newCondition"></a>2.2.3 newCondition</h3><p>关键字 synchronized 与 wait()&#x2F;notify()这两个方法一起使用可以实现等待&#x2F;通</p><p>知模式， Lock 锁的 newContition()方法返回 Condition 对象，Condition 类</p><p>也可以实现等待&#x2F;通知模式。</p><p>用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以</p><p>进行选择性通知， Condition 比较常用的两个方法：</p><p>• await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重</p><p>新获得锁并继续执行。</p><p>• signal()用于唤醒一个等待的线程。</p><p><font color="cornflowerblue">注意：在调用 Condition 的 await()&#x2F;signal()方法前，也需要线程持有相关</font></p><p><font color="cornflowerblue">的 Lock 锁，调用 await()后线程会释放这个锁，在 singal()调用后会从当前</font></p><p><font color="cornflowerblue">Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦</font></p><p><font color="cornflowerblue">获得锁成功就继续执行。</font></p><p><strong>wait()&#x2F;signal()方法对应于使用synchronized的wait()方法和notify()方法</strong></p><p>使用wait() &#x2F; await()方式时：不能使用if，而要使用while避免虚假唤醒，</p><p>因为wait从哪里睡，从哪里醒，醒了过后会继续往下执行</p><p>需要使用while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)&#123;</span><br><span class="line">    condition.await();</span><br><span class="line">    <span class="comment">//this.wait();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-ReentrantLock"><a href="#2-3-ReentrantLock" class="headerlink" title="2.3 ReentrantLock"></a>2.3 ReentrantLock</h2><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。</p><p>ReentrantLock 是唯一实现了 Lock 接口的类，并且 ReentrantLock 提供了更</p><p>多的方法。下面通过一些实例看具体看一下如何使用。</p><p><strong>售票案例的lock实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：创建资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LTicket</span> &#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">saleCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//操作方法：卖票</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出第&quot;</span> + (++saleCount) + <span class="string">&quot;张票，剩余：&quot;</span> + --number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LSaleTicket</span> &#123;</span><br><span class="line">    <span class="comment">//第二步：创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LTicket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-ReadWriteLock"><a href="#2-4-ReadWriteLock" class="headerlink" title="2.4 ReadWriteLock"></a>2.4 ReadWriteLock</h2><p>ReadWriteLock 也是一个接口，在它里面只定义了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">     </span><br><span class="line">     Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">     Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分</p><p>成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的</p><p><strong>ReentrantReadWriteLock</strong> 实现了 ReadWriteLock 接口。</p><p>ReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个</p><p>方法：readLock()和 writeLock()用来获取读锁和写锁。</p><p>• 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写</p><p>锁的线程会一直等待释放读锁。</p><p>• 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则</p><p>申请的线程会一直等待释放写锁。</p><h2 id="2-5-小结-重点"><a href="#2-5-小结-重点" class="headerlink" title="2.5 小结(重点)"></a>2.5 小结(重点)</h2><p>Lock 和 synchronized 有以下几点不同：</p><ol><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内</li></ol><p>置的语言实现；</p><ol start="2"><li><strong>synchronized 在发生异常时，会自动释放线程占有的锁</strong>，因此不会导致死锁现</li></ol><p>象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很</p><p>可能造成死锁现象，因此<strong>使用 Lock 时需要在 finally 块中释放锁</strong>；</p><ol start="3"><li><font color="cornflowerblue">Lock 可以让等待锁的线程响应中断，而 synchronized 却不行</font>，使用</li></ol><p>synchronized 时，等待的线程会一直等待下去，不能够响应中断；</p><ol start="4"><li><p><font color="cornflowerblue">通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</font>。</p></li><li><p><font color="cornflowerblue">Lock 可以提高多个线程进行读操作的效率</font>。</p></li></ol><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而<strong>当竞争资源</strong></p><p><strong>非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于</strong></p><p><strong>synchronized</strong>。</p><h1 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3 线程间通信"></a>3 线程间通信</h1><p>线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模</p><p>型来实现的。我们来基本一道面试常见的题目来分析</p><p><strong>场景—两个线程，一个线程对当前数值加 1，另一个线程对当前数值减 1,要求</strong></p><p><strong>用线程间通信</strong></p><p><strong>多线程编程步骤：</strong></p><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711003002637.png" alt="image-20230711003002637"></p><h2 id="3-1-synchronized-方案"><a href="#3-1-synchronized-方案" class="headerlink" title="3.1 synchronized 方案"></a>3.1 synchronized 方案</h2><p><strong>使用wait()和notify()方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized测试线程间通信：交替加减</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：创建资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="comment">//初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//+1方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//第二步：判断 干活 通知</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第四步：防止虚假唤醒问题</span></span><br><span class="line">        <span class="comment">//不能使用if，而要使用while避免虚假唤醒，因为wait从哪里睡，从哪里醒，醒了过后会继续往下执行</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;   <span class="comment">//判断 number是否为0，如果不是0，等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果number是0，+1</span></span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + + number);</span><br><span class="line">        <span class="comment">//通知 其它线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-1方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//第二步：判断 干活 通知</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">1</span>)&#123;   <span class="comment">//判断 number是否为1，如果不是1，等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果number是1，-1</span></span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + + number);</span><br><span class="line">        <span class="comment">//通知 其它线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="comment">//第三步：创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.incr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.decr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.incr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.decr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;dd&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2-Lock-方案"><a href="#3-2-Lock-方案" class="headerlink" title="3.2 Lock 方案"></a>3.2 Lock 方案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lock测试线程间通信：交替加减</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//第一步：创建资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="comment">//初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//+1方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//第二步：判断 干活 通知</span></span><br><span class="line">        </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第四步：防止虚假唤醒问题</span></span><br><span class="line">            <span class="comment">//不能使用if，而要使用while避免虚假唤醒，因为wait从哪里睡，从哪里醒，醒了过后会继续往下执行</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;   <span class="comment">//判断 number是否为0，如果不是0，等待</span></span><br><span class="line">                condition.await();       </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果number是0，+1</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + + number);</span><br><span class="line">            <span class="comment">//通知 其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//第二步：判断 干活 通知</span></span><br><span class="line">        </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>)&#123;   <span class="comment">//判断 number是否为1，如果不是1，等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果number是1，-1</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + + number);</span><br><span class="line">            <span class="comment">//通知 其它线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LTestVolatile</span> &#123;</span><br><span class="line">    <span class="comment">//第三步：创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.incr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.decr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.incr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        share.decr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;dd&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-线程间定制化通信"><a href="#3-3-线程间定制化通信" class="headerlink" title="3.3 线程间定制化通信"></a>3.3 线程间定制化通信</h2><h3 id="3-3-1-案例介绍"><a href="#3-3-1-案例介绍" class="headerlink" title="3.3.1 案例介绍"></a>3.3.1 案例介绍</h3><p>&#x3D;&#x3D;问题: A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮&#x3D;&#x3D;</p><h3 id="4-4-2-实现流程"><a href="#4-4-2-实现流程" class="headerlink" title="4.4.2 实现流程"></a>4.4.2 实现流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间定制化通信</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里实现：</span></span><br><span class="line"><span class="comment"> * flag=1时，aa打印5次，并set flag=2</span></span><br><span class="line"><span class="comment"> * flag=2时，bb打印10次，并set flag=3</span></span><br><span class="line"><span class="comment"> * flag=3时，cc打印15次，并set flag=1</span></span><br><span class="line"><span class="comment"> * 循环10次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//第一步：创建资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareResource</span> &#123;</span><br><span class="line">    <span class="comment">//标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建三个condition，实现指定唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印5次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：判断 干活 通知</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)&#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + + i + <span class="string">&quot;，轮数：&quot;</span> + loop);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//修改标志位</span></span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">                c2.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印10次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：判断 干活 通知</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + + i + <span class="string">&quot;，轮数：&quot;</span> + loop);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//修改标志位</span></span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">                c3.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印15次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：判断 干活 通知</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + + i + <span class="string">&quot;，轮数：&quot;</span> + loop);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//修改标志位</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                c1.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatileCustom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareResource</span> <span class="variable">shareResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        shareResource.print5(i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        shareResource.print10(i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        shareResource.print15(i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-集合的线程安全"><a href="#4-集合的线程安全" class="headerlink" title="4 集合的线程安全"></a>4 集合的线程安全</h1><h2 id="4-1-ArrayList的线程安全"><a href="#4-1-ArrayList的线程安全" class="headerlink" title="4.1 ArrayList的线程安全"></a>4.1 ArrayList的线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList是线程不安全的，因为它的add()等方法并没有使用synchronized关键字</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 会报异常：java.util.ConcurrentModificationException   并发修改问题</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解决方案：1 Vector                     线程安全，但古老，效率低，不常用</span></span><br><span class="line"><span class="comment"> *         2 Collections                古老，不常用</span></span><br><span class="line"><span class="comment"> *         3 CopyOnWriteArrayList       JUC工具包中的类，常用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法一：Vector</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法二：Collections工具类、</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法三：CopyOnWriteArrayList      写时复制技术</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                    System.out.println(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-HashSet的线程安全"><a href="#4-2-HashSet的线程安全" class="headerlink" title="4.2 HashSet的线程安全"></a>4.2 HashSet的线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet也是线程不安全的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 也会出现并发修改问题   java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解决方法：CopyOnWriteArraySet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方法：CopyOnWriteArraySet</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                    System.out.println(set);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-HashMap的线程安全"><a href="#4-3-HashMap的线程安全" class="headerlink" title="4.3 HashMap的线程安全"></a>4.3 HashMap的线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap也是线程不安全的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也会出现并发修改问题   java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解决方法：1 HashTable                 不推荐</span></span><br><span class="line"><span class="comment"> *         2 ConcurrentHashMap         推荐</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方法：ConcurrentHashMap</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    map.put(key,UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                    System.out.println(map);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-CopyOnWriteArrayList详解-重点"><a href="#4-4-CopyOnWriteArrayList详解-重点" class="headerlink" title="4.4 CopyOnWriteArrayList详解(重点)"></a>4.4 CopyOnWriteArrayList详解(重点)</h2><p>首先我们对 CopyOnWriteArrayList 进行学习,其特点如下:</p><p>它相当于线程安全的 ArrayList。和 ArrayList 一样，它是个可变数组；但是和</p><p>ArrayList 不同的时，它具有以下特性：</p><ol><li>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多</li></ol><p>于可变操作，需要在遍历期间防止线程间的冲突。</p><ol start="2"><li><p>它是线程安全的。</p></li><li><p>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove()</p></li></ol><p>等等）的开销很大。</p><ol start="4"><li><p>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</p></li><li><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代</p></li></ol><p>器时，迭代器依赖于不变的数组快照。</p><p><strong>1. 独占锁效率低：采用读写分离思想解决</strong></p><p><strong>2. 写线程获取到锁，其他写线程阻塞</strong></p><p><strong>3. 复制思想</strong></p><p><font color="red">有点像JUC03中讲的JMM多线程对变量的读写过程，将共享变量复制到自己的工作内存中，再使用volatile实现可见性和有序性（猜测可能是这个，本人不确定）（不是一个东西）</font></p><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容</p><p>器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素</p><p>之后，再将原容器的引用指向新的容器。</p><p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来</strong></p><p><strong>得及写会内存，其他的线程就会读到了脏数据。</strong>解决：通过 volatile 和互斥锁（马上就讲）</p><p>&#x3D;&#x3D;<strong>这就是 CopyOnWriteArrayList 的思想和原理。就是拷贝一份。</strong>&#x3D;&#x3D;</p><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711004453480.png" alt="image-20230711004453480"></p><p>使用CopyOnWriteArrayList 没有线程安全问题</p><p><strong>原因分析</strong>(<strong>重点</strong>):&#x3D;&#x3D;<strong>动态数组与线程安全</strong>&#x3D;&#x3D;</p><p>下面从“动态数组”和“线程安全”两个方面进一步对</p><p>CopyOnWriteArrayList 的原理进行说明。</p><p>• <strong>“动态数组”机制</strong></p><p>o 它内部有个“volatile 数组”(array)来保持数据。在“添加&#x2F;修改&#x2F;删除”数据</p><p>时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该</p><p>数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因</p><p>o <strong>由于它在“添加&#x2F;修改&#x2F;删除”数据时，都会新建数组，所以涉及到修改数据的</strong></p><p><strong>操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，</strong></p><p><strong>效率比较高。</strong></p><p>• <strong>“线程安全”机制</strong></p><p>o 通过 volatile 和互斥锁来实现的。</p><p>o 通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看</p><p>到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读</p><p>取到的数据总是最新的”这个机制的保证。</p><p>o 通过互斥锁来保护数据。在“添加&#x2F;修改&#x2F;删除”数据时，会先“获取互斥锁”，</p><p>再修改完毕之后，先将数据更新到“volatile 数组”中，然后再“释放互斥</p><p>锁”，就达到了保护数据的目的</p><h2 id="4-5-小结-重点"><a href="#4-5-小结-重点" class="headerlink" title="4.5 小结(重点)"></a><strong>4.5 小结(重点)</strong></h2><p><strong>1.线程安全与线程不安全集合</strong></p><p>集合类型中存在线程安全与线程不安全的两种,常见例如:</p><p>ArrayList —– Vector</p><p>HashMap —–HashTable</p><p>但是以上都是通过 synchronized 关键字实现,效率较低</p><p><strong>2.Collections 构建的线程安全集合</strong></p><p><strong>3.java.util.concurrent 并发包下</strong></p><p>CopyOnWriteArrayList 和CopyOnWriteArraySet 类型,通过动态数组与线程安</p><p>全个方面保证线程安全</p><h1 id="5-多线程锁"><a href="#5-多线程锁" class="headerlink" title="5 多线程锁"></a>5 多线程锁</h1><h2 id="5-1-锁的八个问题演示"><a href="#5-1-锁的八个问题演示" class="headerlink" title="5.1 锁的八个问题演示"></a>5.1 锁的八个问题演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//停留4秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------getHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 8锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">1 标准访问，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment">------sendEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 停4秒在短信方法内，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment">------sendEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 新增普通的hello方法，是先打短信还是hello</span></span><br><span class="line"><span class="comment">------getHello</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 现在有两部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">------sendEmail</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 两个静态同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment">------sendEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 两个静态同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment">------sendEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">------sendEmail</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">------sendEmail</span></span><br><span class="line"><span class="comment">------sendSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// phone.sendEmail();</span></span><br><span class="line">               <span class="comment">// phone.getHello();</span></span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的</p><p>一个 synchronized 方法了，</p><p>其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些</p><p>synchronized 方法</p><p>锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的</p><p>synchronized 方法</p><p>加个普通方法后发现和同步锁无关</p><p>换成两个对象后，不是同一把锁了，情况立刻变化。</p><p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p><p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p><p><strong>对于普通同步方法，锁是当前实例对象。</strong></p><p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p><p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方</p><p>法必须等待获取锁的方法释放锁后才能获取锁，</p><p>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，</p><p>所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所</p><p>以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p><p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才</p><p>能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同</p><p>步方法之间，只要它们同一个类的实例对象！</p><h2 id="5-2-公平锁和可重入锁"><a href="#5-2-公平锁和可重入锁" class="headerlink" title="5.2 公平锁和可重入锁"></a>5.2 公平锁和可重入锁</h2><p><strong>公平锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);       <span class="comment">//设置是否为公平锁，默认为false，代表抢占式锁，若为true，则表示若有人，则自觉排队</span></span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711160825024.png" alt="image-20230711160825024"></p><p>可重入锁也叫递归锁：多层锁机制只需要同一把锁即可自由出入</p><p><strong>可重入锁案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可重入锁（递归锁）：多层锁机制只需要同一把锁即可自由出入</span></span><br><span class="line"><span class="comment">         * synchronized(隐式)    lock(显式)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//synchronized可重入锁演示1：</span></span><br><span class="line">        <span class="comment">/*Object o = new Object();</span></span><br><span class="line"><span class="comment">        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            synchronized (o)&#123;</span></span><br><span class="line"><span class="comment">                System.out.println(Thread.currentThread().getName() + &quot;外层&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                synchronized (o)&#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(Thread.currentThread().getName() + &quot;中层&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    synchronized (o)&#123;</span></span><br><span class="line"><span class="comment">                        System.out.println(Thread.currentThread().getName() + &quot;内层&quot;);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;,&quot;t1&quot;).start();*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//synchronized可重入锁演示2：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SyncLockDemo</span>().add();   <span class="comment">//将会报栈内存溢出，证明可以递归调用add方法自己，是可重入锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock演示可重入锁       递归使用锁必须一上锁对应一解锁，加入内部锁上锁了不解锁，自己线程使用会没问题，但是会影响其它线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 外层&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//上锁</span></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-死锁"><a href="#5-3-死锁" class="headerlink" title="5.3 死锁"></a>5.3 死锁</h2><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711160927379.png" alt="image-20230711160927379"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁：两个或者两个以上进程在执行过程中，因为争夺资源而造成一种互相等待的现象，如果设有外力干涉，他们无法再执行下去</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 死锁的验证方式：第一步：jps  第二步：jstack 进程号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先创建两个对象充当两把锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;持有锁a，试图获取锁b&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;持有锁b，试图获取锁a&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-Callable-Future-接口"><a href="#6-Callable-Future-接口" class="headerlink" title="6 Callable&amp;Future 接口"></a>6 Callable&amp;Future 接口</h1><h2 id="6-1-Callable-接口"><a href="#6-1-Callable-接口" class="headerlink" title="6.1 Callable 接口"></a>6.1 Callable 接口</h2><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711005529315.png" alt="image-20230711005529315"></p><p>目前我们学习了有两种创建线程的方法-一种是通过创建 Thread 类，另一种是</p><p>通过使用 Runnable 创建线程。但是，Runnable 缺少的一项功能是，当线程</p><p>终止时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，</p><p>Java 中提供了 Callable 接口。</p><p>&#x3D;&#x3D;<strong>现在我们学习的是创建线程的第三种方案—Callable 接口</strong>&#x3D;&#x3D;</p><p><strong>Callable 接口的特点如下(重点)</strong></p><p>• 为了实现 Runnable，需要实现不返回任何内容的 run（）方法，而对于</p><p>Callable，需要实现在完成时返回结果的 call（）方法。</p><p>• call（）方法可以引发异常，而 run（）则不能。</p><p>• 为实现 Callable 而必须重写 call 方法</p><p>• 不能直接替换 runnable,因为 Thread 类的构造方法根本没有 Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Callable：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-Future-接口"><a href="#6-2-Future-接口" class="headerlink" title="6.2 Future 接口"></a>6.2 Future 接口</h2><p>当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可</p><p>以知道该线程返回的结果。为此，可以使用 Future 对象。</p><p>将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦</p><p>Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的</p><p>一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:</p><p>• <strong>public boolean cancel（boolean mayInterrupt）：</strong>用于停止任务。</p><p>&#x3D;&#x3D;如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true&#x3D;&#x3D;</p><p>&#x3D;&#x3D;时才会中断任务。&#x3D;&#x3D;</p><p>• <strong>public Object get（）抛出 InterruptedException，ExecutionException：</strong></p><p>用于获取任务的结果。</p><p>&#x3D;&#x3D;如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。&#x3D;&#x3D;</p><p>• <strong>public boolean isDone（）：</strong>如果任务完成，则返回 true，否则返回 false</p><p>可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封</p><p>装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结</p><p>果。实际上，future 也可以与 Runnable 一起使用。</p><p>要创建线程，需要 Runnable。为了获得结果，需要 future。</p><h2 id="6-3-FutureTask"><a href="#6-3-FutureTask" class="headerlink" title="6.3 FutureTask"></a>6.3 FutureTask</h2><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方</p><p>便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建</p><p>FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建</p><p>Thread 对象。因此，间接地使用 Callable 创建线程。</p><p><strong>核心原理:(重点)</strong></p><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些</p><p>作业交给 Future 对象在后台完成</p><p>• 当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执</p><p>行状态</p><p>• 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去</p><p>获取结果。</p><p>• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</p><p>• 一旦计算完成，就不能再重新开始或取消计算</p><p>• get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完</p><p>成状态，然后会返回结果或者抛出异常</p><p>• get 只计算一次,因此 get 方法放到最后</p><h2 id="6-4-使用-Callable-和-Future"><a href="#6-4-使用-Callable-和-Future" class="headerlink" title="6.4 使用 Callable 和 Future"></a>6.4 使用 Callable 和 Future</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过Callable接口创建线程 ：可以有返回值 jdk1.5 新增</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较Runnable和Callable接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Runnable     run()       无返回值        不抛出异常       创建方式不同</span></span><br><span class="line"><span class="comment"> * Callable     call()      有返回值        会抛出异常       创建方式不同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Runnable：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Callable：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建Runnable线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread1</span>(),<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建Callable线程  报错</span></span><br><span class="line"><span class="comment">//        new Thread(new MyThread2(),&quot;BB&quot;).start();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建FutureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建Callable线程:</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2,<span class="string">&quot;Lucy&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1,<span class="string">&quot;mary&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用FutureTask的get()方法得到Callable接口的返回值</span></span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(futureTask1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come over&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//FutureTask原理  未来任务</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、老师上课，口渴了，去买票不合适，讲课线程继续。</span></span><br><span class="line"><span class="comment">         *   单开启线程找班上班长帮我买水，把水买回来，需要时候直接get</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2、4个同学， 1同学 1+2...5   ，  2同学 10+11+12....50， 3同学 60+61+62，  4同学 100+200</span></span><br><span class="line"><span class="comment">         *      第2个同学计算量比较大，</span></span><br><span class="line"><span class="comment">         *     FutureTask单开启线程给2同学计算，先汇总 1 3 4 ，最后等2同学计算位完成，统一汇总</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3、考试，做会做的题目，最后看不会做的题目</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 汇总一次</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-小结-重点"><a href="#6-5-小结-重点" class="headerlink" title="6.5 小结(重点)"></a>6.5 小结(重点)</h2><p>• 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些</p><p>作业交给 Future 对象在后台完成, <strong>当主线程将来需要时</strong>，就可以通过 Future</p><p>对象获得后台作业的计算结果或者执行状态</p><p>• <strong>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去</strong></p><p><strong>获取结果</strong></p><p>• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计</p><p>算完成，就不能再重新开始或取消计算。<strong>get 方法而获取结果只有在计算完成</strong></p><p><strong>时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异</strong></p><p><strong>常。</strong></p><p>• <strong>只计算一次</strong></p><h1 id="7-JUC-三大辅助类"><a href="#7-JUC-三大辅助类" class="headerlink" title="7 JUC 三大辅助类"></a>7 JUC 三大辅助类</h1><p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过</p><p>多时 Lock 锁的频繁操作。这三种辅助类为：</p><p>• CountDownLatch: 减少计数</p><p>• CyclicBarrier: 循环栅栏</p><p>• Semaphore: 信号灯</p><h2 id="7-1-减少计数-CountDownLatch"><a href="#7-1-减少计数-CountDownLatch" class="headerlink" title="7.1 减少计数 CountDownLatch"></a>7.1 减少计数 CountDownLatch</h2><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行</p><p>减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法</p><p>之后的语句。</p><p>• CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这</p><p>些线程会阻塞</p><p>• 其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程</p><p>不会阻塞)</p><p>• 当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行</p><p><strong>可使用在原子类AtomicInteger等场景中等待线程执行完毕后才获取值</strong></p><p><strong>场景: 6 个同学陆续离开教室后值班同学才可以关门。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示JUC辅助类：CountDownLatch</span></span><br><span class="line"><span class="comment"> * await()，阻塞线程，等待计数器为0后才执行后面的语句</span></span><br><span class="line"><span class="comment"> * countDown()，每次对计数器  -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//6位同学，都离开教室后，班长才锁门</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//计数器 -1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞线程等待计数器为0</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;班长锁门走人了&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-循环栅栏-CyclicBarrier"><a href="#7-2-循环栅栏-CyclicBarrier" class="headerlink" title="7.2 循环栅栏 CyclicBarrier"></a>7.2 循环栅栏 CyclicBarrier</h2><p>CyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中</p><p>CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一</p><p>次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后</p><p>的语句，即new CyclicBarrier 时定义的Runnable接口中的语句。</p><p>可以将 CyclicBarrier 理解为加 1 操作</p><p><strong>场景: 集齐 7 颗龙珠就可以召唤神龙</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JUC辅助类CyclicBarrier演示：</span></span><br><span class="line"><span class="comment"> * 理解：循环栅栏</span></span><br><span class="line"><span class="comment"> * new CyclicBarrier(int parties,Runnable barrierAction)</span></span><br><span class="line"><span class="comment"> * await()：当调用 parties 次await()方法后，将执行barrierAction中定义的语句</span></span><br><span class="line"><span class="comment"> * 若未达到parties次调用，则一直阻塞barrierAction的调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//集齐7颗龙珠才能召唤神龙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER,() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;成功召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;成功收集到&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;星龙珠&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-信号灯-Semaphore"><a href="#7-3-信号灯-Semaphore" class="headerlink" title="7.3 信号灯 Semaphore"></a>7.3 信号灯 Semaphore</h2><p>Semaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线</p><p>程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方</p><p>法获得许可证，release 方法释放许可</p><p><strong>场景: 抢车位, 6 部汽车 3 个停车位</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示JUC辅助类：SemaphoreDemo:</span></span><br><span class="line"><span class="comment"> * new Semaphore(3);设置许可数量permits</span></span><br><span class="line"><span class="comment"> * acquire()：抢占许可</span></span><br><span class="line"><span class="comment"> * release()：释放许可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6辆车抢3个车位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建semaphore，设置许可数量</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟6辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了车位&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---------离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-读写锁"><a href="#8-读写锁" class="headerlink" title="8 读写锁"></a>8 读写锁</h1><h2 id="8-1-读写锁介绍"><a href="#8-1-读写锁介绍" class="headerlink" title="8.1 读写锁介绍"></a>8.1 读写锁介绍</h2><p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那</p><p>么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以</p><p>应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，</p><p>就不应该允许其他线程对该资源进行读和写的操作了。</p><p>针对这种场景，<strong>JAVA 的并发包提供了读写锁 ReentrantReadWriteLock，</strong></p><p><strong>它表示两个锁，一个是读操作相关的锁，称为<font color="red">共享锁</font>；一个是写相关的锁，称</strong></p><p><strong>为<font color="red">排他锁（独占锁）</font></strong></p><p><font color="red"><strong>读的时候不能写，写的时候可以读</strong></font></p><ol><li>线程进入读锁的前提条件：</li></ol><p>• 没有其他线程的写锁</p><p>• 没有写请求, 或者&#x3D;&#x3D;有写请求，但调用线程和持有锁的线程是同一个(可重入&#x3D;&#x3D;</p><p>&#x3D;&#x3D;锁)。&#x3D;&#x3D;</p><ol start="2"><li>线程进入写锁的前提条件：</li></ol><p>• 没有其他线程的读锁</p><p>• 没有其他线程的写锁</p><p>而读写锁有以下三个重要的特性：</p><p>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公</p><p>平优于公平。</p><p>（2）重进入：读锁和写锁都支持线程重进入。</p><p>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，<font color="cornflowerblue">写锁能够降级成为</font></p><p><font color="cornflowerblue">读锁</font></p><h2 id="8-2-ReentrantReadWriteLock"><a href="#8-2-ReentrantReadWriteLock" class="headerlink" title="8.2 ReentrantReadWriteLock"></a>8.2 ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 类的整体结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>,java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用默认（非公平）的排序属性创建一个新的</span></span><br><span class="line"><span class="comment">     * ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的公平策略创建一个新的 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">        readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回用于写入操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                writerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回用于读取操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.ReadLock <span class="title function_">readLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                readerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ReentrantReadWriteLock 实现了 ReadWriteLock 接口，</p><p>ReadWriteLock 接口定义了获取读锁和写锁的规范，具体需要实现类去实现；</p><p>同时其还实现了 Serializable 接口，表示可以进行序列化，在源代码中可以看</p><p>到 ReentrantReadWriteLock 实现了自己的序列化逻辑。</p><h2 id="8-3-入门案例"><a href="#8-3-入门案例" class="headerlink" title="8.3 入门案例"></a>8.3 入门案例</h2><p><strong>场景: 使用 ReentrantReadWriteLock 对一个 hashmap 进行读和写操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写锁：ReadWriteLock</span></span><br><span class="line"><span class="comment"> * 读锁：共享锁   会发生死锁</span></span><br><span class="line"><span class="comment"> * 写锁：独占锁   会发生死锁</span></span><br><span class="line"><span class="comment"> * 读的时候不能写，写的时候可以读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//新建资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line">    <span class="comment">//创建map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建读写锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,Object value)</span>&#123;</span><br><span class="line">        <span class="comment">//添加写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 正在写操作&quot;</span>+key);</span><br><span class="line">            <span class="comment">//暂停一会</span></span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="comment">//放数据</span></span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放写锁</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取数据</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//添加写锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 正在读操作&quot;</span>+key);</span><br><span class="line">            <span class="comment">//暂停一会</span></span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="comment">//放数据</span></span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读完了&quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放写锁</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.put(num+<span class="string">&quot;&quot;</span>,num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.get(num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-读写锁的演变"><a href="#8-4-读写锁的演变" class="headerlink" title="8.4 读写锁的演变"></a>8.4 读写锁的演变</h2><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711155904877.png" alt="image-20230711155904877"></p><p>缺点：</p><p>(1)造成锁饥饿，一直读，设有写</p><p>操作，比如坐地铁</p><p>(2)读时候，不能写，只有读</p><p>完成之后，才可以写，写操作</p><p>可以读</p><h2 id="8-5-锁降级"><a href="#8-5-锁降级" class="headerlink" title="8.5 锁降级"></a>8.5 锁降级</h2><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711160212543.png" alt="image-20230711160212543"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写锁降级：写锁 -》 读锁 -》 释放写锁 -》 释放读锁</span></span><br><span class="line"><span class="comment"> * 只能由写锁降级为读锁</span></span><br><span class="line"><span class="comment"> * 但是不能由读锁升级为写锁</span></span><br><span class="line"><span class="comment"> * 因为读锁是共享的，你读的时候可能还有其他人正在读</span></span><br><span class="line"><span class="comment"> * 而写锁是独占的，当前只有你一个人在写，所以可以降级为读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();</span><br><span class="line">        </span><br><span class="line">        writeLock.lock();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        readLock.lock();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        writeLock.unlock();</span><br><span class="line"></span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-6-读写锁的死锁"><a href="#8-6-读写锁的死锁" class="headerlink" title="8.6 读写锁的死锁"></a>8.6 读写锁的死锁</h2><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711161304079.png" alt="image-20230711161304079"></p><p><font color="red"><strong>读的时候不能写，写的时候可以读</strong></font></p><p><strong>死锁案例：</strong></p><p>当使用<strong>表锁</strong>时，线程1和线程2都正在读某张表时（因为读锁共享），此时线程1想要写操作，</p><p>他需要等待线程2读完，但线程2此时也想要写操作，他也需要等待线程1读完，此时就造成死锁</p><p>当使用<strong>行锁</strong>时，线程1正在写操作第一行，线程2正在写操作第二行，于此同时，线程1想要操作第二行</p><p>线程2想要操作第一行，此时就造成死锁</p><h2 id="8-7-小结-重要"><a href="#8-7-小结-重要" class="headerlink" title="8.7 小结(重要)"></a>8.7 小结(重要)</h2><p>• 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发</p><p>现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>• 在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写</p><p>锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><p>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把</p><p>获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写</p><p>锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释</p><p>放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p><h1 id="9-阻塞队列"><a href="#9-阻塞队列" class="headerlink" title="9 阻塞队列"></a>9 阻塞队列</h1><h2 id="9-1-BlockingQueue-简介"><a href="#9-1-BlockingQueue-简介" class="headerlink" title="9.1 BlockingQueue 简介"></a>9.1 BlockingQueue 简介</h2><p>Concurrent 包中，BlockingQueue 很好的解决了多线程中，如何高效安全</p><p>“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建</p><p>高质量的多线程程序带来极大的便利。本文详细介绍了 BlockingQueue 家庭</p><p>中的所有成员，包括他们各自的功能以及常见使用场景。</p><p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据</p><p>由队列的一端输入，从另外一端输出；</p><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711162419099.png" alt="image-20230711162419099"></p><p><font color="cornflowerblue">当队列是空的，从队列中获取元素的操作将会被阻塞</font></p><p><font color="cornflowerblue">当队列是满的，从队列中添加元素的操作将会被阻塞</font></p><p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p><p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多</p><p>个元素或者完全清空，使队列变得空闲起来并后续新增</p><p>常用的队列主要有以下两种：</p><p><font color="cornflowerblue">• 先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。</font></p><p><font color="cornflowerblue">从某种程度上来说这种队列也体现了一种公平性</font></p><p><font color="cornflowerblue">• 后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发</font></p><p><font color="cornflowerblue">生的事件(栈)</font></p><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起</p><p>的线程又会自动被唤起</p><p>为什么需要 BlockingQueue</p><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切</p><p>BlockingQueue 都给你一手包办了</p><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细</p><p>节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和</p><p>“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我</p><p>们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准</p><p>备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地</p><p>解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一</p><p>发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度</p><p>大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么</p><p>生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的</p><p>数据处理完毕，反之亦然。</p><p>• <font color="cornflowerblue">当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），</font></p><p><font color="cornflowerblue">直到有数据放入队列</font></p><p><font color="cornflowerblue">• 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），</font></p><p><font color="cornflowerblue">直到队列中有空的位置，线程被自动唤醒</font></p><h2 id="9-2-BlockingQueue-核心方法"><a href="#9-2-BlockingQueue-核心方法" class="headerlink" title="9.2 BlockingQueue 核心方法"></a>9.2 BlockingQueue 核心方法</h2><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711162552598.png" alt="image-20230711162552598"></p><p><strong>BlockingQueue 的核心方法</strong>：</p><p><strong>1.放入数据</strong></p><p>• offer(anObject):表示如果可能的话,将 anObject 加到 BlockingQueue 里,即</p><p>如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.<strong>（本方法不阻塞当</strong></p><p><strong>前执行方法的线程）</strong></p><p>• offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定</p><p>的时间内，还不能往队列中加入 BlockingQueue，则返回失败</p><p>• put(anObject):把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有</p><p>空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.</p><p><strong>2.获取数据</strong></p><p>• poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,<strong>则可以等</strong></p><p><strong>time 参数规定的时间,取不到时返回 null</strong></p><p>• poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，</p><p>如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知</p><p>道时间超时还没有数据可取，返回失败。</p><p>• take(): 取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,<strong>阻断</strong></p><p><strong>进入等待状态直到 BlockingQueue 有新的数据被加入</strong>;</p><p>• drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定</p><p>获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加</p><p>锁或释放锁。</p><h2 id="9-3-入门案例"><a href="#9-3-入门案例" class="headerlink" title="9.3 入门案例"></a>9.3 入门案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建阻塞队列，长度为3</span></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一组：抛出异常</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.element());</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;w&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二组：返回true false</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;w&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三组：阻塞</span></span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;w&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第四组：设置阻塞超时时间</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;w&quot;</span>,<span class="number">3L</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-4-常见的-BlockingQueue"><a href="#9-4-常见的-BlockingQueue" class="headerlink" title="9.4 常见的 BlockingQueue"></a>9.4 常见的 BlockingQueue</h2><h3 id="9-4-1-ArrayBlockingQueue-常用"><a href="#9-4-1-ArrayBlockingQueue-常用" class="headerlink" title="9.4.1 ArrayBlockingQueue(常用)"></a>9.4.1 ArrayBlockingQueue(常用)</h3><p>基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数</p><p>组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数</p><p>组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的</p><p>头部和尾部在数组中的位置</p><p>ArrayBlockingQueue 和LinkedBlockingQueue 间还有一个明显的不同之处</p><p>在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者</p><p>则会生成一个额外的Node 对象。这在长时间内需要高效并发地处理大批量数</p><p>据的系统中，其对于GC 的影响还是存在一定的区别。</p><p>而在创建 ArrayBlockingQueue 时，我们还、可以控制对象的内部锁是否采用</p><p>公平锁，默认采用非公平锁。</p><p>&#x3D;&#x3D;<strong>一句话总结: 由数组结构组成的有界阻塞队列。</strong>&#x3D;&#x3D;</p><h3 id="9-4-2-LinkedBlockingQueue-常用"><a href="#9-4-2-LinkedBlockingQueue-常用" class="headerlink" title="9.4.2 LinkedBlockingQueue(常用)"></a>9.4.2 LinkedBlockingQueue(常用)</h3><p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着一</p><p>个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据</p><p>时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；</p><p>只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue 可以通过</p><p>构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份</p><p>数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p><p>而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生</p><p>产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发</p><p>的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列</p><p>的并发性能。</p><p><strong>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用</strong></p><p><strong>的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个</strong></p><p><strong>类足以。</strong></p><p>&#x3D;&#x3D;<strong>一句话总结: 由链表结构组成的有界（但大小默认值为</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>integer.MAX_VALUE）阻塞队列。</strong>&#x3D;&#x3D;</p><h3 id="9-4-3-DelayQueue"><a href="#9-4-3-DelayQueue" class="headerlink" title="9.4.3 DelayQueue"></a>9.4.3 DelayQueue</h3><p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到</p><p>该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的</p><p>操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻</p><p>塞。</p><p>&#x3D;&#x3D;<strong>一句话总结: 使用优先级队列实现的延迟无界阻塞队列。</strong>&#x3D;&#x3D;</p><h3 id="9-4-4-PriorityBlockingQueue"><a href="#9-4-4-PriorityBlockingQueue" class="headerlink" title="9.4.4 PriorityBlockingQueue"></a>9.4.4 PriorityBlockingQueue</h3><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来</p><p>决定），但需要注意的是 PriorityBlockingQueue 并<strong>不会阻塞数据生产者，而</strong></p><p><strong>只会在没有可消费的数据时，阻塞数据的消费者</strong>。</p><p>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费</strong></p><p><strong>数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间。</p><p>在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是<strong>公平锁</strong>。</p><p>&#x3D;&#x3D;<strong>一句话总结: 支持优先级排序的无界阻塞队列。</strong>&#x3D;&#x3D;</p><h3 id="9-4-5-SynchronousQueue"><a href="#9-4-5-SynchronousQueue" class="headerlink" title="9.4.5 SynchronousQueue"></a>9.4.5 SynchronousQueue</h3><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产</p><p>者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须</p><p>亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么</p><p>对不起，大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一</p><p>个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经</p><p>销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以</p><p>库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式</p><p>会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得</p><p>产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能</p><p>可能会降低。</p><p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的</p><p>行为。</p><p><strong>公平模式和非公平模式的区别:</strong></p><p>• 公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞</p><p>多余的生产者和消费者，从而体系整体的公平策略；</p><p>• 非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平</p><p>锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，</p><p>如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有</p><p>某些生产者或者是消费者的数据永远都得不到处理。</p><p>&#x3D;&#x3D;<strong>一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。</strong>&#x3D;&#x3D;</p><h3 id="9-4-6-LinkedTransferQueue"><a href="#9-4-6-LinkedTransferQueue" class="headerlink" title="9.4.6 LinkedTransferQueue"></a>9.4.6 LinkedTransferQueue</h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队</p><p>列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和</p><p>transfer 方法。</p><p>LinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如</p><p>果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素</p><p>为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时</p><p>发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到</p><p>该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的</p><p>方法返回。</p><p>&#x3D;&#x3D;<strong>一句话总结: 由链表组成的无界阻塞队列。</strong>&#x3D;&#x3D;</p><h3 id="9-4-7-LinkedBlockingDeque"><a href="#9-4-7-LinkedBlockingDeque" class="headerlink" title="9.4.7 LinkedBlockingDeque"></a>9.4.7 LinkedBlockingDeque</h3><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队</p><p>列的两端插入和移除元素。</p><p>对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作</p><p>可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情</p><p>况</p><p>• 插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时</p><p>再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作</p><p>失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异</p><p>常</p><p>• 读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可</p><p>以通过设置超时参数</p><p>&#x3D;&#x3D;<strong>一句话总结: 由链表组成的双向阻塞队列</strong>&#x3D;&#x3D;</p><h2 id="9-5-小结"><a href="#9-5-小结" class="headerlink" title="9.5 小结"></a>9.5 小结</h2><p><strong>1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件</strong></p><p><strong>满足，被挂起的线程又会自动被唤起</strong></p><p><strong>2. 为什么需要 BlockingQueue?</strong> 在 concurrent 包发布以前，在多线程环境下，</p><p>我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，</p><p>而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要</p><p>阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手</p><p>包办了</p><h1 id="10-ThreadPool-线程池"><a href="#10-ThreadPool-线程池" class="headerlink" title="10 ThreadPool 线程池"></a>10 ThreadPool 线程池</h1><h2 id="10-1-线程池简介"><a href="#10-1-线程池简介" class="headerlink" title="10.1 线程池简介"></a>10.1 线程池简介</h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，</p><p>进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理</p><p>者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代</p><p>价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><p>例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需</p><p>要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换</p><p>效率高。</p><p><strong>线程池的优势：</strong> 线程池做的工作只要是控制运行的线程数量，处理过程中将任</p><p>务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，</p><p>超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p><strong>它的主要特点为：</strong></p><p>• 降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p><p>• 提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</p><p>• 提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资</p><p>源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><p>• <strong>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，</strong></p><p><strong>ExecutorService，ThreadPoolExecutor这几个类</strong></p><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711163322964.png" alt="image-20230711163322964"></p><h2 id="10-2-线程池参数说明"><a href="#10-2-线程池参数说明" class="headerlink" title="10.2 线程池参数说明"></a>10.2 线程池参数说明</h2><h3 id="10-2-1-常用参数-重点"><a href="#10-2-1-常用参数-重点" class="headerlink" title="10.2.1 常用参数(重点)"></a>10.2.1 常用参数(重点)</h3><p>• corePoolSize 线程池的核心线程数</p><p>• maximumPoolSize 能容纳的最大线程数</p><p>• keepAliveTime 空闲线程存活时间</p><p>• unit 存活的时间单位</p><p>• workQueue 存放提交但未执行任务的队列</p><p>• threadFactory 创建线程的工厂类</p><p>• handler 等待队列满后的拒绝策略</p><p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线</p><p>程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -</p><p>最大线程数：</p><p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻</p><p>塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到</p><p>maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池</p><p>的拒绝策略了。</p><p>总结起来，也就是一句话，<strong>当提交的任务数大于（workQueue.size() +</strong> </p><p><strong>maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p><h3 id="10-2-2-拒绝策略-重点"><a href="#10-2-2-拒绝策略-重点" class="headerlink" title="10.2.2 拒绝策略(重点)"></a>10.2.2 拒绝策略(重点)</h3><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711164218645.png" alt="image-20230711164218645"></p><p><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常</p><p>信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执</p><p>行流程，影响后续的任务执行。</p><p><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用</p><p>线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由</p><p>于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效</p><p>率上必然的损失较大</p><p><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞</p><p>队列 workQueue 中最老的一个任务，并将新任务加入</p><p><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</p><h2 id="10-3-线程池的常用种类"><a href="#10-3-线程池的常用种类" class="headerlink" title="10.3 线程池的常用种类"></a>10.3 线程池的常用种类</h2><h3 id="10-3-1-newCachedThreadPool-常用"><a href="#10-3-1-newCachedThreadPool-常用" class="headerlink" title="10.3.1 newCachedThreadPool(常用)"></a>10.3.1 newCachedThreadPool(常用)</h3><p><strong>作用</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空</p><p>闲线程，若无可回收，则新建线程.</p><p><strong>特点</strong>: </p><p>• 线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）</p><p>• 线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</p><p>• 当线程池中，没有可用线程，会重新创建一个线程</p><p><strong>场景:</strong> 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较</p><p>短，任务多的场景</p><h3 id="10-3-2-newFixedThreadPool-常用"><a href="#10-3-2-newFixedThreadPool-常用" class="headerlink" title="10.3.2 newFixedThreadPool(常用)"></a>10.3.2 newFixedThreadPool(常用)</h3><p><strong>作用</strong>：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这</p><p>些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线</p><p>程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中</p><p>等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线</p><p>程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池</p><p>中的线程将一直存在。</p><p><strong>特征：</strong></p><p>• 线程池中的线程处于一定的量，可以很好的控制线程的并发量</p><p>• 线程可以重复被使用，在显示关闭之前，都将一直存在</p><p>• 超出一定量的线程被提交时候需在队列中等待</p><p><strong>场景:</strong> 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严</p><p>格限制的场景</p><h3 id="10-3-3-newSingleThreadExecutor-常用"><a href="#10-3-3-newSingleThreadExecutor-常用" class="headerlink" title="10.3.3 newSingleThreadExecutor(常用)"></a>10.3.3 newSingleThreadExecutor(常用)</h3><p><strong>作用</strong>：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该</p><p>线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，</p><p>那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各</p><p>个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的</p><p>newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即</p><p>可使用其他的线程。</p><p><strong>特征：</strong> 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此</p><p>执行</p><p><strong>场景:</strong> 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个</p><p>线程的场景</p><h3 id="10-3-4-newScheduleThreadPool-了解"><a href="#10-3-4-newScheduleThreadPool-了解" class="headerlink" title="10.3.4 newScheduleThreadPool(了解)"></a>10.3.4 newScheduleThreadPool(了解)</h3><p><strong>作用:</strong> 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参</p><p>数，最大线程数为整形的最大数的线程池</p><p><strong>特征:</strong></p><p>（1）线程池中具有指定数量的线程，即便是空线程也将保留 </p><p>（2）可定时或者延迟执行线程活动</p><p><strong>场景:</strong> 适用于需要多个后台线程执行周期任务的场景</p><h2 id="10-4-常用线程池入门案例"><a href="#10-4-常用线程池入门案例" class="headerlink" title="10.4 常用线程池入门案例"></a>10.4 常用线程池入门案例</h2><p><strong>场景: 火车站 3 个售票口, 10 个用户买票</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池      创建多线程的第四种办法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="comment">//演示线程池三种常用分类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池五线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池可扩容线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//10个顾客请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//执行</span></span><br><span class="line">                threadPool3.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 办理事务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程池</span></span><br><span class="line">            threadPool3.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-5-线程池底层工作原理-重要"><a href="#10-5-线程池底层工作原理-重要" class="headerlink" title="10.5 线程池底层工作原理(重要)"></a>10.5 线程池底层工作原理(重要)</h2><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711164040893.png" alt="image-20230711164040893"></p><ol><li><p>在创建了线程池后，线程池中的线程数为零</p></li><li><p>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： 2.1 如</p></li></ol><p>果正在运行的线程数量<strong>小于 corePoolSize，那么马上创建线程运行这个任务</strong>；</p><p>2.2 如果正在运行的线程数量<strong>大于或等于 corePoolSize，那么将这个任务放入</strong></p><p><strong>队列</strong>； 2.3 如果这个时候<strong>队列满了且正在运行的线程数量还小于</strong></p><p><strong>maximumPoolSize，那么还是要创建非核心线程<font color="red">立刻</font>运行这个任务</strong>； 2.4 如</p><p>果<strong>队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程</strong></p><p><strong>池会启动饱和拒绝策略来执行</strong>。（大于QueueSize + MaxPoolSize才拒绝）</p><ol start="3"><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p></li></ol><p>4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 4.2 </p><p>所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><blockquote><p>Springboot应用默认情况下可以同时运行几个线程？</p><p>忘记了，好像是300个，因为springboot应用的线程池的maximumPoolSize为Integer.max，但是maximumPoolSize的优先级最低</p></blockquote><h2 id="10-6-自定义线程池-重要"><a href="#10-6-自定义线程池-重要" class="headerlink" title="10.6 自定义线程池(重要)"></a>10.6 自定义线程池(重要)</h2><ol><li>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都</li></ol><p>有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用</p><p>LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，</p><p>容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参</p><p>数，自定义线程池</p><ol start="2"><li>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</li></ol><p>o corePoolSize 线程池的核心线程数</p><p>o maximumPoolSize 能容纳的最大线程数</p><p>o keepAliveTime 空闲线程存活时间</p><p>o unit 存活的时间单位</p><p>o workQueue 存放提交但未执行任务的队列</p><p>o threadFactory 创建线程的工厂类</p><p>o handler 等待队列满后的拒绝策略</p><ol start="3"><li>为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图</li></ol><p><img src="https://www.hahhome.top/blog/JUCBase/../../image/JUCBase.assets/image-20230711164326660.png" alt="image-20230711164326660"></p><p><strong>自定义线程池案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程池</span></span><br><span class="line"><span class="comment"> * 开发中前面讲的三种线程池创建方式都不会用，会造成OOM</span></span><br><span class="line"><span class="comment"> * 所以一般使用自定义线程池</span></span><br><span class="line"><span class="comment">    • corePoolSize 线程池的核心线程数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    • maximumPoolSize 能容纳的最大线程数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    • keepAliveTime 空闲线程存活时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    • unit 存活的时间单位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    • workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    • threadFactory 创建线程的工厂类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    • handler 等待队列满后的拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//自定义线程池创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">3L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),    <span class="comment">//阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),       <span class="comment">//线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()    <span class="comment">//拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//10个顾客请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理事务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-Fork-Join-分支合并框架"><a href="#11-Fork-Join-分支合并框架" class="headerlink" title="11 Fork&#x2F;Join 分支合并框架"></a>11 Fork&#x2F;Join 分支合并框架</h1><h2 id="11-1-Fork-Join-框架简介"><a href="#11-1-Fork-Join-框架简介" class="headerlink" title="11.1 Fork&#x2F;Join 框架简介"></a>11.1 Fork&#x2F;Join 框架简介</h2><p>Fork&#x2F;Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子</p><p>任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join 框架要完成两件事</p><p>情：</p><blockquote><p><strong>Fork：把一个复杂任务进行分拆，大事化小</strong></p></blockquote><blockquote><p><strong>Join：把分拆任务的结果进行合并</strong></p></blockquote><ol><li><strong>任务分割</strong>：首先 Fork&#x2F;Join 框架需要把大的任务分割成足够小的子任务，如果</li></ol><p>子任务比较大的话还要对子任务进行继续分割</p><ol start="2"><li><strong>执行任务并合并结果</strong>：分割的子任务分别放到双端队列里，然后几个启动线程</li></ol><p>分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，</p><p>启动一个线程从队列里取数据，然后合并这些数据。</p><p>在 Java 的 Fork&#x2F;Join 框架中，使用两个类完成上述操作</p><p>• <strong>ForkJoinTask</strong>:我们要使用 Fork&#x2F;Join 框架，首先需要创建一个 ForkJoin 任务。</p><p>该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集</p><p>成 ForkJoinTask 类，只需要继承它的子类，Fork&#x2F;Join 框架提供了两个子类：</p><p> a.RecursiveAction：用于没有返回结果的任务</p><p> b.RecursiveTask:用于有返回结果的任务</p><p>• <strong>ForkJoinPool</strong>:ForkJoinTask 需要通过 ForkJoinPool 来执行</p><p>• <strong>RecursiveTask</strong>: 继承后可以实现递归(自己调自己)调用的任务</p><p><strong>Fork&#x2F;Join 框架的实现原理</strong></p><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成，</p><p>ForkJoinTask 数组负责将存放以及将程序提交给 ForkJoinPool，而</p><p>ForkJoinWorkerThread 负责执行这些任务。</p><h2 id="11-2-任务拆分案例"><a href="#11-2-任务拆分案例" class="headerlink" title="11.2 任务拆分案例"></a>11.2 任务拆分案例</h2><p><strong>Fork 方法的实现原理：</strong> 当我们调用 ForkJoinTask 的 fork 方法时，程序会把</p><p>任务放在 ForkJoinWorkerThread 的 pushTask 的 <strong>workQueue</strong> 中，异步地</p><p>执行这个任务，然后立即返回结果</p><p>递归任务：继承后可以实现递归（自己调自己）调用的任务</p><p><strong>案例：</strong></p><p><strong>场景: 生成一个计算任务，计算 1+2+3………+1000</strong>,<strong>&#x3D;&#x3D;每 100 个数切分一个</strong></p><p><strong>子任务&#x3D;&#x3D;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并框架：任务拆分合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//拆分差值不能超过10，计算10以内运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;<span class="comment">//拆分开始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;<span class="comment">//拆分结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分和合并过程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断相加两个数值是否大于10</span></span><br><span class="line">        <span class="keyword">if</span> ((end - begin) &lt;= VALUE)&#123;</span><br><span class="line">            <span class="comment">//相加操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//进一步拆分</span></span><br><span class="line">            <span class="comment">//获取中间值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拆分左边</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);</span><br><span class="line">            <span class="comment">//拆分右边</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//调用方法拆分</span></span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            <span class="comment">//合并结果</span></span><br><span class="line">            result = task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建MyTask对象</span></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建分支合并池对象</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line">        <span class="comment">//获取最终合并之后结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//关闭池对象</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-CompletableFuture"><a href="#12-CompletableFuture" class="headerlink" title="12 CompletableFuture"></a>12 CompletableFuture</h1><h2 id="12-1-CompletableFuture-简介"><a href="#12-1-CompletableFuture-简介" class="headerlink" title="12.1 CompletableFuture 简介"></a>12.1 CompletableFuture 简介</h2><p>CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，</p><p>可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可</p><p>以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。</p><p>CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future</p><p>接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程</p><p>的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的</p><p>CompletableFuture 类。</p><h2 id="12-2-Future-与-CompletableFuture"><a href="#12-2-Future-与-CompletableFuture" class="headerlink" title="12.2 Future 与 CompletableFuture"></a>12.2 Future 与 CompletableFuture</h2><p>Futrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提</p><p>交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方</p><p>法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获</p><p>取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或</p><p>者不断轮询才能知道任务是否完成。</p><p><strong>Future 的主要缺点如下：</strong></p><p>（1）不支持手动完成</p><p>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，</p><p>现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直</p><p>等待它执行完成</p><p>（2）不支持进一步的非阻塞调用</p><p>通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行</p><p>额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能</p><p>（3）不支持链式调用</p><p>对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成</p><p>一个链式的 pipline 调用，这在 Future 中是没法实现的。</p><p>（4）不支持多个 Future 合并</p><p>比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，</p><p>执行某些函数，是没法通过 Future 实现的。</p><p>（5）不支持异常处理</p><p>Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题</p><p>是不好定位的。</p><h2 id="12-3-异步调用"><a href="#12-3-异步调用" class="headerlink" title="12.3 异步调用"></a>12.3 异步调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步调用和同步调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//没有返回值的异步调用</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;completableFuture1&quot;</span>);  </span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture1.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//由返回值的异步调用</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;completableFuture2&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture2.whenComplete((t,u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-------t=&quot;</span> + t);</span><br><span class="line">            System.out.println(<span class="string">&quot;-------u=&quot;</span> + u);</span><br><span class="line">        &#125;).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载器</title>
      <link href="/blog/JVMClassLoader/"/>
      <url>/blog/JVMClassLoader/</url>
      
        <content type="html"><![CDATA[<h1 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h1><p>环境JDK1.8中，在JDK1.9时，类的加载器会发生一定的变化，但对于学习改变不大</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="ClassLoader的作用"><a href="#ClassLoader的作用" class="headerlink" title="ClassLoader的作用"></a>ClassLoader的作用</h3><p>类加载器是JVM执行类加载机制的前提。</p><p>ClassLoader的作用：</p><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader:进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给]ava虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p><p><img src="https://www.hahhome.top/blog/JVMClassLoader/../../image/JVMClassLoader.assets/image-20230709204232835.png" alt="image-20230709204232835"></p><p>类加载器最早出现在java1.0版本中，那个时候只是单纯地为了满足java Applet.应用而被研发出来。但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计拳加载器的时候，并没有考虑将它绑定在]VM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p><h3 id="显式加载与隐式加载"><a href="#显式加载与隐式加载" class="headerlink" title="显式加载与隐式加载"></a>显式加载与隐式加载</h3><p>类的加载分类：显式加载Vs隐式加载</p><p>class文件的显式加载与隐式加载的方式是指]VM加载class文件到内存的方式。</p><ul><li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li><li>隐式加载则是不直接在代码中调用classLoader的方法加载class对象，而是通过<strong>虚拟机自动加载到内存中</strong>，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><p>在日常开发以上两种方式一般会混合使用。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>1.何为类的唯一性？</strong></p><p>对于任意一个类，<font color="red">都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</font>。每一个类加载器，都拥有一个独立的类名称空间：<font color="red">比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</font>。否则,即使这两个类源自同一个Class文件，被同一个虚拟机加载，<strong>只要加载他们的类加载器不同，那这两个类就必定不相等</strong>。</p><p><strong>2.命名空间</strong></p><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><p><strong>3.如何判断两个类是同一个类？</strong></p><ul><li>两个类的全类名（包括包名）相等</li><li>加载两个类的类加载器相同</li></ul><h3 id="类加载机制的基本特征"><a href="#类加载机制的基本特征" class="headerlink" title="类加载机制的基本特征"></a>类加载机制的基本特征</h3><p>通常类加载机制有三个基本特征：</p><ul><li><strong>双亲委派模型</strong>。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvidet&#x2F;ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li><li>可见性，<strong>子类加载器可以访问父加载器加载的类型</strong>，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li><li>单一性，由于父加载器的类型对于子加载器是可见的，所以<strong>父加载器中加载过的类型，就不会在子加载器中重复加载</strong>。但是注意，<strong>类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见</strong>。</li></ul><h3 id="类加载器之间的关系"><a href="#类加载器之间的关系" class="headerlink" title="类加载器之间的关系"></a>类加载器之间的关系</h3><p><strong>源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统类加载器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展类加载器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLClassLoader</span> <span class="keyword">extends</span> <span class="title class_">SecureClassLoader</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>AppClassLoader的父类是ExtClassLoader</li><li>ExtClassLoader的父类是BootstrapClassLoader</li><li>AppClassLoader和ExtClassLoader都继承于URLClassLoader，而URLClassLoader继承于SecureClassLoader又继承于ClassLoader</li></ul><h3 id="获取类的加载器"><a href="#获取类的加载器" class="headerlink" title="获取类的加载器"></a>获取类的加载器</h3><p>方式一：获取当前类的ClassLoader</p><p>clazz.getClassLoader()</p><p>方式二：获取当前线程上下文的ClassLoader</p><p>Thread.currentThread().getContextClassLoader()</p><p>方式三：获取系统的ClassLoader</p><p>ClassLoader.getsystemClassLoader()</p><p>方式四：获取调用者的ClassLoader</p><p>DriverManager.getCallerClassLoader()</p><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><h3 id="引导类（启动类）加载器"><a href="#引导类（启动类）加载器" class="headerlink" title="引导类（启动类）加载器"></a>引导类（启动类）加载器</h3><p>启动类加载器（引导类加载器，Bootstrap ClassLoader)</p><ul><li>这个类加载使用C&#x2F;C+语言实现的，嵌套在JVM内部。</li><li>它用来加载]ava的核心库(JAVA_HOME&#x2F;jre&#x2F;Iib&#x2F;rt.jar或sun.boot.class.path路径下的内容)。用于提供JVM自身需要的类。</li><li>并不继承自java.lang.ClassLoader,没有父加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li></ul><blockquote><p>使用-XX:+TraceClassLoading参数得到加载类的列表</p></blockquote><ul><li>启动类加载器使用c++编写的？Yes!</li><li>C&#x2F;C++任指针函数&amp;函数指针、C++支持多继承、更加高效</li><li>Java:由C++演变而来，(C++)–版，单继承</li></ul><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>扩展类加载器(Extension ClassLoader)</p><ul><li><p>Java语言编写，由sun.misc.Launcher:$ExtClassLoader实现。</p></li><li><p>继承于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;Iib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></li><li><p>无法通过扩展类加载器获得引导类加载器，因为引导类加载器是用C&#x2F;C++语言编写的，所以获取的值是null</p></li></ul><h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>应用程序类加载器（系统类加载器，AppClassLoader)</p><ul><li>java语言编写，由sun.misc.Launchers$AppClassLoader实现</li><li>继承于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class,path指定路径下的类库</li><li><font color="red">应用程序中的类加载器默认是系统类加载器。</font></li><li>它是用户自定义类加载器的默认父加载器</li><li>通过ClassLoader的getSystemclassLoader()方法可以获取到该类加载器</li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>用户自定义类加载器</p><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，]ava开发者可以自定义类加载器来实现类库的动态加载,加载源可以是本地的]AR包，也可以是网络上的远程资源。</li><li><font color="red">通过类加载器可以实现非常绝妙的插件机制</font>，这方面的实际应用案例举不胜举。例如，著名的OSGI工组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li><li>同时，<font color="red">自定义加载器能够实现应用隔离</font>，例如Tomcat,Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li><li>自定义类加载器通常需要继承于ClassLoader。</li></ul><p><strong>用户自定义类加载器的两种方式：</strong>查看后续目录为自定义类的加载器中的内容</p><h2 id="ClassLoader结构"><a href="#ClassLoader结构" class="headerlink" title="ClassLoader结构"></a>ClassLoader结构</h2><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p><img src="https://www.hahhome.top/blog/JVMClassLoader/../../image/JVMClassLoader.assets/image-20230709211423138.png" alt="image-20230709211423138"></p><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类</p><h3 id="ClassLoader的主要方法"><a href="#ClassLoader的主要方法" class="headerlink" title="ClassLoader的主要方法"></a>ClassLoader的主要方法</h3><p>主要方法调用顺序：<font color="red">loadClass()内部调用 findClass()内部调用 defineClass()内部调用 preDefineClass()</font></p><p>这里没有写到preDefineClass()，此方法是为了避免重写loadClass方法打破双亲委派机制后，造成核心API被篡改</p><p>抽象类ClassLoader的主要方法：(内部没有抽象方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line"><span class="comment">//加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。该方法中的逻辑就是双亲委派模式的实现。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line"><span class="comment">//查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被1oadClass()方法调用。</span></span><br></pre></td></tr></table></figure><blockquote><p>在门DK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在DK1.2之后己不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在1oadc1ass()方法中被调用的，当1oadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类幼加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。<font color="red">一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</font></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> class&lt;?&gt; defineclass(String name,<span class="type">byte</span>[]b,<span class="type">int</span> off,<span class="type">int</span> len)</span><br><span class="line"><span class="comment">//根据给定的字节数组b转换为c1ass的实例，off和1en参数表示实际Cc1ass信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</span></span><br></pre></td></tr></table></figure><blockquote><p>defineClass()方法是用来将邻yte字节流解析成]VM能够识别的Class对象(ClassLoader中己实现该方法逻辑)，通过这个方法不仅能通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p><p><font color="red">defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</font></p></blockquote><h3 id="loadClass-方法源码"><a href="#loadClass-方法源码" class="headerlink" title="loadClass()方法源码"></a>loadClass()方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//双亲委派机制逻辑代码</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//调用findClass()方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h3><p><strong>SecureClassLoader URLClassLoader</strong></p><p>接着SecureClassLoader:扩展了ClassLoader,新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对Class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<font color="red">在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</font>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><h3 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h3><p><strong>ExtClassLoader AppclassLoader</strong></p><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器</p><p>AppClassLoader,这两个类都继承自URLClassLoader,是sun.misc.Launcher的静态内部类，</p><p>sun.misc.Launcher.主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的</p><p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p><h3 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h3><p><strong>Class.forName()ClassLoader.loadClass():</strong></p><ul><li>Class.forName():是一个静态方法，最常用的是Class.forName(String className);根据传入的类的全限定名返回一个Class对象。<font color="red">该方法在将Class文件加载到内存的同时，会执行类的初始化</font>。如：Class.forName(“com.atguigu.java.HelloWorld”);</li><li>ClassLoader.loadclass():这是一个实例方法，需要一个ClassLoader对象来调用该方法。<font color="red">该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化</font>。该方法因为需要得到一个ClassLoader对象，所以可以根据要指定使用哪个类加载器.如：ClassLoader c1&#x3D; ······;c1.loadClass(“com.atguigu.java.HelloWorld”);</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>1.定义</strong></p><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><strong>2.本质</strong></p><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载</p><p><img src="https://www.hahhome.top/blog/JVMClassLoader/../../image/JVMClassLoader.assets/image-20230709214112724.png" alt="image-20230709214112724"></p><p><img src="https://www.hahhome.top/blog/JVMClassLoader/../../image/JVMClassLoader.assets/image-20230709214118952.png" alt="image-20230709214118952"></p><h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p><strong>1.双亲委派机制优势</strong></p><ul><li><font color="red">避免类的重复加载</font>，确保一个类的全局唯一性</li></ul><p><font color="cornflowerblue">Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载</font>，当父亲己经加载了该类时，就没有必要子ClassLoader再加载一次。</p><ul><li>保护程序安全，<font color="red">防止核心API被随意篡改</font></li></ul><p><strong>2.代码支持</strong></p><p>双亲委派机在java.lang.ClassLoader.loadClass(String,boolean)接口中体现。该接口的逻辑如下：</p><ul><li>(1)先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li><li>(2)判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name,false)接口进行加载。</li><li>(3)反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载。</li><li>(4)如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li></ul><p><strong>双亲委派的模型就隐藏在这第2和第3步中。</strong></p><p><strong>3.举例</strong></p><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是nu11,因此系统调用findClass(String),最终通过引导类加载器进行加载。</p><p><strong>4.思考</strong></p><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String,boolean)方法抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢？这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用java.lang.ClassLoader.defineClass(String.,byte[],int,int,ProtectionDomain)方法，而该方法会执行<font color="red">preDefineClass</font>()接口，该接口中提供了对JDK核心类库的保护。</p><p><strong>5.双亲委托模式的弊端</strong></p><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，<font color="cornflowerblue">即顶层的ClassLoader无法访问底层的ClassLoader所加载的类</font>。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<font color="red">应用类访问系统类自然是没有问厚，但是系统类访问应用类就会出现问题</font>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><p><strong>6.结论：</strong></p><p><font color="red">由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已</font>。</p><p>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p><h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><p>双亲委派模型并不是一个具有强制性约束的模型，而是]Java设计者推荐给开发者们的类加载器实现方式。</p><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到]Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p><p><strong>第一次破坏双亲委派机制：</strong></p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一一即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第个版本中就己经存在，面对己经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<font color="red">为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</font>，只能在JDK1.2之后的java.lang.ClassLoader中<font color="red">添加一个新的protected方法findClass(),</font>并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们己经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><p>以上简单来说就是jdk1.2之前还没有引入双亲委派机制，所以jdk1.2之前就是破坏双亲委派机制的情况</p><p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<font color="red">越基础的类由越上层的加载器进行加载）</font>，基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在己经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的]NDI服务提供者接口(Service Provider Interface,SPI)的代码，现在问题来了，<font color="red">启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</font>(SPI:在Jaya平台中，通常把核心类rt,jar中提供外部服务、可由应用层自行实现的接口称为SPI)</p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<font color="red">线程上下文类加载器(Thread ContextClassLoader)</font>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<font color="red">这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</font>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和]B等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F;services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><p>简单来说就是线程上下文类加载器让启动类加载器和系统类加载器直接联系起来了，中间的扩展类加载器被省略了，所以这破坏了双亲委派机制，其中线程上下文类加载器就是系统类加载器</p><p><strong>第三次破坏双亲委派机制：</strong></p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p><p>IBM公司主导的]SR-291(即0SGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGI中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGI环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<font color="red">网状结构</font>。</p><p>当收到类加载请求时，OSGI将按照下面的顺序进行类搜索：</p><ul><li><font color="red">1)将以java.*开头的类，委派给父类加载器加载。</font></li><li><font color="red">2)否则，将委派列表名单内的类，委派给父类加载器加载。</font></li><li>3)否则，将Import列表中的类，委派给Export这个类的Bund1e的类加载器加载。</li><li>4)否则，查找当前Bund1e的classPath,使用自己的类加载器加载。</li><li>5)否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>6)否则，查找Dynamic Import列表的Bundle,委派给对应Bundle的类加载器加载。</li><li>7)否则，类查找失败。</li></ul><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结：</p><p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但<font color="red">这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</font></p><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p><img src="https://www.hahhome.top/blog/JVMClassLoader/../../image/JVMClassLoader.assets/image-20230709220841256.png" alt="image-20230709220841256"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>沙箱安全机制</p><ul><li>保证程序安全</li><li>保护]ava原生的JDK代码</li></ul><p><font color="red">Java安全模型的核心就是]ava沙箱(sandbox)</font>。什么是沙箱？沙<font color="red">箱是一个限制程序运行的环境</font>。</p><p>沙箱机制就是将]va代码<font color="red">限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问</font>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p><p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的]ava程序运行都可以指定沙箱，可以定制安全策略。</p><p><img src="https://www.hahhome.top/blog/JVMClassLoader/../../image/JVMClassLoader.assets/image-20230709221604225.png" alt="image-20230709221604225"></p><h2 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h2><p><strong>1.为什么要自定义类加载器？</strong></p><ul><li><font color="red">隔离加载类</font></li></ul><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</p><ul><li><font color="red">修改类加载的方式</font></li></ul><p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p><ul><li><font color="red">扩展加载源</font></li></ul><p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p><ul><li><font color="red">防止源码泄漏</font></li></ul><p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p><p><strong>2.常见的场景</strong></p><ul><li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架。</li><li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li></ul><p><strong>3.注意：</strong><br>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换,则加载器反而容易产生不美好的事情。在做]Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p><p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p><p><strong>1.实现方式</strong></p><ul><li><p>Java提供了抽象类java.lang.ClassLoader,所有用户自定义的类加载器都应该继承ClassLoader类。</p></li><li><p>在自定义ClassLoader的子类时候，我们常见的会有两种做法：</p><ul><li><p>方式一：重写loadClass()方法</p></li><li><p>方式二：重写findClass()方法–&gt;推荐（或者继承URLClassLoader）</p></li></ul></li></ul><p><strong>2.对比</strong></p><p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p><ul><li>loadClass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<font color="red">因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</font>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li><li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li></ul><p><strong>3.说明</strong></p><ul><li>其父类加载器是系统类加载器</li><li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口（自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li></ul><h2 id="Java9变化"><a href="#Java9变化" class="headerlink" title="Java9变化"></a>Java9变化</h2><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p><p>1.扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(Platform ClassLoader)。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</p><p>JDK9时基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就己天然地满足了可扩展的需求，那自然无须再保留&lt;]AVA HOME&gt;\Iib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p><p>2,平台类加载器和应用程序类加载器都不再继承自java.net.URLCLassLoader。</p><p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.1 oader.BuiltinClassLoader。</p><p>即<font color="red">URLClassLoader – &gt; BuiltinClassLoader</font>，只是名字改变，为了向下兼容，并没有删除</p><p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p><p>3.在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过**getName()**方法来获取。平台类加载器的名称是platform,.应用类加载器的名称是app。<font color="red">类加载器的名称在调试与类加载器相关的问题时会非常有用</font>。</p><p>4.启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</p><p>5.类加载的委派关系也发生了变动。</p><p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p><p><strong>双亲委派模式示意图</strong></p><p><img src="https://www.hahhome.top/blog/JVMClassLoader/../../image/JVMClassLoader.assets/image-20230709222712492.png" alt="image-20230709222712492"></p><p><font color="cornflowerblue">当知道要加载的类是哪个模块时，可以直接交给对应负责的类加载器</font></p><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><p>蚂蚁金服：</p><p>深入分析ClassLoader,双亲委派机制</p><p>类加载器的双亲委派模型是什么？</p><p>一面：双亲委派机制及使用原因</p><p>百度：</p><p>都有哪些类加载器，这些类加载器都加载哪些文件？</p><p>手写一个类加载器Demo</p><p>Class的forName(“java.lang.String”)和Class的getClassLoader()的1 oadclass(“java.lang.String”)有什么区别？</p><p>腾讯：</p><p>什么是双亲委派模型？</p><p>类加载器有哪些？</p><p>小米：</p><p>双亲委派模型介绍一下</p><p>滴滴：</p><p>简单说说你了解的类加载器</p><p>一面：讲一下双亲委派模型，以及其优点</p><p>字节跳动：</p><p>什么是类加载器，类加载器有哪些？</p><p>京东：</p><p>类加载器的双亲委派模型是什么？</p><p>双亲委派机制可以打破吗？为什么</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的创建和内存布局和执行引擎</title>
      <link href="/blog/JVMMemoryLayoutAndEngine/"/>
      <url>/blog/JVMMemoryLayoutAndEngine/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的创建和内存布局和执行引擎"><a href="#对象的创建和内存布局和执行引擎" class="headerlink" title="对象的创建和内存布局和执行引擎"></a>对象的创建和内存布局和执行引擎</h1><h2 id="课程内容概览"><a href="#课程内容概览" class="headerlink" title="课程内容概览"></a>课程内容概览</h2><p><strong>该部分包含：</strong></p><ul><li>对象的创建及对象的内存布局</li><li>执行引擎</li></ul><blockquote><p>部分图源自作者<a href="https://github.com/youthlql">youthlql</a>，懒得重新看视频截图了，就在这位作者的笔记基础上和自己原ipad的goodnotes笔记结合做了一定修改</p></blockquote><h1 id="对象的创建和内存布局"><a href="#对象的创建和内存布局" class="headerlink" title="对象的创建和内存布局"></a>对象的创建和内存布局</h1><h2 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h2><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/image-20230724172334248.png" alt="image-20230724172334248"></p><ol><li>new：<ul><li>最常见的方式</li><li>单例类中调用getInstance的静态类方法</li><li>XXXFactory的静态方法</li></ul></li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</li><li>Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</li><li>使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ol><h2 id="对象创建的步骤"><a href="#对象创建的步骤" class="headerlink" title="对象创建的步骤"></a>对象创建的步骤</h2><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/image-20230724172349926.png" alt="image-20230724172349926"></p><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p><ul><li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</li><li>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li></ul><p><strong>2、为对象分配内存</strong></p><ul><li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li><li>如果内存规整：采用<strong>指针碰撞</strong>分配内存<ul><li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li><li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li><li>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li></ul></li><li>如果内存不规整<ul><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li><li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “<strong>空闲列表</strong>（Free List）”</li><li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li><li>标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li></ul></li></ul><p><strong>3、处理并发问题</strong></p><ul><li>采用CAS+失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li><li>在Eden区给每个线程分配一块区域</li></ul><p><strong>4、初始化分配到的空间</strong></p><ul><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li><li><p>给对象属性赋值的顺序：</p><ul><li><p>属性的默认值初始化</p></li><li><p>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</p></li><li><p>构造器初始化</p></li></ul></li></ul><p><strong>5、设置对象的对象头</strong></p><ul><li>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li></ul><p><strong>6、执行init方法进行初始化</strong></p><ul><li>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</li><li>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><blockquote><p>内存布局更详细部分在我的《JUC05》中有更详细的讲解，涉及到锁升级的知识</p></blockquote><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/image-20230724172431856.png" alt="image-20230724172431856"></p><p><strong>图解内存布局：</strong></p><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/image-20230724172504200.png" alt="image-20230724172504200"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p><p><strong>1、句柄访问</strong></p><ol><li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li><li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li></ol><p><a href="https://camo.githubusercontent.com/c8691066a14bef63cf196e0ba0317251f310df92081f05286af7d73a1e9ef935/68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030372f303030352e706e67"><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030372f303030352e706e67.png" alt="img"></a></p><p><strong>2、直接指针（HotSpot采用）</strong></p><ol><li>优点：简单快速，直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li><li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/image-20230724172823852.png" alt="image-20230724172823852"></p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title></a></h1><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0001.png"></p><ol><li>执行引擎是Java虚拟机核心的组成部分之一。</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而**<font color="red">虚拟机的执行引擎则是由软件自行实现的</font>**，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<font color="red"><strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</font></li><li>JVM的主要任务是负责**<font color="red">装载字节码到其内部</font>**，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li><li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是**<font color="red">将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</font>**。简单来说，JVM中的执行引擎充当了将<font color="red">高级语言</font>翻译为<font color="red">机器语言</font>的译者。</li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0002.png"></p><p>1、前端编译：从Java程序员-字节码文件的这个过程叫前端编译</p><p>2、执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是<font color="cornflowerblue">后端编译</font>）。</p><h2 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h2><blockquote><p><strong>执行引擎工作过程</strong></p></blockquote><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li><li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0003.png"></p><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><h3 id="解释执行和即时编译"><a href="#解释执行和即时编译" class="headerlink" title="解释执行和即时编译"></a>解释执行和即时编译</h3><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p><ol><li><p>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</p></li><li><p>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0004.png"></p><ol start="3"><li><p>javac编译器（前端编译器）流程图如下所示：</p><p> <img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0005.png"></p></li><li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p><p> <img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0006.png"></p></li></ol><h3 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h3><ol><li>解释器：当Java虚拟机启动时会根据预定义的规范<font color="cornflowerblue">对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong></font>，将每条字节码文件中的内容<font color="cornflowerblue">“翻译”为对应平台的本地机器指令</font>执行。</li><li>JIT（Just In Time Compiler）编译器：<font color="cornflowerblue">就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</font>。</li></ol><p><strong>为什么Java是半编译半解释型语言？</strong></p><ol><li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li><li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li></ol><p><strong>用图总结一下</strong></p><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0007.png"></p><h2 id="机器码-指令-汇编语言"><a href="#机器码-指令-汇编语言" class="headerlink" title="机器码 指令 汇编语言"></a>机器码 指令 汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ol><li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ol><h3 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h3><p><strong>指令</strong></p><ol><li><p>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p></li><li><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p></li><li><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p></li></ol><p><strong>指令集</strong></p><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的</p><ol><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ol><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ol><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</li><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。</li></ol><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ol><li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p></li><li><p>当计算机执行高级语言编写的程序时，<font color="cornflowerblue">仍然需要把程序解释和编译成机器的指令码</font>。完成这个过程的程序就叫做解释程序或编译程序。</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0008.png"></p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ol><li><p>字节码是一种<font color="cornflowerblue">中间状态（中间码）的二进制代码（文件）</font>，它比机器码更抽象，需要直译器转译后才能成为机器码</p></li><li><p>字节码主要为了实现特定软件运行和软件环境、<font color="cornflowerblue">与硬件环境无关。</font></p></li><li><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p></li><li><p>字节码典型的应用为：Java bytecode</p></li></ol><h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p><ol><li><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p></li><li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0009.png"></p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h3><ol><li><p>JVM设计者们的初衷仅仅只是单纯地<font color="red">为了满足Java程序实现跨平台特性</font>，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</p></li><li><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p></li><li><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0010.png"></p><h3 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h3><ol><li>在Java的发展历史里，一共有两套解释执行器，即古老的**<font color="red">字节码解释器</font>**、现在普遍使用的<font color="red"><strong>模板解释器</strong>。</font><ul><li>字节码解释器在执行时通过<font color="cornflowerblue">纯软件代码</font>模拟字节码的执行，<font color="cornflowerblue">效率非常低下。</font></li><li>而模板解释器将<font color="cornflowerblue">每一条字节码和一个模板函数相关联</font>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul></li><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ol><h3 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h3><ol><li><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<font color="cornflowerblue">基于解释器执行已经沦落为低效的代名词</font>，并且时常被一些C&#x2F;C++程序员所调侃。</p></li><li><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<font color="cornflowerblue">将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</font>，这种方式可以使执行效率大幅度提升。</p></li><li><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p></li></ol><h2 id="JIT即时编译器"><a href="#JIT即时编译器" class="headerlink" title="JIT即时编译器"></a>JIT即时编译器</h2><h3 id="Java-代码执行的分类"><a href="#Java-代码执行的分类" class="headerlink" title="Java 代码执行的分类"></a>Java 代码执行的分类</h3><ol><li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li><li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。**<font color="cornflowerblue">它采用解释器与即时编译器并存的架构</font>**。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自<font color="cornflowerblue">取长补短</font>，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p></li><li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</p></li></ol><h3 id="为啥我们还需要解释器呢？"><a href="#为啥我们还需要解释器呢？" class="headerlink" title="为啥我们还需要解释器呢？"></a>为啥我们还需要解释器呢？</h3><ol><li><p>有些开发人员会感觉到诧异，<font color="cornflowerblue">既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢</font>？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p></li><li><p>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</p></li></ol><p><strong>首先明确两点：</strong></p><ol><li><font color="cornflowerblue">当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</font></li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p><strong>所以：</strong></p><ol><li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li>在此模式下，<font color="red">在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</font></li><li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><h3 id="HotSpot虚拟机的执行方式"><a href="#HotSpot虚拟机的执行方式" class="headerlink" title="HotSpot虚拟机的执行方式"></a>HotSpot虚拟机的执行方式</h3><ul><li>当虚拟机启动的时候，<font color="cornflowerblue">解释器可以首先发挥作用</font>，而不必等待即时编译器全部编译完成再执行，这样<font color="cornflowerblue">可以省去许多不必要的编译时间</font>。随着程序运行时间的推移，即时编译器逐渐发挥作用，<font color="cornflowerblue">根据热点探测功能，将有价值的字节码编译为本地机器指令</font>，以换取更高的程序执行效率。</li></ul><ol><li><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p></li><li><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></p></li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0011.png"></p><h3 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h3><ol><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<font color="cornflowerblue">前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。（javac就是常见的前端编译器）</font></li><li>也可能是指虚拟机的<font color="cornflowerblue">后端运行期编译器（JIT编译器</font>，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用<font color="cornflowerblue">静态提前编译器（AOT编译器</font>，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ol><blockquote><p><strong>典型的编译器：</strong></p><ol><li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ol></blockquote><h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><ol><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用**<font color="red">执行的频率</font>**而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为**<font color="red">“热点代码”</font><strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出</strong><font color="red">深度优化</font>**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li><font color="red">一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</font>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<font color="red">栈上替换</font>，或简称为<font color="red">OSR (On StackReplacement)编译。</font></li><li>一个方法究竟<font color="cornflowerblue">要被调用多少次</font>，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<font color="red">热点探测功能。</font></li><li><font color="red"><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</font></li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<font color="red">方法调用计数器</font>（Invocation Counter）和<font color="red">回边计数器</font>（Back Edge Counter）。<ol><li><font color="red">方法调用计数器用于统计方法的调用次数</font></li><li><font color="red">回边计数器则用于统计循环体执行的循环次数</font></li></ol></li></ol><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><ol><li><p>这个计数器就用于统计方法被调用的次数，<font color="red">它的默认阀值在Client模式下是1500次，在Server模式下是10000次(X86机器默认只能是server模式)</font>。超过这个阈值，就会触发JIT编译。</p></li><li><p>这个阀值可以通过虚拟机参数<font color="cornflowerblue"> -XX:CompileThreshold </font>来人为设定。</p></li><li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本</p><ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li><font color="cornflowerblue">如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</font></li><li>如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0013.png"></p><h4 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h4><ol><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个<font color="red">相对的执行频率</font>，即**<font color="red">一段时间之内方法被调用的次数</font>**。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ol><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中<font color="red">循环体代码执行的次数</font>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0014.png"></p><h3 id="HotSpotVM可以设置程序执行方法"><a href="#HotSpotVM可以设置程序执行方法" class="headerlink" title="HotSpotVM可以设置程序执行方法"></a>HotSpotVM可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<strong>完全采用解释器执行</strong>，还是<strong>完全采用即时编译器执行</strong>。如下所示：</p><ol><li><font color="cornflowerblue">-Xint</font>：完全采用解释器模式执行程序；</li><li><font color="cornflowerblue">-Xcomp</font>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li><font color="cornflowerblue">-Xmixed</font>：采用解释器+即时编译器的混合模式共同执行程序。</li></ol><p><img src="https://www.hahhome.top/blog/JVMMemoryLayoutAndEngine/../../image/JVMMemoryLayoutAndEngine.assets/0015.png"></p><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 6520ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 950ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 936ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntCompTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//计算100以内的质数</span></span><br><span class="line">            label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j % k == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span> label;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//System.out.println(j);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论：只用解释器执行是真的慢</p><h3 id="HotSpotVM-JIT-分类"><a href="#HotSpotVM-JIT-分类" class="headerlink" title="HotSpotVM JIT 分类"></a>HotSpotVM JIT 分类</h3><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ol><li><font color="cornflowerblue">-client</font>：指定Java虚拟机运行在Client模式下，并使用<font color="cornflowerblue">C1</font>编译器；<ul><li>C1编译器会对字节码进行<font color="red">简单和可靠的优化，耗时短</font>，以达到更快的编译速度。</li></ul></li><li><font color="cornflowerblue">-server</font>：指定Java虚拟机运行在server模式下，并使用<font color="cornflowerblue">C2</font>编译器。<ul><li>C2进行<font color="red">耗时较长的优化，以及激进优化</font>，但优化的代码执行效率更高。（使用C++）</li></ul></li></ol><h3 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h3><ol><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ol><blockquote><p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？</p></blockquote><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><ol><li><p><font color="red">分层编译（Tiered Compilation）策略</font>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p></li><li><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令<font color="red">“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</font></p></li></ol><p>总结：</p><ol><li>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</li><li><font color="cornflowerblue">C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</font></li></ol><h2 id="其它编译器"><a href="#其它编译器" class="headerlink" title="其它编译器"></a>其它编译器</h2><h3 id="Graal-编译器"><a href="#Graal-编译器" class="headerlink" title="Graal 编译器"></a>Graal 编译器</h3><ul><li><p>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p></li><li><p>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p></li><li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p><p>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</p></li></ul><h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><ol><li><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p></li><li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p><p> .java -&gt; .class -&gt; (使用jaotc) -&gt; .so</p></li></ol><p><strong>AOT编译器编译器的优缺点</strong></p><p><strong>最大的好处：</strong></p><ol><li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ol><p><strong>缺点：</strong></p><ol><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区（03）</title>
      <link href="/blog/JVMRuntimeDataArea3/"/>
      <url>/blog/JVMRuntimeDataArea3/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区（03）"><a href="#运行时数据区（03）" class="headerlink" title="运行时数据区（03）"></a>运行时数据区（03）</h1><h2 id="课程内容概览"><a href="#课程内容概览" class="headerlink" title="课程内容概览"></a>课程内容概览</h2><p><strong>该部分包含：</strong></p><ul><li>方法区</li><li>字符串常量池</li></ul><blockquote><p>部分图源自作者<a href="https://github.com/youthlql">youthlql</a>，懒得重新看视频截图了，就在这位作者的笔记基础上和自己原ipad的goodnotes笔记结合做了一定修改</p></blockquote><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><strong>从线程共享与否的角度来看</strong></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0001.png"></p><p><strong>栈、堆、方法区的交互关系</strong></p><p><strong>下面涉及了对象的访问定位</strong></p><ol><li>Person 类的 .class 类元信息存放在方法区中</li><li>person 变量存放在 Java 栈的局部变量表中</li><li>person对象引用指向堆中实例数据（真正存储）</li><li>在 person 对象中，有个指针指向方法区中的 person 类元信息（类型指针）</li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0002.png"></p><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p></blockquote><h3 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h3><ol><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<font color="red"><strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</font></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0003.png"></p><h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p><ol><li>方法区（Method Area）与Java堆一样，<strong>是各个线程共享的内存区域</strong>。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM<strong>启动的时候被创建</strong>，并且它的实际的物理内存空间中和Java堆区一样都可以是<strong>不连续</strong>的。</li><li>方法区的大小，跟堆空间一样，可以选择<strong>固定大小或者可扩展。</strong></li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ol><h3 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a>HotSpot方法区演进</h3><ol><li>在 JDK7 及以前，习惯上把方法区，称为永久代。<font color="red">JDK8开始，使用<strong>元空间</strong>取代了永久代</font>。</li><li>本质上，方法区和永久代并不等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermsize上限）</li></ul></li><li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<font color="cornflowerblue"><strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</font></li><li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li><li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0005.png"></p><h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h3 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h3><ol><li>通过**-XX:Permsize<strong>来设置永久代初始分配空间。默认值是</strong>20.75M**</li><li><strong>-XX:MaxPermsize</strong>来设定永久代最大可分配空间。32位机器默认是<strong>64M</strong>，64位机器模式是<strong>82M</strong></li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0006.png"></p><h3 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h3><blockquote><p><strong>JDK8 版本设置元空间大小</strong></p></blockquote><ol><li>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</li><li>默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为<strong>21M</strong>，-XX:MaxMetaspaceSize的值是**-1，即没有限制。**</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li><li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是<strong>初始的高水位线</strong>，<strong>一旦触及这个水位线，Full GC将会被触发并卸载没用的类</strong>（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。<strong>新的高水位线的值取决于GC后释放了多少元空间</strong>。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。<font color="red"><strong>为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。-XX:MaxMetaspaceSize使用默认值</strong></font></li></ol><h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h3><p>举例：</p><p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>不设置元空间的上限</strong></p><p>使用默认的 JVM 参数，元空间不设置上限</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p><strong>设置元空间的上限</strong></p><p>JVM 参数</p><p>-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8531</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">29</span>)</span><br></pre></td></tr></table></figure><h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><blockquote><p>这个属于调优的问题，这里先简单的说一下</p></blockquote><ol><li><p>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先<strong>分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</strong></p><ul><li><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当<strong>检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大</strong>，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，<strong>尝试减少程序运行期的内存消耗。</strong></p></li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h3><p><strong>概念</strong></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0007.png"></p><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<font color="cornflowerblue"><strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</font></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0008.png"></p><p><strong>类型信息</strong></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的<strong>完整有效名称</strong>（全名&#x3D;包名.类名）</li><li>这个类型<strong>直接父类的完整有效名</strong>（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的<strong>修饰符</strong>（public，abstract，final的某个子集）</li><li>这个类型<strong>直接接口的一个有序列表</strong></li></ol><p><strong>域（Field）信息</strong></p><blockquote><p>也就是我们常说的成员变量(属性)，域信息是比较官方的称呼</p></blockquote><ol><li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p></li><li><p>域的相关信息包括：<strong>域名称，域类型，域修饰符</strong>（public，private，protected，static，final，volatile，transient的某个子集）</p></li></ol><p><strong>方法（Method）信息</strong></p><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法<strong>名称</strong></li><li>方法的<strong>返回类型</strong>（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li>方法<strong>参数的数量和类型</strong>（按顺序）</li><li>方法的<strong>修饰符</strong>（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的<strong>字节码（bytecodes）、操作数栈、局部变量表及大小</strong>（abstract和native方法除外）</li><li><strong>异常表</strong>（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><h3 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h3><ol><li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p></li><li><p><font color="red">类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</font></p></li></ol><p><strong>举例</strong></p><ol><li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li><li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h4><ol><li>全局常量就是使用 static final 进行修饰</li><li>被声明为final的类变量的处理方法则不同，<font color="cornflowerblue">每个全局常量在编译的时候就会被分配了。</font><ul><li>HotSpot虚拟机中static+final修饰的String类型或者基本类型常量是在链接的准备阶段就会被赋值</li></ul></li></ol><p>查看上面代码，这部分的字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h4 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h4><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p>后面会细讲常量池，这里为了讲清楚方法区，简单带一下。</p></blockquote><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0009.png"></p><ol><li><font color="red">方法区，内部包含了运行时常量池</font></li><li><font color="cornflowerblue">字节码文件，内部包含了常量池</font>。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ol><blockquote><p>常量池&lt;—————————————–&gt;运行时常量池</p><p>​||</p><p>字节码文件中&lt;——–经过类的加载———–&gt;方法区中</p></blockquote><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ol><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的<font color="red">符号引用</font>。</li><li>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0010.png"></p><p><strong>为什么需要常量池？</strong></p><ul><li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在<font color="red">动态链接</font>(栈帧中的动态链接：将符号引用转换为直接引用的过程)的时候会用到运行时常量池，之前有介绍</li></ul><p>比如：如下的代码：</p><pre><code>public class SimpleClass &#123;    public void sayHello() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><ol><li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ol><p><strong>常量池中有啥？</strong></p><ol><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ol><p>MethodInnerStrucTest 的 test1方法的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> invokespecial #<span class="number">5</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">13</span> ldc #<span class="number">6</span> &lt;count = &gt;</span><br><span class="line"><span class="number">15</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">18</span> iload_1</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">22</span> invokevirtual #<span class="number">9</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">25</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>1、#3，#5等等这些带# 的，都是引用了常量池。</p><p><strong>常量池总结</strong></p><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ol><li>运行时常量池（Runtime Constant Pool）<strong>是方法区的一部分。</strong></li><li>常量池表（Constant Pool Table）是<strong>Class字节码文件的一部分</strong>，<font color="red">用于存放编译期生成的各种字面量与符号引用</font>，**<font color="cornflowerblue">这部分内容将在类加载后存放到方法区的运行时常量池中</font>**。（运行时常量池就是常量池在程序运行时的称呼）</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM为<font color="cornflowerblue">每个已加载的类型（类或接口）都维护一个常量池</font>。池中的数据项像数组项一样，是通过<font color="cornflowerblue">索引访问</font>的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</li></ol><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：<font color="red">具备动态性。</font></li></ul><ol start="6"><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ol><h2 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java1.MethodAreaDemo</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">24</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">27.</span>#<span class="number">28</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">29</span>            <span class="comment">// com/atguigu/java1/MethodAreaDemo</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">30</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line">  #<span class="number">13</span> = Utf8               main</span><br><span class="line">  #<span class="number">14</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">15</span> = Utf8               args</span><br><span class="line">  #<span class="number">16</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">17</span> = Utf8               x</span><br><span class="line">  #<span class="number">18</span> = Utf8               I</span><br><span class="line">  #<span class="number">19</span> = Utf8               y</span><br><span class="line">  #<span class="number">20</span> = Utf8               a</span><br><span class="line">  #<span class="number">21</span> = Utf8               b</span><br><span class="line">  #<span class="number">22</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">23</span> = Utf8               MethodAreaDemo.java</span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">31</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">32</span>:#<span class="number">33</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Class              #<span class="number">34</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">28</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">29</span> = Utf8               com/atguigu/java1/MethodAreaDemo</span><br><span class="line">  #<span class="number">30</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">31</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">32</span> = Utf8               out</span><br><span class="line">  #<span class="number">33</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">35</span> = Utf8               println</span><br><span class="line">  #<span class="number">36</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">15</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h4><p>1、初始状态</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0012.png"></p><p>2、首先将操作数500压入操作数栈中</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0013.png"></p><p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0014.png"></p><p>4、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0015.png"></p><p>5、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0016.png"></p><p>6、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0017.png"></p><p>7、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0018.png"></p><p>8、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0019.png"></p><p>9、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0020.png"></p><p>10、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0021.png"></p><p>11、图片写错了是#25和#26（获得System类）</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0022.png"></p><p>12、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0023.png"></p><p>13、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0024.png"></p><p>15、执行加法运算后，将计算结果放在操作数栈顶</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0025.png"></p><p>16、就是真正的打印</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0026.png"></p><p>17、</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0027.png"></p><p><strong>符号引用 –&gt; 直接饮用</strong></p><ol><li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li><li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li></ol><h2 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h2><h3 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h3><ol><li><p>首先明确：<strong>只有Hotspot才有永久代</strong>。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p></li><li><p>Hotspot中方法区的变化：</p></li></ol><table><thead><tr><th>JDK1.6及以前</th><th>有永久代（permanent generation），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td>JDK1.8</td><td><strong>无永久代</strong>，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p><strong>JDK6</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0028.png"></p><p><strong>JDK7</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0029.png"></p><p><strong>JDK8</strong></p><p>方法区由元空间实现，使用物理机本地内存</p><ul><li><font color="cornflowerblue">静态存储区域和字符串常量池还是属于方法区，只是存储在堆中而已</font></li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0030.png"></p><h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p></blockquote><ol><li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。<font color="red">这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</font></li><li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li><li>这项改动是很有必要的，原因有：<ol><li><font color="red">为永久代设置空间大小是很难确定的</font>。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li><li><font color="red">对永久代进行调优是很困难的</font>。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低<strong>Full GC</strong><ol><li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li></ol></li></ol></li></ol><p><strong><font color="red">原因总结：</font></strong></p><ul><li>永久代空间不足，使用虚拟机内存，内存可能被耗尽</li><li>永久代垃圾回收效率低下，且容易造成内存泄露</li><li>使用元空间使用本地内存，可以自动调节元空间大小，并且字符串常量池和静态存储区域在堆中，更容易进行垃圾收集</li></ul><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p><ul><li>JDK7中将StringTable放到了堆空间中。<font color="red">因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收</font>，而Full GC是老年代的空间不足、永久代不足时才会触发。</li><li>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。<font color="red">放到堆里，能及时回收内存。</font></li></ul><p>总结：JDK7时调整，因为永久代空间较小，且回收效率很低，只有Full GC才会回收触发，字符串太多，放到堆中能及时回收</p><h3 id="各种变量存放在哪里"><a href="#各种变量存放在哪里" class="headerlink" title="各种变量存放在哪里"></a>各种变量存放在哪里</h3><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> *  staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一共有3中类型的变量：①局部变量②成员变量③静态变量</p><p><font color="red">先说结论：<strong>new出来的实体始终都存放在堆中</strong></font></p><p>1、<font color="cornflowerblue">staticObj</font>随着Test的类型信息存放在方法区，但是在jdk7及以后，实际是<font color="cornflowerblue">存储在堆中的</font></p><p>2、<font color="cornflowerblue">instanceObj</font>随着Test的对象实例<font color="cornflowerblue">存放在Java堆</font></p><p>3、<font color="cornflowerblue">localObject</font>则是存放在foo()方法栈帧的<font color="cornflowerblue">局部变量表中。</font></p><p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<font color="red"><strong>只要是对象实例必然会在Java堆中分配</strong>。</font></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0034.png"></p><blockquote><p>1、0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  </p><p>2、可以发现三个变量都在这个范围内</p><p>3、所以可以得到上面结论</p></blockquote><p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0035.png"></p><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ol><li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p></li><li><p><font color="cornflowerblue">一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</font>。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容：<font color="red"><strong>常量池中废弃的常量和不再使用的类型</strong>。</font></p></li></ol><p><strong>常量：</strong></p><ol><li><p>先来说说方法区内常量池之中主要存放的两大类常量：<font color="cornflowerblue">字面量</font>和<font color="cornflowerblue">符号引用</font>。字面量比较接近Java语言层次的常量概念，<strong>如文本字符串、被声明为final的常量值等</strong>。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，<font color="cornflowerblue">只要常量池中的常量没有被任何地方引用，就可以被回收。</font></p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p></li></ol><p><strong>不再使用的类型：</strong></p><p>下面也称作<strong>类卸载</strong></p><p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于<font color="cornflowerblue">“不再被使用的类”的条件就非常<strong>苛刻</strong>了</font>。需要同时满足下面三个条件：</p><ul><li><p>该类<strong>所有的实例</strong>都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该<strong>类的类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang**.Class对象没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的 <font color="cornflowerblue">仅仅是“被允许”</font>（允许不一定会施行），而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><p><strong>虽然很难，但是类的卸载又必须具备仅仅是“被允许”</strong></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><ol><li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li><li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常，<font color="cornflowerblue">访问直接内存的速度会优于Java堆。即读写性能高。</font></li><li>因此出于性能考虑，<font color="cornflowerblue">读写频繁的场合可能会考虑使用直接内存。</font></li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span></span><br><span class="line"><span class="comment"> *  byte[] / char[]     Buffer</span></span><br><span class="line"><span class="comment"> *  Stream              Channel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接占用了 1G 的本地内存</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0037.jpg"></p><h3 id="直接内存与-OOM"><a href="#直接内存与-OOM" class="headerlink" title="直接内存与 OOM"></a>直接内存与 OOM</h3><ol><li><p><font color="cornflowerblue">直接内存也可能导致OutofMemoryError异常</font></p></li><li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p></li><li><p>直接内存的<font color="cornflowerblue">缺点</font>为：</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li><li><p>直接内存大小可以通过MaxDirectMemorySize设置</p></li><li><p><font color="cornflowerblue">如果不指定，默认与堆的最大值-Xmx参数值一致</font></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BufferTest2 &#123;</span><br><span class="line">    private static final int BUFFER = 1024 * 1024 * 20;//20MB</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;ByteBuffer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                count++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:<span class="number">694</span>)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0040.jpg"></p><h3 id="BIO-与-NIO"><a href="#BIO-与-NIO" class="headerlink" title="BIO 与 NIO"></a>BIO 与 NIO</h3><p><strong>非直接缓存区（BIO）</strong></p><p>原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0038.png"></p><p><strong>直接缓冲区（NIO）</strong></p><p>NIO 直接操作物理磁盘，省去了中间过程</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0039.png"></p><h2 id="运行时数据区结构图再览"><a href="#运行时数据区结构图再览" class="headerlink" title="运行时数据区结构图再览"></a>运行时数据区结构图再览</h2><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/0036.png"></p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol><li>百度<ul><li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li></ul></li><li>蚂蚁金服：<ul><li>Java8的内存分代改进</li><li>JVM内存分哪几个区，每个区的作用是什么？</li><li>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li><li>二面：Eden和survior的比例分配</li></ul></li><li>小米：<ul><li>jvm内存分区，为什么要有新生代和老年代</li></ul></li><li>字节跳动：<ul><li>二面：Java的内存分区</li><li>二面：讲讲vm运行时数据库区</li><li>什么时候对象会进入老年代？</li></ul></li><li>京东：<ul><li>JVM的内存结构，Eden和Survivor比例。</li><li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li></ul></li><li>天猫：<ul><li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li><li>一面：JVM的内存模型，Java8做了什么改</li></ul></li><li>拼多多：<ul><li>JVM内存分哪几个区，每个区的作用是什么？</li></ul></li><li>美团：<ul><li>java内存分配</li><li>jvm的永久代中会发生垃圾回收吗？</li><li>一面：jvm内存分区，为什么要有新生代和老年代？</li></ul></li></ol><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title></a></h1><h1 id="字符串常量池StringTable"><a href="#字符串常量池StringTable" class="headerlink" title="字符串常量池StringTable"></a>字符串常量池StringTable</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ol><li>String：字符串，使用一对 “” 引起来表示</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span> ;   <span class="comment">// 字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure><ol start="2"><li>String被声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</li><li>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code></li></ol><h2 id="为什么-JDK9-改变了-String-的结构"><a href="#为什么-JDK9-改变了-String-的结构" class="headerlink" title="为什么 JDK9 改变了 String 的结构"></a>为什么 JDK9 改变了 String 的结构</h2><blockquote><p> <strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p></blockquote><p><strong>为什么改为 byte[] 存储？</strong></p><ol><li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li><li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些<font color="red">字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费</font>。</li><li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存</li><li>结论：String再也不用char[] 来存储了，<font color="red">改成了byte [] 加上编码标记</font>，节约了一些空间</li><li>同时基于String的数据结构，例如<strong>StringBuffer和StringBuilder</strong>也同样做了修改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value</span><br></pre></td></tr></table></figure><h2 id="字符串的存储规则"><a href="#字符串的存储规则" class="headerlink" title="字符串的存储规则"></a>字符串的存储规则</h2><ul><li>String：代表<strong>不可变的字符序列</strong>。简称：<font color="cornflowerblue">不可变性</font>。</li></ul><ol><li>当对字符串<strong>重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</strong></li><li>当对现有的字符串进行<strong>连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</strong></li><li>当调用String的<strong>replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值</strong>，不能使用原有的value进行赋值。</li></ol><ul><li><font color="cornflowerblue"><strong>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</strong></font></li></ul><p>（<strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong>）</p><ul><li><strong><font color="red">字符串常量池是不会存储相同内容的字符串的</font></strong></li></ul><h2 id="String-的底层结构"><a href="#String-的底层结构" class="headerlink" title="String 的底层结构"></a>String 的底层结构</h2><ol><li>String的String Pool（字符串常量池）<font color="red">是一个固定大小的<strong>Hashtable</strong></font>，默认值大小长度是1009。<font color="cornflowerblue">如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长</font>，而链表长了后直接会造成的影响就是当<font color="cornflowerblue">调用String.intern()方法时性能会大幅下降。</font></li><li>使用**-XX:StringTablesize**可设置StringTable的长度</li><li>在<font color="cornflowerblue">JDK6</font>中StringTable是固定的，就是<font color="cornflowerblue">1009的长度</font>，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li>在<font color="cornflowerblue">JDK7</font>中，StringTable的长度默认值是<font color="cornflowerblue">60013</font>，StringTablesize设置没有要求</li><li>在<font color="cornflowerblue">JDK8</font>中，StringTable的长度默认值是<font color="cornflowerblue">60013，StringTable可以设置的最小值为1009</font></li></ol><h2 id="String的创建方式和内存分配"><a href="#String的创建方式和内存分配" class="headerlink" title="String的创建方式和内存分配"></a>String的创建方式和内存分配</h2><ul><li>通过new的方式创建字符串eg：String s &#x3D; new String(“Hello world !”);<ul><li><font color="red">一般情况下，会创建两个字符串对象会存储在堆中和String Table中</font></li></ul></li><li>通过双引号声明出来的           eg：String s &#x3D; “Hello world!”;<ul><li><font color="red">会直接存储在String Table中</font></li></ul></li></ul><p>注意：**<font color="red">字符串常量池是不会存储相同内容的字符串的</font>**</p><p>验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2321</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2330</span></span><br><span class="line">        <span class="comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2331</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2331</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2331</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可见，上面字符串的地址到2331就不再继续增长，证明字符串常量池中相同字面量的字符串只会存在一份</li><li>2331-2321 &#x3D; 10</li></ul><ol><li>Java 6及以前，字符串常量池存放在永久代</li><li>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，<font color="red">即将字符串常量池的位置调整到Java堆内</font><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li>Java8元空间，字符串常量在堆</li></ol><h3 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h3><p>为什么要调整位置？<br>    *   永久代的默认空间大小比较小<br>        *   永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space<br>            *   堆中空间足够大，字符串可被及时回收</p><ol start="2"><li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ol><p><font color="red">一句话：JDK7时调整，因为永久代空间较小，且回收效率很低，只有Full GC才会回收触发，字符串太多，放到堆中能及时回收</font></p><h2 id="字符串的拼接操作"><a href="#字符串的拼接操作" class="headerlink" title="&#x3D;&#x3D;字符串的拼接操作&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符串的拼接操作&#x3D;&#x3D;</h2><ul><li><font color="red">常量与常量</font>的拼接结果在常量池，<font color="red">原理是编译期优化</font><ul><li>eg：”a” + “b” &#x3D; “ab”，”ab”也会在常量池</li></ul></li><li><font color="red">常量池中不会存在相同内容的变量</font></li><li>拼接前后，<font color="red">只要其中有一个是<strong>变量</strong>，结果就在堆中</font>。变量拼接的原理是<font color="cornflowerblue">StringBuilder</font><ul><li>用final修饰的算常量</li><li><font color="cornflowerblue">new String() + new String()：将会创建6个对象</font>，两个newString的堆对象，两个字符串常量对象，以及拼接操作的StringBuilder和返回的return new String()对象，注意：<font color="cornflowerblue">这里返回的return new String()不会在字符串常量池中创建对象</font></li></ul></li><li>如果拼接的结果<font color="cornflowerblue">调用intern()方法</font>，根据该字符串是否在常量池中存在，分为：<ul><li>如果存在，则返回字符串在常量池中的地址</li><li>如果字符串常量池中不存在该字符串<ul><li>jdk6及以前：则在常量池中创建一份，并返回此对象的地址</li><li>jdk7及以后：<font color="cornflowerblue">若堆中有相同字面量的字符串实例</font>，<font color="red">那么在常量池中创建一个指向堆中该字符串实例的引用指针，并返回该引用，</font><font color="cornflowerblue">若堆中不存在</font>，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ul></li></ul><p><strong>编译器优化举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">        * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">        * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">       System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>如果出现变量举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译器优化</span></span><br><span class="line">    <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间直接new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含变量拼接底层细节"><a href="#含变量拼接底层细节" class="headerlink" title="含变量拼接底层细节"></a>含变量拼接底层细节</h3><p><strong>普通情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，toString()方法底层会return new String()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含final情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">      如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">   2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">       System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="拼接方式执行效率区别"><a href="#拼接方式执行效率区别" class="headerlink" title="拼接方式执行效率区别"></a>拼接方式执行效率区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//System.out.println(src);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span> &#123;</span><br><span class="line">    <span class="comment">//自始至终只需要创建一个StringBuilder</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//System.out.println(src);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>体会执行效率：通过StringBuilder的<font color="red">append()</font>的方式添加字符串<font color="red">的效率要远高于</font>使用String的字符串拼接方式！</li><li>原因：<ol><li>StringBuilder的append()的方式：<ul><li><font color="cornflowerblue">自始至终中只创建过一个StringBuilder的对象</font></li></ul></li><li>使用String的字符串拼接方式：<ul><li><font color="cornflowerblue">创建过多个StringBuilder和String</font>（调的toString方法）的对象，内存占用更大；</li><li>如果进行<font color="cornflowerblue">GC，需要花费额外的时间</font>（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li></ul></li></ol></li><li>改进的空间：<ul><li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，<font color="red">建议使用构造器实例化</font>：</li><li><code>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]</code></li><li>这样可以<font color="red">避免频繁扩容</font></li></ul></li></ol><h2 id="intern-方法及其使用"><a href="#intern-方法及其使用" class="headerlink" title="intern()方法及其使用"></a>intern()方法及其使用</h2><h3 id="intern-定义及其演变"><a href="#intern-定义及其演变" class="headerlink" title="intern()定义及其演变"></a>intern()定义及其演变</h3><ol><li><p>intern是一个<font color="cornflowerblue">native方法</font>，调用的是底层C的方法</p></li><li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：<font color="red">intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</font>。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String myInfo = new string(&quot;I love atguigu&quot;).intern();</span><br></pre></td></tr></table></figure></li><li><p>也就是说，如果<font color="cornflowerblue">在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同</font>。因此，下列表达式的值必定是true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</span><br></pre></td></tr></table></figure></li><li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p></li></ol><p><strong>JDK6VSJDK7</strong></p><p>总结String的intern()的使用：</p><ul><li>jdk1.6中，将这个字符串对象尝试放入串池。<ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此对象<font color="red">复制一份，放入串池</font>，并返回串池中的<font color="red">对象地址</font></li></ul></li><li>Jdk1.7起，将这个字符串对象尝试放入串池。<ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，<font color="cornflowerblue">若堆中有相同字面量的字符串实例</font>，<font color="red">那么在常量池中创建一个指向堆中该字符串实例的引用指针，并返回该引用，</font><font color="cornflowerblue">若堆中不存在</font>，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ul><h3 id="字符串拼接、创建对象个数、intern-的使用案例"><a href="#字符串拼接、创建对象个数、intern-的使用案例" class="headerlink" title="&#x3D;&#x3D;字符串拼接、创建对象个数、intern()的使用案例&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符串拼接、创建对象个数、intern()的使用案例&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>new String() + new String()案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea3/../../image/JVMRuntimeDataArea3.assets/image-20230724171336785.png" alt="image-20230724171336785"></p><h2 id="String的去重操作"><a href="#String的去重操作" class="headerlink" title="String的去重操作"></a>String的去重操作</h2><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p></blockquote><p>暂时了解一下，后面会详解垃圾回收器</p><p><strong>String去重操作的背景</strong></p><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ol><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ol><p><strong>String 去重的的实现</strong></p><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。<font color="cornflowerblue">对每一个访问的对象都会检查是否是候选的要去重的String对象。</font></li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个<font color="cornflowerblue">Hashtable</font>来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ul><p><strong>命令行选项</strong></p><ol><li>UseStringDeduplication(bool) ：开启String去重，<font color="red">默认是不开启的，需要手动开启。</font></li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区（02）</title>
      <link href="/blog/JVMRuntimeDataArea2/"/>
      <url>/blog/JVMRuntimeDataArea2/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区（02）"><a href="#运行时数据区（02）" class="headerlink" title="运行时数据区（02）"></a>运行时数据区（02）</h1><h2 id="课程内容概览"><a href="#课程内容概览" class="headerlink" title="课程内容概览"></a>课程内容概览</h2><p><strong>该部分包含：</strong></p><ul><li>堆</li></ul><blockquote><p>部分图源自作者<a href="https://github.com/youthlql">youthlql</a>，懒得重新看视频截图了，就在这位作者的笔记基础上和自己原ipad的goodnotes笔记结合做了一定修改</p></blockquote><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><h3 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h3><ol><li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，<strong>一个运行时数据区只有一个堆和一个方法区</strong>。</li><li>但是<strong>进程包含多个线程，他们是<font color="red">共享同一堆空间</font>的</strong>。</li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0001.png"></p><ol><li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p></li><li><p>Java堆区在<font color="red">JVM启动的时候即被创建</font>，其空间大小也就确定了，堆是JVM管理的<font color="red">最大一块内存空间</font>，并且<font color="red">堆内存的大小是可以调节</font>的。</p></li><li><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li><p>所有的线程共享Java堆，在这里还<font color="red">可以划分<strong>线程私有</strong>的缓冲区</font>（Thread Local Allocation Buffer，**<font color="red">TLAB</font>**）。</p></li><li><p>《Java虚拟机规范》中对Java堆的描述是：**<font color="red">所有的对象实例以及数组都应当在运行时分配在堆上</font>**。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）(<font color="cornflowerblue">因为HotSpot虚拟机不采取栈上分配</font>)</p><ul><li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li></ul></li><li><p><font color="cornflowerblue">数组和对象<strong>可能</strong>永远不会存储在栈上</font>（<strong>不一定，逃逸分析的时候</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p></li><li><p>在<font color="red">方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</font>。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li><p>堆，<font color="red">是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域</font>。</p></li></ol><blockquote><p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHeap</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My ID is &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0002.png"></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ol><li><font color="cornflowerblue">Java7 </font>及之前堆内存逻辑上分为三部分：<font color="red">新生区+养老区+<strong>永久区</strong></font><ul><li>Young Generation Space    新生区      Young&#x2F;New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Old generation space    养老区           Old&#x2F;Tenure</li><li>Permanent Space   永久区                   Perm</li></ul></li><li><font color="cornflowerblue">Java 8</font>及之后堆内存逻辑上分为三部分：<font color="red">新生区+养老区+<strong>元空间</strong></font><ul><li>Young Generation Space <font color="red">新生区，又被划分为Eden区和Survivor区</font></li><li>Old generation space 养老区</li><li>Meta Space 元空间 Meta</li></ul></li></ol><p>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0003.png"></p><ol start="2"><li>堆空间内部结构，JDK1.8之前从永久代 替换成 <font color="red">元空间（元空间不适用JVM内存）</font></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0004.png"></p><h2 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h2><p>运行下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、双击jdk目录下的这个文件</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0005.png"></p><p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0006.png"></p><p>3、运行上面的代码</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0007.png"></p><h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><h3 id="设置堆内存"><a href="#设置堆内存" class="headerlink" title="设置堆内存"></a>设置堆内存</h3><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p><ul><li><strong><font color="red">-Xms</font><strong>用于表示</strong>堆区的起始内存</strong>，等价于**-XX:InitialHeapSize**</li><li><strong><font color="red">-Xmx</font><strong>则用于表示</strong>堆区的最大内存</strong>，等价于**-XX:MaxHeapSize**</li></ul></li><li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p></li><li><p><font color="red">通常会将-Xms和-Xmx两个参数配置相同的值</font>（<font color="cornflowerblue">其目的是为了能够在java垃圾回收机制清理完成堆区后不需要重新分隔计算堆区的大小</font>）</p></li></ol><ul><li>解释：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li><li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul><ol start="4"><li><p>默认情况下:</p><ul><li><strong>初始内存大小：物理电脑内存大小&#x2F;64</strong></li><li><strong>最大内存大小：物理电脑内存大小&#x2F;4</strong></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xms : 123M</span><br><span class="line">-Xmx : 1794M</span><br><span class="line">系统内存大小为：<span class="number">7.</span>6875G</span><br><span class="line">系统内存大小为：<span class="number">7.</span>0078125G</span><br></pre></td></tr></table></figure><p>1、笔者电脑内存大小是8G，不足8G的原因是操作系统自身还占据了一些。</p><p>2、两个不一样的原因待会再说</p><p>设置下参数再看</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0008.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms : 575M</span><br><span class="line">-Xmx : 575M</span><br></pre></td></tr></table></figure><p>为什么会少25M</p><p><strong>方式一： jps   &#x2F;  jstat -gc 进程id</strong></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0009.png"></p><blockquote><p>jps：查看java进程</p><p>jstat：查看某进程内存使用情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure><p>1、</p><p>25600+25600+153600+409600 &#x3D; 614400K</p><p>614400 &#x2F;1024 &#x3D; 600M</p><p>2、</p><p>25600+153600+409600 &#x3D; 588800K</p><p>588800 &#x2F;1024 &#x3D; 575M</p><p>3、</p><p>并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）</p><p><font color="red">即S区只计算一个的值</font></p><p> <strong>方式二：-XX:+PrintGCDetails</strong></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0010.png"></p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、设置虚拟机参数</p><p><code>-Xms600m -Xmx600m</code></p><p>最终输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:<span class="number">29</span>)</span><br><span class="line">at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>2、堆内存变化图</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0011.png"></p><p>3、原因：大对象导致堆内存溢出</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0012.png"></p><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>1、存储在JVM中的Java对象可以被划分为两类：</p><pre><code>- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</code></pre><p>2、Java堆区进一步细分的话，可以划分为<font color="red">年轻代（YoungGen）和老年代（oldGen）</font></p><p>3、其中<font color="red">年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</font></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0013.png"></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0014.png"></p><ul><li><p>配置新生代与老年代在堆结构的占比</p><ul><li><p>默认<font color="red"><strong>-XX:NewRatio</strong>&#x3D;2</font>，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p></li><li><p>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p></li></ul></li></ul><ol><li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，</p></li><li><p>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如<font color="red">-XX:SurvivorRatio&#x3D;8（默认值为8，但因为自适应调节机制，实际比例可能为6:1:1）</font></p></li><li><p><font color="red">几乎&lt;&#x2F;所有的Java对象都是在Eden区被new出来的。</font></p></li><li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p></li><li><p>可以使用选项”<font color="red">-Xmn”设置新生代最大内存大小（会与NewRatio造成冲突，优先级比NewRatio高，一般不设置）</font>，但这个参数一般使用默认值就可以了。</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0015.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span></span><br><span class="line"><span class="comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span></span><br><span class="line"><span class="comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EdenSurvivorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只是来打个酱油~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><p><strong>具体过程</strong></p><ol><li><p><font color="red">new的对象先放伊甸园区</font>。此区有大小限制。</p></li><li><p><font color="red">当伊甸园的空间填满时</font>，程序又需要创建对象，JVM的垃圾回收器将<font color="red">对伊甸园区进行垃圾回收（MinorGC）</font>，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</p></li><li><p><font color="red">然后将伊甸园中的剩余对象移动到幸存者0区</font>。</p></li><li><p><font color="red">如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</font>。</p></li><li><p>如果再次经历垃圾回收，此时会<font color="red">重新放回幸存者0区，接着再去幸存者1区</font>。</p></li><li><p>啥时候能去养老区呢？可以设置次数。<font color="red">默认是15次</font>。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：</p><p><font color="cornflowerblue"><strong>-XX:MaxTenuringThreshold</strong>&#x3D;N</font> 进行设置</p></li><li><p>在养老区，相对悠闲。当<font color="red">养老区内存不足时，再次触发GC：Major GC</font>，进行养老区的内存清理</p></li><li><p><font color="red">若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常</font>。</p></li></ol><h3 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h3><p>1、我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC &#x2F; Minor GC操作</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0016.png"></p><p>2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p><p>3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1</p><blockquote><p>下一次再进行GC的时候，</p><p>1、这一次的s0区为空，所以成为下一次GC的S1区</p><p>2、这一次的s1区则成为下一次GC的S0区</p><p>3、也就是<font color="red">说s0区和s1区在互相转换</font>。</p></blockquote><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0017.png"></p><p>4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0018.png"></p><p>关于垃圾回收：<font color="red">频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</font></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0019.png" alt="0019"></p><h3 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h3><p><font color="red"><strong>对象分配的特殊情况</strong></font></p><ol><li><strong>如果来了一个新对象，先看看 Eden 是否放的下？</strong><ul><li><strong>如果 Eden 放得下，则直接放到 Eden 区</strong></li><li><strong>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</strong></li></ul></li><li><strong>将对象放到老年区又有两种情况：</strong><ul><li><strong>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</strong></li><li><strong>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</strong></li></ul></li><li><strong>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些年龄还没满15的对象，让他们直接晋升至老年区</strong></li><li><strong>若是Eden区往S区放对象时，要是该对象比S区大小还大，则该对象会直接别放入老年区</strong></li><li><strong>若S区中，某年龄大小的所有对象占S区的一半及以上，则大于等于该年龄的所有对象直接晋升老年区</strong></li></ol><h3 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h3><ol><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控，推荐）</li><li>Jprofiler（APP+IDEA插件）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ol><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ol><li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p></li><li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，<font color="cornflowerblue">大部分时候回收的都是指新生代</font>。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li></ol><ul><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><strong>新生代收集</strong>（Minor GC&#x2F;Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC&#x2F;Old GC）：只是老年代的圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li><font color="red">注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><p><strong>整堆收集</strong>（<strong>Full GC</strong>）：收集整个java堆和方法区的垃圾收集。</p></li></ul><blockquote><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p></blockquote><h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><strong>年轻代 GC（Minor GC）触发机制</strong></p><ol><li><p>当<font color="red">年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满</font>。<font color="cornflowerblue">Survivor满不会主动引发GC</font>，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</p></li><li><p>因为Java对象<font color="red">大多都具备朝生夕灭</font>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p></li><li><p>Minor GC会引发<font color="cornflowerblue">STW</font>（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0020.png"></p><h3 id="Major-Full-GC"><a href="#Major-Full-GC" class="headerlink" title="Major&#x2F;Full GC"></a>Major&#x2F;Full GC</h3><blockquote><p>Full GC有争议，后续详解两者区别，暂时先看着</p></blockquote><p><strong>老年代GC（MajorGC）触发机制</strong></p><ol><li><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p></li><li><p>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在<font color="cornflowerblue">老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</font></li></ul></li><li><p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p></li><li><p><font color="cornflowerblue">如果Major GC后，内存还不足，就报OOM了</font></p></li></ol><p><strong>Full GC 触发机制（后面细讲）</strong></p><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ol><li>调用System.gc()时，系统建议执行FullGC，但是<font color="cornflowerblue">不必然</font>执行</li><li>超大对象晋升时老年代空间不足（正常情况老年代空间不足也可能是Major GC，注意分晓）</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存（空间分配担保策略为true）</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>说明：<font color="red">Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</font></p><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), <span class="number">0.0009094</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), <span class="number">0.0009568</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), <span class="number">0.0005594</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), <span class="number">0.0005890</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 472K-&gt;0K(2560K)] [ParOldGen: 5946K-&gt;4944K(7168K)] 6418K-&gt;4944K(9728K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="number">0.0045270</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), <span class="number">0.0004954</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">124</span>)</span><br><span class="line">at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">448</span>)</span><br><span class="line">at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">136</span>)</span><br><span class="line">at com.atguigu.java1.GCTest.main(GCTest.java:<span class="number">20</span>)</span><br><span class="line">[PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 4944K-&gt;4877K(7168K)] 4944K-&gt;4877K(8704K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="number">0.0076061</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">遍历次数为：<span class="number">16</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 1536K, used 60K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 1024K, <span class="number">5</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f058</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 4877K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">68</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffac3408</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 391K, capacity 394K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p></li><li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p></li></ul><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><p><font color="red">先说结论：不分代每次垃圾收集时，都会进行整堆扫描，遍历所有对象，非常浪费时间和性能</font></p><ul><li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0021.png"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p><ul><li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li></ul><ul><li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0022.png"></p><h2 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h2><ol><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li><li>对象晋升老年代的年龄阀值，可以通过选项**<font color="red">-XX:MaxTenuringThreshold</font>**来设置</li></ol><p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p><ol><li><strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li><li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li><li><strong>长期存活的对象分配到老年代</strong></li><li><strong>动态对象年龄判断</strong>：如果Survivor区中<strong>相同年龄</strong>的所有对象大小的<strong>总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li><strong>S区放不下的对象直接进入老年代</strong></li><li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。（默认开启，后面有讲）</li></ol><blockquote><p>一些细节放在后面说</p></blockquote><h2 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h2><h3 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h3><ol start="2"><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用<font color="cornflowerblue"><strong>加锁等机制</strong>，进而影响分配速度。</font></li></ol><h3 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h3><p>TLAB（Thread Local Allocation Buffer）</p><ol><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<font color="red">JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</font></li><li>多线程同时分配内存时，<font color="red"><strong>使用TLAB可以避免一系列的非线程安全问题（因为是线程私有的，可以无视锁问题，效率提升）</strong></font>，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<font color="red"><strong>快速分配策略</strong>。</font></li><li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0023.png"></p><p>1、每个线程都有一个TLAB空间</p><p>2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</p><h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ol><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<font color="red"><strong>JVM确实是将TLAB作为内存分配的首选</strong>。</font></p></li><li><p>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</p></li><li><p>默认情况下，TLAB空间的内存非常小，<font color="cornflowerblue">仅占有整个Eden空间的1%</font>，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</p></li><li><p><font color="cornflowerblue">一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</font></p></li></ol><blockquote><p>哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                   </p><p>—-这是《深入理解JVM》–第三版里说的</p></blockquote><p><strong>TLAB 分配过程</strong></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea2/../../image/JVMRuntimeDataArea2.assets/0024.png"></p><h2 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h2><h3 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h3><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>我们只说常用的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试堆空间常用的jvm参数：</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line"><span class="comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span></span><br><span class="line"><span class="comment"> *                             jinfo -flag SurvivorRatio 进程id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span></span><br><span class="line"><span class="comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line"><span class="comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span></span><br><span class="line"><span class="comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span></span><br><span class="line"><span class="comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="空间分配担保策略"><a href="#空间分配担保策略" class="headerlink" title="空间分配担保策略"></a>空间分配担保策略</h3><p>1、在发生Minor GC之前，虚拟机会<font color="red">检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</font>。</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。<ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续<font color="red">检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong></font>。<ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则进行一次Full GC。</li></ul></li><li>如果HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li></ul></li></ul><p><strong>历史版本</strong></p><ol><li><font color="red">在JDK6 Update 24之后</font>，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li><li>JDK6 Update 24之后的规则变为**<font color="red">只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</font>**，否则将进行Full GC。<font color="red">即 HandlePromotionFailure&#x3D;true，不能为false</font></li></ol><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p><strong>堆是分配对象的唯一选择么？</strong></p><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><ol><li><p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></li><li><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**<font color="red">如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</font>**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p></li><li><p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p></li></ol><p><strong>逃逸分析概述</strong></p><ol><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li><font color="red">逃逸分析的基本行为就是分析对象动态作用域：</font><ul><li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</strong></li><li><strong>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</strong></li></ul></li></ol><p><strong>逃逸分析举例</strong></p><p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span>? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>逃逸分析参数设置</strong></p><ol><li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p></li><li><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“**-XX:+DoEscapeAnalysis**”显式开启逃逸分析</li><li>通过选项“**-XX:+PrintEscapeAnalysis**”查看逃逸分析的筛选结果</li></ul></li></ol><p><strong>总结</strong></p><p><font color="red"><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong></font></p><h3 id="代码优化策略"><a href="#代码优化策略" class="headerlink" title="代码优化策略"></a>代码优化策略</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li><strong>栈上分配</strong>：<strong>将堆分配转化为栈分配</strong>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li><strong>同步省略</strong>：如果一个对象被发现<strong>只有一个线程被访问到，</strong>那么对于这个对象的操作<strong>可以不考虑同步。</strong></li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。（<strong>将聚合量分解为标量和更小的聚合量</strong>）</li></ol><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ol><li><strong>JIT编译器在编译期间根据逃逸分析的结果</strong>，发现如果一个对象并**<font color="cornflowerblue">没有逃逸出方法的话，就可能被优化成栈上分配</font>**。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就<font color="red">无须进行垃圾回收</font>了。</li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ol><p><strong>栈上分配举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;808K(38400K)] 33280K-&gt;816K(125952K), 0.0483350 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0008411 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;792K(38400K)] 34096K-&gt;800K(125952K), 0.0008427 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34072K-&gt;808K(38400K)] 34080K-&gt;816K(125952K), 0.0012223 secs] [Times: user=0.08 sys=0.00, real=0.00 secs] </span><br><span class="line">花费的时间为： 114 ms</span><br></pre></td></tr></table></figure><p>1、JVM 参数设置</p><p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：发生了 GC ，耗时 114ms</p><p><strong>开启逃逸分析的情况</strong></p><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： 5 ms</span><br></pre></td></tr></table></figure><p>1、参数设置</p><p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：并没有发生 GC ，耗时5ms 。</p><h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ol><li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p></li><li><p>在动态编译同步块的时候，JIT编译器可以<font color="red">借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong></font>。</p></li><li><p>如果没有，那么<font color="cornflowerblue">JIT编译器</font>在编译这个同步块的时候<font color="cornflowerblue">就会取消对这部分代码的同步</font>。这样就能大大提高并发性和性能。这个**取消同步的过程就叫同步省略，也叫<font color="red">锁消除</font>**。</p></li></ol><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hollis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节码分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    public void f() &#123;</span><br><span class="line">        Object hollis = new Object();</span><br><span class="line">        synchronized(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> astore_1</span><br><span class="line"> <span class="number">8</span> aload_1</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> monitorenter</span><br><span class="line"><span class="number">12</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> aload_2</span><br><span class="line"><span class="number">20</span> monitorexit</span><br><span class="line"><span class="number">21</span> goto <span class="number">29</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">24</span> astore_3</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> monitorexit</span><br><span class="line"><span class="number">27</span> aload_3</span><br><span class="line"><span class="number">28</span> athrow</span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p><ol><li><p><strong>标量（scalar）是指一个无法再分解成更小的数据的数据</strong>。Java中的原始数据类型就是标量。</p></li><li><p>相对的，<strong>那些还可以分解的数据叫做聚合量（Aggregate）</strong>，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p></li><li><p>在JIT阶段，<strong>如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过<font color="cornflowerblue">JIT</font>优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<font color="red">标量替换</font>。</strong></p></li></ol><p><strong>标量替换举例</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li><font color="red">标量替换为栈上分配提供了很好的基础</font>。</li></ol><p><strong>标量替换参数设置</strong></p><p>参数 <strong>-XX:+ElimilnateAllocations</strong>：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>未开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p><p>2、日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;880K(98304K), <span class="number">0.0012658</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26480K-&gt;832K(98304K), <span class="number">0.0012124</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;784K(98304K), <span class="number">0.0009719</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26384K-&gt;832K(98304K), <span class="number">0.0009071</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;768K(98304K), <span class="number">0.0010643</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26368K-&gt;824K(101376K), <span class="number">0.0012354</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32568K-&gt;712K(100864K), <span class="number">0.0011291</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32456K-&gt;712K(100864K), <span class="number">0.0006368</span> secs]</span><br><span class="line">花费的时间为： <span class="number">99</span> ms</span><br></pre></td></tr></table></figure><p><strong>开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p><p>2、日志：时间减少很多，且无GC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： 6 ms</span><br></pre></td></tr></table></figure><p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p><p><strong>这里设置参数如下：</strong></p><ol><li>参数 -server：启动Server模式，因为<strong>在server模式下，才可以启用逃逸分析</strong>。（X86机器只能使用server模式）</li><li>参数 <strong>-XX:+DoEscapeAnalysis</strong>：启用逃逸分析</li><li>参数 <strong>-Xmx</strong>10m：指定了堆空间最大为10MB</li><li>参数 <strong>-XX:+PrintGC</strong>：将打印GC日志。</li><li>参数 <strong>-XX:+EliminateAllocations</strong>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ol><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><ol><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是<font color="red">无法保证逃逸分析的性能消耗一定能高于他的消耗</font>。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是<font color="red">逃逸分析自身也是需要进行一系列复杂的分析</font>的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也<font color="red">是JIT即时编译器优化技术中一个十分重要的手段</font>。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，**<font color="red">Oracle Hotspot JVM中并未这么做</font>**（刚刚演示的效果，是<font color="cornflowerblue">因为HotSpot实现了标量替换</font>），这一点在逃逸分析相关的文档里已经说明，<font color="red"><strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</font></li><li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ol><blockquote><p><strong>堆是分配对象的唯一选择么？</strong></p></blockquote><p>综上：<strong>HotSpot虚拟机所有对象实例都是分配在堆上</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p></li><li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p></li><li><p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</p></li><li><p>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</p></li><li><p>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p></li><li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</p></li><li><p>当GC发生在老年代时则被称为Major GC或者Full GC。</p></li><li><p>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载过程</title>
      <link href="/blog/JVMClassLoading/"/>
      <url>/blog/JVMClassLoading/</url>
      
        <content type="html"><![CDATA[<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p><img src="https://www.hahhome.top/blog/JVMClassLoading/../../image/JVMClassLoading.assets/image-20230709125627229.png" alt="image-20230709125627229"></p><p>我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</p><ul><li><p>加载（Loading）：查找编译后该类对应的 .class文件，并对常量进行默认初始化赋值0</p></li><li><p>链接（Linking）：</p><ul><li>验证（Verify）：验证class文件是否符合当前虚拟机的要求</li><li>准备（Prepare）：为类变量分配内存并设置默认初始值0，并为常量进行显式赋值</li><li>解析（Resolve）：将常量池内的符号引用转换为直接引用的过程</li></ul></li><li><p>初始化（Initialization）：执行类构造器 clinit()方法的过程，对类变量初始化赋值</p></li></ul><h2 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h2><h3 id="加载的理解"><a href="#加载的理解" class="headerlink" title="加载的理解"></a>加载的理解</h3><p><font color="red">查找编译后该类对应的 .class文件</font></p><p><font color="red">所谓加载，简而言之就是将)ava类的字节码文件加载到机器内存中，并在内存中构建出]ava类的原型一一类模板对象。</font>所谓类模板对象，其实就是]va类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取]ava类中的任意信息，能够对]ava类的成员变量进行遍历，也能进行Java方法的调用。</p><p>反射的机制即基于这一基础。如果JVM没有将]aVa类的声明信息存储起来，则JVM在运行期也无法反射。</p><h3 id="加载完成的操作"><a href="#加载完成的操作" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h3><p><font color="red">加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。</font></p><p>在加载类时，)ava虚拟机必须完成以下3件事情：</p><ul><li>通过类的全名，获取类的二进制数据流。</li><li>解析类的二进制数据流为方法区内的数据结构(Java类模型)</li><li>创建java.lang.c1ass类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><ul><li>引导类&#x2F;启动类 加载器Bootstrap ClassLoader：用c&#x2F;c++编写，不继承于Classloader类，用于加载Java核心类库等，若要输出该类的对象，将会输出NULL</li><li>扩展类加载器Extension ClassLoader：用Java编写，继承于Classloader类</li><li>系统类加载器Application ClassLoader：用Java编写，继承于Classloader类，是默认的类加载器</li><li>特殊的：自定义类加载器自己重写findClass()方法的加载器</li></ul><h3 id="获取ClassLoader类对象的途径"><a href="#获取ClassLoader类对象的途径" class="headerlink" title="获取ClassLoader类对象的途径"></a>获取ClassLoader类对象的途径</h3><p>方式一：获取当前类的ClassLoader<br>clazz.getClassLoader()<br>方式二：获取当前线程上下文的ClassLoader<br>Thread.currentThread().getContextClassLoader()<br>方式三：获取系统的ClassLoader<br>ClassLoader.getsystemClassLoader()<br>方式四：获取调用者的ClassLoader<br>DriverManager.getCallerClassLoader()</p><h2 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h2><h3 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h3><p>验证class文件是否符合当前虚拟机的要求</p><p><font color="red">它的目的是保证加载的字节码是合法、合理并符合规范的。</font></p><ol><li>进行格式验证<ul><li>魔数检查</li><li>版本检查</li><li>长度检查</li></ul></li><li>语义检查<ul><li>是否继承final</li><li>是否有父类</li><li>抽象方法是否有实现</li></ul></li><li>字节码验证<ul><li>跳转指令是否指向正确位置</li><li>操作数类型是否合理、</li></ul></li><li>符号引用验证<ul><li>符号引用的直接引用是否存在</li></ul></li></ol><p><font color="red">其中格式验证会和加载阶段一起执行。</font>验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</p><p><font color="red">格式验证之外的验证操作将会在方法区中进行。</font></p><p>具体说明：<br>1.<strong>格式验证</strong>：是否以魔数OxCAFEBABE开头，主版本和副版本号是否在当前]ava虚拟机的支持范围内，数据中每一个项是否都<br>拥有正确的长度等。</p><p>2.Java虚拟机会进行字节码的<strong>语义检查</strong>，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p><ul><li>是否所有的类都有父类的存在（在Java里，除了Object外，其他类都应该有父类）</li><li>是否一些被定义为final的方法或者类被重写或继承了</li><li>非抽象类是否实现了所有抽象方法或者接口方法</li><li>是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract情况<br>下的方法，就不能是final的了)</li></ul><p>3.]av虚拟机还会进行<strong>字节码验证</strong>，字节码验证也是<font color="cornflowerblue">验证过程中最为复杂的一个过程</font>。它试图通过对字节码流的分析，判断字节<br>码是否可以被正确地执行。比如：</p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型等</li></ul><p>栈映射帧(StackMapTable)就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。<br>但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显<br>的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是<br>完全没有问题的。</p><p><font color="red">在前面3次检查中，已经排除子文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</font></p><p>4.校验器还将进行<strong>符号引用的验证</strong>。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<font color="red">虚拟机就会检查这些类或者方法确实是存在的</font>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError,如果一个方法无法被找到，则会抛出NoSuchMethodError。</p><p>此阶段在解析环节才会执行。</p><h3 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h3><p><font color="red">为类变量分配内存并设置默认初始值0，并为常量进行显式赋值</font></p><p>准备阶段(Preparation),简言之，为<font color="red">类的静态变量分配内存，并将其初始化为默认值。</font></p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。</p><p>Java虚拟机为各类型变量默认的初始值如表所示：</p><table><thead><tr><th>类型</th><th>默认初始值</th></tr></thead><tbody><tr><td>byte</td><td>0</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>0(false)</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>注意：Java并不支持boolean:类型，对于boolean类型，内部实现是int,由于int的默认值是g,故对应的，boolean的默认值就是false</p><p>注意：</p><p>1.<font color="red">这里不包含基本数据类型的字段用static final修饰的情况，因为final在编译的时候就会分配并初始化赋值，准备阶段会显式赋值</font>，具体在初始化部分详解</p><p>2.注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><p>3.在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p><h3 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h3><p><font color="red">将常量池内的符号引用转换为直接引用的过程</font></p><p><font color="red">解析阶段(Resolution),简言之，将类、接口、字段和方法的符号引用转为直接引用。</font></p><p>1.具体描述：</p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在C1ass类文件中<br>,通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下print1n()方法被<br>调用时，系统需要明确知道该方法的位置。</p><p>举例：输出操作System.out.println()对应的字节码：</p><p>invokevirtual #24 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</p><p><font color="red">通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</font></p><h2 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h2><p><font color="red">执行类构造器&lt; clinit&gt;()方法的过程，对类的静态变量初始化赋值</font></p><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h3><p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。（即：<font color="cornflowerblue">到了初始化阶段，才真正开始执行类中定义的Java程序代码</font>。）</p><p><font color="red">切始化阶段的重要工作是执行类的初始化方法：&lt; clinit&gt;()方法。</font></p><ul><li>该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在]ava程序中调用该方法，虽然该方法也是由字节码指令所组成。</li><li>它是由类静态成员的赋值语句以及static语句块合并产生的</li></ul><p><strong>说明</strong></p><ol><li><p>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的&lt; clinit&gt;总是在子类&lt; clinit&gt;之前被调用。也就是说，父类的static块优先级高于子类。</p></li><li><p>Java编译器并不会为所有的类都产生&lt; clinit&gt;()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含&lt; clinit&gt;()方法？</p><ul><li><p>一个类中并没有声明任何的类变量，也没有静态代码块时</p></li><li><p>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p></li><li><p>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</p></li></ul></li><li><p><strong>&lt; clinit&gt;()是带锁线程安全的</strong></p></li></ol><ul><li>锁是隐式的，若两个类交叉相互调用，有可能造成死锁</li></ul><h3 id="哪些不会生成-clinit-方法"><a href="#哪些不会生成-clinit-方法" class="headerlink" title="哪些不会生成&lt; clinit&gt;()方法"></a>哪些不会生成&lt; clinit&gt;()方法</h3><p><img src="https://www.hahhome.top/blog/JVMClassLoading/../../image/JVMClassLoading.assets/image-20230709134249348.png" alt="image-20230709134249348"></p><h3 id="static-final修饰显式赋值"><a href="#static-final修饰显式赋值" class="headerlink" title="static+final修饰显式赋值"></a>static+final修饰显式赋值</h3><p>使用static+final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p><ul><li>情况1：在链接阶段的准备环节赋值</li><li>情况2：在初始化阶段&lt; clinit&gt;()中赋值</li></ul><p><strong>结论：</strong></p><p><strong>在链接阶段的准备环节赋值的情况：</strong></p><ol><li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</li><li>对于string来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</li></ol><p><strong>在初始化阶段&lt; clinit&gt;()中赋值的情况：</strong></p><p>排除上述的在准备环节赋值的情况之外的情况。</p><p>最终结论：</p><ul><li><font color="red">使用static+final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。</font><ul><li><font color="red">即静态常量（基本数据类型（不包括封装类）、String类型字面量（”XXX”这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值</font></li></ul></li><li><font color="red">引用数据类型的静态常量，尤其是new String(“XXX”)这种形式，都是在初始化中的&lt; client&gt;()中进行显示赋值的</font></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意：</font></p><ul><li><strong>JVM规范提出推荐在初始化阶段进行赋值</strong>，<strong>只是HotSpot</strong>虚拟机对static+final修饰的String类型或者基本类型常量在准备阶段就进行了赋值</li><li>对于static修饰的类变量，会使用contentValue属性提醒虚拟机进行赋值，使用final修饰的变量虽然字节码中也会出现contentValue属性，但是JVM会忽视它，final变量是在实例创建的时候赋值的</li></ul><h2 id="使用（Using）"><a href="#使用（Using）" class="headerlink" title="使用（Using）"></a>使用（Using）</h2><p><strong>检查类的初始化情况</strong>：主动使用vs被动使用（这里并不算真正的类的使用，只是分情况讨论哪些情况才会导致&lt; clinit&gt;()的执行）</p><p>调试期间可以添加参数<code>-XX:+TraceClassLoading</code>来打印<strong>类的加载</strong>(Loading)情况</p><h3 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h3><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备己经完成。)</p><p><font color="cornflowerblue">主动使用即会造成类的初始化（Initialization）</font></p><ol><li>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</li><li>当调用类的静态方法时，即当使用了字节码invokestatic指令。</li><li>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作)</li><li>当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</li><li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<ul><li>其实现的接口一般情况下不会被初始化</li></ul></li><li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getstatic、REF_putstatic、REF_invokeStatic方法句柄对应的类)</li></ol><p><font color="red">只有类的主动使用，才会进行类的初始化，执行&lt; clinit&gt;()方法进行初始化赋值</font></p><h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p>除了以上八种情况，其他使用Java类的方式都被看作是对<font color="red">类的被动使用，都不会导致类的初始化</font>（<font color="cornflowerblue">即类的加载过程中的Initialization</font>）</p><p>关于类的被动使用，即不会进行类的初始化操作，即不会调用clinit.&gt;()</p><ol><li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。<ul><li>当通过子类引用父类的静态变量，不会导致子类初始化</li></ul></li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就己经被显式赋值了。</li><li>调用ClassLoader类的了loadcLass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。<ul><li>ClassLoader.getSystemClassLoader().loadClass(“com.spongehah.java.Person”)，该种反射加载类的方式并不会造成类的初始化</li></ul></li></ol><h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。</p><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用ew关键字为其创建对象实例。</p><h2 id="卸载（Unloading）"><a href="#卸载（Unloading）" class="headerlink" title="卸载（Unloading）"></a>卸载（Unloading）</h2><h3 id="一、类、类的加载器、类的实例之间的引用关系"><a href="#一、类、类的加载器、类的实例之间的引用关系" class="headerlink" title="一、类、类的加载器、类的实例之间的引用关系"></a>一、类、类的加载器、类的实例之间的引用关系</h3><p>在类加载器的内部实现中，用一个]ava集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器,调用Class对象的getclassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的]ava类都有一个静态属性Class,它引用代表这个类的Class对象。</p><h3 id="二、类的生命周期"><a href="#二、类的生命周期" class="headerlink" title="二、类的生命周期"></a>二、类的生命周期</h3><p><strong>当Sample类被加载、链接和初始化后</strong>，它的生命周期就开始了。<strong>当代表Sample类的Class对象不再被引用</strong>，即不可触及</p><p>时，Class对象就会结束生命周期，<strong>Sample类在方法区内的数据也会被卸载</strong>，从而结束Sample类的生命周期。</p><p><font color="red">一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</font></p><h3 id="三、具体例子"><a href="#三、具体例子" class="headerlink" title="三、具体例子"></a>三、具体例子</h3><p><img src="https://www.hahhome.top/blog/JVMClassLoading/../../image/JVMClassLoading.assets/image-20230709202450409.png" alt="image-20230709202450409"></p><p><font color="cornflowerblue">若要想卸载方法区中某类的数据结构，根据图来看，必须要它的Class对象被回收，而Class对象要被回收，需要要它的实例对象（Sample对象）、ClassLoader对象（MyClassLoader对象）和局部变量表中引用Class对象的局部变量（objClass引用变量）全部被回收，才可能能够回收掉该类的数据结构</font></p><p>loader1变量和obj变量间接应用代表Sample类的class对象，而objclass变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为null,此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p><p>当再次有需要时，会检查Sample类的class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的class实例（可以通过哈希码查看是否是同一个实例）。</p><h3 id="四、类的卸载"><a href="#四、类的卸载" class="headerlink" title="四、类的卸载"></a>四、类的卸载</h3><p>(1)<strong>启动类加载咖载的类型在整个运行期间是不可能被卸载的</strong>(jvm和jls规范)</p><p>(2)被<strong>系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载</strong>，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，<strong>其达到unreachable的可能性极小。</strong></p><p>(3)<font color="cornflowerblue">被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载</font>，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的)。</p><p>综合以上三点，一个己经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><p><font color="cornflowerblue">综上所述：一般情况下，只有自定义的类加载器有可能被卸载，其它类的加载器都不太可能被卸载，故其加载的类也不会被卸载</font></p><p><strong>回顾：方法区的垃圾回收</strong></p><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong>。</p><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><font color="cornflowerblue">该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</font></li><li><font color="cornflowerblue">加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSG1、]SP的重加载等，否则通常是很难达成的。</font></li><li><font color="cornflowerblue">该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</font></li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“<strong>被允许</strong>”，而并不是和对象一样，没有引用了就必然会回收。</p><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><p><strong>蚂蚁金服：</strong></p><p>描述一下JVM加载Class文件的原理机制？</p><p>一面：类加载过程</p><p><strong>百度：</strong></p><p>类加载的时机</p><p>java类加载过程？</p><p>简述java类加载机制？</p><p><strong>腾讯：</strong></p><p>JVM中类加载机制，类加载过程？</p><p><strong>滴滴：</strong></p><p>JVM类加载机制</p><p><strong>美团：</strong></p><p>]ava类加载过程</p><p>描述一下jvm加载class文件的原理机制</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区（01）</title>
      <link href="/blog/JVMRuntimeDataArea1/"/>
      <url>/blog/JVMRuntimeDataArea1/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区（01）"><a href="#运行时数据区（01）" class="headerlink" title="运行时数据区（01）"></a>运行时数据区（01）</h1><h2 id="课程内容概览"><a href="#课程内容概览" class="headerlink" title="课程内容概览"></a>课程内容概览</h2><p><strong>该部分包含：</strong></p><ul><li>前置知识了解</li><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><blockquote><p>部分图源自作者<a href="https://github.com/youthlql">youthlql</a>，懒得重新看视频截图了，就在这位作者的笔记基础上和自己原ipad的goodnotes笔记结合做了一定修改</p></blockquote><h1 id="前置知识-类的加载简单了解"><a href="#前置知识-类的加载简单了解" class="headerlink" title="前置知识-类的加载简单了解"></a>前置知识-类的加载简单了解</h1><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ul><li><p>加载（Loading）：查找编译后该类对应的 .class文件，并对常量进行默认初始化赋值0</p></li><li><p>链接（Linking）：</p><ul><li>验证（Verify）：验证class文件是否符合当前虚拟机的要求</li><li>准备（Prepare）：为类变量分配内存并设置默认初始值0，并为常量进行显式赋值</li><li>解析（Resolve）：将常量池内的符号引用转换为直接引用的过程</li></ul></li><li><p>初始化（Initialization）：执行类构造器 clinit()方法的过程，对类变量初始化赋值</p></li></ul><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><ul><li>引导类&#x2F;启动类 加载器Bootstrap ClassLoader：用c&#x2F;c++编写，不继承于Classloader类，用于加载Java核心类库等，若要输出该类的对象，将会输出NULL</li><li>扩展类加载器Extension ClassLoader：用Java编写，继承于Classloader类</li><li>系统类加载器Application ClassLoader：用Java编写，继承于Classloader类，是默认的类加载器</li><li>特殊的：自定义类加载器自己重写loadClass()或findClass()方法的加载器</li></ul><p><font color="cornflowerblue">自定义类加载器的父类是系统类加载器</font></p><h3 id="获取ClassLoader类对象的途径"><a href="#获取ClassLoader类对象的途径" class="headerlink" title="获取ClassLoader类对象的途径"></a>获取ClassLoader类对象的途径</h3><p>方式一：获取当前类的ClassLoader<br>clazz.getClassLoader()<br>方式二：获取当前线程上下文的ClassLoader<br>Thread.currentThread().getContextClassLoader()<br>方式三：获取系统的ClassLoader<br>ClassLoader.getsystemClassLoader()<br>方式四：获取调用者的ClassLoader<br>DriverManager.getCallerClassLoader()</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/image-20230703163721280.png" alt="image-20230703163721280"></p><p><strong>工作原理</strong></p><ul><li>1)如果一个类加载器收到了类加载请求，它并不会自已先去加载，而是把这个请求委托给父类的加载器去执行：</li><li>2)如果父类加载器还存在其父类加载器则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器</li><li>3)如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自已去加载，这就是双亲委派模式。</li></ul><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.Shkstart</li></ul></li></ul><p>举例：在自己的项目中写一个目录为Java.lang下的类String，当new这个自己写的String类时，逐层向上委托过后，最高层的启动类加载器可以执行该请求，故new的String类时核心类库中的String类，自己写的没有办法被new到，保护了API不被篡改（<font color="cornflowerblue">自己写的类都由Application ClassLoader加载</font>）</p><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：主动使用和被动使用。</p><p><font color="cornflowerblue">主动使用即会造成类的初始化（Initialization）</font></p><p><strong>主动使用</strong>，又分为八种情况：</p><ol><li><p>创建类的实例，包括new、反射、克隆、反序列化</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射中使用Class.forName(“com.atguigu.Test”)加载类时，会进行初始化2</p></li><li><p>初始化一个类的子类，但是不会初始化其实现的接口</p></li><li><p>若是一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</p></li><li><p>Java虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类，虚拟机会先初始化这个主类）</p></li><li><p>JDK7开始提供的动态语言支持：</p><ul><li><p>java.lang.invoke.MethodHandle实例的解析结果，当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。</p></li><li><p>REF_getstatic、REF_putStatic、REF_invokeStatic方法句柄对应的类没有初始化，则初始化</p></li></ul></li></ol><p><font color="red">只有类的主动使用，才会进行类的初始化，执行clinit()方法进行初始化赋值</font></p><p>除了以上八种情况，其他使用Java类的方式都被看作是对<font color="red">类的被动使用，都不会导致类的初始化</font>（<font color="cornflowerblue">即类的加载过程中的Initialization</font>）</p><p><strong>被动使用</strong></p><p>关于类的被动使用，即不会进行类的初始化操作，即不会调用clinit.&gt;()</p><ol><li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。<ul><li>当通过子类引用父类的静态变量，不会导致子类初始化</li></ul></li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就己经被显式赋值了。</li><li>调用ClassLoader类的了loadcLass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。<ul><li>ClassLoader.getSystemClassLoader().loadClass(“com.spongehah.java.Person”)，该种反射加载类的方式并不会造成类的初始化</li></ul></li></ol><h1 id="基础知识了解"><a href="#基础知识了解" class="headerlink" title="基础知识了解"></a>基础知识了解</h1><h2 id="HotSpot虚拟机结构"><a href="#HotSpot虚拟机结构" class="headerlink" title="HotSpot虚拟机结构"></a>HotSpot虚拟机结构</h2><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/image-20230703170639531.png" alt="image-20230703170639531"></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/image-20230703162327913.png" alt="image-20230703162327913"></p><p>【HotSpot虚拟机结构图】</p><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p>Java虚拟机定义了若千种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/image-20230703162256930.png" alt="image-20230703162256930"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>JVM 线程</strong></p><ul><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ul><p><strong>JVM系统线程</strong></p><ul><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li><p><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</p></li><li><p><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</p></li><li><p><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</p></li><li><p><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码。</p></li><li><p><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。</p></li></ul></li></ul><h1 id="程序计数器PC-Register"><a href="#程序计数器PC-Register" class="headerlink" title="程序计数器PC Register"></a>程序计数器PC Register</h1><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/image-20230703163236435.png" alt="image-20230703163236435"></p><p>【运行时数据区结构图】</p><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h2><p>JVM中的程序计数寄存器(Program Counter Register)中，Reqister的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>，CPU只有把数据存储到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<font color="red">JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</font></p><ul><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所调的<font color="red">当前方法</font>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值(undefined)，本地方法的指令地址存储在本地方法栈中</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutotMemoryError情况的区域。</li><li><font color="red">PC Register没有GC和OOM</font></li></ul><h2 id="PC寄存器作用"><a href="#PC寄存器作用" class="headerlink" title="PC寄存器作用"></a>PC寄存器作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/image-20230703171158679.png" alt="image-20230703171158679"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">2</span>; size <span class="number">675</span> bytes</span><br><span class="line">  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3</span><br><span class="line">  Compiled from <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.PCRegisterTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">26</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">27</span>            <span class="comment">// abc</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">30.</span>#<span class="number">31</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">32</span>            <span class="comment">// com/atguigu/java/PCRegisterTest</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               args</span><br><span class="line">  #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               i</span><br><span class="line">  #<span class="number">19</span> = Utf8               I</span><br><span class="line">  #<span class="number">20</span> = Utf8               j</span><br><span class="line">  #<span class="number">21</span> = Utf8               k</span><br><span class="line">  #<span class="number">22</span> = Utf8               s</span><br><span class="line">  #<span class="number">23</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">24</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">25</span> = Utf8               PCRegisterTest.java</span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               abc</span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">30</span> = Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               com/atguigu/java/PCRegisterTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        <span class="number">10</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc</span></span><br><span class="line">        <span class="number">12</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">14</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">21</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">24</span>: iload_3</span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">23</span>     <span class="number">2</span>     j   I</span><br><span class="line">           <span class="number">10</span>      <span class="number">19</span>     <span class="number">3</span>     k   I</span><br><span class="line">           <span class="number">14</span>      <span class="number">15</span>     <span class="number">4</span>     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0009.png" alt="0009"></p><h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p></li><li><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0010.png" alt="0010"></p><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**<font color="red">为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</font>**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><blockquote><p>注意并行和并发的区别</p></blockquote><h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h2><ol><li><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p></li><li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p></li><li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0011.png" alt="0011"></p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h2><p><font color="red">首先栈是运行时的单位，而堆是存储的单位。</font></p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0001.png" alt="0001"></p><ul><li><p>Java虚拟机栈是什么？</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。<strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部<strong>保存一个个的栈帧</strong>（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</li></ul></li><li><p>虚拟机栈的生命周期</p><ul><li><strong>生命周期和线程一致</strong>，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li><p>主管Java程序的运行，它保<strong>存方法的局部变量</strong>（8 种基本数据类型、对象的引用地址）、<strong>部分结果</strong>，并<strong>参与方法的调用和返回</strong>。</p></li><li><p>局部变量，它是相比于成员变量来说的（或属性）</p></li><li><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p></li></ul></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0002.png" alt="0002"></p><p><strong>虚拟机栈的特点</strong></p><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li><font color="red">栈不需要GC，但是可能存在OOM</font></li></ul></li></ul><p><strong>虚拟机栈的异常</strong></p><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java栈的大小是<font color="cornflowerblue">动态</font>的或者是<font color="cornflowerblue">固定不变</font>的。</p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h2 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h2><p><strong>概念</strong></p><blockquote><p>多去官方文档看看：<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p><p>地址经常变</p></blockquote><p>我们可以使用参数 <strong><font color="red">-Xss</font></strong> 选项来设置线程的<strong>最大栈空间</strong>，栈的大小直接决定了函数调用的最大可达深度。</p><blockquote><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux&#x2F;x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris&#x2F;x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul></blockquote><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0004-16890796567761.png" alt="0004"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没设置参数前</strong></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11404</span></span><br><span class="line"><span class="number">11405</span></span><br><span class="line"><span class="number">11406</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="number">691</span>)</span><br></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p><strong>设置栈参数之后</strong></p><p>部分输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2474</span></span><br><span class="line"><span class="number">2475</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="number">77</span>)</span><br></pre></td></tr></table></figure><p>说明参数起作用了</p><h2 id="栈的存储单位-栈帧"><a href="#栈的存储单位-栈帧" class="headerlink" title="栈的存储单位-栈帧"></a>栈的存储单位-栈帧</h2><ol><li>每个线程都有自己的栈，栈中的数据都是以**<font color="red">栈帧</font>**（Stack Frame）的格式存在</li><li>在这个线程上正在执行的<font color="red">每个方法都各自对应一个栈帧</font>（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即<strong>只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的</strong>。这个栈帧被称为**<font color="cornflowerblue">当前栈帧</font>（Current Frame）<strong>，与当前栈帧相对应的方法就是</strong><font color="cornflowerblue">当前方法</font>（Current Method）<strong>，定义这个方法的类就是</strong><font color="cornflowerblue">当前类&lt;（Current Class）**</font></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0005.png" alt="0005"></p><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><p><font color="red">局部变量表</font>（Local Variables）</p></li><li><p><font color="red">操作数栈</font>（Operand Stack）（或<font color="red">表达式栈</font>）</p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0006.png" alt="0006"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p><strong>概念</strong></p><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li>**定义为一个<font color="red">数字数组</font>，主要用于<font color="red">存储方法参数和定义在方法体内的局部变量</font>**，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此**<font color="red">不存在数据安全问题</font>**</li><li><strong>局部变量表所需的容量<font color="red">大小是在编译期确定下来</font>的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法<font color="red">运行期间是不会改变局部变量表的大小</font>的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，<font color="cornflowerblue">栈越大，方法嵌套调用次数越多</font>。（主要取决于局部变量表的大小）<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li><font color="cornflowerblue">局部变量表中的变量只在当前方法调用中有效</font>。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，<font color="cornflowerblue">随着方法栈帧的销毁，局部变量表也会随之销毁</font>。</li></ul></li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalVariablesTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">        dateP = <span class="literal">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p><h3 id="Slot槽"><a href="#Slot槽" class="headerlink" title="Slot槽"></a>Slot槽</h3><p><font color="red">即局部变量表数组的每一个小格</font></p><ol><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，**<font color="red">最基本的存储单元是Slot（变量槽）</font>**，局部变量表中存放编译期可知的各种<font color="cornflowerblue">基本数据类型（8种），引用类型（reference），returnAddress类型的变量</font>。</li><li>在局部变量表里，**<font color="red">32位以内的类型只占用一个slot</font><strong>（包括returnAddress类型），</strong><font color="red">64位的类型占用两个slot</font>**（long和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都<font color="cornflowerblue">分配一个访问索引</font>，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**<font color="red">按照顺序被复制</font>**到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，<font color="red">只需要使用前一个索引即可</font>。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么**<font color="red">该对象引用this将会存放在index为0的slot处</font>**，其余的参数按照参数表顺序继续排列。（this也相当于一个变量），<font color="red"><strong>即非static方法，this将会被放在index0处</strong></font></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0014.png"></p><p><strong>Slot代码示例</strong></p><p><strong>this 存放在 index &#x3D; 0 的位置：</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>局部变量表：this 存放在 index &#x3D; 0 的位置</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0015.png"></p><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">      dateP = <span class="literal">null</span>;</span><br><span class="line">      name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">      <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> dateP + name2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0016.png"></p><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经出了作用域的变量b占据的slot的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量 c 重用了局部变量 b 的 slot 位置</p><p><strong>举例：静态变量与局部变量的对比</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line"><span class="number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line"><span class="number">2</span>、按照在类中声明的位置分：</span><br><span class="line">  <span class="number">2</span>-<span class="number">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  <span class="number">2</span>-<span class="number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道<font color="cornflowerblue">类变量</font>有两次初始化的机会<strong>，</strong>第一次是在“<font color="red">准备阶段</font>”，执行系统初始化，对类变量设置零值，另一次则是在“<font color="red">初始化</font>”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了<font color="red">局部变量则必须人为的初始化</font>，否则无法使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i;<span class="comment">//报错，因为局部变量必须显式赋值</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li><p>在栈帧中，<font color="cornflowerblue">与性能调优关系最为密切的部分就是前面提到的局部变量表</font>。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收<font color="cornflowerblue">根节点</font>，<font color="red">只要被局部变量表中直接或间接引用的对象都不会被回收</font>。</p></li></ol><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个<font color="red">后进先出</font>（Last - In - First -Out）的 操作数栈，也可以称之为**<font color="red">表达式栈</font>**（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p></li></ol><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0018.png"></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0019.png"></p><h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ol><li><p>操作数栈，**<font color="red">主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</font>**。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的<font color="red">最大深度在编译期就定义好了</font>，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈<font color="red">并非采用访问索引的方式来进行数据访问的</font>，而是只能通过标准的入栈和出栈操作来完成一次数据访问。</p></li><li><p><font color="red">如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</font>，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ol><h3 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">       <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0021.png"></p><p><strong>一步一步看流程</strong></p><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0022.png"></p><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><ul><li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0023.png"></p><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0024.png"></p><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0025.png"></p><p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0026.png"></p><p><strong>小问题</strong></p><p><strong>关于类型转换的说明</strong></p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0027.png"></p><ul><li>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li><li>但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0028.png"></p><ul><li>m改成800之后，byte存储不了，就成了short型，sipush 800</li></ul><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + n;</span><br><span class="line">      <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0029.png"></p><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0030.png"></p><h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</p></li><li><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p></li><li><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p></li></ol><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li><p>每一个栈帧内部都包含**<font color="red">一个指向运行时常量池中该栈帧所属方法的引用</font><strong>。包含这个引用的目的就是</strong>为了支持当前方法的代码能够实现<font color="red">动态链接</font>**（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**<font color="red">动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</font>**</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/image-20230711214051104.png" alt="image-20230711214051104"></p><p><strong>为什么要用常量池呢？</strong></p><ol><li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p></li><li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ol><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的<font color="cornflowerblue">目标方法在编译期确定，且运行期保持不变时</font>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果<font color="cornflowerblue">被调用的方法在编译期无法被确定下</font>来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。（<font color="red">如多态的使用和lamda表达式</font>）</p><h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在<font color="cornflowerblue">编译期可知，且运行期保持不变时</font>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法<font color="cornflowerblue">在编译期无法被确定下来</font>，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span> &#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部分字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokevirtual #<span class="number">2</span>                  <span class="comment">// Method com/atguigu/java2/Animal.eat:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokeinterface #<span class="number">3</span>,  <span class="number">1</span>            <span class="comment">// InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure><p>invokevirtual 体现为晚期绑定</p><p>invokeinterface 也体现为晚期绑定</p><p>invokespecial 体现为早期绑定</p><h3 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h3><p><strong>虚方法与非虚方法的区别</strong></p><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li><font color="red">静态方法、私有方法、final方法、实例构造器、父类方法</font>都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本             <font color="cornflowerblue">1和2是非虚方法</font></init></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法            <font color="cornflowerblue"> 3和4除final修饰的方法，都是虚方法</font></li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行            <font color="cornflowerblue">虚方法</font></p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。<font color="red">其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</font></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MethodInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son 类中 show() 方法的字节码指令如下</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0032.png"></p><p><strong>关于 invokedynamic 指令</strong></p><ol><li><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是<font color="red">Java为了实现【动态类型语言】支持而做的一种改进</font>。</p></li><li><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到<font color="red">Java8的Lambda表达式的出现，invokedynamic指令的生成</font>，在Java中才有了直接的生成方式。</p></li><li><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态语言和静态语言</strong></p><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></li></ol><p>Java：String info &#x3D; “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)<br>    JS：var name &#x3D; “shkstart”;    var name &#x3D; 10;（运行时才进行检查）</p><pre><code>Python: info = 130.5 (运行时才检查)</code></pre><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li><p>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<font color="cornflowerblue">为了提高性能</font>，<strong>JVM采用在类的<font color="red">方法区建立一个虚方法表</font>（virtual method table）来实现</strong>，<font color="red">非虚方法不会出现在表中</font>。<font color="red">使用索引表来代替查找</font>。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></li><li><p><font color="cornflowerblue">每个类中都有一个虚方法表</font>，表中存放着各个方法的实际入口。</p></li><li><p>虚方法表是什么时候被创建的呢？虚方法表会在<font color="cornflowerblue">类加载的链接阶段被创建并开始初始化</font>，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。（<font color="cornflowerblue">类的准备阶段完成后成表</font>）</p></li></ol><p><strong>例子</strong></p><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0034.png"></p><p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p><p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0039.png"></p><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p></blockquote><ol><li><p>存放<font color="red">调用该方法的pc寄存器的值</font>。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**<font color="red">调用者（即外层方法）的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</font>**。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前<font color="cornflowerblue">栈帧出栈</font>的过程。此时，需要<font color="red">恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值</font>等，让<strong>调用者方法继续执行下去</strong>。</p></li><li><p>正常完成出口和异常完成出口的区别在于：<font color="red">通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</font></p></li></ol><p><strong>方法退出的两种方式</strong></p><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><p><strong>正常退出：</strong></p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ol><p><strong>异常退出：</strong></p><ol><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p></li><li><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p></li></ol><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0040.png"></p><p>异常处理表：</p><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul><p><img src="https://www.hahhome.top/blog/JVMRuntimeDataArea1/../../image/JVMRuntimeDataArea1.assets/0041.png"></p><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a>栈相关面试题</h2><p><strong>举例栈溢出的情况？</strong></p><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><p><strong>调整栈大小，就能保证不出现溢出么？</strong></p><p>不能保证不溢出，只能保证SOF出现的几率小</p><p><strong>分配的栈内存越大越好么？</strong></p><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><p><strong>垃圾回收是否涉及到虚拟机栈？</strong></p><p>不会</p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF、OOM</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><p><strong>方法中定义的局部变量是否线程安全？</strong></p><p>具体问题具体分析</p><ol><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：方法内部是线程安全的，外部是不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><ol><li>简单地讲，**<font color="cornflowerblue">一个Native Method是一个Java调用非Java代码的接囗</font>**一个Native Method是这样一个Java方法：</li><li><font color="cornflowerblue">该方法的实现由非Java语言实现</font>，比如<font color="cornflowerblue"><strong>C</strong></font>。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义<font color="cornflowerblue">一个native method时，并不提供实现体（不提供并非没有）</font>（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的<font color="cornflowerblue">初衷是融合C&#x2F;C++程序</font>。</li></ol><p><strong>举例</strong></p><p>需要注意的是：<font color="red">标识符native可以与其它java标识符连用，但是abstract除外</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">Native2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">Native3</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要使用 Native Method？</strong></p><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li><strong>与Java环境外交互</strong></li></ul><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><ul><li><strong>与操作系统的交互</strong></li></ul><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><ul><li><strong>Sun’s Java</strong></li></ul><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol><p><strong>本地方法的现状</strong></p><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><ol><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li><font color="red">本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</font></li><li><font color="red">它甚至可以直苦使处理器中的寄存器</font></li><li><font color="red">直接从本地内存的堆中分配任意数量的内存。</font></li><li><font color="cornflowerblue">本地方法栈通过本地方法接口访问运行时数据区</font></li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中支持，并且直接将木地方法栈和虚拟机栈合二为一。</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，<strong>也是线程私有的</strong>。</li><li>允许被实现成<strong>固定</strong>或者是可<strong>动态扩展</strong>的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><p>PC Register没有GC和OOM</p><p>Java栈没有GC，有OOM</p><p>本地方法栈没有GC，有OOM</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/hello-world/"/>
      <url>/blog/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
