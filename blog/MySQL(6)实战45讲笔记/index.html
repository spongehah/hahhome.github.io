<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>MySQL(6)实战45讲笔记 | HahHome</title><meta name="author" content="spongehah"><meta name="copyright" content="spongehah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL实战45讲 主要参考：  MySQL实战45讲	作者：林晓斌（丁奇） 极客时间：https:&#x2F;&#x2F;time.geekbang.org&#x2F;column&#x2F;intro&#x2F;100020801 参考资源：https:&#x2F;&#x2F;funnylog.gitee.io&#x2F;mysql45&#x2F;   01 讲基础架构：一条SQL查询语句是如何执行的  第一步：连接器连接sleep1show processlist  连接完成后"><meta property="og:type" content="article"><meta property="og:title" content="MySQL(6)实战45讲笔记"><meta property="og:url" content="https://blog.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="HahHome"><meta property="og:description" content="MySQL实战45讲 主要参考：  MySQL实战45讲	作者：林晓斌（丁奇） 极客时间：https:&#x2F;&#x2F;time.geekbang.org&#x2F;column&#x2F;intro&#x2F;100020801 参考资源：https:&#x2F;&#x2F;funnylog.gitee.io&#x2F;mysql45&#x2F;   01 讲基础架构：一条SQL查询语句是如何执行的  第一步：连接器连接sleep1show processlist  连接完成后"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.hahhome.top/img/cover_default_img/07.webp"><meta property="article:published_time" content="2023-10-01T06:50:06.000Z"><meta property="article:modified_time" content="2023-10-20T08:13:17.740Z"><meta property="article:author" content="spongehah"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.hahhome.top/img/cover_default_img/07.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.hahhome.top/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MySQL(6)实战45讲笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-10-20 16:13:17"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/rightMenu.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="baidu-site-verification" content="codeva-yFYMl1Bz4G"><div id="myscoll"></div><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})</script><link rel="stylesheet" href="/css/loading-bar.css"><script src="/pluginsSrc/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover_default_img/07.webp)"><nav id="nav"><span id="blog-info"><a href="/" title="HahHome"><span class="site-name">HahHome</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL(6)实战45讲笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-01T06:50:06.000Z" title="发表于 2023-10-01 14:50:06">2023-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-20T08:13:17.740Z" title="更新于 2023-10-20 16:13:17">2023-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">140.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>449分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MySQL(6)实战45讲笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL实战45讲"><a href="#MySQL实战45讲" class="headerlink" title="MySQL实战45讲"></a>MySQL实战45讲</h1><blockquote><p>主要参考：</p><ul><li>MySQL实战45讲	作者：林晓斌（丁奇）</li><li>极客时间：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100020801">https://time.geekbang.org/column/intro/100020801</a></li><li>参考资源：<a target="_blank" rel="noopener" href="https://funnylog.gitee.io/mysql45/">https://funnylog.gitee.io/mysql45/</a></li></ul></blockquote><h1 id="01-讲基础架构：一条SQL查询语句是如何执行的"><a href="#01-讲基础架构：一条SQL查询语句是如何执行的" class="headerlink" title="01 讲基础架构：一条SQL查询语句是如何执行的"></a>01 讲基础架构：一条SQL查询语句是如何执行的</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><h3 id="连接sleep"><a href="#连接sleep" class="headerlink" title="连接sleep"></a>连接sleep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br></pre></td></tr></table></figure><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/f2da4aa3a672d48ec05df97b9f992fed.png" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数<strong>wait_timeout</strong>控制的，默认值是<strong>8小时</strong>。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>MySQL 服务支持的最大连接数由 <strong>max_connections</strong> 参数控制，比如我的 MySQL 服务默认是 <strong>151</strong> 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是<strong>尽量使用长连接</strong>。</p><p><strong>但是全部使用长连接</strong>后，你可能会发现，有些时候MySQL占用<strong>内存涨得特别快</strong>，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么<strong>解决</strong>这个问题呢？你可以考虑以下两种方案。</p><ol><li><code>定期断开长连接</code>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection来重新初始化连接资源</code>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p><strong>大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p><strong>查询缓存的命中率会非常低</strong>，并且<strong>在一个表上有更新的时候，跟这个表有关的查询缓存会失效</strong>。</p><p>除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说<strong>8.0开始彻底没有这个功能</strong>了。</p><h2 id="第三步：分析器"><a href="#第三步：分析器" class="headerlink" title="第三步：分析器"></a>第三步：分析器</h2><p>MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><ul><li>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</li></ul><p>做完了这些识别以后，就要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><ul><li><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p></li><li><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p></li></ul><h2 id="第四步：优化器"><a href="#第四步：优化器" class="headerlink" title="第四步：优化器"></a>第四步：优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p><h2 id="第五步：执行器"><a href="#第五步：执行器" class="headerlink" title="第五步：执行器"></a>第五步：执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的<strong>权限</strong>，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><p>如果<strong>有权限</strong>，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p><strong>eg：</strong></p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个<strong>rows_examined</strong>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h1 id="02-讲日志系统：一条SQL更新语句是如何执行的"><a href="#02-讲日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="02 讲日志系统：一条SQL更新语句是如何执行的"></a>02 讲日志系统：一条SQL更新语句是如何执行的</h1><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230919205345326.png" alt="image-20230919205345326"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><blockquote><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p></blockquote><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板<strong>redo log是InnoDB引擎特有的日志</strong>，而<strong>Server层也有自己的日志，称为binlog</strong>（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li><code>redo log是InnoDB引擎特有的</code>；<code>binlog是MySQL的Server层实现的</code>，所有引擎都可以使用。</li><li>redo log是<strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；binlog是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”（三种格式）。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h2 id="更新语句执行过程"><a href="#更新语句执行过程" class="headerlink" title="更新语句执行过程"></a>更新语句执行过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img" style="zoom:50%"><p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h2 id="redo-log的两阶段提交"><a href="#redo-log的两阶段提交" class="headerlink" title="redo log的两阶段提交"></a>redo log的两阶段提交</h2><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol><li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li></ol><p>可以看到，<strong>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</strong>。</p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><p>即<strong>保证主库和从库的数据一致性</strong></p><blockquote><p>redo log用于保证crash-safe能力。<strong>innodb_flush_log_at_trx_commit</strong>这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p><strong>sync_binlog</strong>这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p></blockquote><h1 id="03-讲事务隔离：为什么你改了我还看不见"><a href="#03-讲事务隔离：为什么你改了我还看不见" class="headerlink" title="03 讲事务隔离：为什么你改了我还看不见"></a>03 讲事务隔离：为什么你改了我还看不见</h1><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h2 id="长事务的坏处"><a href="#长事务的坏处" class="headerlink" title="长事务的坏处"></a>长事务的坏处</h2><p><strong>总结：</strong></p><p>1、务的特性：原子性、一致性、隔离性、持久性<br>2、多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读<br>3、事务隔离级别：读未提交、读提交、可重复读、串行化<br>4、不同事务隔离级别的区别：<br>读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到<br>读提交：一个事务提交之后，它所做的变更才可以被别的事务看到<br>可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的<br>串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</p><p>5、配置方法：启动参数transaction-isolation<br>6、事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。</p><p>7、回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。<br>8、什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。</p><p>9、为什么<strong>尽量不要使用长事务</strong>。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</p><p>10、事务启动方式：一、显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；二、set autocommit&#x3D;0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。<br>11、建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit&#x3D;1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。</p><p>可以在information_schema库的innodb_trx这个表中<strong>查询长事务</strong>，比如下面这个语句，用于查找持续时间超过60s的事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure><h1 id="04-讲深入浅出索引-上"><a href="#04-讲深入浅出索引-上" class="headerlink" title="04 讲深入浅出索引(上)"></a>04 讲深入浅出索引(上)</h1><p><strong>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</strong></p><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p><p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/0c62b601afda86fe5d0fe57346ace957.png" alt="img"></p><p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以<strong>哈希索引做区间查询(范围查询)的速度是很慢的</strong>。</p><p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p><p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p><h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230920194507068.png" alt="image-20230920194507068"></p><p>这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个**时间复杂度是O(log(N))**。</p><p>这个索引结构<strong>支持范围查询</strong>。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要<strong>更新数据</strong>的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，<strong>成本太高</strong>。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/04fb9d24065635a6a637c25ba9ddde68.png" alt="img"></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个**时间复杂度是O(log(N))**。</p><p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p><p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，<strong>这个查询可真够慢的</strong>。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p><p><strong>N叉树</strong>由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230920195036279.png" alt="image-20230920195036279"></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，<strong>我们在应用中应该尽量使用主键查询</strong>。</p><p>当不使用有序索引时，插入可能造成<strong>页分裂</strong>，严重影响数据库性能</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p><strong>总结：</strong></p><p>1.索引的作用：提高数据查询效率<br>2.常见索引模型：哈希表、有序数组、搜索树</p><p>3.哈希表：键 - 值(key - value)。<br>4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置<br>5.哈希冲突的处理办法：链表<br>6.哈希表适用场景：只有等值查询的场景</p><p>7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))<br>8.有序数组查询效率高，更新效率低<br>9.有序数组的适用场景：静态存储引擎。</p><p>10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子<br>11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))<br>12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树</p><p>13.InnoDB中的索引模型：B+Tree<br>14.索引类型：主键索引、非主键索引<br>主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)<br>15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)</p><p>16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。<br>17.从性能和存储空间方面考量，自增主键往往是更合理的选择</p><h1 id="05-讲深入浅出索引-下"><a href="#05-讲深入浅出索引-下" class="headerlink" title="05 讲深入浅出索引(下)"></a>05 讲深入浅出索引(下)</h1><h2 id="回表过程"><a href="#回表过程" class="headerlink" title="回表过程"></a>回表过程</h2><p>在下面这个表T中，如果我执行 <strong>select * from T where k between 3 and 5</strong>，需要执行几次树的搜索操作，会扫描多少行？</p><p>下面是这个表的初始化语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230921102234370.png" alt="image-20230921102234370"></p><p>现在，我们一起来看看这条SQL查询语句的执行流程：</p><ol><li>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</li><li>再到ID索引树查到ID&#x3D;300对应的R3；</li><li>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</li><li>再回到ID索引树查到ID&#x3D;500对应的R4；</li><li>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</li></ol><p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p><p>有没有可能经过索引优化，避免回表过程呢？</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果执行的语句是select <strong>ID</strong> from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><p>需要注意的是，在<strong>引擎内部</strong>使用覆盖索引在索引k上其实读了<strong>三个记录</strong>，R3~R5（对应的索引k上的记录项），但是对于MySQL的<strong>Server层</strong>来说，它就是找引擎拿到了<strong>两条记录</strong>，因此MySQL认为扫描行数是2。</p><h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p><strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p><strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><p>第二要<strong>考虑的原则就是空间</strong>了。比如name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p><p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p><p>然后呢？</p><p>当然是判断其他条件是否满足。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而MySQL 5.6 引入<strong>的索引下推优化</strong>（index condition pushdown)， 可以<strong>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><p>索引下推是使用联合索引时，若是后面的索引失效，就可以使用索引下推</p><p><strong>总结：</strong><br>回表：回到主键索引树搜索的过程，称为回表<br>覆盖索引：某索引已经覆盖了查询需求，称为覆盖索引，例如：select ID from T where k between 3 and 5<br>在引擎内部使用覆盖索引在索引K上其实读了三个记录，R3~R5(对应的索引k上的记录项)，但对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2</p><p>最左前缀原则：B+Tree这种索引结构，可以利用索引的”最左前缀”来定位记录<br>只要满足最左前缀，就可以利用索引来加速检索。<br>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符<br>第一原则是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p><p>索引下推：在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段值。<br>MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h1 id="06-讲全局锁和表锁：给表加个字段怎么有这么多阻碍"><a href="#06-讲全局锁和表锁：给表加个字段怎么有这么多阻碍" class="headerlink" title="06 讲全局锁和表锁：给表加个字段怎么有这么多阻碍"></a>06 讲全局锁和表锁：给表加个字段怎么有这么多阻碍</h1><p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都select出来存成文本。</p><p>但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li></ul><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？<strong>一致性读是好，但前提是引擎要支持这个隔离级别。</strong>比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。</p><p>所以，<strong>single-transaction方法只适用于所有的表使用事务引擎的库。</strong>如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。</p><p>你也许会问，<strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p><ul><li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><blockquote><p>我认为还有一个原因：修改global属性后，已有的session不会更改</p></blockquote><p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p><strong>表锁的语法是 lock tables … read&#x2F;write。</strong></p><p><strong>另一类表级的锁是MDL（metadata lock)。</strong>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230921112908550.png" alt="image-20230921112908550"></p><p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</p><p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被<strong>阻塞</strong>。</p><p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p><strong>解决方法：</strong></p><p>比较理想的机制是，<strong>在alter table语句里面设定等待时间</strong>，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p><p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT&#x2F;WAIT n这个语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>根据加锁范围：MySQL里面的锁可以分为：全局锁、表级锁、行级锁</p><p>一、全局锁：<br>对整个数据库实例加锁。<br>MySQL提供加全局读锁的方法：Flush tables with read lock(FTWRL)<br>这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会被阻塞。<br>使用场景：全库逻辑备份。<br>风险：<br>1.如果在主库备份，在备份期间不能更新，业务停摆<br>2.如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟</p><p>官方自带的逻辑备份工具mysqldump，当mysqldump使用参数–single-transaction的时候，会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>一致性读是好，但是前提是引擎要支持这个隔离级别。<br>如果要全库只读，为什么不使用set global readonly&#x3D;true的方式？<br>1.在有些系统中，readonly的值会被用来做其他逻辑，比如判断主备库。所以修改global变量的方式影响太大。<br>2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</p><p>二、表级锁<br>MySQL里面表级锁有两种，一种是表锁，一种是元数据锁(meta data lock,MDL)<br>表锁的语法是:lock tables … read&#x2F;write<br>可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。<br>对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><p>MDL：不需要显式使用，在访问一个表的时候会被自动加上。<br>MDL的作用：保证读写的正确性。<br>在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。<br>读锁之间不互斥。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。<br>MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p><h1 id="07-讲行锁功过：怎么减少行锁对性能的影响"><a href="#07-讲行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="07 讲行锁功过：怎么减少行锁对性能的影响"></a>07 讲行锁功过：怎么减少行锁对性能的影响</h1><p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<strong>InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一</strong>。</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，<font color="red">如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</font>。</p><blockquote><p>eg：</p><p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p><ol><li>从顾客A账户余额中扣除电影票价；</li><li>给影院B的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p><p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，<strong>提升了并发度</strong>。</p></blockquote><h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。这是什么原因呢？</p><p>这里，我就要说到<strong>死锁</strong>和<strong>死锁检测</strong>了。</p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230922131553223.png" alt="image-20230922131553223"></p><p>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>在InnoDB中，<strong>innodb_lock_wait_timeout的默认值是50s</strong>，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是<strong>无法接受</strong>的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现<strong>很多误伤</strong>。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且<strong>innodb_deadlock_detect</strong>的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有<strong>额外负担</strong>的。</p><p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是<strong>O(n)<strong>的操作。假设有</strong>1000</strong>个并发线程要同时更新同一行，那么死锁检测操作就是<strong>100万</strong>这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到<strong>CPU利用率很高，但是每秒却执行不了几个事务</strong>。</p><h2 id="怎么解决由热点行更新导致的性能问题？"><a href="#怎么解决由热点行更新导致的性能问题？" class="headerlink" title="怎么解决由热点行更新导致的性能问题？"></a>怎么解决由热点行更新导致的性能问题？</h2><p><font color="red">怎么解决由这种热点行更新导致的性能问题呢？</font></p><ul><li><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是<strong>业务有损</strong>的。</li><li><strong>另一个思路是控制并发度。</strong>根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。</li></ul><p>因此，这个<strong>并发控制要做在数据库服务端</strong>。如果你有<strong>中间件</strong>，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</p><p>可能你会问，<strong>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</strong></p><p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，<strong>影院的账户总额等于这10个记录的值的总和</strong>。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的<strong>1&#x2F;10</strong>，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p><p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。</p><p><strong>总结：</strong></p><p>两阶段锁：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放， 而是要等到事务结束时才释放。<br>建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>死锁：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态。</p><p>解决方案：<br>1、通过参数 innodb_lock_wait_timeout 根据实际业务场景来设置超时时间，InnoDB引擎默认值是50s。<br>2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状态）。</p><p>如何解决热点行更新导致的性能问题？<br>1、如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用<br>2、控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。<br>3、将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。</p><p><strong>innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</strong></p><h1 id="08-讲事务到底是隔离的还是不隔离的"><a href="#08-讲事务到底是隔离的还是不隔离的" class="headerlink" title="08 讲事务到底是隔离的还是不隔离的"></a>08 讲事务到底是隔离的还是不隔离的</h1><h2 id="read-view的生成以及当前读"><a href="#read-view的生成以及当前读" class="headerlink" title="read view的生成以及当前读"></a>read view的生成以及当前读</h2><p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/823acf76e53c0bdba7beab45e72e90d6.png" alt="img"></p><p>图1 事务A、B、C的执行流程</p><blockquote><p>这里，我们需要注意的是事务的启动时机。</p><p><strong>begin&#x2F;start transaction</strong> 命令并不是一个事务的起点，在执行到它们之后的<strong>第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动</strong>。如果你想要<strong>马上启动一个事务</strong>，可以使用<strong>start transaction with consistent snapshot</strong> 这个命令。</p><p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是<strong>默认autocommit&#x3D;1</strong>。</p></blockquote><p>在这个例子中，事务C没有显式地使用begin&#x2F;commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p><p>这时，如果我告诉你<strong>事务B查到的k的值是3</strong>，而<strong>事务A查到的k的值是1</strong>，你是不是感觉有点晕呢？</p><h3 id="read-view原理"><a href="#read-view原理" class="headerlink" title="read view原理"></a>read view原理</h3><p>InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p><ul><li>数组里面事务ID的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务ID的最大值加1记为<strong>高水位</strong>。</li><li>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</li><li>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</li><li>这个视图数组把所有的row trx_id 分成了几种不同的情况。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230922142150072.png" alt="image-20230922142150072"></p><p><strong>read view规则：</strong></p><p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p><ol><li>如果落在<strong>绿色部分</strong>，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在<strong>红色部分</strong>，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在<strong>黄色部分</strong>，那就包括两种情况<br>a. 若 row trx_id<strong>在</strong>数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id<strong>不在</strong>数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><p><strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p>所以上面那道例题的分析如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230922142355909.png" alt="image-20230922142355909"></p><p>现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p><ul><li>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>细心的同学可能有疑问了：<strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p><p>你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p><blockquote><p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p><p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p><p>这里我们提到了一个概念，叫作当前读。其实，<strong>除了update语句外，select语句如果加锁，也是当前读。</strong></p></blockquote><p>READ VIEW分为快照读和当前读，**<font color="red">修改删除插入操作和加锁的select操作都属于当前读</font>**</p><p><strong>总结：</strong></p><p>1.innodb支持RC和RR隔离级别实现是用的一致性视图(consistent read view)</p><p>2.事务在启动时会拍一个快照,这个快照是基于整个库的.<br>基于整个库的意思就是说一个事务内,整个库的修改对于该事务都是不可见的(对于快照读的情况)</p><p>3.事务是如何实现的MVCC呢?<br>(1)每个事务都有一个事务ID,叫做transaction id(严格递增)<br>(2)事务在启动时,找到已提交的最大事务ID记为up_limit_id。<br>(3)事务在更新一条语句时,比如id&#x3D;1改为了id&#x3D;2.会把id&#x3D;1和该行之前的row trx_id写到undo log里,<br>并且在数据页上把id的值改为2,并且把修改这条语句的transaction id记在该行行头<br>(4)再定一个规矩,一个事务要查看一条数据时,必须先用该事务的up_limit_id与该行的transaction id做比对,<br>如果up_limit_id&gt;&#x3D;transaction id,那么可以看.如果up_limit_id&lt;transaction id,则只能去undo log里去取。去undo log查找数据的时候,也需要做比对,必须up_limit_id&gt;transaction id,才返回数据</p><p>4.什么是当前读,由于当前读都是<strong>先读后写</strong>,只能读当前的值,所以为当前读会更新事务内的up_limit_id为该事务的transaction id</p><p>5.为什么rr能实现可重复读而rc不能,分两种情况<br>(1)快照读的情况下,rr不能更新事务内的up_limit_id,<br>而rc每次会把up_limit_id更新为快照读之前最新已提交事务的transaction id,则rc不能可重复读<br>(2)当前读的情况下,rr是利用record lock+gap lock来实现的,而rc没有gap,所以rc不能可重复读</p><h1 id="09-讲普通索引和唯一索引，应该怎么选择"><a href="#09-讲普通索引和唯一索引，应该怎么选择" class="headerlink" title="09 讲普通索引和唯一索引，应该怎么选择"></a>09 讲普通索引和唯一索引，应该怎么选择</h1><p>在不同的业务场景下，应该选择普通索引，还是唯一索引？</p><p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from CUser where id_card = &#x27;xxxxxxxyyyyyyzzzzz&#x27;;</span><br></pre></td></tr></table></figure><p>所以，你一定会考虑在id_card字段上建索引。</p><p>由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p><p>现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p><h2 id="查询过程的区别"><a href="#查询过程的区别" class="headerlink" title="查询过程的区别"></a>查询过程的区别</h2><p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是，<strong>微乎其微</strong>。</p><h2 id="更新过程的区别"><a href="#更新过程的区别" class="headerlink" title="更新过程的区别"></a>更新过程的区别</h2><h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change buffer。</p><p>当需要<strong>更新一个数据页</strong>时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些<strong>更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页</strong>了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。</p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了<strong>访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中</strong>，也会执行merge操作。</p><p>显然，如果能够将更新操作先记录在change buffer，<strong>减少读磁盘</strong>，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>那么，<strong>什么条件下可以使用change buffer呢？</strong></p><ul><li>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要<strong>将数据页读入内存才能判断</strong>。如果都已经读入到内存了，那<strong>直接更新内存</strong>会更快，就没必要使用change buffer了。</li><li>因此，唯一索引的更新就不能使用change buffer，实际上也只有<strong>普通索引</strong>可以使用。</li></ul><p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数<strong>innodb_change_buffer_max_size</strong>来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><h3 id="更新区别"><a href="#更新区别" class="headerlink" title="更新区别"></a>更新区别</h3><p>现在，你已经理解了change buffer的机制，那么我们再一起来看看<strong>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的。</strong></p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p><p>但，这不是我们关注的重点。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及<strong>随机IO的访问，是数据库里面成本最高的操作之一</strong>。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p>之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p><h2 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h2><p>使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p><p>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，<strong>change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大</strong>。</p><ul><li>因此，对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时<strong>change buffer的使用效果最好</strong>。这种业务模型常见的就是账单类、日志类的系统。</li><li>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，<strong>反而增加了change buffer的维护代价</strong>。所以，对于这种业务模式来说，change buffer反而起到了副作用。</li></ul><p>这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我<strong>建议你尽量选择普通索引</strong>。</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p>使用普通索引：</p><ol><li>业务代码已经保证不会写入重复数据</li><li>归档库：归档数据已经是确保没有唯一键冲突了，要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。</li></ol><h2 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h2><p>现在，我们要在表上执行这个插入语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图所示是带change buffer的更新状态图。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20230924140201162.png" alt="image-20230924140201162" style="zoom:50%"><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>比如，我们现在要执行 select * from t where k in (k1, k2)。这里，我画了这两个读请求的流程图。</p><p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230924140252534.png" alt="image-20230924140252534"></p><p>从图中可以看到：</p><ol><li>读Page 1的时候，<strong>直接从内存返回</strong>。有几位同学在前面文章的评论中问到，WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li><li>要读Page 2的时候，需要把Page 2从磁盘<strong>读入内存中，然后应用change buffer里面的操作日志</strong>，生成一个正确的版本并返回结果。</li></ol><p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，</p><ul><li><strong>redo log 主要节省的是<code>随机写</code>磁盘的IO消耗（转成顺序写）</strong></li><li><strong>而change buffer主要节省的则是<code>随机读</code>磁盘的IO消耗。</strong></li></ul><blockquote><p>注意：这里change buffer是针对<strong>insert</strong>操作的页更新，针对非唯一索引和唯一索引的<strong>update</strong>和<strong>delete</strong>而且条件是where 索引值&#x3D;这种情况，会采用锁定读，这时候要“<strong>先读后写</strong>”，读的时候数据会读入内存，更新的时候直接改内存，就<strong>不需要change buffer</strong>了</p></blockquote><h2 id="总结与问题"><a href="#总结与问题" class="headerlink" title="总结与问题"></a>总结与问题</h2><p>选择普通索引还是唯一索引？<br>对于查询过程来说：<br>a、普通索引，查到满足条件的第一个记录后，继续查找下一个记录，知道第一个不满足条件的记录<br>b、唯一索引，由于索引唯一性，查到第一个满足条件的记录后，停止检索<br>但是，两者的性能差距微乎其微。因为InnoDB根据数据页来读写的。<br>对于更新过程来说：<br>概念：change buffer<br>当需要更新一个数据页，如果数据页在内存中就直接更新，如果不在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中。下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中的与这个页有关的操作。</p><p>change buffer是可以持久化的数据。在内存中有拷贝，也会被写入到磁盘上</p><p>purge:将change buffer中的操作应用到原数据页上，得到最新结果的过程，成为merge<br>访问这个数据页会触发merge，系统有后台线程定期merge，在数据库正常关闭的过程中，也会执行merge</p><p>唯一索引的更新不能使用change buffer</p><p>change buffer用的是buffer pool里的内存，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。<br>change buffer 因为减少了随机磁盘访问，所以对更新性能的提升很明显。</p><p>change buffer使用场景<br>在一个数据页做purge之前，change buffer记录的变更越多，收益就越大。<br>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer,但之后由于马上要访问这个数据页，会立即触发purge过程。<br>这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p><p>索引的选择和实践：<br>尽可能使用普通索引。<br>redo log主要节省的是随机写磁盘的IO消耗(转成顺序写)，而change buffer主要节省的则是随机读磁盘的IO消耗。</p><p>思考题：<br>change buffer不会丢失，因为change buffer是可以持久化的数据，在磁盘上占据了系统表空间ibdata，对应的内部系统表名为SYS_IBUF_TABLE，并且changebuffer的变更也会写入到redo log，因此在异常关机的时候，不会丢失。</p><h1 id="10-讲MySQL为什么有时候会选错索引"><a href="#10-讲MySQL为什么有时候会选错索引" class="headerlink" title="10 讲MySQL为什么有时候会选错索引"></a>10 讲MySQL为什么有时候会选错索引</h1><h2 id="MySQL选错索引举例"><a href="#MySQL选错索引举例" class="headerlink" title="MySQL选错索引举例"></a>MySQL选错索引举例</h2><p>前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。</p><p>不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索引，而导致执行速度变得很慢？</p><p>我们一起来看一个例子吧。</p><p>我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB；</span><br></pre></td></tr></table></figure><p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p><p>接下来，我们分析一条SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure><p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。</p><p>你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/2cfce769551c6eac9bfbee0563d48fe3.png" alt="img"></p><p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索引a。</p><p>不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做如下操作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/1e5ba1c2934d3b2c0d96b210a27e1a1e.png" alt="img"></p><p>这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删除后，又调用了 idata这个存储过程，插入了10万行数据。</p><p>这时候，session B的查询语句select * from t where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。</p><p>为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用force index(a)来让优化器强制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）。</p><p>下面的三条SQL语句，就是这个实验过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set long_query_time=0;</span><br><span class="line">select * from t where a between 10000 and 20000; /*Q1*/</span><br><span class="line">select * from t force index(a) where a between 10000 and 20000;/*Q2*/</span><br></pre></td></tr></table></figure><ul><li>第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</li><li>第二句，Q1是session B原来的查询；</li><li>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</li></ul><p>如图3所示是这三条SQL语句执行完成后的慢查询日志。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7c58b9c71853b8bba1a8ad5e926de1f6.png" alt="img"></p><p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间。</p><p>这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。</p><h2 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h2><p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。</p><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。</p><p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p><p>我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出问题了。</p><p>那么，问题就是：<strong>扫描行数是怎么判断的？</strong></p><p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p><p>我们可以使用show index方法，看到一个索引的基数。如图4所示，就是表t的show index 的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/16dbf8124ad529fec0066950446079d4.png" alt="img"></p><h3 id="基数统计方法"><a href="#基数统计方法" class="headerlink" title="基数统计方法"></a>基数统计方法</h3><p>那么，<strong>MySQL是怎样得到索引的基数的呢？</strong>这里，我给你简单介绍一下MySQL采样统计的方法。</p><p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p><p>采样统计的时候，InnoDB默认会选择<strong>N个数据页</strong>，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过<strong>1&#x2F;M</strong>的时候，会自动触发重新做一次索引统计。</p><p>在MySQL中，有两种存储索引统计的方式，可以通过设置参数<strong>innodb_stats_persistent</strong>的值来选择：</p><ul><li>设置为<strong>on</strong>的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。</li><li>设置为<strong>off</strong>的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。</li></ul><p>由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。</p><p>你可以从图4中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。</p><h3 id="预估扫描行数"><a href="#预估扫描行数" class="headerlink" title="预估扫描行数"></a>预估扫描行数</h3><p>其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。</p><p>接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/e2bc5f120858391d4accff05573e1289.png" alt="img"></p><p>图5 意外的explain结果</p><p>rows这个字段表示的是预计扫描行数。</p><p>其中，Q1的结果还是符合预期的，rows的值是104620；<strong>但是Q2的rows值是37116，偏差就大了</strong>。而图1中我们用explain命令看到的rows是只有10001行，<strong>是这个偏差误导了优化器的判断</strong>。</p><p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢？</p><p>这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。</p><p>而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。</p><p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p><p>使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，但图1的选择是对的。也就是说，这个策略并没有问题。</p><p>所以冤有头债有主，MySQL选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。</p><blockquote><p><strong>为什么会得到错误的扫描行数？</strong></p><p>1.为什么没有session A,session B扫描的行数是1W<br>由于mysql是使用标记删除来删除记录的,并不从索引和数据文件中真正的删除。<br>如果delete和insert中间的间隔相对较小,purge线程还没有来得及清理该记录。<br>如果主键相同的情况下,<strong>新插入的insert会沿用之前删除的delete的记录的空间</strong>。<br>由于相同的数据量以及表大小,所以导致了统计信息没有变化<br>2.为什么开启了session A,session B扫描行数变成3W<br>由于session A开启了一致性读,目的为了保证session A的可重复读,insert只能<br>另起炉灶,<strong>不能占用delete的空间</strong>。所以出现的情况就是delete虽然删除了,但是<br>未释放空间,insert又增加了空间。导致统计信息有误</p><p>delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来的10万行。</p><p>但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数据。</p><p>这样，索引a上的数据其实就有两份。</p><p>然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令看到的扫描行数为什么还是100000左右？（潜台词，如果这个也翻倍，也许优化器还会认为选字段a作为索引更合适）</p><p>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是show table status的值。</p></blockquote><h3 id="修正统计信息"><a href="#修正统计信息" class="headerlink" title="修正统计信息"></a>修正统计信息</h3><p>既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。我们来看一下执行效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/209e9d3514688a3bcabbb75e54e1e49c.png" alt="img"></p><p>图6 执行analyze table t 命令恢复的explain结果</p><p>这回对了。</p><p>所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法来处理。</p><p>其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优化器可不止是看扫描行数。</p><h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><p>依然是基于这个表t，我们看看另外一个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;</span><br></pre></td></tr></table></figure><p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。</p><p>在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？</p><p>为了便于分析，我们先来看一下a、b这两个索引的结构图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230924143943300.png" alt="image-20230924143943300"></p><p>图7 a、b索引的结构图</p><p>如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。</p><p>如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描50001行。</p><p>所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底是不是这么一回事儿。</p><p>图8是执行explain的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/483bcb1ef3bb902844e80d9cbdd73ab8.png" alt="img"></p><p>图8 使用explain方法查看执行计划 2</p><p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行数是50198。</p><p>从这个结果中，你可以得到两个结论：</p><ol><li>扫描行数的估计值依然不准确；</li><li>这个例子里MySQL又选错了索引。</li></ol><h2 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h2><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p><p><strong>一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。</strong>MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p><p>我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行效果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9582401a6bed6cb8fd803c9555750b54.png" alt="img"></p><p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化器的选择快了40多倍。</p><p>也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。</p><p>不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。</p><p>但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。</p><p>所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？</p><p>既然优化器放弃了使用索引a，说明a还不够合适，所以<strong>第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。</strong>比如，在这个例子里，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p>我们来看看改之后的效果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/14cd598e52a2b72dd334a42603e5b894.png" alt="img"></p><p>图10 order by b,a limit 1 执行结果</p><p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。</p><p>现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。</p><p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才可以这么做。</p><p>如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from  (select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 100)alias limit 1;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/b1a2ad43c78477d7f93dbc692cbaa0d7.png" alt="img"></p><p>图11 改写SQL的explain</p><p>在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数据特征诱导了一下优化器，也不具备通用性。</p><p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p><p>不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。</p><p>如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子，最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</p><h1 id="11-讲怎么给字符串字段加索引"><a href="#11-讲怎么给字符串字段加索引" class="headerlink" title="11 讲怎么给字符串字段加索引"></a>11 讲怎么给字符串字段加索引</h1><h2 id="字符串前缀索引"><a href="#字符串前缀索引" class="headerlink" title="字符串前缀索引"></a>字符串前缀索引</h2><p>现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天要讨论的问题。</p><p>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table SUser(</span><br><span class="line">ID bigint unsigned primary key,</span><br><span class="line">email varchar(64), </span><br><span class="line">... </span><br><span class="line">)engine=innodb; </span><br></pre></td></tr></table></figure><p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select f1, f2 from SUser where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure><p>从第4和第5篇讲解索引的文章中，我们可以知道，如果email这个字段上没有索引，那么这个语句就只能做全表扫描。</p><p>同时，MySQL是支持前缀索引的，也就是说，你可以<strong>定义字符串的一部分作为索引</strong>。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><p>比如，这两个在email字段上创建索引的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure><p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。</p><p>那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引的示意图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230925162512042.png" alt="image-20230925162512042"></p><p>从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以<strong>占用的空间会更小</strong>，这就是使用前缀索引的优势。</p><blockquote><p>执行时：使用前缀索引会一直回表进行判断，<strong>增加了回表次数</strong>，在此例中，要回主键索引取4次数据，也就是扫描了4行。</p><p>而使用完全索引只用扫描一行</p><p>通过这个对比，你很容易就可以发现，<strong>使用前缀索引后，可能会导致查询语句读数据的次数变多</strong>。</p></blockquote><p>但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了。</p><p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><h2 id="怎么定义好前缀索引"><a href="#怎么定义好前缀索引" class="headerlink" title="怎么定义好前缀索引"></a>怎么定义好前缀索引</h2><p>于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p><p>实际上，我们在建立索引时关注的是区分度，<strong>区分度越高越好</strong>。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br></pre></td></tr></table></figure><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure><p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。</p><h2 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h2><p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。</p><p>你先来看看这个SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure><p>与前面例子中的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure><p>相比，这个语句只要求返回id和email字段。</p><p>所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p><p>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><blockquote><p>使用前缀索引，就算包含了要查询的所有字段，也都会回表，<strong>不能使用覆盖索引</strong></p></blockquote><h2 id="定义字符串索引的其他方式"><a href="#定义字符串索引的其他方式" class="headerlink" title="定义字符串索引的其他方式"></a>定义字符串索引的其他方式</h2><p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。</p><p>按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。</p><p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p><p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p><p>答案是，有的。</p><h3 id="倒序存储"><a href="#倒序存储" class="headerlink" title="倒序存储"></a>倒序存储</h3><p>如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card = reverse(&#x27;input_id_card_string&#x27;);</span><br></pre></td></tr></table></figure><p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。</p><h3 id="hash字段"><a href="#hash字段" class="headerlink" title="hash字段"></a>hash字段</h3><p>你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure><p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure><p>这样，索引的长度变成了<strong>4个字节</strong>，比原来小了很多。</p><h3 id="倒序和hash的异同"><a href="#倒序和hash的异同" class="headerlink" title="倒序和hash的异同"></a>倒序和hash的异同</h3><p>接下来，我们再一起看看<strong>使用倒序存储和使用hash字段这两种方法的异同点。</strong></p><p><strong>相同点：</strong></p><p>都<strong>不支持范围查询</strong></p><ul><li>倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash字段的方式也只能支持等值查询。</li></ul><p>它们的<strong>区别</strong>，主要体现在以下三个方面：</p><ol><li>从占用的额外空间来看，<strong>倒序</strong>存储方式在主键索引上，<strong>不会消耗额外的存储空间</strong>，而<strong>hash</strong>字段方法<strong>需要增加一个字段</strong>。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段的int类型也差不多抵消了。</li><li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，<strong>reverse函数额外消耗的CPU资源会更小些</strong>。</li><li>从查询效率上看，使用<strong>hash</strong>字段方式的查询性能相对<strong>更稳定一些</strong>。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ol><h1 id="12-讲为什么我的MySQL会“抖”一下"><a href="#12-讲为什么我的MySQL会“抖”一下" class="headerlink" title="12 讲为什么我的MySQL会“抖”一下"></a>12 讲为什么我的MySQL会“抖”一下</h1><p>平时的工作中，不知道你有没有遇到过这样的场景，一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</p><p>看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。</p><h2 id="为什么会突然变慢？"><a href="#为什么会突然变慢？" class="headerlink" title="为什么会突然变慢？"></a>为什么会突然变慢？</h2><p>在前面第2篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/68633">《日志系统：一条SQL更新语句是如何执行的？》</a>中，我为你介绍了WAL机制。现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写完redo log后，就返回给客户端，本次更新成功。</p><p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。</p><p>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是flush。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p><p>接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10文，这次又要赊9文。</p><p><strong>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</strong></p><h2 id="什么时候会flush"><a href="#什么时候会flush" class="headerlink" title="什么时候会flush"></a>什么时候会flush</h2><p>那么，什么情况会引发数据库的flush过程呢？</p><ul><li>第一种场景是，<strong>粉板满了，记不下了</strong>。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。<br>这个场景，对应的就是<strong>InnoDB的redo log写满了</strong>。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20230925165033023.png" alt="image-20230925165033023" style="zoom:50%"><p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图中从write pos到CP’之间就是可以再写入的redo log的区域。</p><ul><li><p>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。<br>这种场景，对应的就是<strong>系统内存不足</strong>。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。<strong>如果淘汰的是“脏页”，就要先将脏页写到磁盘</strong>。<br>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</p><ul><li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。</li></ul></li><li><p>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。<br>这种场景，对应的就是MySQL认为<strong>系统“空闲”的时候</strong>。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</p></li><li><p>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。<br>这种场景，对应的就是<strong>MySQL正常关闭的情况</strong>。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ul><h2 id="flush操作对系统性能的影响"><a href="#flush操作对系统性能的影响" class="headerlink" title="flush操作对系统性能的影响"></a>flush操作对系统性能的影响</h2><p>其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前两种场景下的性能问题。</p><p>第一种是“<strong>redo log写满了，要flush脏页</strong>”，<strong>这种情况是InnoDB要尽量避免的</strong>。因为出现这种情况的时候，整个系统就<strong>不能再接受更新</strong>了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</p><p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li></ul><p>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显<strong>影响性能</strong>的：</p><ol><li><strong>一个查询要淘汰的脏页个数太多</strong>，会导致查询的响应时间明显变长；</li><li><strong>日志写满</strong>，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li></ol><p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><h2 id="InnoDB刷脏页速度的控制策略"><a href="#InnoDB刷脏页速度的控制策略" class="headerlink" title="InnoDB刷脏页速度的控制策略"></a>InnoDB刷脏页速度的控制策略</h2><h3 id="主机IO能力"><a href="#主机IO能力" class="headerlink" title="主机IO能力"></a>主机IO能力</h3><p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。</p><p>首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</p><p>这就要用到<strong>innodb_io_capacity</strong>这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><p>其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，说MySQL的写入速度很慢，TPS很低，但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。</p><p>他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</p><p>虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按照“全力”的百分比来刷脏页。</p><blockquote><p>InnoDB的刷盘速度就是要参考这两个因素：一个是<strong>脏页比例</strong>，一个是<strong>redo log写盘速度</strong>。</p></blockquote><h3 id="脏页比例"><a href="#脏页比例" class="headerlink" title="脏页比例"></a>脏页比例</h3><p>参数<strong>innodb_max_dirty_pages_pct</strong>是**<code>脏页比例上限</code><strong>，默认值是</strong>75%<strong>。InnoDB会根据当前的</strong><code>脏页比例</code>（假设为M）**，算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：(<strong>我自己测试mysql8默认值为90%</strong>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷脏页的速度计算"><a href="#刷脏页的速度计算" class="headerlink" title="刷脏页的速度计算"></a>刷脏页的速度计算</h3><p>InnoDB每次写入的日志都有一个序号，当前<strong>写入的序号跟checkpoint对应的序号之间的<code>差值</code>，我们假设为N</strong>。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道<strong>N越大，算出来的值越大就好了</strong>。</p><blockquote><p>即checkpoint和write pos差的越远，说明空间不多了，刷的越快</p></blockquote><p>然后，<strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p><blockquote><p>R &#x3D; max(F1(M), F2(N))</p><p>刷脏页的速度 &#x3D; innodb_io_capacity * R</p></blockquote><p>当前<strong>脏页比例越高</strong>，<strong>redo log越久没merge</strong>，即越久没同步磁盘数据，当前<strong>刷脏页速度越快</strong>，**<font color="red">但都需要定义好主机IO能力innodb_io_capacity这个变量</font>**</p><p>现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</p><p>要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且**平时要多关注脏页比例，不要让它经常接近75%**。</p><p>其中，脏页比例是通过Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total得到的，具体的命令参考下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_dirty&#x27;;</span><br><span class="line">select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_total&#x27;;</span><br><span class="line">select @a/@b;</span><br></pre></td></tr></table></figure><blockquote><p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，<strong>如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉</strong>；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是<strong>对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷</strong>。</p><p>在InnoDB中，<strong>innodb_flush_neighbors</strong> 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><p>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</p><p>而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</p><p><strong>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</strong></p></blockquote><h1 id="13-讲为什么表数据删掉一半，表文件大小不变"><a href="#13-讲为什么表数据删掉一半，表文件大小不变" class="headerlink" title="13 讲为什么表数据删掉一半，表文件大小不变"></a>13 讲为什么表数据删掉一半，表文件大小不变</h1><p>经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</p><p>那么今天，我就和你聊聊数据库表的空间回收，看看如何解决这个问题。</p><p>这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。一个InnoDB表包含两部分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以我们今天主要讨论的是表数据。</p><p>接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。</p><h2 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="headerlink" title="参数innodb_file_per_table"></a>参数innodb_file_per_table</h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p><ol><li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</li></ol><p>从MySQL 5.6.6版本开始，它的默认值就是ON了。</p><p>我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>所以，<strong>将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p><p>我们在删除整个表的时候，可以使用<strong>drop table命令回收表空间</strong>。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><p>我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。</p><blockquote><p>当innodb_file_per_table为ON时，使用drop table能回收表空间</p></blockquote><p>接下来要看的是使用delete删除数据的情况：</p><h2 id="delete删除数据"><a href="#delete删除数据" class="headerlink" title="delete删除数据"></a>delete删除数据</h2><p>因为<strong>记录和数据页都可以被复用</strong></p><p>所以使用delete删除后，表空间未被回收掉，文件大小没减小</p><blockquote><p>但是，<strong>数据页的复用跟记录的复用是不同的。</strong></p><p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</p><p>而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新页的时候，page A是可以被复用的。</p></blockquote><p>进一步地，如果我们<strong>用delete命令把整个表的数据删除</strong>呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，<strong>文件不会变小</strong>。</p><p>delete命令其实只是把记录的位置，或者数据页标记为了<strong>“可复用”</strong>，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是<strong>“空洞”</strong>。</p><p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。页分裂会时页的空间利用率降低，造成空洞</p><p><strong>更新索引上的值</strong>，可以理解为删除一个旧的值，再插入一个新值。不难理解，这<strong>也是会造成空洞</strong>的。</p><p>也就是说，经过大量<strong>增删改</strong>的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p><blockquote><p>insert、delete、update都会造成空洞</p></blockquote><p>而重建表，就可以达到这样的目的。</p><h2 id="解决方法：重建表"><a href="#解决方法：重建表" class="headerlink" title="解决方法：重建表"></a>解决方法：重建表</h2><p>你可以使用alter table A engine&#x3D;InnoDB命令来重建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table A engine=InnoDB</span><br></pre></td></tr></table></figure><p>但是分为两种情况，执行的具体过程不同</p><p>分为<strong>MySQL 5.5版本之前和之后</strong></p><p>在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230926151135184.png" alt="image-20230926151135184"></p><blockquote><p>MySQL5.5之前，是采用在<strong>server层</strong>创建<strong>临时表</strong>来完成表的重建的</p><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，<strong>在整个DDL过程中，表A中不能有更新</strong>。也就是说，<strong>这个DDL不是Online的</strong>。</p></blockquote><p><strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><p>我给你简单描述一下引入了Online DDL之后，重建表的流程：</p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个<strong>日志文件（row log）</strong>中，对应的是图中state2的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li><li>用临时文件替换表A的数据文件。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230926151320804.png" alt="image-20230926151320804"></p><blockquote><p>MySQL5.6开始，是在<strong>存储引擎</strong>创建<strong>临时文件</strong>完成的，并且由于<strong>日志文件</strong>记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表A做增删改操作。这也就是<strong>Online DDL</strong>名字的来源。</p><p>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就<strong>退化成读锁</strong>了。所以可以进行表的更新</p><p>为什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。</p></blockquote><p>需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很<strong>消耗IO和CPU资源</strong>的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。</p><blockquote><p>注意：在重建表的时候，<strong>InnoDB不会把整张表占满，每个页留了1&#x2F;16给后续的更新用</strong>。也就是说，其实重建表之后<strong>不是“最”紧凑</strong>的。</p></blockquote><h2 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h2><p>MySQL5.5之前，我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。</p><p>MySQL5.5之后，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。<strong>整个DDL过程都在InnoDB内部完成</strong>。对于server层来说，没有把数据挪动到临时表，是一个<strong>“原地”操作</strong>，这就是<strong>“inplace”</strong>名称的来源。</p><p>所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p><p>答案是不能。因为，tmp_file也是要占用临时空间的。</p><p>我们重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=inplace;</span><br></pre></td></tr></table></figure><p>跟inplace对应的就是拷贝表的方式了，用法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=copy;</span><br></pre></td></tr></table></figure><p>当你使用ALGORITHM&#x3D;copy的时候，表示的是强制拷贝表，对应的流程就是MySQL5.5之前的操作过程。</p><p>但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？</p><p>其实不是的，只是在重建表这个逻辑中刚好是这样而已。</p><p>比如，如果我要给InnoDB表的一个字段加全文索引或空间索引，写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add FULLTEXT(field_name);</span><br></pre></td></tr></table></figure><p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p><p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p><ol><li>DDL过程如果是Online的，就一定是inplace的；</li><li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li></ol><blockquote><p>意思就是：MySQL5.6开始，alter语句除了添加全文索引和空间索引，都支持Online DDL</p><p><strong>不影响增删改，就是 Online；相对 Server层没有新建临时表，就是 inplace</strong></p></blockquote><ul><li>从MySQL 5.6版本开始，alter table t engine &#x3D; InnoDB（也就是recreate）默认的就是上面MySQL5.5之后的流程了；</li><li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li><li>optimize table t 等于recreate+analyze。</li></ul><h1 id="14-讲count-这么慢，我该怎么办"><a href="#14-讲count-这么慢，我该怎么办" class="headerlink" title="14 讲count(*)这么慢，我该怎么办"></a>14 讲count(*)这么慢，我该怎么办</h1><p>你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。然后你可能就想了，MySQL怎么这么笨啊，记个总数，每次要查的时候直接读出来，不就好了吗。</p><p>那么今天，我们就来聊聊count(*)语句到底是怎样实现的，以及MySQL为什么会这么实现。然后，我会再和你说说，如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎么做。</p><h2 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h2><p>你首先要明确的是，在不同的MySQL引擎中，count(*)有不同的实现方式。</p><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p><p>在前面的文章中，我们一起分析了为什么要使用InnoDB，因为不论是在事务支持、并发能力还是在数据安全方面，InnoDB都优于MyISAM。我猜你的表也一定是用了InnoDB引擎。这就是当你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。</p><p>当然，现在这个看上去笨笨的MySQL，在执行<strong>count(*)操作的时候还是做了优化</strong>的。</p><p>你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到<strong>最小的那棵树</strong>来遍历。*<em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</em></em></p><p>如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？</p><p>你可能还记得在第10篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71173">《 MySQL为什么有时候会选错索引？》</a>中我提到过，索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到40%到50%。<strong>所以，show table status命令显示的行数也不能直接使用。</strong></p><p>到这里我们小结一下：</p><ul><li>MyISAM表虽然count(*)很快，但是不支持事务；</li><li>show table status命令虽然返回很快，但是不准确；</li><li>InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><p>到底应该怎么办呢？你需要<strong>自己找一个地方</strong>，把操作记录表的行数存起来。</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？</p><p>没错，缓存系统可能会丢失更新。</p><p>当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p><p>但实际上，<strong>将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工作，这个值还是逻辑上不精确的。</strong></p><p>你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。</p><p>我们是这么定义不精确的：</p><ol><li>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</li><li>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。</li></ol><p>这两种情况，都是逻辑不一致的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230926153605478.png" alt="image-20230926153605478"></p><p>或者反过来，也是不精确的</p><p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><p>根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，<strong>如果我们把这个计数直接放到数据库里单独的一张计数表C中，又会怎么样呢？</strong></p><p>首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p><p>我们这篇文章要解决的问题，都是由于InnoDB要支持事务，从而导致InnoDB表不能把count(*)直接存起来，然后查询的时候直接返回形成的。</p><p>所谓以子之矛攻子之盾，现在我们就利用<strong>“事务”</strong>这个特性，把问题解决掉。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20230926153851388.png" alt="image-20230926153851388" style="zoom:50%"><p>我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p><p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p><h2 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h2><p>在前面文章的评论区，有同学留言问到：在select count(?) from t这样的查询语句里面，count(* )、count(主键id)、count(字段)和count(1)等不同用法的性能，有哪些差别。今天谈到了count(*)的性能问题，我就借此机会和你详细说明一下这几种用法的性能差别。</p><p>需要注意的是，下面的讨论还是<strong>基于InnoDB</strong>引擎的。</p><p>这里，首先你要弄清楚count()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p><p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p><p>至于分析性能差别的时候，你可以记住这么几个原则：</p><ol><li>server层要什么就给什么；</li><li>InnoDB只给必要的值；</li><li>现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol><p>这是什么意思呢？接下来，我们就一个个地来看看。</p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li></ol><p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p><p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是<strong>专门做了优化</strong>，不取值。count(*)肯定不是null，按行累加。会找到<strong>最小的那棵树</strong>遍历</p><p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照count(*)来处理，多么简单的优化啊。</p><p>当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且MySQL已经优化过count(*)了，你直接使用这种用法就可以了。</p><p>所以结论是：按照效率排序的话，*<em>count(字段)&lt;count(主键id)&lt;count(1)≈count(</em> )*<em>，所以我建议你，尽量使用count(</em>)。</p><blockquote><p>其实，把计数放在Redis里面，不能够保证计数和MySQL表里的数据精确一致的原因，是<strong>这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong>而把计数值也放在MySQL中，就解决了一致性视图的问题。</p><p>InnoDB引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。这也是InnoDB引擎备受青睐的原因之一。</p></blockquote><h1 id="15-讲答疑文章（一）：日志和索引相关问题"><a href="#15-讲答疑文章（一）：日志和索引相关问题" class="headerlink" title="15 讲答疑文章（一）：日志和索引相关问题"></a>15 讲答疑文章（一）：日志和索引相关问题</h1><h2 id="两阶段提交不同异常重启的现象"><a href="#两阶段提交不同异常重启的现象" class="headerlink" title="两阶段提交不同异常重启的现象"></a>两阶段提交不同异常重启的现象</h2><p>《02》</p><p><strong>在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。</strong></p><p>如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生crash，那崩溃恢复的时候MySQL会怎么处理？</p><p>我们先来看一下崩溃恢复时的判断规则。</p><ol><li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li><li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol><h4 id="追问1：MySQL怎么知道binlog是完整的"><a href="#追问1：MySQL怎么知道binlog是完整的" class="headerlink" title="追问1：MySQL怎么知道binlog是完整的?"></a>追问1：MySQL怎么知道binlog是完整的?</h4><p>回答：一个事务的binlog是有完整格式的：</p><ul><li>statement格式的binlog，最后会有<strong>COMMIT</strong>；</li><li>row格式的binlog，最后会有一个<strong>XID event</strong>。</li></ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><h4 id="追问2：redo-log-和-binlog是怎么关联起来的"><a href="#追问2：redo-log-和-binlog是怎么关联起来的" class="headerlink" title="追问2：redo log 和 binlog是怎么关联起来的?"></a>追问2：redo log 和 binlog是怎么关联起来的?</h4><p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p><ul><li>如果碰到既有prepare、又有commit的redo log，就直接提交；</li><li>如果碰到只有parepare、而没有commit的redo log，就<strong>拿着XID去binlog找对应的事务</strong>。</li></ul><h4 id="追问3：处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"><a href="#追问3：处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计" class="headerlink" title="追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?"></a>追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</h4><p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个binlog恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h4 id="追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h4><p>回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p><h4 id="追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"></a>追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</h4><p>回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？</p><p>答案是不可以。</p><p>如果说<strong>历史原因</strong>的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是MyISAM，设计之初就有没有支持崩溃恢复。</p><p>InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。</p><p>InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log好了。</p><p>而如果说<strong>实现上的原因</strong>的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流程，我画了一张示意图，这里就没有redo log了。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20230927100447599.png" alt="image-20230927100447599" style="zoom:50%"><p>这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。</p><p>如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生了crash。</p><p>重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经认为提交完成了，不会再应用一次binlog1。</p><p>但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。</p><p>也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此时，binlog里面并没有记录数据页的更新细节，是补不回来的。</p><p>你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个redo log出来。</p><p>所以，至少现在的binlog能力，还不能支持崩溃恢复。</p><h4 id="追问6：那能不能反过来，只用redo-log，不要binlog？"><a href="#追问6：那能不能反过来，只用redo-log，不要binlog？" class="headerlink" title="追问6：那能不能反过来，只用redo log，不要binlog？"></a>追问6：那能不能反过来，只用redo log，不要binlog？</h4><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。</p><p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是开着的。因为binlog有着redo log无法替代的功能。</p><p>一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。</p><p>一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。</p><p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，这些下游系统就没法输入了。</p><p>总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo log还做不到。你看，发展生态是多么重要。</p><h4 id="追问7：redo-log一般设置多大？"><a href="#追问7：redo-log一般设置多大？" class="headerlink" title="追问7：redo log一般设置多大？"></a>追问7：redo log一般设置多大？</h4><p>回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力就发挥不出来了。</p><p>所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧。</p><h4 id="追问8：正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？"><a href="#追问8：正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？" class="headerlink" title="追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？"></a>追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</h4><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。</p><p>实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由redo log更新过去”的情况。</p><ol><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</li><li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li></ol><h4 id="追问9：redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？"><a href="#追问9：redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？" class="headerlink" title="追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？"></a>追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？</h4><p>回答：这两个问题可以一起回答。</p><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t1 ...</span><br><span class="line">insert into t2 ...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><p>（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p><p>单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p><h2 id="修改一样的数据MySQL会怎样运行"><a href="#修改一样的数据MySQL会怎样运行" class="headerlink" title="修改一样的数据MySQL会怎样运行"></a>修改一样的数据MySQL会怎样运行</h2><p>这时候，表t里有唯一的一行数据(1,2)。假设，我现在要执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t set a=2 where id=1;</span><br></pre></td></tr></table></figure><p>你会看到这样的结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/367b3f299b94353f32f75ea825391170.png" alt="img"><br>结果显示，匹配(rows matched)了一行，修改(Changed)了0行。</p><p>仅从现象上看，MySQL内部在处理这个命令的时候，可以有以下三种选择：</p><ol><li>更新都是先读后写的，MySQL读出数据，发现a的值本来就是2，不更新，直接返回，执行结束；</li><li>MySQL调用了InnoDB引擎提供的“修改为(1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</li><li>InnoDB认真执行了“把这个值修改成(1,2)”这个操作，该加锁的加锁，该更新的更新。</li></ol><blockquote><p>MySQL采取的措施是第三条</p></blockquote><h1 id="16-讲“orderby”是怎么工作的"><a href="#16-讲“orderby”是怎么工作的" class="headerlink" title="16 讲“orderby”是怎么工作的"></a>16 讲“orderby”是怎么工作的</h1><p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前1000个人的姓名、年龄。</p><p>假设这个表的部分定义是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `city` varchar(16) NOT NULL,</span><br><span class="line">  `name` varchar(16) NOT NULL,</span><br><span class="line">  `age` int(11) NOT NULL,</span><br><span class="line">  `addr` varchar(128) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>这时，你的SQL语句可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000  ;</span><br></pre></td></tr></table></figure><p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么执行的，以及有什么参数会影响执行的行为。</p><h2 id="filesort归并排序"><a href="#filesort归并排序" class="headerlink" title="filesort归并排序"></a>filesort归并排序</h2><p>如果name字段不能使用索引排序，那么将会使用filesort</p><p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索引。</p><p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/826579b63225def812330ef6c344a303.png" alt="img"></p><p>​ 图1 使用explain命令查看语句的执行情况</p><p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p>为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230927101107961.png" alt="image-20230927101107961"></p><p>​ 图2 city字段的索引示意图</p><p>从图中可以看到，满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。</p><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>当<strong>sort_buffer_size &gt; 要排序的数据</strong>时，</p><p>这个语句执行流程如下所示 ：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p>我们暂且把这个排序过程，称为<strong>全字段排序</strong>，执行流程的示意图如下所示，下一篇文章中我们还会用到这个排序。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/6c821828cddf46670f9d56e126e3e772.jpg" alt="img" style="zoom:50%"><p>​ 图3 全字段排序</p><p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取<strong>决于排序所需的内存和参数sort_buffer_size</strong>。</p><p>sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。<strong>如果要排序的数据量小于sort_buffer_size，排序就在内存中完成</strong>。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><blockquote><p>你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 打开optimizer_trace，只对本线程有效 */</span><br><span class="line">SET optimizer_trace=&#x27;enabled=on&#x27;; </span><br><span class="line"></span><br><span class="line">/* @a保存Innodb_rows_read的初始值 */</span><br><span class="line">select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name = &#x27;Innodb_rows_read&#x27;;</span><br><span class="line"></span><br><span class="line">/* 执行语句 */</span><br><span class="line">select city, name,age from t where city=&#x27;杭州&#x27; order by name limit 1000; </span><br><span class="line"></span><br><span class="line">/* 查看 OPTIMIZER_TRACE 输出 */</span><br><span class="line">SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"></span><br><span class="line">/* @b保存Innodb_rows_read的当前值 */</span><br><span class="line">select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = &#x27;Innodb_rows_read&#x27;;</span><br><span class="line"></span><br><span class="line">/* 计算Innodb_rows_read差值 */</span><br><span class="line">select @b-@a;</span><br></pre></td></tr></table></figure><p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/89baf99cdeefe90a22370e1d6f5e6495.png" alt="img"></p><p>​ 图4 全排序的OPTIMIZER_TRACE部分结果</p><ul><li>number_of_tmp_files：排序过程中使用的临时文件数<ul><li>内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件。</strong></li><li>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成</li></ul></li><li>examined_rows&#x3D;4000，表示参与排序的行数是4000行。</li><li>sort_mode 里面的packed_additional_fields的意思是，<strong>全字段排序</strong>，并在排序过程对字符串做了“紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</li><li>最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。<ul><li>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会显示为4001。这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数据从临时表取出来的时候，会让Innodb_rows_read的值加1。</li></ul></li></ul></blockquote><h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，<strong>要分成很多个临时文件，排序的性能会很差</strong>。</p><p>所以<strong>如果单行很大，这个方法效率不够好</strong>。</p><p>接下来，我来修改一个参数，让MySQL采用另外一种算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET max_length_for_sort_data = 16;</span><br></pre></td></tr></table></figure><p>max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我们再来看看计算过程有什么改变。</p><p>新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。</p><p>但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并<strong>按照id的值回到原表</strong>中取出city、name和age三个字段返回给客户端。</li></ol><p>这个执行流程的示意图如下，我把它称为rowid排序。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/dc92b67721171206a302eb679c83e86d.jpg" alt="img" style="zoom:50%"><p>​ 图5 rowid排序</p><p>对比图3的全字段排序流程图你会发现，<strong>rowid排序多访问了一次表t的主键索引</strong>，就是步骤7。</p><p>需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><p>根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？</p><p>现在，我们就来看看结果有什么不同。</p><p>首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a这个语句的值变成5000了。</p><p>因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因此会多读1000行。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/27f164804d1a4689718291be5d10f89b.png" alt="img"></p><p>​ 图6 rowid排序的OPTIMIZER_TRACE部分输出</p><p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。</p><ul><li>sort_mode变成了&lt;sort_key, **rowid**&gt;，表示参与排序的只有name和id这两个字段。</li><li>number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><h3 id="全字段排序-VS-rowid排序"><a href="#全字段排序-VS-rowid排序" class="headerlink" title="全字段排序 VS rowid排序"></a>全字段排序 VS rowid排序</h3><ul><li>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li><li>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li></ul><p>这也就体现了MySQL的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p><strong>对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></p><blockquote><p>全字段排序<br>1.通过索引将所需的字段全部读取到sort_buffer中<br>2.按照排序字段进行排序<br>3.将结果集返回给客户端</p><p>缺点：<br>1.造成sort_buffer中存放不下很多数据，因为除了排序字段还存放其他字段，对sort_buffer的利用效率不高<br>2.当所需排序数据量很大时，会有很多的临时文件，排序性能也会很差</p><p>优点：MySQL认为内存足够大时会优先选择全字段排序，因为这种方式比rowid 排序避免了一次回表操作</p><p>rowid排序<br>1.通过控制排序的行数据的长度来让sort_buffer中尽可能多的存放数据，max_length_for_sort_data<br>2.只将需要排序的字段和主键读取到sort_buffer中，并按照排序字段进行排序<br>3.按照排序后的顺序，取id进行回表取出想要获取的数据<br>4.将结果集返回给客户端</p><p>优点：更好的利用内存的sort_buffer进行排序操作，尽量减少对磁盘的访问</p><p>缺点：回表的操作是随机IO，会造成大量的随机读，不一定就比全字段排序减少对磁盘的访问</p></blockquote><h2 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h2><p>其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p><p>你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢？</p><p>确实是这样的。</p><p>所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user(city, name);</span><br></pre></td></tr></table></figure><p>作为与city索引的对比，我们来看看这个索引的示意图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230927102414680.png" alt="image-20230927102414680"></p><p>​ 图7 city和name联合索引示意图</p><p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。</p><p>这样整个查询过程的流程就变成了：</p><ol><li>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name)取下一个记录主键id；</li><li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li></ol><p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一下。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/fc53de303811ba3c46d344595743358a.png" alt="img"></p><p>​ 图9 引入(city,name)联合索引后，查询语句的执行计划</p><p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了。也就</p><p>是说，在我们这个例子里，只需要扫描1000次。</p><p>这里我们可以再稍微复习一下。<strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p><p>按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。</p><p>针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure><p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p><ol><li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li></ol><p>然后，我们再来看看explain的结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9e40b7b8f0e3f81126a9171cc22e3423.png" alt="img"></p><p>​ 图11 引入(city,name,age)联合索引后，查询语句的执行计划</p><p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p><p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where city in (&#x27;杭州&#x27;,&quot;苏州&quot;) order by name limit 100;</span><br></pre></td></tr></table></figure><p>那么，这个语句执行的时候会有排序过程吗，为什么？</p><blockquote><p>虽然有(city,name)联合索引，对于单个city内部，name是递增的。但是由于这条SQL语句不是要单独地查一个city的值，而是同时查了”杭州”和” 苏州 “两个城市，因此所有满足条件的name就不是递增的了。也就是说，<strong>这条SQL语句需要排序。</strong></p><p>那怎么避免排序呢？</p><p>这里，我们要用到(city,name)联合索引的特性，把这一条语句拆成两条语句，执行流程如下：</p><ol><li>执行select * from t where city&#x3D;“杭州” order by name limit 100; 这个语句是不需要排序的，客户端用一个长度为100的内存数组A保存结果。</li><li>执行select * from t where city&#x3D;“苏州” order by name limit 100; 用相同的方法，假设结果被存进了内存数组B。</li><li>现在A和B是两个有序数组，然后你可以用归并排序的思想，得到name最小的前100值，就是我们需要的结果了。</li></ol></blockquote><h1 id="17-orderby-2-如何正确地显示随机消息"><a href="#17-orderby-2-如何正确地显示随机消息" class="headerlink" title="17 orderby 2 如何正确地显示随机消息"></a>17 orderby 2 如何正确地显示随机消息</h1><p>这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在，如果让你来设计这个SQL语句，你会怎么写呢？</p><p>为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择3个单词，有什么方法实现，存在什么问题以及如何改进。</p><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><p>首先，你会想到用**order by rand()**来实现这个逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点复杂的。</p><p>我们先用explain命令来看看这个语句的执行情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>​ 图1 使用explain命令查看语句的执行情况</p><p>Extra字段显示<strong>Using temporary</strong>，表示的是需要使用临时表；<strong>Using filesort</strong>，表示的是需要执行排序操作。</p><p>因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。</p><p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一下上一篇文章的一个结论：<strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p>我强调了“InnoDB表”，你肯定想到了，<strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。</p><p>理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们来尝试分析一下语句的扫描行数。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li><li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li><li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li><li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li><li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li><li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li></ol><p>接下来，我们通过<strong>慢查询日志（slow log）</strong>来验证一下我们分析得到的扫描行数是否正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span><br><span class="line">SET timestamp=1541402277;</span><br><span class="line">select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p><p>这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有趣，分析对了开心，分析错了但是弄清楚了也很开心。</p><p>现在，我来把完整的排序执行流程图画出来。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20230928180111638.png" alt="image-20230928180111638" style="zoom:50%"><p>​ 图4 随机排序完整流程图1</p><p>图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章中，我们对InnoDB表排序的时候，明明用的还是ID字段。</p><p>这时候，我们就要回到一个基本概念：<strong>MySQL的表是用什么方法来定位“一行数据”的。</strong></p><p>在前面<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/69236">第4</a>和<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/69636">第5</a>篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是不是就没有主键，就没办法回表了？</p><p>其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p><p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li><li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li><li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li></ul><p>到这里，我来稍微小结一下：<strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><h2 id="磁盘临时表InnoDB"><a href="#磁盘临时表InnoDB" class="headerlink" title="磁盘临时表InnoDB"></a>磁盘临时表InnoDB</h2><blockquote><p>磁盘临时表是上一节中归并排序的两种方式，</p><p>而内存临时表内存（tmp_table_size）不足时才会别为磁盘临时表，</p><ul><li>使用内存临时表会优先选择rowid排序，因为在内存中回表消耗不大，不用读磁盘</li></ul><p>磁盘临时表是<strong>InnoDB表</strong>，有三种排序方式，一般情况下速度从快到满依次是：</p><ol><li>优先队列排序	limit数据量大小 &lt; sort_buffer_size，在内存中构造大顶堆完成</li><li>全字段排序 sort_buffer_size &gt; 数据量大小，不使用磁盘文件</li><li>rowid排序 sort_buffer_size &lt; 数据量大小，使用磁盘文件，需要回表读磁盘，最慢</li></ol></blockquote><p>那么，是不是所有的临时表都是内存表呢？</p><p>其实不是的。<strong>tmp_table_size</strong>这个配置限制了内存临时表的大小，默认值是<strong>16M</strong>。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p><strong>磁盘临时表使用的引擎默认是InnoDB</strong>，是由参数internal_tmp_disk_storage_engine控制的。</p><p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。</p><p>为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set tmp_table_size=1024;</span><br><span class="line">set sort_buffer_size=32768;</span><br><span class="line">set max_length_for_sort_data=16;</span><br><span class="line">/* 打开 optimizer_trace，只对本线程有效 */</span><br><span class="line">SET optimizer_trace=&#x27;enabled=on&#x27;; </span><br><span class="line"></span><br><span class="line">/* 执行语句 */</span><br><span class="line">select word from words order by rand() limit 3;</span><br><span class="line"></span><br><span class="line">/* 查看 OPTIMIZER_TRACE 输出 */</span><br><span class="line">SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/78d2db9a4fdba81feadccf6e878b4aab.png" alt="img"></p><p>​ 图5 OPTIMIZER_TRACE部分结果</p><p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。</p><p>因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字段组成的行。</p><h3 id="优先队列排序"><a href="#优先队列排序" class="headerlink" title="优先队列排序"></a>优先队列排序</h3><p>这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，<strong>超过了sort_buffer_size 定义的 32768字节</strong>了。但是，number_of_tmp_files的值居然是0，难道不需要用临时文件吗？</p><p>这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，即：<strong>优先队列排序算法</strong>。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序算法，而是采用了优先队列排序算法。</p><p>其实，我们现在的SQL语句，<strong>只需要取R值最小的3个rowid</strong>。但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。</p><p>也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，想一下就明白了，这浪费了非常多的计算量。</p><p>而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p><ol><li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li></ol><p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p><ol><li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；</li><li>重复第2步，直到第10000个(R’,rowid’)完成比较。</li></ol><p>这里我简单画了一个优先队列排序过程的示意图。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/e9c29cb20bf9668deba8981e444f6897.png" alt="img" style="zoom:33%"><p>​ 图6 优先队列排序算法示例</p><p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个<strong>最大堆</strong>。</p><p>图5的OPTIMIZER_TRACE结果中，<strong>filesort_priority_queue_optimization这个部分的chosen&#x3D;true</strong>，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的number_of_tmp_files是0。</p><p>这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一样了。</p><p>我们再看一下上面一篇文章的SQL查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000  ;</span><br></pre></td></tr></table></figure><p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，<strong>超过了我设置的sort_buffer_size大小</strong>，所以只能使用<strong>归并排序算法</strong>。</p><h2 id="解决文章开头随机排序的方法"><a href="#解决文章开头随机排序的方法" class="headerlink" title="解决文章开头随机排序的方法"></a>解决文章开头随机排序的方法</h2><p><strong>方法1</strong></p><p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p><ol><li>取得这个表的主键id的最大值M和最小值N;</li><li>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</li><li>取不小于X的第一个ID的行。</li></ol><p>我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select max(id),min(id) into @M,@N from t ;</span><br><span class="line">set @X= floor((@M-@N+1)*rand() + @N);</span><br><span class="line">select * from t where id &gt;= @X limit 1;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p><p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id&#x3D;4的这一行的概率是取得其他行概率的两倍。</p><p>如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。</p><p>解决：</p><p>对应单词这种总量不是很多的数据，第一感觉应该装jdk缓存或者<strong>redis缓存</strong>。由于需要随机访问，数组比较好。假如一个单词平均10个字节，10*10000，不到1M就装下了。<br>如果一定要用数据库来做，老师的方案1比较好，空洞的问题，如果单词库不变，可以在上线前<strong>整理数据</strong>，把空洞处理调。比如：原来单词存在A表，新建B表 ，执行 insert into B(word) select word from A. B的id是自增的，就会生成连续的主键。当然如果A表写比较频繁，且数据量较大，业务上禁用这种写法，RR的隔离级别会锁A表</p></blockquote><p><strong>方法2</strong></p><p>所以，为了得到严格随机的结果，你可以用下面这个流程:</p><ol><li>取得整个表的行数，并记为C。</li><li>取得 Y &#x3D; floor(C * rand())。 floor函数在这里的作用，就是取整数部分。</li><li>再用limit Y,1 取得一行。</li></ol><p>我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line">set @Y = floor(@C * rand());</span><br><span class="line">set @sql = concat(&quot;select * from t limit &quot;, @Y, &quot;,1&quot;);</span><br><span class="line">prepare stmt from @sql;</span><br><span class="line">execute stmt;</span><br><span class="line">DEALLOCATE prepare stmt;</span><br></pre></td></tr></table></figure><blockquote><p>由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。</p><p>这个随机算法2，解决了算法1里面明显的概率不均匀问题。</p><p>MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，执行代价比随机算法1的代价要高。</p><p>当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。</p><p>你可能问了，如果按照这个表有10000行来计算的话，C&#x3D;10000，要是随机到比较大的Y值，那扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小很多呢？我就把这个问题留给你去课后思考吧。</p></blockquote><p><strong>方法3：即方法2取多值</strong></p><p>现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p><ol><li>取得整个表的行数，记为C；</li><li>根据相同的随机方法得到Y1、Y2、Y3；</li><li>再执行三个limit Y, 1语句得到三行数据。</li></ol><p>我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line">set @Y1 = floor(@C * rand());</span><br><span class="line">set @Y2 = floor(@C * rand());</span><br><span class="line">set @Y3 = floor(@C * rand());</span><br><span class="line">select * from t limit @Y1，1； //在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行</span><br><span class="line">select * from t limit @Y2，1；</span><br><span class="line">select * from t limit @Y3，1；</span><br></pre></td></tr></table></figure><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p><p>这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后执行下面这条SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t limit N, M-N+1;</span><br></pre></td></tr></table></figure><p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。</p><p>当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以的</p><h1 id="18-讲为什么这些SQL语句逻辑相同，性能却差异巨大"><a href="#18-讲为什么这些SQL语句逻辑相同，性能却差异巨大" class="headerlink" title="18 讲为什么这些SQL语句逻辑相同，性能却差异巨大"></a>18 讲为什么这些SQL语句逻辑相同，性能却差异巨大</h1><h1 id="（即索引失效）"><a href="#（即索引失效）" class="headerlink" title="（即索引失效）"></a>（即索引失效）</h1><h2 id="索引字段使用函数"><a href="#索引字段使用函数" class="headerlink" title="索引字段使用函数"></a>索引字段使用函数</h2><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>两张表，一张未utf8，一张为utf8mb4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /*语句Q1*/</span><br></pre></td></tr></table></figure><p>也就是说，实际上这个语句等同于下面这个写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p><p>这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>到这里，你终于明确了，字符集不同只是条件之一，<strong>连接过程中要求在被驱动表的索引字段上加函数操作</strong></p><p><strong>两种解决办法：</strong></p><ul><li>比较常见的优化方法是，把trade_detail表上的tradeid字段的<strong>字符集也改成utf8mb4</strong>，这样就没有字符集转换的问题了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</span><br></pre></td></tr></table></figure><ul><li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大，或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </span><br></pre></td></tr></table></figure><p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看到，这次索引走对了。</p><h1 id="19-讲为什么我只查一行的语句，也执行这么慢"><a href="#19-讲为什么我只查一行的语句，也执行这么慢" class="headerlink" title="19 讲为什么我只查一行的语句，也执行这么慢"></a>19 讲为什么我只查一行的语句，也执行这么慢</h1><h2 id="影响查询速度的几种情况"><a href="#影响查询速度的几种情况" class="headerlink" title="影响查询速度的几种情况"></a>影响查询速度的几种情况</h2><p>为了便于描述，我还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段id和c，并且我在里面插入了10万行记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h3><p>如图1所示，在表t执行下面的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure><p>查询结果长时间不返回。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/8707b79d5ed906950749f5266014f22a.png" alt="img"></p><p>​ 图1 查询长时间不返回</p><p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一下show processlist命令，看看当前语句处于什么状态。</p><p>然后我们再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。</p><h4 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h4><p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/5008d7e9e22be88a9c80916df4f4b328.png" alt="img"></p><p>​ 图2 Waiting for table metadata lock状态示意图</p><p>出现<strong>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</strong></p><p>这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。</p><p>但是，由于在show processlist的结果里面，session A的Command列是“Sleep”，导致查找起来很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需要设置performance_schema&#x3D;on，相比于设置为off会有10%左右的性能损失)</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select blocking_pid from sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/74fb24ba3826e3831eeeff1670990c01.png" alt="img"></p><p>​ 图4 查获加表锁的线程id</p><h4 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h4><p>接下来，我给你举另外一种查询被堵住的情况。</p><p>我在表t上，执行下面的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.processlist where id=1;</span><br></pre></td></tr></table></figure><p>这里，我先卖个关子。</p><p>你可以看一下图5。我查出来这个线程的状态是Waiting for table flush，你可以设想一下这是什么原因。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/2d8250398bc7f8f7dce8b6b1923c3724.png" alt="img"></p><p>​ 图5 Waiting for table flush状态示意图</p><p>这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用法，一般有以下两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables t with read lock;</span><br><span class="line"></span><br><span class="line">flush tables with read lock;</span><br></pre></td></tr></table></figure><p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p><p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p><p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。</p><p>现在，我们一起来复现一下这种情况，<strong>复现步骤</strong>如图6所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/2bbc77cfdb118b0d9ef3fdd679d0a69c.png" alt="img"></p><p>​ 图6 Waiting for table flush的复现步骤</p><h4 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h4><p>现在，经过了表级锁的考验，我们的select 语句终于来到引擎里了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1 lock in share mode; </span><br></pre></td></tr></table></figure><p>上面这条语句的用法你也很熟悉了，我们在第8篇<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>文章介绍当前读时提到过。</p><p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p><p>复现步骤和现场如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3e68326b967701c59770612183277475.png" alt="img"></p><p>​ 图 8 行锁复现</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3c266e23fc307283aa94923ecbbc738f.png" alt="img"></p><p>图 9 行锁show processlist 现场</p><p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。</p><p>这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到。</p><p>查询方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t sys.innodb_lock_waits where locked_table=`&#x27;test&#x27;.&#x27;t&#x27;`\G</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/d8603aeb4eaad3326699c13c46379118.png" alt="img" style="zoom:67%"><p>​ 图10 通过sys.innodb_lock_waits 查行锁</p><p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是KILL QUERY 4或KILL 4。</p><p>不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，现在执行KILL QUERY，无法让这个事务去掉id&#x3D;1上的行锁。</p><p>实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了id&#x3D;1上的行锁。</p><h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><p>经过了重重封“锁”，我们再来看看一些查询慢的例子。</p><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>先来看一条你一定知道原因的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where c=50000 limit 1;</span><br></pre></td></tr></table></figure><p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p><p>作为确认，你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接后先执行了 set long_query_time&#x3D;0，将慢查询日志的时间阈值设置为0。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d8b2b5f97c60ae4fc4a03c616847503c.png" alt="img"></p><p>​ 图11 全表扫描5万行的slow log</p><p>Rows_examined显示扫描了50000行。你可能会说，不是很慢呀，11.5毫秒就返回了，我们线上一般都配置超过1秒才算慢查询。但你要记住：<strong>坏查询不一定是慢查询</strong>。我们这个例子里面只有10万行记录，数据量大起来的话，执行时间就线性涨上去了。</p><p>扫描行数多，所以执行慢，这个很好理解。</p><h4 id="undo链太长"><a href="#undo链太长" class="headerlink" title="undo链太长"></a>undo链太长</h4><p>但是接下来，我们再看一个只扫描一行，但是执行很慢的语句。</p><p>如图12所示，是这个例子的slow log。可以看到，执行的语句是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1；</span><br></pre></td></tr></table></figure><p>虽然扫描行数是1，但执行时间却长达800毫秒。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/66f26bb885401e8e460451ff6b0c0746.png" alt="img"></p><p>​ 图12 扫描一行却执行得很慢</p><p>是不是有点奇怪呢，这些时间都花在哪里了？</p><p>如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id&#x3D;1 lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/bde83e269d9fa185b27900c8aa8137d2.png" alt="img"></p><p>​ 图 13 加上lock in share mode的slow log</p><p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。</p><p>可能有的同学已经有答案了。如果你还没有答案的话，我再给你一个提示信息，图14是这两个语句的执行输出结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/1fbb84bb392b6bfa93786fe032690b1c.png" alt="img"></p><p>​ 图14 两个语句的输出结果</p><p>第一个语句的查询结果里c&#x3D;1，带lock in share mode的语句返回的是c&#x3D;1000001。看到这里应该有更多的同学知道原因了。如果你还是没有头绪的话，也别着急。我先跟你说明一下复现步骤，再分析原因。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/84667a3449dc846e393142600ee7a2ff.png" alt="img"></p><p>​ 图15 复现步骤</p><p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p><p>session B执行完100万次update语句后，id&#x3D;1这一行处于什么状态呢？你可以从图16中找到答案。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/46bb9f5e27854678bfcaeaf0c3b8a98c.png" alt="img" style="zoom:50%"><p>​ 图16 id&#x3D;1的数据状态</p><p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><p>注意，undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方便你看图。</p><h1 id="20-讲幻读是什么，幻读有什么问题"><a href="#20-讲幻读是什么，幻读有什么问题" class="headerlink" title="20 讲幻读是什么，幻读有什么问题"></a>20 讲幻读是什么，幻读有什么问题</h1><h2 id="非索引字段更新语句的加锁情况"><a href="#非索引字段更新语句的加锁情况" class="headerlink" title="非索引字段更新语句的加锁情况"></a>非索引字段更新语句的加锁情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。</p><p>上期我留给你的问题是，下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where d=5 for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><blockquote><p>先说结论：</p><ul><li>RC级别下，非索引字段的更新操作会对全表每一条记录加行锁</li><li>RR级别下，非索引字段的更新操作会对全表每一条记录邻间锁（记录锁+间隙锁）</li></ul></blockquote><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读指的是<strong>一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</strong></p><p>这里，我需要对“幻读”做一个说明：</p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读”下才会出现</strong><ul><li>若是快照读，MVCC机制已经解决了幻读问题</li><li>若是当前读，采用加间隙锁的方式解决幻读</li></ul></li><li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅<strong>专指“新插入的行”</strong>。</li></ol><h2 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h2><p>现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是<strong>间隙锁(Gap Lock)。</strong></p><p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20230930153653250.png" alt="image-20230930153653250"></p><p>这样，当你执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p><p><strong>间隙锁之间都不存在冲突关系。</strong></p><p>这句话不太好理解，我给你举个例子：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7c37732d936650f1cda7dbf27daf7498.png" alt="img"></p><p>​ 图7 间隙锁之间不互锁</p><p>这里session B并不会被堵住。因为表t里并没有c&#x3D;7这个记录，因此session A加的是间隙锁(5,10)。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]。</p><p><strong>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p><p>间隙锁容易造成<strong>死锁</strong>，且<strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong></p><blockquote><p><strong>间隙锁是在可重复读隔离级别下才会生效</strong>的。所以，你如果把隔离级别设置为<strong>读提交</strong>的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要<strong>把binlog格式设置为row</strong>。这，也是现在不少公司使用的配置组合。</p></blockquote><h1 id="21-邻间锁的范围和规则"><a href="#21-邻间锁的范围和规则" class="headerlink" title="21 邻间锁的范围和规则"></a>21 邻间锁的范围和规则</h1><h2 id="两原则两优化一bug"><a href="#两原则两优化一bug" class="headerlink" title="两原则两优化一bug"></a>两原则两优化一bug</h2><p>MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即5.x系列&lt;&#x3D;5.7.24，8.0系列 &lt;&#x3D;8.0.13。</p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的<strong>等值</strong>查询，给<strong>唯一索引</strong>加锁的时候，next-key lock<strong>退化为行锁</strong>。</li><li>优化2：索引上的<strong>等值</strong>查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock<strong>退化为间隙锁</strong>。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。（自己测试mysql8.0.25已经不满足此bug）</li></ol><blockquote><p>另外：<strong>锁是加在索引树上的</strong></p></blockquote><p>我还是以上篇文章的表t为例，和你解释一下这些规则。表t的建表语句和初始化语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/585dfa8d0dd71171a6fa16bed4ba816c.png" alt="img"></p><p>​ 图1 等值查询的间隙锁</p><p>由于表t中没有id&#x3D;7的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</li><li>同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是**(5,10)**。</li></ol><p>所以，session B要往这个间隙里面插入id&#x3D;8的记录会被锁住，但是session C修改id&#x3D;10这行是可以的。</p><h3 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h3><p>第二个例子是关于覆盖索引上的锁：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/465990fe8f6b418ca3f9992bd1bb5465.png" alt="img"></p><p>​ 图2 只加在非唯一索引上的锁</p><p>看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。</p><p>这里session A要给索引c上c&#x3D;5的这一行加上读锁。</p><ol><li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>要注意c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此退化成间隙锁(5,10)。</li><li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li></ol><p>所以最终加锁范围为**(0,10)的c索引树**</p><p>但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</p><p>需要注意，在这个例子中，lock in share mode<strong>只锁覆盖索引</strong>，</p><blockquote><p>要避开覆盖索引：<strong>①使用for update 上锁	②不使用覆盖索引</strong></p><ul><li>但是如果是for update就不一样了。 执行 for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</li><li>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成select d from t where c&#x3D;5 lock in share mode。你可以自己验证一下效果。</li></ul></blockquote><h3 id="案例三：主键-唯一-索引范围锁"><a href="#案例三：主键-唯一-索引范围锁" class="headerlink" title="案例三：主键(唯一)索引范围锁"></a>案例三：主键(唯一)索引范围锁</h3><p>第三个例子是关于范围查询的。</p><p>举例之前，你可以先思考一下这个问题：对于我们这个表t，下面这两条查询语句，加锁范围相同吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=10 for update;</span><br><span class="line">mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure><p>你可能会想，id定义为int类型，这两个语句就是等价的吧？其实，它们<strong>并不完全等价</strong>。</p><p>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让session A执行第二个查询语句，来看看加锁效果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/30b839bf941f109b04f1a36c302aea80.png" alt="img"></p><p>​ 图3 主键索引上范围查询的锁</p><p>现在我们就用前面提到的加锁规则，来分析一下session A 会加什么锁呢？</p><ol><li>开始执行的时候，要找到第一个id&#x3D;10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。</li><li>范围查找就往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]，由于是范围查询，所以优化1和2不适用。</li></ol><p>所以，session A这时候锁的范围就是主键索引上，<strong>行锁id&#x3D;10</strong>和next-key lock**(10,15]**。这样，session B和session C的结果你就能理解了。</p><p>这里你需要注意一点，首次session A定位查找id&#x3D;10的行的时候，是当做等值查询来判断的，而向右扫描到id&#x3D;15的时候，用的是范围查询判断。</p><h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><p>接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。</p><p>需要注意的是，与案例三不同的是，案例四中查询语句的where部分用的是字段c。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7381475e9e951628c9fc907f5a57697a.png" alt="img"></p><p>图4 非唯一索引范围锁</p><p>这次session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的**(5,10] 和(10,15]** 这两个next-key lock。</p><p>所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。</p><p>这里需要扫描到c&#x3D;15才停止扫描，是合理的，因为InnoDB要扫到c&#x3D;15，才知道不需要继续往后找了。</p><h3 id="案例五：唯一索引范围锁bug"><a href="#案例五：唯一索引范围锁bug" class="headerlink" title="案例五：唯一索引范围锁bug"></a>案例五：唯一索引范围锁bug</h3><p>前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中bug的案例。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/b105f8c4633e8d3a84e6422b1b1a316d.png" alt="img"></p><p>​ 图5 唯一索引范围锁的bug</p><p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id&#x3D;15这一行就应该停止了。</p><p>但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id&#x3D;20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p><p>所以上锁范围是：**(10,20]**</p><p>所以你看到了，session B要更新id&#x3D;20这一行，是会被锁住的。同样地，session C要插入id&#x3D;16的一行，也会被锁住。</p><p>照理说，这里锁住id&#x3D;20这一行的行为，其实是没有必要的。因为扫描到id&#x3D;15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个bug。</p><p>我也曾找社区的专家讨论过，官方bug系统上也有提到，但是并未被verified。所以，认为这是bug这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。</p><blockquote><p>我在mysql8.0.25中测试已不存在此bug</p></blockquote><h3 id="案例六：非唯一索引上存在”等值”的例子"><a href="#案例六：非唯一索引上存在”等值”的例子" class="headerlink" title="案例六：非唯一索引上存在”等值”的例子"></a>案例六：非唯一索引上存在”等值”的例子</h3><p>接下来的例子，是为了更好地说明“间隙”这个概念。这里，我给表t插入一条新记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t values(30,10,30);</span><br></pre></td></tr></table></figure><p>新插入的这一行c&#x3D;10，也就是说现在表里有两个c&#x3D;10的行。那么，这时候索引c上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231004150328954.png" alt="image-20231004150328954"></p><p>​ 图6 非唯一索引等值的例子</p><p>可以看到，虽然有两个c&#x3D;10，但是它们的主键值id是不同的（分别是10和30），因此这两个c&#x3D;10的记录之间，也是有间隙的。</p><p>图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c&#x3D;10,id&#x3D;30)这样的形式，来表示索引上的一行。</p><p>现在，我们来看一下案例六。</p><p>这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/b55fb0a1cac3500b60e1cf9779d2da78.png" alt="img"></p><p>​ 图7 delete 示例</p><p>这时，session A在遍历的时候，先访问第一个c&#x3D;10的记录。同样地，根据原则1，这里加的是(c&#x3D;5,id&#x3D;5)到(c&#x3D;10,id&#x3D;10)这个next-key lock。</p><p>然后，session A向右查找，直到碰到(c&#x3D;15,id&#x3D;15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c&#x3D;10,id&#x3D;10) 到 (c&#x3D;15,id&#x3D;15)的间隙锁。</p><p>也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231004150443919.png" alt="image-20231004150443919"></p><p>​ 图 8 delete</p><p>加锁效果示例这个蓝色区域左右两边都是虚线，表示开区间**(5,15)**，即 (c&#x3D;5,id&#x3D;5) 和 (c&#x3D;15,id&#x3D;15) 这两行上都没有锁。</p><h3 id="案例七：limit-语句加锁"><a href="#案例七：limit-语句加锁" class="headerlink" title="案例七：limit 语句加锁"></a>案例七：limit 语句加锁</h3><p>例子6也有一个对照案例，场景如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/afc3a08ae7a254b3251e41b2a6dae02e.png" alt="img"></p><p>​ 图9 limit 语句加锁</p><p>这个例子里，session A的delete语句加了 limit 2。你知道表t里c&#x3D;10的记录其实只有两条，因此加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert语句执行通过了，跟案例六的结果不同。</p><p>这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c&#x3D;10, id&#x3D;30)这一行之后，满足条件的语句已经有两条，循环就结束了。</p><p>因此，索引c上的加锁范围就变成了从（c&#x3D;5,id&#x3D;5)到（c&#x3D;10,id&#x3D;30)这个前开后闭区间**(5,10-30)**，如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231004150555757.png" alt="img"></p><p>​ 图10 带limit 2的加锁效果</p><p>可以看到，(c&#x3D;10,id&#x3D;30）之后的这个间隙并没有在加锁范围里，因此insert语句插入c&#x3D;12是可以执行成功的。</p><blockquote><p>这个例子对我们实践的指导意义就是，<strong>在删除数据的时候尽量加limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p></blockquote><h3 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h3><p>前面的例子中，我们在分析的时候，是按照next-key lock的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：<strong>next-key lock实际上是间隙锁和行锁加起来的结果。</strong></p><blockquote><p>next-key lock会<strong>先加间隙锁，再加行记录锁</strong></p></blockquote><p>你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7b911a4c995706e8aa2dd96ff0f36506.png" alt="img"></p><p>​ 图11 案例八的操作序列</p><p>现在，我们按时间顺序来分析一下为什么是这样的结果。</p><ol><li>session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；</li><li>session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；</li><li>然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死锁，InnoDB让session B回滚。</li></ol><p>你可能会问，session B的next-key lock不是还没申请成功吗？</p><p>其实是这样的，session B的“加next-key lock(5,10] ”操作，实际上分成了两步，<strong>先是加(5,10)的间隙锁（间隙锁不互斥），加锁成功；然后加c&#x3D;10的行锁</strong>，这时候才被锁住的。</p><p>也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>文章开头初始化的表t，里面有6条记录，图12的语句序列中，为什么session B的insert操作，会被锁住呢？<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3a7578e104612a188a2d574eaa3bd81e.png" alt="img"></p><p>​ 图12 锁分析思考题</p><ol><li>由于是order by c desc，第一个要定位的是索引c上“最右边的”c&#x3D;20的行，所以会加上间隙锁(20,25)和next-key lock (15,20]。</li><li>在索引c上向左遍历，<strong>要扫描到c&#x3D;10才停下来</strong>，所以next-key lock会加到(5,10]，这正是阻塞session B的insert语句的原因。</li><li>在扫描过程中，c&#x3D;20、c&#x3D;15、c&#x3D;10这三行都存在值，由于是select *，所以会在主键id上加三个行锁。</li></ol><p>因此，session A 的select语句锁的范围就是：</p><ol><li>索引c上 **(5, 25)**；</li><li>主键索引上id&#x3D;10、15、20三个行锁。</li></ol><p><strong>总结：</strong></p><p>1、查询过程中访问到的对象才会加锁，而加锁的基本单位是next-key lock（前开后闭）；</p><p>2、等值查询上MySQL的优化：索引上的等值查询，如果是唯一索引，next-key lock会退化为行锁，如果不是唯一索引，需要访问到第一个不满足条件的值，此时next-key lock会退化为间隙锁；</p><p>3、范围查询：无论是否是唯一索引，范围查询都需要访问到不满足条件的第一个值为止；（bug未修复时）</p><h1 id="22-讲MySQL有哪些“饮鸩止渴”提高性能的方法"><a href="#22-讲MySQL有哪些“饮鸩止渴”提高性能的方法" class="headerlink" title="22 讲MySQL有哪些“饮鸩止渴”提高性能的方法"></a>22 讲MySQL有哪些“饮鸩止渴”提高性能的方法</h1><h2 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h2><p>正常的短连接模式就是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。</p><p>我在第1篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/68319">《基础架构：一条SQL查询语句是如何执行的？》</a>中说过，MySQL建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p><p>在数据库压力比较小的时候，这些额外的成本并不明显。</p><p>碰到这种情况时，一个比较自然的想法，就是调高max_connections的值。但这样做是有风险的。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。</p><p>那么这种情况下，你还有没有别的建议呢？我这里还有两种方法，但要注意，这些方法都是有损的。</p><h3 id="第一种方法：先处理掉那些占着连接但是不工作的线程。"><a href="#第一种方法：先处理掉那些占着连接但是不工作的线程。" class="headerlink" title="第一种方法：先处理掉那些占着连接但是不工作的线程。"></a>第一种方法：先处理掉那些占着连接但是不工作的线程。</h3><p>但是需要注意，在show processlist的结果里，踢掉显示为sleep的线程，可能是有损的</p><p>我们来看下面这个例子。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9091ff280592c8c68665771b1516c62a.png" alt="img"></p><p>图1 sleep线程的两种状态</p><p>在上面这个例子里，如果断开session A的连接，因为这时候session A还没有提交，所以MySQL只能按照回滚事务来处理；而断开session B的连接，就没什么大影响。所以，如果按照优先级来说，你应该<strong>优先断开像session B</strong>这样的事务外空闲的连接。</p><p>但是，怎么判断哪些是事务外空闲的呢？session C在T时刻之后的30秒执行show processlist，看到的结果是这样的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/ae6a9ceecf8517e47f9ebfc565f0f925.png" alt="img"></p><p>图2 sleep线程的两种状态，show processlist结果</p><p>图中id&#x3D;4和id&#x3D;5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查information_schema库的innodb_trx表。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/ca4b455c8eacbf32b98d1fe9ed9876e8.png" alt="img"></p><p>图3 从information_schema.innodb_trx查询事务状态</p><p>这个结果里，trx_mysql_thread_id&#x3D;4，表示id&#x3D;4的线程还处在事务中。</p><p>因此，如果是连接数过多，你可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。</p><p>从服务端断开连接使用的是<strong>kill connection + id</strong>的命令， 一个客户端处于sleep状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><p>从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL一直没恢复”。</p><h3 id="第二种方法：减少连接过程的消耗（不推荐）"><a href="#第二种方法：减少连接过程的消耗（不推荐）" class="headerlink" title="第二种方法：减少连接过程的消耗（不推荐）"></a>第二种方法：减少连接过程的消耗（不推荐）</h3><p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p><p>跳过权限验证的方法是：重启数据库，并使用<strong>–skip-grant-tables</strong>参数启动。这样，整个MySQL会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p><p>但是，这种方法特别符合我们标题里说的“饮鸩止渴”，<strong>风险极高，是我特别不建议使用的方案</strong>。尤其你的库外网可访问的话，就更不能这么做了。</p><p><strong>在MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 –skip-networking参数打开，</strong>表示这时候数据库只能被本地的客户端连接。可见，MySQL官方对skip-grant-tables这个参数的安全问题也很重视。</p><p>除了短连接数暴增可能会带来性能问题外，实际上，我们在线上碰到更多的是查询或者更新语句导致的性能问题。其中，查询问题比较典型的有两类，一类是由新出现的慢查询导致的，一类是由QPS（每秒查询数）突增导致的。而关于更新语句导致的性能问题，我会在下一篇文章和你展开说明。</p><h2 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h2><p>在MySQL中，会引发性能问题的慢查询，大体有以下三种可能：</p><ol><li>索引没有设计好；</li><li>SQL语句没写好；</li><li>MySQL选错了索引。</li></ol><p>接下来，我们就具体分析一下这三种可能，以及对应的解决方案。</p><h3 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h3><p><strong>导致慢查询的第一种可能是，索引没有设计好。</strong></p><p>这种场景一般就是通过紧急创建索引来解决。MySQL 5.6版本以后，创建索引都支持Online DDL了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table 语句。</p><p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的大致流程是这样的：</p><ol><li>在备库B上执行 set sql_log_bin&#x3D;off，也就是不写binlog，然后执行alter table 语句加上索引；</li><li>执行主备切换；</li><li>这时候主库是B，备库是A。在A上执行 set sql_log_bin&#x3D;off，然后执行alter table 语句加上索引。</li></ol><p>这是一个“古老”的DDL方案。平时在做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳妥。但是在需要紧急处理时，上面这个方案的效率是最高的。</p><h3 id="SQL语句没写好"><a href="#SQL语句没写好" class="headerlink" title="SQL语句没写好"></a>SQL语句没写好</h3><p><strong>导致慢查询的第二种可能是，语句没写好。</strong></p><p>比如，我们犯了在第18篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/74059">《为什么这些SQL语句逻辑相同，性能却差异巨大？》</a>中提到的那些错误，导致语句没有使用上索引。</p><p>这时，我们可以通过改写SQL语句来处理。MySQL 5.7提供了<strong>query_rewrite</strong>功能，可以把输入的一种语句改写成另外一种模式。</p><p>比如，语句被错误地写成了 select * from t where id + 1 &#x3D; 10000，你可以通过下面的方式，增加一个语句改写规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);</span><br><span class="line"></span><br><span class="line">call query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure><p>这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。你可以用图4中的方法来确认改写规则是否生效。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static001.geekbang.org/resource/image/47/8a/47a1002cbc4c05c74841591d20f7388a.png" alt="img"></p><p>​ 图4 查询重写效果</p><h3 id="MySQL选错索引"><a href="#MySQL选错索引" class="headerlink" title="MySQL选错索引"></a>MySQL选错索引</h3><p><strong>导致慢查询的第三种可能，就是碰上了我们在第10篇文章</strong><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71173"><strong>《MySQL为什么有时候会选错索引？》</strong></a><strong>中提到的情况，MySQL选错了索引。</strong></p><p>这时候，应急方案就是给这个语句加上<strong>force index</strong>。</p><p>同样地，使用查询重写功能，给原来的语句加上force index，也可以解决这个问题。</p><p>上面我和你讨论的由慢查询导致性能问题的三种可能情况，实际上出现最多的是前两种，即：索引没设计好和语句没写好。而这两种情况，恰恰是完全可以避免的。比如，通过下面这个过程，我们就可以预先发现问题。</p><ol><li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li><li>在测试表里插入模拟线上的数据，做一遍回归测试；</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果还有不明白的，欢迎给我留言，我们一起讨论）。</li></ol><p>不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。</p><p>如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的 表结构设计，全量回归测试都是必要的。这时候，你需要工具帮你检查所有的SQL语句的返回结果。比如，你可以使用开源工具pt-query-digest(<a target="_blank" rel="noopener" href="https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html)%E3%80%82">https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html)。</a></p><h2 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h2><p>有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致MySQL压力过大，影响服务。</p><p>我之前碰到过一类情况，是由一个新功能的bug导致的。当然，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。</p><p>而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。我这里再和你展开说明一下。</p><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接<strong>把白名单去掉</strong>。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号<strong>把这个用户删掉</strong>，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接<strong>重写成”select 1”返回</strong>。（不推荐）</li></ol><p>当然，这个操作的风险很高，需要你特别细致。它可能存在两个副作用：</p><ol><li>如果别的功能里面也用到了这个SQL语句模板，会有误伤；</li><li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以select 1的结果返回的话，可能会导致后面的业务逻辑一起失败。</li></ol><p>所以，方案3是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低的一个方案。</p><p>同时你会发现，<strong>其实方案1和2都要依赖于规范的运维体系：虚拟化、白名单机制、业务账号分离。由此可见，更多的准备，往往意味着更稳定的系统。</strong></p><h1 id="23-redo-log和bin-log持久化机制"><a href="#23-redo-log和bin-log持久化机制" class="headerlink" title="23 redo log和bin log持久化机制"></a>23 redo log和bin log持久化机制</h1><h2 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h2><p>其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。</p><p>系统给<strong>binlog cache（默认32K）</strong>分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9ed86644d5f39efb0efec595abb92e3e.png" alt="img"></p><p>​ 图1 binlog写盘状态</p><p>可以看到，<strong>每个线程有自己binlog cache</strong>，但是<strong>共用同一份binlog文件</strong>。</p><ul><li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li><strong>sync_binlog&#x3D;0</strong>的时候，表示每次提交事务都只write，不fsync；</li><li><strong>sync_binlog&#x3D;1</strong>的时候，表示每次提交事务都会执行fsync；</li><li>**sync_binlog&#x3D;N(N&gt;1)**的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为<strong>100~1000</strong>中的某个数值。</p><p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会<strong>丢失最近N个事务的binlog日志</strong>。</p><h2 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h2><p>接下来，我们再说说redo log的写入机制。</p><p>在专栏的<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73161">第15篇答疑文章</a>中，我给你介绍了redo log buffer。事务在执行过程中，生成的redo log是要先写到redo log buffer的。</p><blockquote><p>然后就有同学问了，redo log buffer里面的内容，是不是每次生成后都要直接持久化到磁盘呢？</p><p>答案是，不需要。</p><p>如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p><p>那么，另外一个问题是，事务还没提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？</p><p>答案是，确实会有。</p></blockquote><p>这个问题，要从redo log可能存在的三种状态说起。这三种状态，对应的就是图2 中的三个颜色块。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9d057f61d3962407f413deebc80526d4.png" alt="img"></p><p>​ 图2 MySQL redo log存储状态</p><p>这三种状态分别是：</p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li><strong>设置为0的时候</strong>，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li><strong>设置为1的时候</strong>，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li><strong>设置为2的时候</strong>，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p><strong>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志</strong>，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p><ol><li><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong>注意，由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。</li><li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong>假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer里的日志一起持久化到磁盘。</li></ol><p>这里需要说明的是，我们介绍两阶段提交的时候说过，时序上redo log先prepare， 再写binlog，最后再把redo log commit。</p><p>如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。（如果你印象有点儿模糊了，可以再回顾下<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73161">第15篇文章</a>中的相关内容）。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p><p>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p><h3 id="组提交机制"><a href="#组提交机制" class="headerlink" title="组提交机制"></a>组提交机制</h3><p>这时候，你可能有一个疑问，这意味着我从MySQL看到的TPS是每秒两万的话，每秒就会写四万次磁盘。但是，我用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？</p><p>解释这个问题，就要用到组提交（group commit）机制了。</p><p>这里，我需要先和你介绍<strong>日志逻辑序列号</strong>（log sequence number，<strong>LSN</strong>）的概念。LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。</p><p>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。关于LSN和redo log、checkpoint的关系，我会在后面的文章中详细展开。</p><p>如图3所示，是三个并发事务(trx1, trx2, trx3)在prepare 阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120 和160。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/933fdc052c6339de2aa3bf3f65b188cc.png" alt="img"></p><p>​ 图3 redo log 组提交</p><p>从图中可以看到，</p><ol><li>trx1是第一个到达的，会被选为这组的 <strong>leader</strong>；</li><li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候<strong>LSN也变成了160</strong>；</li><li>trx1去写盘的时候，带的就是LSN&#x3D;160，因此<strong>等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘</strong>；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p><p>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p><h3 id="细化两阶段提交"><a href="#细化两阶段提交" class="headerlink" title="细化两阶段提交"></a>细化两阶段提交</h3><p>为了让一次fsync带的组员更多，MySQL有一个很有趣的优化：拖时间。在介绍两阶段提交的时候，我曾经给你画了一个图，现在我把它截过来。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20231005202355961.png" alt="image-20231005202355961" style="zoom:50%"><p>​ 图4 两阶段提交</p><p>图中，我把“写binlog”当成一个动作。但实际上，写binlog是分成两步的：</p><ol><li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li><li>调用fsync持久化。</li></ol><p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20231005202444056.png" alt="image-20231005202444056" style="zoom:50%"><p>​ 图5 两阶段提交细化</p><p>这么一来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。</p><h3 id="提升binlog组提交效果"><a href="#提升binlog组提交效果" class="headerlink" title="提升binlog组提交效果"></a>提升binlog组提交效果</h3><p>不过通常情况下第3步执行得会很快，所以<strong>binlog的write和fsync间的间隔时间短</strong>，导致能集合到一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。</p><p>如果你想<strong>提升binlog组提交的效果</strong>，可以通过设置 <strong>binlog_group_commit_sync_delay</strong> 和 <strong>binlog_group_commit_sync_no_delay_count</strong>来实现。</p><ol><li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个条件<strong>是或的关系</strong>，也就是说只要有一个满足条件就会调用fsync。</p><p>所以，当binlog_group_commit_sync_delay设置为0的时候，binlog_group_commit_sync_no_delay_count也无效了。</p><blockquote><p>这两个参数还可以在26讲 MySQL5.7方案中，用来制造更多的“同时处于prepare阶段的事务”。这样就增加了备库复制的并行度</p></blockquote><p>之前有同学在评论区问到，WAL机制是减少磁盘写，可是每次提交事务都要写redo log和binlog，这磁盘读写次数也没变少呀？</p><p>现在你就能理解了，WAL机制主要得益于两个方面：</p><ol><li>redo log 和 binlog都是<strong>顺序写</strong>，磁盘的顺序写比随机写速度要快；</li><li><strong>组提交机制</strong>，可以大幅度<strong>降低磁盘的IOPS消耗</strong>。</li><li>WAL避免了直接修改页的修改数据量和读取页的数据量严重不成比例</li></ol><p>分析到这里，我们再来回答这个问题：<strong>如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</strong></p><p>针对这个问题，可以考虑以下三种方法：</p><ol><li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。</li></ol><p>我不建议你把innodb_flush_log_at_trx_commit 设置成0。因为把这个参数设置成0，表示redo log只保存在内存中，这样的话MySQL本身异常重启也会丢数据，风险太大。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置成0其实性能差不多，但这样做MySQL异常重启时就不会丢数据了，相比之下风险会更小。</p><h1 id="24-MySQL主备流程"><a href="#24-MySQL主备流程" class="headerlink" title="24 MySQL主备流程"></a>24 MySQL主备流程</h1><h2 id="MySQL主备的基本原理"><a href="#MySQL主备的基本原理" class="headerlink" title="MySQL主备的基本原理"></a>MySQL主备的基本原理</h2><p>如图1所示就是基本的主备切换流程。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231007142153070.png" alt="image-20231007142153070"></p><p>​ 图 1 MySQL主备切换流程</p><p>在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</p><p>当需要切换的时候，就切成状态2。这时候客户端读写访问的都是节点B，而节点A是B的备库。</p><h3 id="备库设置为readonly的好处"><a href="#备库设置为readonly的好处" class="headerlink" title="备库设置为readonly的好处"></a>备库设置为readonly的好处</h3><p>在状态1中，虽然节点B没有被直接访问，但是我依然建议你把节点B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p><blockquote><ol><li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以<strong>防止误操作</strong>；</li><li><strong>防止切换逻辑有bug</strong>，比如切换过程中出现双写，造成主备不一致；</li><li>可以用readonly状态，来<strong>判断节点的角色</strong>。</li></ol></blockquote><p>你可能会问，我把备库设置成只读了，还怎么跟主库保持同步更新呢？</p><p>这个问题，你不用担心。因为<strong>readonly设置对超级(super)权限用户是无效的</strong>，而用于同步更新的线程，就拥有超级权限。</p><h3 id="主从复制的详细流程"><a href="#主从复制的详细流程" class="headerlink" title="主从复制的详细流程"></a>主从复制的详细流程</h3><p>接下来，我们再看看<strong>节点A到B这条线的内部流程是什么样的</strong>。图2中画出的就是一个update语句在节点A执行，然后同步到节点B的完整流程图。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img" style="zoom:50%"><p>​ 图2 主备流程图</p><p>图2中，包含了我在上一篇文章中讲到的binlog和redo log的写入机制相关的内容，可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。</p><p>备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：</p><ol><li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始<strong>请求binlog</strong>，这个位置包含文件名和日志偏移量。</li><li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中<strong>io_thread负责与主库建立连接</strong>。</li><li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li><li>备库B拿到binlog后，写到本地文件，称为<strong>中转日志</strong>（relay log）。</li><li>sql_thread读取中转日志，解析出日志里的命令，<strong>并执行</strong>。</li></ol><p>这里需要说明，后来由于多线程复制方案的引入，<strong>sql_thread演化成为了多个线程</strong>，跟我们今天要介绍的原理没有直接关系，暂且不展开。</p><p>分析完了这个长连接的逻辑，我们再来看一个问题：binlog里面到底是什么内容，为什么备库拿过去可以直接执行。</p><h2 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h2><p>我在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73161">第15篇答疑文章</a>中，和你提到过binlog有两种格式，一种是statement，一种是row。可能你在其他资料上还会看到有第三种格式，叫作mixed，其实它就是前两种格式的混合。</p><p>为了便于描述binlog的这三种格式间的区别，我创建了一个表，并初始化几行数据。如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的。</p><p>注意，下面这个语句包含注释，如果你用MySQL客户端来做这个实验的话，要记得加**-c**参数，否则客户端会自动去掉注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from t /*comment*/  where a&gt;=4 and t_modified&lt;=&#x27;2018-11-10&#x27; limit 1;</span><br></pre></td></tr></table></figure><p>当binlog_format&#x3D;statement时，binlog里面记录的就是SQL语句的原文。你可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;master.000001&#x27;;</span><br></pre></td></tr></table></figure><p>命令看binlog中的内容。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/b9818f73cd7d38a96ddcb75350b52931.png" alt="img"></p><p>​ 图3 statement格式binlog 示例</p><p>现在，我们来看一下图3的输出结果。</p><ul><li>第一行SET @@SESSION.GTID_NEXT&#x3D;’ANONYMOUS’你可以先忽略，后面文章我们会在介绍主备切换的时候再提到；</li><li>第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务；</li><li>第三行就是真实执行的语句了。可以看到，在真实执行的delete命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是MySQL根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到test库的表t。<br>use ‘test’命令之后的delete 语句，就是我们输入的SQL原文了。可以看到，binlog“忠实”地记录了SQL命令，甚至连注释也一并记录了。</li><li>最后一行是一个COMMIT。你可以看到里面写着<strong>xid&#x3D;61</strong>。用于<strong>验证binlog的完整性</strong>和<strong>关联redo log和binlog</strong></li></ul><p>为了说明statement 和 row格式的区别，我们来看一下这条delete命令的执行效果图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/96c2be9c0fcbff66883118526b26652b.png" alt="img"></p><p>​ 图4 delete执行warnings</p><p>可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格式，并且语句中有limit，所以这个命令可能是<strong>unsafe</strong>的。</p><p>为什么这么说呢？这是因为delete <strong>带limit，很可能会出现主备数据不一致的情况</strong>。比如上面这个例子：</p><ol><li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a&#x3D;4这一行；</li><li>但如果使用的是索引t_modified，那么删除的就是 t_modified&#x3D;’2018-11-09’也就是a&#x3D;5这一行。</li></ol><p>由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库执行这条SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引t_modified。因此，MySQL认为这样写是有风险的。</p><p>那么，如果我把binlog的格式改为binlog_format&#x3D;‘row’， 是不是就没有这个问题了呢？我们先来看看这时候binog中的内容吧。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d67a38db154afff610ae3bb64e266826.png" alt="img"></p><p>​ 图5 row格式binlog 示例</p><p>可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。但是，row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows。</p><ol><li>Table_map event，用于说明接下来要操作的表是test库的表t;</li><li>Delete_rows event，用于定义删除的行为。</li></ol><p>其实，我们通过图5是看不到详细信息的，还需要借助mysqlbinlog工具，用下面这个命令解析和查看binlog中的内容。因为图5中的信息显示，这个事务的binlog是从8900这个位置开始的，所以可以用start-position参数来指定从这个位置的日志开始解析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog  -vv data/master.000001 --start-position=8900;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/c342cf480d23b05d30a294b114cebfc2.png" alt="img"></p><p>​ 图6 row格式binlog 示例的详细信息</p><p>从这个图中，我们可以看到以下几个信息：</p><ul><li>server id 1，表示这个事务是在server_id&#x3D;1的这个库上执行的。</li><li>每个event都有CRC32的值，这是因为我把参数binlog_checksum设置成了CRC32。</li><li>Table_map event跟在图5中看到的相同，显示了接下来要打开的表，map到数字226。现在我们这条SQL语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。</li><li>我们在mysqlbinlog的命令中，使用了**-vv参数是为了把内容都解析出来**，所以从结果里面可以看到各个字段的值（比如，@1&#x3D;4、 @2&#x3D;4这些值）。</li><li><strong>binlog_row_image的默认配置是FULL</strong>，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为<strong>MINIMAL</strong>，则只会记录必要的信息，在这个例子里，就是只会记录id&#x3D;4这个信息。</li><li>最后的<strong>Xid event</strong>，用于表示事务被正确地提交了。</li></ul><p>你可以看到，当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样binlog传到备库去的时候，就肯定会删除id&#x3D;4的行，不会有主备删除不同行的问题。</p><h3 id="为什么会有mixed格式的binlog？"><a href="#为什么会有mixed格式的binlog？" class="headerlink" title="为什么会有mixed格式的binlog？"></a>为什么会有mixed格式的binlog？</h3><p>基于上面的信息，我们来讨论一个问题：<strong>为什么会有mixed这种binlog格式的存在场景？</strong>推论过程是这样的：</p><ul><li>因为有些<strong>statement格式的binlog可能会导致主备不一致</strong>，所以要使用row格式。</li><li>但<strong>row格式的缺点是，很占空间</strong>。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</li><li>所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</li></ul><p>也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。</p><p>因此，如果你的线上MySQL设置的binlog格式是statement的话，那基本上就可以认为这是一个不合理的设置。你至少应该把binlog的格式设置为mixed。</p><p>比如我们这个例子，设置为mixed后，就会记录为row格式；而如果执行的语句去掉limit 1，就会记录为statement格式。</p><p>当然我要说的是，现在<strong>越来越多的场景要求把MySQL的binlog格式设置成row</strong>。这么做的理由有很多，我来给你举一个可以直接看出来的好处：<strong>恢复数据</strong>。</p><p>接下来，我们就分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题。</p><p>通过图6你可以看出来，即使我执行的是delete语句，row格式的binlog也会把被删掉的行的整行信息保存起来。所以，如果你在执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。</p><p>如果你是执行错了insert语句呢？那就更直接了。row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把insert语句转成delete语句，删除掉这被误插入的一行数据就可以了。</p><p>如果执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了update语句的话，只需要把这个event前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。</p><p>其实，由delete、insert或者update语句导致的数据操作错误，需要恢复到操作之前状态的情况，也时有发生。MariaDB的<a target="_blank" rel="noopener" href="https://mariadb.com/kb/en/library/flashback/">Flashback</a>工具就是基于上面介绍的原理来回滚数据的。</p><p>虽然mixed格式的binlog现在已经用得不多了，但这里我还是要再借用一下mixed格式来说明一个问题，来看一下这条SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t values(10,10, now());</span><br></pre></td></tr></table></figure><p>如果我们把binlog格式设置为mixed，你觉得MySQL会把它记录为row格式还是statement格式呢？</p><p>先不要着急说结果，我们一起来看一下这条语句执行的效果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/0150301698979255a6f27711c35e9eef.png" alt="img"></p><p>​ 图7 mixed格式和now()</p><p>可以看到，MySQL用的居然是statement格式。你一定会奇怪，如果这个binlog过了1分钟才传给备库的话，那主备的数据不就不一致了吗？</p><p>接下来，我们再用mysqlbinlog工具来看看：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/1ad3a4c4b9a71955edba5195757dd041.png" alt="img"></p><p>​ 图8 TIMESTAMP 命令</p><p>从图中的结果可以看到，原来binlog在记录event的时候，多记了一条命令：<strong>SET TIMESTAMP&#x3D;1546103491</strong>。它<strong>用 SET TIMESTAMP命令约定了接下来的now()函数的返回时间</strong>。</p><p>因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备份，这个insert语句插入的行，值都是固定的。也就是说，通过这条SET TIMESTAMP命令，MySQL就确保了主备数据的一致性。</p><p>我之前看过有人在重放binlog数据的时候，是这么做的：用mysqlbinlog解析出日志，然后把里面的statement语句直接拷贝出来执行。</p><p>你现在知道了，这个方法是有风险的。因为有些语句的执行结果是依赖于上下文命令的，直接执行的结果很可能是错误的。</p><h3 id="使用binlog恢复数据的命令"><a href="#使用binlog恢复数据的命令" class="headerlink" title="使用binlog恢复数据的命令"></a>使用binlog恢复数据的命令</h3><p>所以，用binlog来恢复数据的标准做法是，用 mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行。类似下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog master.000001  --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span><br></pre></td></tr></table></figure><p>这个命令的意思是，将 master.000001 文件里面从第2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p><h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>通过上面对MySQL中binlog基本内容的理解，你现在可以知道，binlog的特性确保了在备库执行相同的binlog，可以得到与主库相同的状态。</p><p>因此，我们可以认为正常情况下主备的数据是一致的。也就是说，图1中A、B两个节点的内容是一致的。其实，图1中我画的是M-S结构，但实际生产上使用比较多的是双M结构，也就是图9所示的主备切换流程。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231007143221323.png" alt="image-20231007143221323"></p><p>​ 图 9 MySQL主备切换流程–双M结构</p><p>对比图9和图1，你可以发现，双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p><p>但是，双M结构还有一个问题需要解决。</p><p>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新语句后也会生成binlog。（我建议你把参数log_slave_updates设置为on，表示备库执行relay log后生成binlog）。</p><p>那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</p><p><strong>解决方法：</strong></p><p>从上面的图6中可以看到，MySQL在binlog中记录了这个命令第一次执行时所在实例的server id。因此，我们可以用下面的逻辑，来<strong>解决</strong>两个节点间的循环复制的问题：</p><ol><li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到binlog并在重放的过程中，<strong>生成与原binlog的server id相同的新的binlog</strong>；</li><li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的<strong>相同</strong>，表示这个日志是自己生成的，就直接<strong>丢弃</strong>这个日志。</li></ol><p>按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p><ol><li>从节点A更新的事务，binlog里面记的都是A的server id；</li><li>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</li><li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ol><blockquote><p>仍然有可能出现循环赋值的场景：</p><ul><li>一种场景是，在一个主库更新事务后，用命令set global server_id&#x3D;x<strong>修改了server_id</strong>。等日志再传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。</li><li>另一种场景是，有三个节点的时候，如图7所示，<strong>trx1是在节点 B执行的</strong>，因此binlog上的server_id就是B，binlog传给节点 A，然后<strong>A和A’搭建了双M结构，就会出现循环复制</strong>。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231007143448050.png" alt="image-20231007143448050"></p><p>​ 图7 三节点循环复制</p><p>这种三节点复制的场景，做数据库迁移的时候会出现。</p><p><strong>解决：</strong></p><p>如果出现了循环复制，可以在A或者A’上，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER TO IGNORE_SERVER_IDS=(server_id_of_B);</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>这样这个节点收到日志后就不会再执行。过一段时间后，再执行下面的命令把这个值改回来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER TO IGNORE_SERVER_IDS=();</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></blockquote><h1 id="25-MySQL主备切换策略"><a href="#25-MySQL主备切换策略" class="headerlink" title="25 MySQL主备切换策略"></a>25 MySQL主备切换策略</h1><p>在上一篇文章中，我和你介绍了binlog的基本内容，在一个主备关系中，每个备库接收主库的binlog并执行。</p><p>正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是<strong>最终一致性</strong>。</p><p>但是，<strong>MySQL要提供高可用能力，只有最终一致性是不够的</strong>。为什么这么说呢？今天我就着重和你分析一下。</p><p>这里，我再放一次上一篇文章中讲到的双M结构的主备切换流程图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231007144319772.png" alt="image-20231007144319772"></p><p>​ 图 1 MySQL主备切换流程–双M结构</p><h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><p>主备切换可能是一个<strong>主动运维动作</strong>，比如软件升级、主库所在机器按计划下线等，<strong>也可能是被动操作，比如主库所在机器掉电</strong>。</p><p>接下来，我们先一起看看<strong>主动切换</strong>的场景。</p><p>在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即<strong>“同步延迟”</strong>。与数据同步有关的时间点主要包括以下三个：</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓<strong>主备延迟</strong>，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是<strong>T3-T1</strong>。</p><p>你可以在备库上执行<strong>show slave status</strong>命令，它的返回结果里面会显示<strong>seconds_behind_master</strong>，用于表示当前备库延迟了多少秒。</p><p>seconds_behind_master的计算方法是这样的：</p><ol><li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li></ol><p>可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。</p><p>你可能会问，如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？</p><p>其实不会的。因为，备库连接到主库的时候，会通过执行**SELECT UNIX_TIMESTAMP()**函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。</p><p>需要说明的是，在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p>所以说，<strong>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢</strong>。接下来，我就和你一起分析下，这可能是由哪些原因导致的。</p><h3 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h3><ol><li>备库所在机器的性能要比主库所在的机器性能差</li><li>备库的压力大</li><li>大事务</li><li>备库的并行复制能力</li></ol><p><strong>首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</strong></p><p>一般情况下，有人这么部署时的想法是，反正备库没有请求，所以可以用差一点儿的机器。或者，他们会把20个主库放在4台机器上，而把备库集中在一台机器上。</p><p>其实我们都知道，更新请求对IOPS的压力，在主库和备库上是无差别的。所以，做这种部署时，一般都会将备库设置为<strong>“非双1”</strong>的模式。</p><p>但实际上，更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。</p><p>当然，这种部署现在比较少了。因为主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况。</p><p>追问1：但是，做了对称部署以后，还可能会有延迟。这是为什么呢？</p><p>这就是<strong>第二种常见的可能了，即备库的压力大</strong>。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。</p><p>我真就见过不少这样的情况。由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p><p>这种情况，我们一般可以这么处理：</p><ol><li><strong>一主多从</strong>。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ol><p>其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。</p><blockquote><p>备注：这里需要说明一下，从库和备库在概念上其实差不多。在我们这个专栏里，为了方便描述，我把会在HA过程中被选成新主库的，称为备库，其他的称为从库。</p></blockquote><p>追问2：采用了一主多从，保证备库的压力不会超过主库，还有什么情况可能导致主备延迟吗？</p><p><strong>这就是第三种可能了，即大事务。</strong></p><p>大事务这种情况很好理解。因为主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟。</p><p>不知道你所在公司的DBA有没有跟你这么说过：不要<strong>一次性地用delete语句删除太多数据</strong>。其实，这就是一个典型的大事务场景。</p><p>比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作。</p><p>结果，负责的DBA同学半夜就会收到延迟报警。然后，DBA团队就要求你后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p><p><strong>另一种典型的大事务场景，就是大表DDL。</strong>这个场景，我在前面的文章中介绍过。处理方案就是，计划内的DDL，建议使用gh-ost方案（这里，你可以再回顾下第13篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/72388">《为什么表数据删掉一半，表文件大小不变？》</a>中的相关内容）。</p><p>追问3：如果主库上也不做大事务了，还有什么原因会导致主备延迟吗？</p><p>造成主备延迟还有一个大方向的原因，就是<strong>备库的并行复制能力</strong>。这个话题，我会留在下一篇文章再和你详细介绍。</p><p>其实还是有不少其他情况会导致主备延迟，如果你还碰到过其他场景，欢迎你在评论区给我留言，我来和你一起分析、讨论。</p><p>由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。</p><h2 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h2><p>在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：</p><ol><li>判断备库B现在的seconds_behind_master，如果<strong>小于某个值（比如5秒）继续下一步</strong>，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly设置为true；</li><li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231007144334670.png" alt="image-20231007144334670"></p><p>​ 图2 MySQL可靠性优先主备切换流程</p><p>备注：图中的SBM，是seconds_behind_master参数的简写。</p><p>可以看到，这个切换流程中是有不可用时间的。因为<strong>在步骤2之后，主库A和备库B都处于readonly状态，也就是说这时系统处于不可写状态</strong>，直到步骤5完成后才能恢复。</p><p>在这个不可用状态中，<strong>比较耗费时间的是步骤3</strong>，可能需要耗费好几秒的时间。<strong>这也是为什么需要在步骤1先做判断</strong>，确保seconds_behind_master的值足够小。</p><p>试想如果一开始主备延迟就长达30分钟，而不先做判断直接切换的话，系统的不可用时间就会长达30分钟，这种情况一般业务都是不可接受的。</p><p>当然，系统的不可用时间，是由这个数据可靠性优先的策略决定的。你也可以选择可用性优先的策略，来把这个不可用时间几乎降为0。</p><h2 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h2><p>如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。</p><p>我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p><p>接下来，我就和你分享一个可用性优先流程产生数据不一致的例子。假设有一个表 t：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `c` int(11) unsigned DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t(c) values(1),(2),(3);</span><br></pre></td></tr></table></figure><p>这个表定义了一个自增主键id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员要继续在表t上执行两条插入语句的命令，依次是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t(c) values(4);</span><br><span class="line">insert into t(c) values(5);</span><br></pre></td></tr></table></figure><p>假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到5秒。在插入一条c&#x3D;4的语句后，发起了主备切换。</p><p>图3是<strong>可用性优先策略，且binlog_format&#x3D;mixed</strong>时的切换流程和数据结果。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/3786bd6ad37faa34aca25bf1a1d8af3a.png" alt="img" style="zoom:50%"><p>​ 图3 可用性优先策略，且binlog_format&#x3D;mixed</p><p>现在，我们一起分析下这个切换流程：</p><ol><li>步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。</li><li>步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c&#x3D;4”这个中转日志，就开始接收客户端“插入 c&#x3D;5”的命令。</li><li>步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。</li><li>步骤5中，备库B执行“插入c&#x3D;4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c&#x3D;5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li></ol><p>最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个<strong>数据不一致</strong>，是由可用性优先流程导致的。</p><p>那么，如果我还是用<strong>可用性优先策略，但设置binlog_format&#x3D;row</strong>，情况又会怎样呢？</p><p>因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。</p><p>图4中我画出了详细过程，你可以自己再分析一下。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/b8d2229b2b40dd087fd3b111d1bdda43.png" alt="img" style="zoom:50%"><p>​ 图4 可用性优先策略，且binlog_format&#x3D;row</p><p>从上面的分析中，你可以看到一些结论：</p><ol><li><strong>使用row格式的binlog时，数据不一致的问题更容易被发现</strong>。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li><li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li></ol><h2 id="哪种情况选择可用性优先策略"><a href="#哪种情况选择可用性优先策略" class="headerlink" title="哪种情况选择可用性优先策略"></a>哪种情况选择可用性优先策略</h2><p>但事无绝对，<strong>有没有哪种情况数据的可用性优先级更高呢？</strong></p><p>答案是，有的。</p><p>我曾经碰到过这样的一个场景：</p><ul><li><strong>有一个库的作用是记录操作日志</strong>。这时候，如果数据不一致可以通过binlog来修补，而这个短暂的不一致也不会引发业务问题。</li><li>同时，<strong>业务系统依赖于这个日志写入逻辑</strong>，如果这个库不可写，会导致线上的业务操作无法执行。</li></ul><p>这时候，你可能就需要选择先强行切换，<strong>事后再补数据的策略</strong>。</p><p><strong>改进措施：</strong></p><p>当然，事后复盘的时候，我们想到了一个改进措施就是，<strong>让业务逻辑不要依赖于这类日志的写入</strong>。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临时库里面。</p><p>这样的话，这种场景就又可以使用可靠性优先策略了。</p><p>接下来我们再看看，<strong>按照可靠性优先的思路，异常切换会是什么效果？</strong></p><p>假设，主库A和备库B间的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主库。我们在主动切换的时候，可以等到主备延迟小于5秒的时候再启动切换，但这时候已经别无选择了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231007144348654.png" alt="image-20231007144348654"></p><p>​ 图5 可靠性优先策略，主库不可用</p><p>采用可靠性优先策略的话，你就必须得等到备库B的seconds_behind_master&#x3D;0之后，才能切换。但现在的情况比刚刚更严重，并不是系统只读、不可写的问题了，而是系统处于完全不可用的状态。因为，主库A掉电后，我们的连接还没有切到备库B。</p><p>你可能会问，那能不能直接切换到备库B，但是保持B只读呢？</p><p>这样也不行。</p><p>因为，这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前执行完成的事务，会认为有“数据丢失”。</p><p>虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢失数据的状态”也是不能被接受的。</p><p>聊到这里你就知道了，<strong>在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的</strong>。<strong>延迟的时间越小</strong>，在主库故障的时候，服务恢复需要的时间就越短，<strong>可用性就越高</strong>。</p><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>一般现在的数据库运维系统都有备库延迟监控，其实就是在备库上执行 show slave status，采集seconds_behind_master的值。</p><p>假设，现在你看到你维护的一个备库，它的延迟监控的图像类似图6，是一个45°斜向上的线段，你觉得可能是什么原因导致呢？你又会怎么去确认这个原因呢？</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231007145533901.png" alt="image-20231007145533901"></p><p>看这曲线,应该是从库正在应用一个<strong>大事务</strong>,或者一个大表上无主键的情况(有该表的更新)<br>应该是T3随着时间的增长在增长,而T1这个时间点是没变的,造成的现象就是<br>随着时间的增长,second_behind_master也是有规律的增长</p><h1 id="26-MySQL备库的并行复制能力"><a href="#26-MySQL备库的并行复制能力" class="headerlink" title="26 MySQL备库的并行复制能力"></a>26 MySQL备库的并行复制能力</h1><h2 id="备库的并行复制能力"><a href="#备库的并行复制能力" class="headerlink" title="备库的并行复制能力"></a>备库的并行复制能力</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/1a85a3bac30a32438bfd8862e5a34eef-169673606207815.png" alt="img" style="zoom:50%"><p>​ 图1 主备流程图</p><p>谈到主备的<strong>并行复制能力</strong>，我们要关注的是图中<strong>黑色的两个箭头</strong>。一个箭头代表了客户端写入主库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如图1所示，<strong>第一个箭头要明显粗于第二个箭头</strong>。</p><p>在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。</p><p>而日志在备库上的执行，就是图中备库上<strong>sql_thread</strong>更新数据(DATA)的逻辑。<strong>如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟</strong>。</p><p><strong>在官方的5.6版本之前，MySQL只支持单线程复制</strong>，由此在主库并发高、TPS高时就会出现严重的主备延迟问题。</p><h2 id="从库实现并行复制的思路"><a href="#从库实现并行复制的思路" class="headerlink" title="从库实现并行复制的思路"></a>从库实现并行复制的思路</h2><p>从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说MySQL多线程复制的演进过程。</p><p>其实说到底，所有的多线程复制机制，都是要把图1中只有一个线程的sql_thread，拆成多个线程，也就是都符合下面的这个模型：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/bcf75aa3b0f496699fd7885426bc6245-169673606207917.png" alt="img" style="zoom:50%"><p>​ 图2 多线程模型</p><p>图2中，<strong>coordinator就是原来的sql_thread</strong>, 不过现在它不再直接更新数据了，只<strong>负责读取中转日志和分发事务</strong>。<strong>真正更新日志的，变成了worker线程</strong>。而work线程的个数，就是由参数<strong>slave_parallel_workers</strong>决定的。根据我的经验，把这个值设置为<strong>8~16之间最好（32核物理机</strong>（1&#x2F;4~1&#x2F;2）的情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。（我的8核默认值是4）</p><p>接下来，你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个事务分给worker_1，第二个事务发给worker_2呢？</p><p>其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，<strong>由于CPU的调度策略，很可能第二个事务最终比第一个事务先执行</strong>。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。</p><p>接下来，请你再设想一下另外一个问题：同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p><p>答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。</p><p>所以，<strong>coordinator在分发的时候，需要满足以下这两个基本要求</strong>：</p><ol><li>不能造成更新覆盖。这就要求<strong>更新同一行的两个事务，必须被分发到同一个worker中</strong>。</li><li><strong>同一个事务不能被拆开</strong>，必须放到同一个worker中。</li></ol><p>各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策略。</p><h2 id="MySQL-5-5版本的并行复制策略（作者自写）"><a href="#MySQL-5-5版本的并行复制策略（作者自写）" class="headerlink" title="MySQL 5.5版本的并行复制策略（作者自写）"></a>MySQL 5.5版本的并行复制策略（作者自写）</h2><p><strong>官方MySQL 5.5版本是不支持并行复制的</strong>。但是，在2012年的时候，我自己服务的业务出现了严重的主备延迟，原因就是备库只有单线程复制。然后，我就先后写了两个版本的并行策略。</p><p>这里，我给你介绍一下这两个版本的并行策略，即按表分发策略和按行分发策略，以帮助你理解MySQL官方版本并行复制策略的迭代。</p><h3 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。<strong>因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行</strong>。</p><p>当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图3所示，就是按表分发的规则。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/8b6976fedd6e644022d4026581fb8d76-169673606207919.png" alt="img" style="zoom:50%"><p>​ 图3 按表并行复制程模型</p><p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“<strong>库名.表名</strong>”，value是一个数字，表示队列中有多少个事务修改这个表。</p><p>在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p><p>图3中，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，有1个事务涉及到db2.t2表；hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数据。</p><p>假设在图中的情况下，coordinator从中转日志中读入一个<strong>新事务T</strong>，这个事务修改的行涉及到<strong>表t1和t3</strong>。</p><p>现在我们用事务T的分配流程，来看一下分配规则。</p><ol><li>由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事务要修改同一个表的数据，这种情况我们说事务T和worker_1是冲突的。</li><li>按照这个逻辑，顺序判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突。</li><li><strong>事务T跟多于一个worker冲突，coordinator线程就进入等待</strong>。</li><li>每个worker继续执行，同时修改hash_table。假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉。</li><li>这样coordinator会发现跟事务T冲突的worker只有worker_1了，因此就把它分配给worker_1。</li><li>coordinator继续读下一个中转日志，继续分配事务。</li></ol><p>也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下<strong>三种情况</strong>：</p><ol><li>如果<strong>跟所有worker都不冲突</strong>，coordinator线程就会把这个事务分配给最空闲的woker;</li><li>如果<strong>跟多于一个worker冲突</strong>，coordinator线程就<strong>进入等待</strong>状态，直到和这个事务存在冲突关系的worker<strong>只剩下1个</strong>；</li><li>如果<strong>只跟一个worker冲突</strong>，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。</li></ol><p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，<strong>如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了</strong>。</p><h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，<strong>这个模式要求binlog格式必须是row</strong>。</p><p>这时候，我们判断一个事务T和worker是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p><p>按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+唯一键的值”。</p><p>但是，这个“唯一键”只有主键id还是不够的，我们还需要考虑下面这种场景，表t1中除了主键，还有唯一索引a：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t1` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `a` (`a`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);</span><br></pre></td></tr></table></figure><p>假设，接下来我们要在主库执行这两个事务：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/f19916e27b8ff28e87ed3ad9f5473378-169673606207921.png" alt="img"></p><p>​ 图4 唯一键冲突示例</p><p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能session B的语句先执行。这时候id&#x3D;1的行的a的值还是1，就会报唯一键冲突。</p><p>因此，基于行的策略，事务hash表中还需要考虑唯一键，即key应该是“<strong>库名+表名+索引a的名字+a的值</strong>”。</p><p>比如，在上面这个例子中，我要在表t1上执行update t1 set a&#x3D;1 where id&#x3D;2语句，在binlog里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p><p>因此，coordinator在解析这个语句的binlog的时候，这个事务的hash表就有三个项:</p><ol><li>key&#x3D;hash_func(db1+t1+“PRIMARY”+2), value&#x3D;2; 这里value&#x3D;2是因为修改前后的行id值不变，出现了两次。</li><li>key&#x3D;hash_func(db1+t1+“a”+2), value&#x3D;1，表示会影响到这个表a&#x3D;2的行。</li><li>key&#x3D;hash_func(db1+t1+“a”+1), value&#x3D;1，表示会影响到这个表a&#x3D;1的行。</li></ol><p>可见，<strong>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</strong></p><h3 id="这两种方式的缺点和解决方法"><a href="#这两种方式的缺点和解决方法" class="headerlink" title="这两种方式的缺点和解决方法"></a>这两种方式的缺点和解决方法</h3><p>你可能也发现了，这<strong>两个方案</strong>其实都有一些<strong>约束条件</strong>：</p><ol><li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，<strong>主库的binlog格式必须是row</strong>；</li><li>表必须有<strong>主键</strong>；</li><li><strong>不能有外键</strong>。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。</li></ol><p>但，好在这三条约束规则，本来就是DBA之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。</p><p>对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，<strong>按行分发</strong>的策略有<strong>两个问题</strong>：</p><ol><li><strong>耗费内存</strong>。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。</li><li><strong>耗费CPU</strong>。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。</li></ol><p>所以，我在实现这个策略的时候会<strong>设置一个阈值</strong>，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过10万行），就暂时<strong>退化为单线程模式</strong>，退化过程的逻辑大概是这样的：</p><ol><li>coordinator暂时先hold住这个事务；</li><li>等待所有worker都执行完成，变成空队列；</li><li>coordinator直接执行这个事务；</li><li>恢复并行模式。</li></ol><p>读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。</p><h2 id="MySQL-5-6版本的并行复制策略"><a href="#MySQL-5-6版本的并行复制策略" class="headerlink" title="MySQL 5.6版本的并行复制策略"></a>MySQL 5.6版本的并行复制策略</h2><p>官方<strong>MySQL5.6</strong>版本，支持了并行复制，只是支持的粒度是<strong>按库并行</strong>。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的hash表里，<strong>key就是数据库名</strong>。</p><p>这个策略的并行效果，取决于压力模型。<strong>如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好</strong>。</p><p>相比于按表和按行分发，这个策略有<strong>两个优势</strong>：</p><ol><li><strong>构造hash值的时候很快，只需要库名</strong>；而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况。</li><li><strong>不要求binlog的格式</strong>。因为statement格式的binlog也可以很容易拿到库名。</li></ol><p>但是，<strong>如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了</strong>；或者如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p><p>理论上你可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。</p><h2 id="MariaDB的并行复制策略"><a href="#MariaDB的并行复制策略" class="headerlink" title="MariaDB的并行复制策略"></a>MariaDB的并行复制策略</h2><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/76161">第23篇文章</a>中，我给你介绍了redo log<strong>组提交(group commit)优化</strong>， 而MariaDB的并行复制策略利用的就是这个特性：</p><ol><li>能够在<strong>同一组里提交的事务，一定不会修改同一行</strong>；</li><li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li></ol><p>在实现上，MariaDB是这么做的：</p><ol><li>在一组里面一起提交的事务，有一个<strong>相同的commit_id</strong>，下一组就是commit_id+1；</li><li>commit_id直接写到binlog里面；</li><li>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</li><li>这一组<strong>全部执行完成后</strong>，coordinator<strong>再</strong>去取下一批。</li></ol><p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析binlog，并拆分到worker”上。而MariaDB的这个策略，目标是“模拟主库的并行模式”。</p><p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。<strong>在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</strong></p><p>如图5所示，假设了三组事务在主库的执行情况，你可以看到在trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/8fec5fb48d6095aecc80016826efbfc3-169673606207923.png" alt="img" style="zoom:50%"><p>​ 图5 主库并行事务</p><p>而按照MariaDB的并行复制策略，备库上的执行效果如图6所示。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/8ac3799c1ff2f9833619a1624ca3e622-169673606207925.png" alt="img" style="zoom:50%"><p>​ 图6 MariaDB 并行复制，备库并行效果</p><p>可以看到，<strong>在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行</strong>，这样系统的吞吐量就不够。</p><p>另外，这个方案<strong>很容易被大事务拖后腿</strong>。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，<strong>只有一个worker线程在工作</strong>，是对资源的浪费。</p><p>不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p><h2 id="MySQL-5-7的并行复制策略"><a href="#MySQL-5-7的并行复制策略" class="headerlink" title="MySQL 5.7的并行复制策略"></a>MySQL 5.7的并行复制策略</h2><p>在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数<strong>slave_parallel_type</strong>来控制并行复制策略：</p><ol><li>配置为<strong>DATABASE</strong>，表示使用MySQL 5.6版本的<strong>按库并行</strong>策略；</li><li>配置为 <strong>LOGICAL_CLOCK</strong>（默认），表示的就是<strong>类似MariaDB的策略</strong>。不过，MySQL 5.7这个策略，针对并行度<strong>做了优化</strong>。这个优化的思路也很有趣儿。</li></ol><p>你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？</p><p>答案是，不能。</p><p>因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的worker，就会出现备库跟主库不一致的情况。</p><p>而上面提到的MariaDB这个策略的核心，是<strong>“所有处于commit”状态的事务可以并行。事务处于commit状态，表示已经通过了锁冲突的检验了</strong>。</p><p>这时候，你可以再回顾一下两阶段提交，我把前面<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/76161">第23篇文章</a>中介绍过的两阶段提交过程图贴过来。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/5ae7d074c34bc5bd55c82781de670c28-169673606208027.png" alt="img" style="zoom:50%"><p>​ 图7 两阶段提交细化过程图</p><p>其实，不用等到commit阶段，<strong>只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突的检验了</strong>。</p><p>因此，MySQL 5.7并行复制策略的思想是：</p><ol><li><strong>同时处于prepare状态的事务，在备库执行时是可以并行的；</strong></li><li>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。</li></ol><p>我在第23篇文章，讲binlog的组提交的时候，介绍过两个参数：</p><ol><li><strong>binlog_group_commit_sync_delay</strong>参数，表示延迟多少微秒后才调用fsync;</li><li><strong>binlog_group_commit_sync_no_delay_count</strong>参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个参数是用于故意拉长binlog从write到fsync的时间，以此<strong>减少binlog的写盘次数</strong>。在MySQL 5.7的并行复制策略里，它们可以用来<strong>制造更多的“同时处于prepare阶段的事务”</strong>。这样就<strong>增加了备库复制的并行度</strong>。</p><p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p><h2 id="MySQL-5-7-22的并行复制策略"><a href="#MySQL-5-7-22的并行复制策略" class="headerlink" title="MySQL 5.7.22的并行复制策略"></a>MySQL 5.7.22的并行复制策略</h2><p>在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于WRITESET的并行复制。</p><p>相应地，新增了一个参数<strong>binlog_transaction_dependency_tracking</strong>，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p><ol><li><strong>COMMIT_ORDER</strong>(默认)，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略，即LOGICAL_CLOCK。</li><li><strong>WRITESET</strong>，表示的是对于事务涉及更新的<strong>每一行</strong>，计算出这一行的<strong>hash值</strong>，<strong>组成集合writeset</strong>。如果两个事务没有操作相同的行，也就是说它们的writeset<strong>没有交集，就可以并行</strong>。</li><li><strong>WRITESET_SESSION</strong>，是在WRITESET的基础上多了一个约束，即在<strong>主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序</strong>。</li></ol><p>当然为了唯一标识，这个hash值是通过“<strong>库名+表名+索引名+值</strong>”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个hash值。</p><p>你可能看出来了，这跟我们前面介绍的基于<strong>MySQL 5.5版本的按行分发的策略是差不多的</strong>。不过，MySQL官方的这个实现还是有很大的优势：</p><ol><li>writeset是在主库生成后<strong>直接写入到binlog</strong>里面的，这样在备库执行的时候，<strong>不需要解析binlog内容</strong>（event里的行数据），<strong>节省了很多计算量</strong>；</li><li><strong>不需要</strong>把整个事务的binlog都扫一遍才能<strong>决定分发到哪个worker</strong>，<strong>更省内存</strong>；</li><li>由于备库的分发策略不依赖于binlog内容，所以binlog是<strong>statement格式也是可以的</strong>。</li></ol><p>因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。</p><p>当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化为单线程模型。</p><h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><p>假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主库搭建一个相同版本的备库。</p><p>这时候，你为了更快地让备库追上主库，要开并行复制。在binlog_transaction_dependency_tracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择哪一个呢？</p><blockquote><p>应该将这个参数设置为WRITESET。</p><p>由于主库是单线程压力模式，所以每个事务的commit_id都不同，那么设置为COMMIT_ORDER模式的话，从库也只能单线程执行。</p><p>同样地，由于WRITESET_SESSION模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下<strong>退化成单线程复制</strong>。</p><p>所以，应该将binlog_transaction_dependency_tracking 设置为WRITESET。</p></blockquote><p><strong>总结：</strong></p><p>slave_parallel_workers：work线程的个数(推荐设置为CPU核数的1&#x2F;4 ~ 1&#x2F;2)</p><p><strong>slave_parallel_type</strong> 的默认值 <code>LOGICAL_CLOCK</code><br><strong>binlog_transaction_dependency_tracking</strong> 的默认值 <code>COMMIT_ORDER</code><br>都指同一个策略，都是优化后的MariaDB策略</p><p>binlog_transaction_dependency_tracking 的 WRITESET 和按行分发策略类似</p><h1 id="27-MySQL主备切换找同步点"><a href="#27-MySQL主备切换找同步点" class="headerlink" title="27 MySQL主备切换找同步点"></a>27 MySQL主备切换找同步点</h1><h2 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h2><p>大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题，就要涉及到接下来两篇文章要讨论的架构：一主多从。</p><p>今天这篇文章，我们就先聊聊一主多从的切换正确性。然后，我们在下一篇文章中再聊聊解决一主多从的查询逻辑正确性的方法。</p><p>如图1所示，就是一个基本的<strong>一主多从</strong>结构。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/aadb3b956d1ffc13ac46515a7d619e79.png" alt="img" style="zoom:50%"><p>​ 图1 一主多从基本结构</p><p>图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p><p>今天我们要讨论的就是，在一主多从架构下，主库故障后的主备切换问题。</p><p>如图2所示，就是主库发生故障，主备切换后的结果。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/0014f97423bd75235a9187f492fb2453.png" alt="img" style="zoom:50%"><p>​ 图2 一主多从基本结构–主备切换</p><p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p><p>接下来，我们再一起看看一个切换系统会怎么完成一主多从的主备切换过程。</p><h2 id="基于位点pos的主备切换"><a href="#基于位点pos的主备切换" class="headerlink" title="基于位点pos的主备切换"></a>基于位点pos的主备切换</h2><p>这里，我们需要先来回顾一个知识点。</p><p>当我们把节点B设置成节点A’的从库的时候，需要执行一条change master命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos  </span><br></pre></td></tr></table></figure><p>这条命令有这么6个参数：</p><ul><li>MASTER_HOST、MASTER_PORT、MASTER_USER和MASTER_PASSWORD四个参数，分别代表了主库A’的IP、端口、用户名和密码。</li><li>最后两个参数MASTER_LOG_FILE和MASTER_LOG_POS表示，要从主库的master_log_name文件的master_log_pos这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li></ul><p>那么，这里就有一个问题了，节点B要设置成A’的从库，就要执行change master命令，就<strong>不可避免地要设置位点的这两个参数</strong>，但是这两个参数到底应该怎么设置呢？</p><p>原来节点B是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同的。因此，从库B要切换的时候，就需要先经过<strong>“找同步位点”</strong>这个逻辑。</p><p>这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？</p><p>我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。</p><p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库B上已经执行过的事务。</p><p>一种取同步位点的方法是这样的：</p><ol><li>等待新主库A’把中转日志（relay log）全部同步完成；</li><li>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</li><li><strong>取原主库A故障的时刻T</strong>；</li><li>用mysqlbinlog工具解析A’的File，得到T时刻的位点。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File --stop-datetime=T --start-datetime=T</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3471dfe4aebcccfaec0523a08cdd0ddd.png" alt="img"></p><p>​ 图3 mysqlbinlog 部分输出结果</p><p>图中，<strong>end_log_pos后面的值“123”</strong>，表示的就是A’这个实例，在T时刻写入新的binlog的位置。然后，我们就可以<strong>把123这个值作为$master_log_pos</strong> ，用在节点B的change master命令里。</p><p>当然<strong>这个值并不精确</strong>。为什么呢？</p><p>你可以设想有这么一种情况，假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。</p><p>那么，这时候系统的状态是这样的：</p><ol><li>在从库B上，由于同步了binlog， R这一行已经存在；</li><li>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</li><li>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。</li></ol><p>这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p><p>所以，<strong>通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</strong></p><p><strong>一种做法是</strong>，主动跳过一个事务。跳过命令的写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global sql_slave_skip_counter=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库A’时，<strong>持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况</strong>，以此来跳过可能涉及的所有事务。</p><p><strong>另外一种方式是，</strong>通过设置slave_skip_errors参数，直接设置跳过指定的错误。</p><p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p><ul><li>1062错误是插入数据时唯一键冲突；</li><li>1032错误是删除数据时找不到行。</li></ul><p>因此，我们可以<strong>把slave_skip_errors 设置为 “1032,1062”</strong>，这样中间碰到这两个错误时就直接跳过。</p><p>这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p><p>这个背景是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，所以才可以这么设置slave_skip_errors参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p><h2 id="GTID全局事务ID"><a href="#GTID全局事务ID" class="headerlink" title="GTID全局事务ID"></a>GTID全局事务ID</h2><p>通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以建立从库B和新主库A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，<strong>MySQL 5.6版本引入了GTID</strong>，彻底解决了这个困难。</p><p>那么，GTID到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍一下。</p><p><strong>GTID</strong>的全称是Global Transaction Identifier，也就是<strong>全局事务ID</strong>，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=server_uuid:gno</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li><li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。</li></ul><p>这里我需要和你说明一下，在MySQL的官方文档里，GTID格式是这么定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=source_id:transaction_id</span><br></pre></td></tr></table></figure><p>这里的source_id就是server_uuid；而后面的这个transaction_id，我觉得容易造成误导，所以我改成了gno。为什么说使用transaction_id容易造成误解呢？</p><p>因为，在MySQL里面我们说<strong>transaction_id就是指事务id</strong>，事务id是在事务执行过程中分配的，<strong>如果这个事务回滚了，事务id也会递增</strong>，而<strong>gno是在事务提交的时候才会分配</strong>。</p><p>从效果上看，GTID往往是连续的，因此我们用gno来表示更容易理解。</p><blockquote><p>GTID模式的启动也很简单，我们只需要在启动一个MySQL实例的时候，加上参数<strong>gtid_mode&#x3D;on</strong>和<strong>enforce_gtid_consistency&#x3D;on</strong>就可以了。</p></blockquote><h3 id="GTID的生成策略"><a href="#GTID的生成策略" class="headerlink" title="GTID的生成策略"></a>GTID的生成策略</h3><p>在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种方式取决于session变量gtid_next的值。</p><ol><li>如果<strong>gtid_next&#x3D;automatic</strong>，代表使用<strong>默认值</strong>。这时，MySQL就会把server_uuid:gno分配给这个事务。<br>a. 记录binlog的时候，先记录一行 SET @@SESSION.GTID_NEXT&#x3D;‘server_uuid:gno’;<br>b. 把这个GTID加入本实例的GTID集合。</li><li>如果gtid_next是一个<strong>指定的GTID的值</strong>，比如通过set gtid_next&#x3D;’current_gtid’指定为current_gtid，那么就有两种可能：<ul><li>a. 如果current_gtid已经<strong>存在</strong>于实例的GTID集合中，接下来执行的这个事务会直接<strong>被系统</strong>忽略；</li><li>b. 如果current_gtid<strong>没有存在</strong>于实例的GTID集合中，就<strong>将这个current_gtid分配</strong>给接下来要执行的事务，也就是说系统不需要给这个事务生成新的GTID，因此<strong>gno也不用加1</strong>。</li></ul></li></ol><p>注意，<strong>一个current_gtid只能给一个事务使用</strong>。这个事务提交后，如果要执行下一个事务，就要执行set 命令，把gtid_next<strong>设置成另外一个gtid或者automatic</strong>。</p><p>这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”。</p><h3 id="GTID处理冲突的基本用法"><a href="#GTID处理冲突的基本用法" class="headerlink" title="GTID处理冲突的基本用法"></a>GTID处理冲突的基本用法</h3><p>这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明GTID的基本用法。</p><p>我们在实例X中创建一个表t。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(1,1);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/28a5cab0079fb12fd5abecd92b3324c2.png" alt="img"></p><p>​ 图4 初始化数据的binlog</p><p>可以看到，事务的BEGIN之前有一条SET @@SESSION.GTID_NEXT命令。这时，如果实例X有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先执行这两个SET命令，这样被加入从库的GTID集合的，就是图中的这两个GTID。</p><p>假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(1,1);</span><br></pre></td></tr></table></figure><p>并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p><p>那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现<strong>主键冲突</strong>，导致实例X的同步线程停止。这时，我们应该怎么处理呢？</p><p>处理方法就是，你可以执行下面的这个语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set gtid_next=&#x27;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#x27;;</span><br><span class="line">begin;</span><br><span class="line">commit;</span><br><span class="line">set gtid_next=automatic;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>其中，前三条语句的作用，是通过<strong>提交一个空事务，把这个GTID加到实例X的GTID集合中</strong>。如图5所示，就是执行完这个空事务之后的show master status的结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/c8d3299ece7d583a3ecd1557851ed157.png" alt="img"></p><p>​ 图5 show master status结果</p><p><strong>可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID</strong>。</p><p>这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”<strong>已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务</strong>，也就不会再出现主键冲突的错误。</p><p>在上面的这个语句序列中，start slave命令之前还有一句set gtid_next&#x3D;automatic。这句话的作用是<strong>“恢复GTID的默认分配行为”</strong>，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配gno&#x3D;3。</p><h3 id="基于GTID的主备切换"><a href="#基于GTID的主备切换" class="headerlink" title="基于GTID的主备切换"></a>基于GTID的主备切换</h3><p>现在，我们已经理解GTID的概念，再一起来看看基于GTID的主备复制的用法。</p><p>在GTID模式下，备库B要设置为新主库A’的从库的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">master_auto_position=1 </span><br></pre></td></tr></table></figure><p>其中，<strong>master_auto_position&#x3D;1</strong>就<strong>表示这个主备关系使用的是GTID协议</strong>。可以看到，前面让我们头疼不已的MASTER_LOG_FILE和MASTER_LOG_POS参数，已经不需要指定了。</p><p>我们把现在这个时刻，实例A’的GTID集合记为set_a，实例B的GTID集合记为set_b。接下来，我们就看看现在的主备切换逻辑。</p><p>我们在实例B上执行start slave命令，取binlog的逻辑是这样的：</p><ol><li>实例B指定主库A’，基于主备协议建立连接。</li><li><strong>实例B把set_b发给主库A’</strong>。</li><li><strong>实例A’算出</strong>set_a与set_b的<strong>差集</strong>，也就是所有存在于set_a，但是不存在于set_b的GITD的集合，判断A’本地是否包含了这个差集需要的所有binlog事务。<br>a. 如果<strong>不包含</strong>，表示A’已经把实例B需要的binlog给删掉了，<strong>直接返回错误</strong>；<br>b. 如果确认<strong>全部包含</strong>，A’从自己的binlog文件里面，找出第一个不在set_b的事务，<strong>发给B</strong>；</li><li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。</li></ol><p>其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就<strong>必须保证主库发给备库的日志是<code>完整</code>的</strong>。因此，<strong>如果实例B需要的日志已经不存在，A’就拒绝把日志发给B。</strong></p><p>这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</p><p>基于上面的介绍，我们再来看看引入GTID后，一主多从的切换场景下，主备切换是如何实现的。</p><p>由于不需要找位点了，所以从库B、C、D只需要分别执行change master命令指向实例A’即可。</p><p>其实，严谨地说，主备切换不是不需要找位点了，而是<strong>找位点这个工作，在实例A’内部就已经自动完成了</strong>。但由于这个工作是自动的，所以<strong>对HA系统的开发人员来说，非常友好</strong>。</p><p>之后这个系统就由新主库A’写入，主库A’的自己生成的binlog中的GTID集合格式是：server_uuid_of_A’:1-M。</p><p>如果之前从库B的GTID集合格式是 server_uuid_of_A:1-N， 那么切换之后GTID集合的格式就变成了server_uuid_of_A:1-N, server_uuid_of_A’:1-M。</p><p>当然，主库A’之前也是A的备库，因此主库A’和从库B的GTID集合是一样的。这就达到了我们预期。</p><h3 id="GTID和在线DDL改善主备临时添加索引"><a href="#GTID和在线DDL改善主备临时添加索引" class="headerlink" title="GTID和在线DDL改善主备临时添加索引"></a>GTID和在线DDL改善主备临时添加索引</h3><p>接下来，我再举个例子帮你理解GTID。</p><p>之前在第22篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/75746">《MySQL有哪些“饮鸩止渴”提高性能的方法？》</a>中，我和你提到业务高峰期的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以<strong>先在备库加索引，然后再切换</strong>。</p><p>当时我说，<strong>在双M结构下，备库执行的DDL语句也会传给主库，为了避免传回后对主库造成影响，要通过set sql_log_bin&#x3D;off关掉binlog。</strong></p><p>评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是<strong>binlog并没有记录下这一个更新，是不是会导致数据和日志不一致</strong>？</p><p>这个问题提得非常好。当时，我在留言的回复中就引用了GTID来说明。今天，我再和你展开说明一下。</p><p>假设，这两个互为主备关系的库还是实例X和实例Y，且当前主库是X，并且都打开了GTID模式。这时的主备切换流程可以变成下面这样：</p><ul><li>在实例X上执行stop slave。</li><li>在实例Y上执行DDL语句。注意，这里并不需要关闭binlog。</li><li>执行完成后，查出这个DDL语句对应的GTID，并记为 server_uuid_of_Y:gno。</li><li>到实例X上执行以下语句序列：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set GTID_NEXT=&quot;server_uuid_of_Y:gno&quot;;</span><br><span class="line">begin;</span><br><span class="line">commit;</span><br><span class="line">set gtid_next=automatic;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>这样做的目的在于，既可以让实例Y的更新有binlog记录，同时也可以确保不会在实例X上执行这条更新。</p><ul><li>接下来，执行完主备切换，然后照着上述流程再执行一遍即可。</li></ul><blockquote><p><strong>总结：</strong></p><p>开启GTID：</p><ul><li>gtid_mode&#x3D;on</li><li>enforce_gtid_consistency&#x3D;on</li></ul><p>修改GTID生成策略：</p><ul><li>gtid_next&#x3D;automatic（默认自动生成策略）</li><li>gtid_next&#x3D;特定值</li></ul></blockquote><h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h2><p>你在GTID模式下设置主从关系的时候，从库执行start slave命令后，主库发现需要的binlog已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？</p><ol><li>如果业务允许主从不一致的情况，那么可以在主库上先执行show global variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purged1；然后先在从库上执行reset master，再执行set global gtid_purged &#x3D;‘gtid_purged1’；最后执行start slave，就会从主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li><li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li><li>如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量binlog的从库，追上日志以后，如果有需要，再接回主库。</li><li>如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。</li></ol><h1 id="28-MySQL读写分离的延迟问题"><a href="#28-MySQL读写分离的延迟问题" class="headerlink" title="28 MySQL读写分离的延迟问题"></a>28 MySQL读写分离的延迟问题</h1><h2 id="两种读写分离架构"><a href="#两种读写分离架构" class="headerlink" title="两种读写分离架构"></a>两种读写分离架构</h2><p>在上一篇文章中，我和你介绍了一主多从的结构以及切换流程。今天我们就继续聊聊一主多从架构的应用场景：读写分离，以及<strong>怎么处理主备延迟导致的读写分离</strong>问题。</p><p>我们在上一篇文章中提到的一主多从的结构，其实就是读写分离的基本结构了。这里，我再把这张图贴过来，方便你理解。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231009165207991.png" alt="image-20231009165207991"></p><p>​ 图1 读写分离基本结构</p><p>读写分离的主要目标就是分摊主库的压力。图1中的结构是客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。</p><p>还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy， 由proxy根据请求类型和上下文决定请求的分发路由。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231009165218418.png" alt="image-20231009165218418"></p><p>​ 图2 带proxy的读写分离架构</p><p>接下来，我们就看一下客户端直连和带proxy的读写分离架构，各有哪些特点。</p><ol><li>客户端直连方案，因为<strong>少了一层proxy转发，所以查询性能稍微好一点儿</strong>，并且整体架构<strong>简单</strong>，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。<br>你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如Zookeeper，尽量让业务端只专注于业务逻辑开发。</li><li>带proxy的架构，<strong>对客户端比较友好</strong>。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy也需要有高可用架构。因此，带proxy架构的整体就相对比较复杂。</li></ol><p>理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带proxy的架构方向发展的。</p><h2 id="怎么处理过期读"><a href="#怎么处理过期读" class="headerlink" title="怎么处理过期读"></a>怎么处理过期读</h2><p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p><p><strong>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</strong></p><p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能100%避免的。</p><p>不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。</p><p>接下来，我们就来讨论怎么处理过期读问题。</p><p>这里，我先把文章中涉及到的处理过期读的方案汇总在这里，以帮助你更好地理解和掌握全文的知识脉络。这些方案包括：</p><ul><li>强制走主库方案；</li><li>sleep方案；</li><li>判断主备无延迟方案；</li><li>配合semi-sync方案；</li><li>等主库位点方案；</li><li>等GTID方案。</li></ul><h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p><ol><li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li><li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li></ol><p>你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是<strong>用得最多</strong>的。</p><p>当然，这个方案最大的问题在于，有时候你会碰到“所有查询都不能是过期读”的需求，比如一些金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。</p><p>因此接下来，我们来讨论的话题是：可以支持读写分离的场景下，有哪些解决过期读的方案，并分析各个方案的优缺点。</p><h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。</p><p>这个方案的<strong>假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据</strong>。</p><p>这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接在发起查询时先执行一条sleep语句，用户体验很不友好啊。</p><p>但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，我们可以换一种方式。</p><p>以卖家发布商品为例，商品发布后，用Ajax（Asynchronous JavaScript + XML，异步JavaScript和XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查询。</p><p>这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。</p><p>也就是说，这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个<strong>不精确</strong>包含了两层意思：</p><ol><li>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；</li><li>如果延迟超过1秒，还是会出现过期读。</li></ol><p>看到这里，你是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似Ajax场景下的过期读问题，但还是怎么看都不靠谱儿。别着急，接下来我就和你介绍一些更准确的方案。</p><h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>要确保备库无延迟，通常有三种做法。</p><p>通过前面的<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/76795">第25篇</a>文章，我们知道<strong>show slave status</strong>结果里的<strong>seconds_behind_master</strong>参数的值，可以用来衡量主备延迟时间的长短。</p><p>所以<strong>第一种确保主备无延迟的方法是，</strong>每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p><p>seconds_behind_master的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和GTID的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p><p>如图3所示，是一个show slave status结果的部分截图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/00110923007513e865d7f43a124887c1.png" alt="img"></p><p>​ 图3 show slave status结果</p><p>现在，我们就通过这个结果，来看看具体如何通过对比位点和GTID来确保主备无延迟。</p><p><strong>第二种方法，</strong> <strong>对比位点</strong>确保主备无延迟：</p><ul><li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li><li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li></ul><p>如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</p><p><strong>第三种方法，</strong> <strong>对比GTID集合</strong>确保主备无延迟：</p><ul><li>Auto_Position&#x3D;1 ，表示这对主备关系使用了GTID协议。</li><li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</li><li>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。</li></ul><p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p><p>可见，<strong>对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。</strong></p><p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p><p>我们现在一起来回顾下，一个事务的binlog在主备库之间的状态：</p><ol><li>主库执行完成，写入binlog，并反馈给客户端；</li><li>binlog被从主库发送给备库，备库收到；</li><li>在备库执行binlog完成。</li></ol><p>我们上面判断主备无延迟的逻辑，是<strong>“备库收到的日志都执行完成了”</strong>。但是，从binlog在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而<strong>备库还没收到日志的状态</strong>。</p><p>如图4所示就是这样的一个状态。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20231009165524004.png" alt="image-20231009165524004" style="zoom:50%"><p>​ 图4 备库还没收到trx3</p><p>这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：</p><ol><li>trx1和trx2已经传到从库，并且已经执行完成了；</li><li>trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li></ol><p>如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。</p><p>那么，这个问题有没有办法解决呢？</p><h3 id="配合semi-sync半同步复制"><a href="#配合semi-sync半同步复制" class="headerlink" title="配合semi-sync半同步复制"></a>配合semi-sync半同步复制</h3><p>要解决这个问题，就要引入<strong>半同步复制</strong>，也就是semi-sync replication。</p><p>semi-sync做了这样的设计：</p><ol><li>事务提交的时候，主库把binlog发给从库；</li><li><strong>从库收到binlog以后，发回给主库一个ack</strong>，表示收到了；</li><li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li></ol><p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/76795">第25篇文章</a>的评论区，有同学问到：如果主库掉电的时候，有些binlog还来不及发给从库，会不会导致系统数据丢失？</p><p>答案是，如果使用的是普通的异步复制模式，就可能会丢失，但semi-sync就可以解决这个问题。</p><p>这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p><p>但是，semi-sync+位点判断的方案，<strong>只对一主一备的场景是成立的</strong>。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p><ol><li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</li><li>但<strong>如果是查询落到其他从库</strong>上，它们可能还没有收到最新的日志，就会<strong>产生过期读</strong>的问题。</li></ol><p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的<strong>高峰期</strong>，主库的位点或者<strong>GTID集合更新很快</strong>，那么上面的两个位点<strong>等值判断就会一直不成立</strong>，很可能出现从库上迟迟无法响应查询请求的情况。</p><p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。</p><p>为什么这么说呢？我们来看一下这个时序图。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/9cf54f3e91dc8f7b8947d7d8e384aa09.png" alt="img" style="zoom:50%"><p>​ 图5 主备持续延迟一个事务</p><p>图5所示，就是等待位点方案的一个bad case。图中备库B下的虚线框，分别表示relaylog和binlog中的事务。可以看到，图5中从状态1 到状态4，一直处于延迟一个事务的状态。</p><p>备库B一直到状态4都和主库A存在延迟，如果用上面必须等到无延迟才能查询的方案，select语句直到状态4都不能被执行。</p><p>但是，其实客户端是在发完trx1更新后发起的select语句，我们<strong>只需要确保trx1已经执行完成就可以执行select语句</strong>了。也就是说，如果在状态3执行查询请求，得到的就是预期结果了。</p><p>到这里，我们小结一下，semi-sync配合判断主备无延迟的方案，<strong>存在两个问题</strong>：</p><ol><li><strong>一主多从</strong>的时候，在某些从库执行查询请求会存在<strong>过期读</strong>的现象；</li><li>在<strong>持续延迟</strong>的情况下，可能出现<strong>过度等待</strong>的问题。</li></ol><p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p><h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p>要理解等主库位点方案，我需要先和你介绍一条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>这条命令的逻辑如下：</p><ol><li>它是<strong>在从库执行</strong>的；</li><li>参数file和pos指的是主库上的文件名和位置；</li><li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li></ol><p>这个命令正常返回的结果是一个<strong>正整数M</strong>，表示<strong>从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务</strong>。</p><p>当然，除了正常返回一个正整数M外，这条命令还会返回一些<strong>其他结果</strong>，包括：</p><ol><li>如果执行期间，备库同步线程发生异常，则返回NULL；</li><li>如果等待超过N秒，就返回-1；</li><li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。</li></ol><p>对于图5中先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p><ol><li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行select master_pos_wait(File, Position, 1)；</li><li>如果返回值是&gt;&#x3D;0的正整数，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>我把上面这个流程画出来。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/b20ae91ea46803df1b63ed683e1de357.png" alt="img" style="zoom:50%"><p>​ 图6 master_pos_wait方案</p><p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。</p><p><strong>步骤5到主库执行查询语句，是这类方案常用的退化机制</strong>。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p><p>你可能会说，如果所有的从库都延迟超过1秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p><p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p><h3 id="等待GTID方案"><a href="#等待GTID方案" class="headerlink" title="等待GTID方案"></a>等待GTID方案</h3><p>如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。</p><p>MySQL中同样提供了一个类似的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select wait_for_executed_gtid_set(gtid_set, 1);</span><br></pre></td></tr></table></figure><p>这条命令的逻辑是：</p><ol><li>等待，直到这个库执行的事务中包含传入的gtid_set，<strong>返回0</strong>；</li><li><strong>超时返回1。</strong></li></ol><p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。</p><p>这时，等GTID的执行流程就变成了：</p><ol><li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><p>我把这个流程图画出来。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/d521de8017297aff59db2f68170ee739.png" alt="img" style="zoom:50%"><p>​ 图7 wait_for_executed_gtid_set方案</p><p>在上面的第一步中，trx1事务更新完成后，从返回包直接获取这个事务的GTID。问题是，怎么能够让MySQL在执行事务后，返回包中带上GTID呢？</p><p>你只需要将参数<strong>session_track_gtids</strong>设置为<strong>OWN_GTID</strong>，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。</p><p>在专栏的<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/68319">第一篇文章</a>中，我介绍mysql_reset_connection的时候，评论区有同学留言问这类接口应该怎么使用。</p><p>这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的API(<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html)%E3%80%82">https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html)。</a></p><p>比如，为了让客户端在事务提交后，返回的GITD能够在客户端显示出来，我对MySQL客户端代码做了点修改，如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/973bdd8741f830acebe005cbf37a7663.png" alt="img"></p><p>​ 图8 显示更新事务的GTID–代码</p><p>这样，就可以看到语句执行完成，显示出GITD的值。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/253106d31d9d97aaa2846b2015f593fe.png" alt="img"></p><p>​ 图9 显示更新事务的GTID–效果</p><p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用mysql_session_track_get_first这个函数</p><blockquote><p><strong>总结：</strong></p><p>本节在于如何处理“过期读”问题</p><ol><li>需要实时返回数据的强制走主库</li><li>sleep(1)：假装1s就能同步完成（不精确）</li><li>判断主备是否无延迟<ul><li>show slave status 查看 seconds_behind_master（只能精确到s）</li><li>对比位点：show slave status 查看 Master_Log_File的Read_Master_Log_Pos 和 Relay_Master_Log_File 的 Exec_Master_Log_Pos 是否相同</li><li>对比GTID集合：Auto_Position&#x3D;1表示使用GTID，Retrieved_Gtid_Set 和 Executed_Gtid_Set 是否相同</li><li><strong>注意：但是都只能判断的是已经发送给备库的binlog是否同步完成，还有没来得及发送的</strong></li></ul></li><li>上一点配合半同步复制<ul><li>有一个从库发送ACK才才返回执行结果</li><li><strong>注意：①一主多从时只有发送ack的从库才能保证没有过期读</strong><br><strong>②在持续延迟的情况下，可能出现过度等待的问题</strong></li></ul></li><li>等主库 位点&#x2F;GTID 方案<ul><li>等主库位点：在从库执行select master_pos_wait(file, pos[, timeout]);&gt;&#x3D;0 才在从库执行查询语句，否则在主库执行</li><li>等GTID方案：在从库执行select wait_for_executed_gtid_set(gtid_set, 1);&#x3D;0 才在从库执行查询语句，否则在主库执行</li><li><strong>可在代码中编写判断逻辑选择使用主库还是从库执行查询</strong></li></ul></li></ol><p><strong>综上所述：按情况采取1 或 3+4 或5的方案</strong></p></blockquote><h2 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h2><p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等待GTID的方案，现在你要对主库的一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p><p>假设，这条语句在主库上要执行10分钟，提交后传到备库就要10分钟（典型的<strong>大事务</strong>）。那么，在主库DDL之后再提交的事务的GTID，去备库查的时候，就会等10分钟才出现。</p><p>这样，这个读写分离机制在这10分钟之内都会超时，然后走主库。</p><p>这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后<strong>把读请求都切到主库，再在主库上做DDL。等备库延迟追上以后，再把读请求切回备库</strong>。</p><h1 id="29-判断MySQL服务是否可用"><a href="#29-判断MySQL服务是否可用" class="headerlink" title="29 判断MySQL服务是否可用"></a>29 判断MySQL服务是否可用</h1><p>我在第<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/76795">25</a>和<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/77427">27</a>篇文章中，和你介绍了主备切换流程。通过这些内容的讲解，你应该已经很清楚了：在一主一备的双M架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。</p><p>主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由HA系统发起的。</p><p>这也就引出了我们今天要讨论的问题：怎么判断一个主库出问题了？</p><h2 id="select-1判断"><a href="#select-1判断" class="headerlink" title="select 1判断"></a>select 1判断</h2><p>实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。现在，我们来看一下这个场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_thread_concurrency=3;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(1,1)</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/35076dd3d0a0d44d22b76d2a29885255.png" alt="img"></p><p>​ 图1 查询blocked</p><p>我们设置<strong>innodb_thread_concurrency</strong>参数的目的是，控制InnoDB的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。</p><p>这里，我把innodb_thread_concurrency设置成3，表示InnoDB只允许3个线程并行执行。而在我们的例子中，前三个session 中的sleep(100)，使得这三个语句都处于“执行”状态，以此来模拟大查询。</p><p>你看到了， session D里面，select 1是能执行成功的，但是查询表t的语句会被堵住。也就是说，如果这时候我们用select 1来检测实例是否正常的话，是检测不出问题的。</p><p>在InnoDB中，innodb_thread_concurrency这个参数的<strong>默认值是0，表示不限制并发线程数量</strong>。但是，不限制并发线程数肯定是不行的。因为，一个机器的CPU核数有限，线程全冲进来，上下文切换的成本就会太高。</p><p>所以，通常情况下，我们<strong>建议把innodb_thread_concurrency设置为64~128之间的值</strong>。这时，你一定会有疑问，并发线程上限数设置为128够干啥，线上的并发连接数动不动就上千了。</p><p>产生这个疑问的原因，是搞混了<strong>并发连接和并发查询。</strong></p><p>并发连接和并发查询，并不是同一个概念。你在show processlist的结果里，看到的几千个连接，指的就是并发连接。而<strong>“当前正在执行”的语句，才是我们所说的并发查询</strong>。</p><p>并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为并发查询太高才是CPU杀手。这也是为什么我们需要设置innodb_thread_concurrency参数的原因。</p><p>然后，你可能还会想起我们在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/70215">第7篇文章</a>中讲到的热点更新和死锁检测的时候，如果把innodb_thread_concurrency设置为128的话，那么出现同一行热点更新的问题时，是不是很快就把128消耗完了，这样整个系统是不是就挂了呢？</p><p>实际上，<strong>在线程进入锁等待以后，并发线程的计数会减一</strong>，也就是说等行锁（也包括间隙锁）的线程是不算在128里面的。</p><p>MySQL这样设计是非常有意义的。因为，进入锁等待的线程已经不吃CPU了；更重要的是，必须这么设计，才能避免整个系统锁死。</p><p>为什么呢？假设处于锁等待的线程也占并发线程的计数，你可以设想一下这个场景：</p><ol><li>线程1执行begin; update t set c&#x3D;c+1 where id&#x3D;1, 启动了事务trx1， 然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面。</li><li>线程2到线程129都执行 update t set c&#x3D;c+1 where id&#x3D;1; 由于等行锁，进入等待状态。这样就有128个线程处于等待状态；</li><li>如果处于锁等待状态的线程计数不减一，InnoDB就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系统就堵住了。</li></ol><p>下图2显示的就是这个状态。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/3206ea18b8a24b546515b1b95dc4a11d.png" alt="img" style="zoom:50%"><p>​ 图2 系统锁死状态（假设等行锁的语句占用并发计数）</p><p>这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程都处于等待状态，此时占用的CPU却是0，而这明显不合理。所以，我们说InnoDB在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且是必要的。</p><p>虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，就比如我们上面例子中前三个事务中的select sleep(100) from t，还是要算进并发线程的计数的。在这个例子中，同时在执行的语句超过了设置的innodb_thread_concurrency的值，这时候系统其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。</p><p>因此，我们使用select 1的判断逻辑要修改一下。</p><h2 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h2><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况，我们需要找一个访问InnoDB的场景。一般的做法是，在系统库（<strong>mysql库）里创建一个表，比如命名为health_check</strong>，里面只放一行数据，然后定期执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from mysql.health_check; </span><br></pre></td></tr></table></figure><p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。</p><p>但是，我们马上还会碰到下一个问题，即：<strong>空间满了以后，这种方法又会变得不好使</strong>。（查询不写日志）</p><p>我们知道，更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p><p>因此，我们还是把这条监控语句再改进一下。接下来，我们就看看把查询语句改成更新语句后的效果。</p><h2 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h2><p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update mysql.health_check set t_modified=now();</span><br></pre></td></tr></table></figure><p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p><p>但，备库的检测也是要写binlog的。由于我们一般会把数据库A和B的主备关系设计为双M结构，所以在备库B上执行的检测命令，也要发回给主库A。</p><p>但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以，现在看来mysql.health_check 这个表就<strong>不能只有一行数据</strong>了。</p><p>为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并用A、B的<strong>server_id做主键</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `health_check` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">/* 检测命令 */</span><br><span class="line">insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now();</span><br></pre></td></tr></table></figure><p>由于MySQL规定了<strong>主库和备库的server_id必须不同</strong>（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p><p>更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，<strong>“判定慢”</strong>一直是让DBA头疼的问题。</p><p>你一定会疑惑，<strong>更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定慢的问题呢？</strong></p><p>其实，这里涉及到的是服务器IO资源分配的问题。</p><p>首先，所有的检测逻辑都需要一个超时时间N。<strong>执行一条update语句，超过N秒后还不返回，就认为系统不可用</strong>。</p><p>你可以设想一个日志盘的IO利用率已经是100%的场景。这时候，整个系统响应非常慢，已经需要做主备切换了。</p><p>但是你要知道，IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。而我们的<strong>检测使用的update命令，需要的资源很少</strong>，所以<strong>可能</strong>在拿到IO资源的时候就可以提交成功，并且<strong>在超时时间N秒未到达之前就返回给了检测系统</strong>。</p><p>检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。</p><p>也就是说，这时候在业务系统上正常的SQL语句已经执行得很慢了，但是DBA上去一看，HA系统还在正常工作，并且认为主库现在处于可用状态。</p><p>之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。</p><p>因为，外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起执行语句的时候，我们才有可能发现问题。而且，如果你的运气不够好的话，可能第一次轮询还不能发现，这就会导致切换慢的问题。</p><p>所以，接下来我要再和你介绍一种在MySQL内部发现数据库问题的方法。</p><h2 id="内部统计IO"><a href="#内部统计IO" class="headerlink" title="内部统计IO"></a>内部统计IO</h2><p>针对磁盘利用率这个问题，如果MySQL可以告诉我们，内部每一次IO请求的时间，那我们判断数据库是否出问题的方法就可靠得多了。</p><p>其实，MySQL 5.6版本以后提供的<strong>performance_schema</strong>库，就在<strong>file_summary_by_event_name</strong>表里统计了每次IO请求的时间。</p><p>file_summary_by_event_name表里有很多行数据，我们先来看看**event_name&#x3D;’wait&#x2F;io&#x2F;file&#x2F;innodb&#x2F;innodb_log_file’**这一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from performance_schema.file_summary_by_event_name where event_name=&#x27;wait/io/file/innodb/innodb_log_file&#x27;\G;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/752ccfe43b4eab155be17401838c62dd.png" alt="img"></p><p>​ 图3 performance_schema.file_summary_by_event_name的一行</p><blockquote><p>图中这一行表示统计的是redo log的写入时间，第一列EVENT_NAME 表示统计的类型。</p><p>接下来的三组数据，显示的是redo log操作的时间统计。</p><p><strong>第一组五列</strong>，是所有<strong>IO类型</strong>的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具体的统计项， <strong>单位是皮秒</strong>；前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。</p><p><strong>第二组六列</strong>，是<strong>读操作</strong>的统计。最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共从redo log里读了多少个字节。</p><p><strong>第三组六列</strong>，统计的是<strong>写操作</strong>。</p><p><strong>第四组五列</strong>，是对<strong>其他类型数据</strong>的统计。在<strong>redo log里</strong>，你可以认为它们就是<strong>对fsync</strong>的统计。</p></blockquote><p>在performance_schema库的file_summary_by_event_name表里，binlog对应的是event_name &#x3D; “wait&#x2F;io&#x2F;file&#x2F;sql&#x2F;binlog”这一行。各个字段的统计逻辑，与redo log的各个字段完全相同。这里，我就不再赘述了。</p><p>因为我们每一次操作数据库，performance_schema都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗的。</p><p>我的测试结果是，<strong>如果打开所有的performance_schema项，性能大概会下降10%左右</strong>。所以，我建议你只打开自己需要的项进行统计。你可以通过下面的方法打开或者关闭某个具体项的统计。</p><p>如果要打开redo log的时间监控，你可以执行这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update setup_instruments set ENABLED=&#x27;YES&#x27;, Timed=&#x27;YES&#x27; where name like &#x27;%wait/io/file/innodb/innodb_log_file%&#x27;;</span><br></pre></td></tr></table></figure><p>假设，现在你已经开启了redo log和binlog这两个统计信息，那要怎么把这个信息用在实例状态诊断上呢？</p><p>很简单，你可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，你可以<strong>设定阈值</strong>，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select event_name,MAX_TIMER_WAIT  FROM performance_schema.file_summary_by_event_name where event_name in (&#x27;wait/io/file/innodb/innodb_log_file&#x27;,&#x27;wait/io/file/sql/binlog&#x27;) and MAX_TIMER_WAIT&gt;200*1000000000;</span><br></pre></td></tr></table></figure><p><strong>发现异常后</strong>，取到你需要的信息，再通过下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; truncate table performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure><p><strong>把之前的统计信息清空</strong>。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>总结：</strong></p><ol><li>select 1 判断：同时在执行的语句超过了设置的innodb_thread_concurrency的值，但是seect 1仍然能成功执行，所以不行</li><li>查表判断：不能检测磁盘，如果磁盘满了，因为查询不会写日志，所以无法发现磁盘的问题</li><li>更新判断：<ul><li>主备更新同一行，可能出现行差错</li><li>主备以各自的server_id为id，更新对应的行<ul><li>但是如果IO利用率很高时，这个检测update需要的资源很少仍然可能拿到IO资源在规定时间内返回</li></ul></li></ul></li><li>内部统计IO：设定阈值查看有无单次IO请求时间超过设定毫秒的异常</li></ol><p><strong>综上所述：推荐采用更新判断 + 内部统计IO的方法判断MySQL服务是否可用</strong></p><p>使用非常广泛的MHA（Master High Availability）默认使用的是select 1</p></blockquote><h1 id="30-讲答疑文章（二）：邻间锁的相关问题"><a href="#30-讲答疑文章（二）：邻间锁的相关问题" class="headerlink" title="30 讲答疑文章（二）：邻间锁的相关问题"></a>30 讲答疑文章（二）：邻间锁的相关问题</h1><p>在第<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/75173">20</a>和<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/75659">21</a>篇文章中，我和你介绍了InnoDB的间隙锁、next-key lock，以及加锁规则。所以，我就从中挑选了几个有代表性的问题，构成了今天这篇答疑文章的主题，即：<strong>用动态的观点看加锁</strong>。</p><p><strong>为了方便你理解，我们再一起复习一下加锁规则。这个规则中，包含了两个“原则”、两个“优化”和一个“bug”：</strong></p><ul><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ul><p>接下来，我们的讨论还是基于下面这个表t：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><h2 id="非等号也有等值查询"><a href="#非等号也有等值查询" class="headerlink" title="非等号也有等值查询"></a>非等号也有等值查询</h2><p>有同学对“等值查询”提出了疑问：等值查询和“遍历”有什么区别？为什么我们文章的例子里面，where条件是不等号，这个过程里也有等值查询？</p><p>我们一起来看下这个例子，分析一下这条查询语句的加锁范围：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where id&gt;9 and id&lt;12 order by id desc for update;</span><br></pre></td></tr></table></figure><p>利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和**(10, 15)**。也就是说，id&#x3D;15这一行，并没有被加上行锁。为什么呢？</p><p>我们说加锁单位是next-key lock，都是前开后闭区间，但是这里用到了<strong>优化2</strong>，即索引上的等值查询，向右遍历的时候id&#x3D;15不满足条件，所以next-key lock退化为了间隙锁 (10, 15)。</p><h3 id="这些“等值查询哪里来的”"><a href="#这些“等值查询哪里来的”" class="headerlink" title="这些“等值查询哪里来的”"></a>这些“等值查询哪里来的”</h3><p>但是，我们的查询语句中where条件是大于号和小于号，这里的“等值查询”又是从哪里来的呢？</p><p>要知道，加锁动作是发生在语句执行过程中的，所以你在分析加锁行为的时候，要从索引上的数据结构开始。这里，我再把这个过程拆解一下。</p><p>如图1所示，是这个表的索引id的示意图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231011162943054.png" alt="image-20231011162943054"> 图1 索引id示意图</p><ol><li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id&#x3D;12的这个值，只是最终没找到，但找到了(10,15)这个间隙。</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id&#x3D;5这一行，所以会加一个next-key lock (0,5]。</li></ol><p>也就是说，在执行过程中，<strong>通过树搜索的方式定位记录的时候，用的是“等值查询”的方法</strong>。</p><h3 id="等值查询的过程"><a href="#等值查询的过程" class="headerlink" title="等值查询的过程"></a>等值查询的过程</h3><p>与上面这个例子对应的，是 @发条橙子 同学提出的问题：下面这个语句的加锁范围是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select id from t where c in(5,20,10) lock in share mode;</span><br></pre></td></tr></table></figure><p>这条查询语句里用的是in，我们先来看这条语句的explain结果。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/8a089159c82c1458b26e2756583347b3.png" alt="img"></p><p>​ 图2 in语句的explain结果</p><p>可以看到，这条in语句使用了索引c并且rows&#x3D;3，说明这三个值都是通过B+树搜索定位的。</p><p>在查找c&#x3D;5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c&#x3D;5，就要向右遍历，找到c&#x3D;10才确认没有了，这个过程满足优化2，所以加了间隙锁**(5,10)**。</p><p>同样的，执行c&#x3D;10这个逻辑的时候，加锁的范围是**(5,10] 和 (10,15)<strong>；执行c&#x3D;20这个逻辑的时候，加锁的范围是</strong>(15,20] 和 (20,25)。**</p><p>通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c&#x3D;5的记录锁，再加c&#x3D;10的记录锁，最后加c&#x3D;20的记录锁。</p><p>你可能会说，这个加锁范围，不就是从(5,25)中去掉c&#x3D;15的行锁吗？为什么这么麻烦地分段说呢？</p><p>因为我要跟你强调这个过程：这些锁是<strong>“在执行过程中一个一个加的”，而不是一次性加上去的。</strong></p><h3 id="死锁的例子"><a href="#死锁的例子" class="headerlink" title="死锁的例子"></a>死锁的例子</h3><p>理解了这个加锁过程之后，我们就可以来分析下面例子中的死锁问题了。</p><p>如果同时有另外一个语句，是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where c in(5,20,10) order by c desc for update;</span><br></pre></td></tr></table></figure><p>此时的加锁范围，又是什么呢？</p><p>我们现在都知道间隙锁是不互锁的，但是这两条语句都会在索引c上的c&#x3D;5、10、20这三行记录上加记录锁。</p><p>这里你需要注意一下，由于语句里面是order by c desc， 这三个记录锁的加锁顺序，是先锁c&#x3D;20，然后c&#x3D;10，最后是c&#x3D;5。</p><p>也就是说，<strong>这两条语句要加锁相同的资源，但是加锁顺序相反</strong>。当这两条语句并发执行的时候，就可能出现死锁。</p><p>关于死锁的信息，MySQL只保留了最后一个死锁的现场，但这个现场还是不完备的。</p><p>有同学在评论区留言到，希望我能展开一下怎么看死锁。现在，我就来简单分析一下上面这个例子的死锁现场。</p><h3 id="怎么看死锁？"><a href="#怎么看死锁？" class="headerlink" title="怎么看死锁？"></a>怎么看死锁？</h3><p>图3是在出现死锁后，执行<strong>show engine innodb status</strong>命令得到的部分输出。这个命令会输出很多信息，有一节LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/a7dccb91bc17d12746703eb194775cf6.png" alt="img"></p><p>​ 图3 死锁现场</p><blockquote><p>我们来看看这图中的几个关键信息。</p><ol><li>这个结果分成三部分：<ul><li>(1) TRANSACTION，是第一个事务的信息；</li><li>(2) TRANSACTION，是第二个事务的信息；</li><li>WE ROLL BACK TRANSACTION (1)，是最终的处理结果，表示回滚了第一个事务。</li></ul></li><li>第一个事务的信息中：<ul><li>WAITING FOR THIS LOCK TO BE GRANTED，表示的是这个事务在等待的锁信息；</li><li>index c of table <code>test</code>.<code>t</code>，说明在等的是表t的索引c上面的锁；</li><li>lock mode S waiting 表示这个语句要自己加一个读锁，当前的状态是等待中；</li><li>Record lock说明这是一个记录锁；</li><li>n_fields 2表示这个记录是两列，也就是字段c和主键字段id；</li><li>0: len 4; hex 0000000a; asc ;;是第一个字段，也就是c。值是十六进制a，也就是10；</li><li>1: len 4; hex 0000000a; asc ;;是第二个字段，也就是主键id，值也是10；</li><li>这两行里面的asc表示的是，接下来要打印出值里面的“可打印字符”，但10不是可打印字符，因此就显示空格。</li><li>第一个事务信息就只显示出了等锁的状态，在等待(c&#x3D;10,id&#x3D;10)这一行的锁。</li><li>当然你是知道的，既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。别着急，我们从第二个事务的信息中推导出来。</li></ul></li><li>第二个事务显示的信息要多一些：<ul><li>“ HOLDS THE LOCK(S)”用来显示这个事务持有哪些锁；</li><li>index c of table <code>test</code>.<code>t</code> 表示锁是在表t的索引c上；</li><li>hex 0000000a和hex 00000014表示这个事务持有c&#x3D;10和c&#x3D;20这两个记录锁；</li><li>WAITING FOR THIS LOCK TO BE GRANTED，表示在等(c&#x3D;5,id&#x3D;5)这个记录锁。</li></ul></li></ol><p>从上面这些信息中，我们就知道：</p><ol><li>“lock in share mode”的这条语句，持<strong>有c&#x3D;5的记录锁，在等c&#x3D;10的锁</strong>；</li><li>“for update”这个语句，持有c&#x3D;20和c&#x3D;10的记录锁，在等c&#x3D;5的记录锁。</li></ol><p>因此导致了死锁。这里，我们可以得到两个结论：</p><ol><li>由于锁是一个个加的，<strong>要避免死锁，对同一组资源，要按照尽量相同的顺序访问</strong>；</li><li>在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以<strong>InnoDB选择了回滚成本更小</strong>的lock in share mode语句，<strong>来回滚</strong>。</li></ol></blockquote><h3 id="怎么看锁等待？"><a href="#怎么看锁等待？" class="headerlink" title="怎么看锁等待？"></a>怎么看锁等待？</h3><h4 id="delete和insert的例子"><a href="#delete和insert的例子" class="headerlink" title="delete和insert的例子"></a>delete和insert的例子</h4><p>看完死锁，我们再来看一个锁等待的例子。</p><p>在第21篇文章的评论区，@Geek_9ca34e 同学做了一个有趣验证，我把复现步骤列出来：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/af3602b81aeb49e33577ba372d220a75.png" alt="img"></p><p>​ 图4 delete导致间隙变化</p><p>可以看到，由于session A并没有锁住c&#x3D;10这个记录，所以session B删除id&#x3D;10这一行是可以的。但是之后，session B再想insert id&#x3D;10这一行回去就不行了。</p><p>现在我们一起看一下此时show engine innodb status的结果，看看能不能给我们一些提示。锁信息是在这个命令输出结果的TRANSACTIONS这一节。你可以在文稿中看到这张图片<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/c3744fb7b61df2a5b45b8eb1f2a853a6.png" alt="img"></p><p>​ 图 5 锁等待信息</p><p>我们来看几个关键信息。</p><ol><li>index PRIMARY of table <code>test</code>.<code>t</code> ，表示这个语句被锁住是因为表t主键上的某个锁。</li><li>lock_mode X locks gap before rec insert intention waiting 这里有几个信息：<ul><li>insert intention表示当前线程准备插入一个记录，这是一个插入意向锁。为了便于理解，你可以认为它就是这个插入动作本身。</li><li>gap before rec 表示这是一个间隙锁，而不是记录锁。</li></ul></li><li>那么这个gap是在哪个记录之前的呢？接下来的0~4这5行的内容就是这个记录的信息。</li><li>n_fields 5也表示了，这一个记录有5列：<ul><li>0: len 4; hex 0000000f; asc ;;第一列是主键id字段，十六进制f就是id&#x3D;15。所以，这时我们就知道了，这个间隙就是id&#x3D;15之前的，因为id&#x3D;10已经不存在了，它表示的就是(5,15)。</li><li>1: len 6; hex 000000000513; asc ;;第二列是长度为6字节的事务id，表示最后修改这一行的是trx id为1299的事务。</li><li>2: len 7; hex b0000001250134; asc % 4;; 第三列长度为7字节的回滚段信息。可以看到，这里的acs后面有显示内容(%和4)，这是因为刚好这个字节是可打印字符。</li><li>后面两列是c和d的值，都是15。</li></ul></li></ol><p>因此，我们就知道了，<strong>由于delete操作把id&#x3D;10这一行删掉了，原来的两个间隙(5,10)、(10,15）变成了一个(5,15)。</strong></p><p>说到这里，你可以联合起来再思考一下这两个现象之间的关联：</p><ol><li>session A执行完select语句后，什么都没做，但它<strong>加锁的范围突然“变大”了；</strong></li><li>第21篇文章的课后思考题，当我们执行select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc lock in share mode; 向左扫描到c&#x3D;10的时候，要把(5, 10]锁起来。</li></ol><p>也就是说，所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。</p><h4 id="update的例子"><a href="#update的例子" class="headerlink" title="update的例子"></a>update的例子</h4><p>看过了insert和delete的加锁例子，我们再来看一个update语句的案例。在留言区中@信信 同学做了这个试验：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/61c1ceea7b59201649c2514c9db864a7.png" alt="img"></p><p>​ 图 6 update 的例子</p><p>你可以自己分析一下，session A的加锁范围是索引c上的 (5,10]、(10,15]、(15,20]、(20,25]和(25,suprenum]。</p><p>之后session B的第一个update语句，要把c&#x3D;5改成c&#x3D;1，你可以理解为两步：</p><ol><li>插入(c&#x3D;1, id&#x3D;5)这个记录；</li><li>删除(c&#x3D;5, id&#x3D;5)这个记录。</li></ol><p>按照我们上一节说的，索引c上(5,10)间隙是由这个间隙右边的记录，也就是c&#x3D;10定义的。所以通过这个操作，session A的加锁范围变成了图7所示的样子：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/d2f6a0c46dd8d12f6a90dacc466d53e9.png" alt="img" style="zoom:50%"><p>​ 图 7 session B修改后， session A的加锁范围</p><p>好，接下来session B要执行 update t set c &#x3D; 5 where c &#x3D; 1这个语句了，一样地可以拆成两步：</p><ol><li>插入(c&#x3D;5, id&#x3D;5)这个记录；</li><li>删除(c&#x3D;1, id&#x3D;5)这个记录。</li></ol><p>第一步<strong>试图在已经加了间隙锁的(1,10)中插入数据，所以就被堵住了</strong>。</p><h2 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h2><p>上面我们提到一个很重要的点：所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。</p><p>那么，一个空表有间隙吗？这个间隙是由谁定义的？你怎么验证这个结论呢？</p><p>一个空表就只有一个间隙。比如，在空表上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where id&gt;1 for update;</span><br></pre></td></tr></table></figure><p>这个查询语句加锁的范围就是next-key lock <strong>(-∞, supremum]。</strong></p><h1 id="31-讲误删数据怎么办"><a href="#31-讲误删数据怎么办" class="headerlink" title="31 讲误删数据怎么办"></a>31 讲误删数据怎么办</h1><p>在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p><p>虽然我们之前遇到的大多数的数据被删，都是运维同学或者DBA背锅的。但实际上，只要有数据操作权限的同学，都有可能踩到误删数据这条线。</p><p>今天我们就来聊聊误删数据前后，我们可以做些什么，减少误删数据的风险，和由误删数据带来的损失。</p><p>为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p><ol><li>使用delete语句误删数据行；</li><li>使用drop table或者truncate table语句误删数据表；</li><li>使用drop database语句误删数据库；</li><li>使用rm命令误删整个MySQL实例。</li></ol><h2 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h2><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/76446">第24篇文章</a>中，我们提到如果是使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。</p><p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要<strong>确保binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。</strong></p><p>具体恢复数据时，对单个事务做如下处理：</p><ol><li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；</li><li>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</li><li>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li></ol><p>如果误操作不是一个，而是多个，会怎么样呢？比如下面三个事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(A)delete ...</span><br><span class="line">(B)insert ...</span><br><span class="line">(C)update ...</span><br></pre></td></tr></table></figure><p>现在要把数据库恢复回这三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(reverse C)update ...</span><br><span class="line">(reverse B)delete ...</span><br><span class="line">(reverse A)insert ...</span><br></pre></td></tr></table></figure><p>也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p><p><strong>需要说明的是，我不建议你直接在主库上执行这些操作。</strong></p><p>恢复数据比较安全的做法，是恢复出一个备份，<strong>或者找一个从库作为临时库，在这个临时库上执行这些操作</strong>，然后再将确认过的临时库的数据，恢复回主库。</p><p>为什么要这么做呢？</p><p>这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就<strong>可能会出现对数据的二次破坏。</strong></p><h2 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库&#x2F;表"></a>误删库&#x2F;表</h2><p>这种情况下，要想恢复数据，就需要使用<strong>全量备份，加增量日志</strong>的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。</p><p>在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p><ol><li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</li><li>用备份恢复出一个临时库；</li><li>从日志备份里面，取出凌晨0点之后的日志；</li><li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li></ol><p>这个流程的示意图如下所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/2fafd0b75286e0163f432f85428ff8db.png" alt="img" style="zoom:50%"><p>​ 图1 数据恢复流程-mysqlbinlog方法</p><p>关于这个过程，我需要和你说明如下几点：</p><ol><li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li><li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：<ul><li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日志继续执行；</li><li>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next&#x3D;gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。</li></ul></li></ol><p>不过，即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：</p><ol><li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志；</li><li>用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。我们在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/77083">第26篇文章</a>中介绍的那些并行复制的方法，在这里都用不上。</li></ol><h3 id="加速恢复的方法"><a href="#加速恢复的方法" class="headerlink" title="加速恢复的方法"></a>加速恢复的方法</h3><p><strong>一种加速的方法是，</strong>在用备份恢复出临时实例之后，将这个临时实例<strong>设置成线上备库的从库</strong>，这样：</p><ol><li>在start slave之前，先通过执行﻿<br>change replication filter replicate_do_table &#x3D; (tbl_name) 命令，就可以<strong>让临时库只同步误操作的表</strong>；</li><li>这样做也可以<strong>用上并行复制技术</strong>，来加速整个数据恢复过程。</li></ol><p>这个过程的示意图如下所示。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/65bb04929b8235fb677c7a78b5bd67f1.png" alt="img" style="zoom:50%"><p>​ 图2 数据恢复流程-master-slave方法</p><p>可以看到，图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。</p><p>假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show binlogs 显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就需要去binlog备份系统中找到这两个文件。</p><p><strong>把之前删掉的binlog放回备库的操作步骤</strong>，是这样的：</p><ol><li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；</li><li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是 “.&#x2F;master.000005”和“.&#x2F;master.000006”;</li><li>重启备库，目的是要让备库重新识别这两个日志文件；</li><li>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。</li></ol><p>不论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：<strong>误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。</strong></p><p>也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份。</p><p>但是，一个系统不可能备份无限的日志，你还需要根据成本和磁盘空间资源，设定一个日志保留的天数。如果你的DBA团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就表示备份系统保留的日志时间就至少是半个月。</p><p>另外，我建议你不论使用上述哪种方式，<strong>都要把这个数据恢复功能做成自动化工具，并且经常拿出来演练。</strong>为什么这么说呢？</p><p>这里的原因，主要包括两个方面：</p><ol><li>虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失降到最小，也应该不用跑路了。</li><li>而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过去了。</li></ol><h2 id="rm删除数据"><a href="#rm删除数据" class="headerlink" title="rm删除数据"></a>rm删除数据</h2><p>其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p><p>这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p><p>当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。</p><p>应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。</p><h2 id="提前预防误删"><a href="#提前预防误删" class="headerlink" title="提前预防误删"></a>提前预防误删</h2><h3 id="方法统计"><a href="#方法统计" class="headerlink" title="方法统计"></a>方法统计</h3><p>当然，<strong>我们不止要说误删数据的事后处理办法，更重要是要做到事前预防</strong>。我有以下两个建议：</p><ol><li>把<strong>sql_safe_updates</strong>参数设置为<strong>on</strong>。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li><li>代码上线前，必须经过<strong>SQL审计</strong>。</li><li>账号分离，设置<strong>用户权限</strong></li><li>制定操作<strong>规范</strong></li><li>延迟复制备库</li></ol><p>你可能会说，设置了sql_safe_updates&#x3D;on，如果我真的要把一个小表的数据全部删掉，应该怎么办呢？</p><p>如果你确定这个删除操作没问题的话，可以在delete语句中加上where条件，比如where id&gt;&#x3D;0。</p><p>但是，delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，你应该优先考虑使用truncate table或者drop table命令。</p><p>使用delete命令删除的数据，你还可以用Flashback来恢复。而使<strong>用truncate &#x2F;drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了</strong>。为什么呢？</p><p>这是因为，即使我们配置了binlog_format&#x3D;row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。</p><h3 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h3><p>虽然我们可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。</p><p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第6天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。</p><p>那么，我们有什么方法可以缩短恢复数据需要的时间呢？</p><p>如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑<strong>搭建延迟复制的备库。</strong>这个功能是MySQL 5.6版本引入的。</p><p>一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p><p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p><h3 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库&#x2F;表的方法"></a>预防误删库&#x2F;表的方法</h3><p>虽然常在河边走，很难不湿鞋，但终究还是可以找到一些方法来避免的。所以这里，我也会给你一些减少误删操作风险的建议。</p><p>第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：</p><ul><li>我们只给业务开发同学DML权限，而不给truncate&#x2F;drop权限。而如果业务开发人员有DDL需求的话，也可以通过开发管理系统得到支持。</li><li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li></ul><p>第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p><ul><li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li><li>改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li></ul><h1 id="32-讲为什么还有kill不掉的语句"><a href="#32-讲为什么还有kill不掉的语句" class="headerlink" title="32 讲为什么还有kill不掉的语句"></a>32 讲为什么还有kill不掉的语句</h1><p>在MySQL中有两个kill命令：</p><ol><li>kill query +线程id 表示终止这个线程中正在执行的语句</li><li>kill connection +线程id 这里connection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</li></ol><p>不知道你在使用MySQL的时候，有没有遇到过这样的现象：使用了kill命令，却没能断开这个连接。再执行show processlist命令，看到这条语句的Command列显示的是<strong>Killed</strong>。</p><p>你一定会奇怪，显示为Killed是什么意思，不是应该直接在show processlist的结果里看不到这个线程了吗？</p><p>其实大多数情况下，kill query&#x2F;connection命令是有效的。比如，执行一个查询的过程中，发现执行时间太久，要放弃继续查询，这时我们就可以用kill query命令，终止这条查询语句。</p><p>还有一种情况是，语句处于锁等待的时候，直接使用kill命令也是有效的。我们一起来看下这个例子：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/17f88dc70c3fbe06a7738a0ac01db4d0.png" alt="img"></p><p>​ 图1 kill query 成功的例子</p><p>可以看到，session C 执行kill query以后，session B几乎同时就提示了语句被中断。这，就是我们预期的结果。</p><h2 id="收到kill以后，线程做什么？"><a href="#收到kill以后，线程做什么？" class="headerlink" title="收到kill以后，线程做什么？"></a>收到kill以后，线程做什么？</h2><p>但是，这里你要停下来想一下：session B是直接终止掉线程，什么都不管就直接退出吗？显然，这是不行的。</p><p>我在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/69862">第6篇文章</a>中讲过，当对一个表做增删改查操作时，会在表上加MDL读锁。所以，session B虽然处于blocked状态，但还是拿着一个MDL读锁的。如果线程被kill的时候，就直接终止，那之后这个MDL读锁就没机会被释放了。</p><p>这样看来，<strong>kill并不是马上停止的意思</strong>，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始<strong>“执行停止的逻辑了”</strong>。</p><blockquote><p>其实，这跟Linux的kill命令类似，kill -N pid并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。</p></blockquote><p><strong>实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件事：</strong></p><ol><li>把session B的<strong>运行状态改成THD::KILL_QUERY</strong>(将变量killed赋值为THD::KILL_QUERY)；</li><li>给session B的执行线程<strong>发一个信号</strong>。</li></ol><blockquote><p>为什么要发信号呢？</p><p>因为像图1的我们例子里面，session B处于锁等待状态，如果只是把session B的线程状态设置THD::KILL_QUERY，<strong>线程B并不知道这个状态变化</strong>，还是会继续等待。发一个信号的目的，就是<strong>通知session B退出等待</strong>，来处理这个THD::KILL_QUERY状态。</p><p>上面的分析中，隐含了这么三层意思：</p><ol><li>一个语句执行过程中有<strong>多处“埋点”</strong>，在这些“埋点”的地方判断线程状态，如果<strong>发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑</strong>；</li><li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li><li>语句从开始进入终止逻辑，到终止逻辑完全完成，是<strong>有一个过程</strong>的。</li></ol><p>到这里你就知道了，原来不是“说停就停的”。</p></blockquote><h2 id="kill不掉的例子"><a href="#kill不掉的例子" class="headerlink" title="kill不掉的例子"></a>kill不掉的例子</h2><p>接下来，我们<strong>再看一个kill不掉的例子</strong>，也就是我们在前面<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/78134">第29篇文章</a>中提到的 innodb_thread_concurrency 不够用的例子。</p><p>首先，执行set global innodb_thread_concurrency&#x3D;2，将InnoDB的并发线程上限数设置为2；然后，执行下面的序列：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/32e4341409fabfe271db3dd4c4df696e.png" alt="img"></p><p>​ 图2 kill query 无效的例子</p><p>可以看到：</p><ol><li>sesssion C执行的时候被堵住了；</li><li>但是session D执行的kill query C命令却没什么效果，</li><li>直到session E执行了kill connection命令，才断开了session C的连接，提示“Lost connection to MySQL server during query”，</li><li>但是这时候，如果在session E中执行show processlist，你就能看到下面这个图。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/915c20e4c11b104d7bcf9d3457304c53.png" alt="img"></p><p>​ 图3 kill connection之后的效果</p><p>这时候，id&#x3D;12这个线程的<strong>Commnad列显示的是Killed</strong>。也就是说，客户端虽然断开了连接，但实际上服务端上这条语句还在执行过程中。</p><blockquote><p><strong>为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？</strong></p><p>在实现上，等行锁时，使用的是pthread_cond_timedwait函数，这个等待状态可以被唤醒。但是，在这个例子里，12号线程的等待逻辑是这样的：每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。</p><p>也就是说，虽然12号线程的状态已经被设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。</p><p>而当session E执行kill connection 命令时，是这么做的，</p><ol><li>把12号线程状态设置为KILL_CONNECTION；</li><li>关掉12号线程的网络连接。因为有这个操作，所以你会看到，这时候session C收到了断开连接的提示。</li></ol><p>那为什么执行show processlist的时候，会看到Command列显示为killed呢？其实，这就是因为在执行show processlist的时候，有一个特别的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed。</span><br></pre></td></tr></table></figure><p>所以其实，即使是客户端退出了，这个线程的状态仍然是在等待中。那这个线程什么时候会退出呢？</p><p>答案是，<strong>只有等到满足进入InnoDB的条件后，session C的查询语句继续执行</strong>，然后才有可能判断到线程状态已经变成了KILL_QUERY或者KILL_CONNECTION，再进入终止逻辑阶段。</p><p><strong>因为设置的线程数已经满了，该语句根本不能进入InnoDB执行，所有无法去判断线程的状态然后执行终止逻辑</strong></p></blockquote><h2 id="kill不掉情况总结"><a href="#kill不掉情况总结" class="headerlink" title="kill不掉情况总结"></a>kill不掉情况总结</h2><p>到这里，我们来小结一下。</p><p><strong>这个例子是kill无效的第一类情况，即：线程没有执行到判断线程状态的逻辑。</strong>跟这种情况相同的，还有由于IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。</p><p><strong>另一类情况是，终止逻辑耗时较长。</strong>这时候，从show processlist结果上看也是Command&#x3D;Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种：</p><ol><li><strong>超大事务执行期间被kill</strong>。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li><li><strong>大查询回滚</strong>。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长。</li><li><strong>DDL命令执行到最后阶段</strong>，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响耗时较久。</li></ol><blockquote><p>之前有人问过我，如果直接在客户端通过<strong>Ctrl+C</strong>命令，是不是就可以直接终止线程呢？</p><p>答案是，不可以。</p><p>这里有一个误解，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。</p><p>而由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，<strong>执行Ctrl+C的时候，是MySQL客户端另外启动一个连接，然后发送一个kill query 命令。</strong></p><p>所以，你可别以为在客户端执行完Ctrl+C就万事大吉了。因为，要kill掉一个线程，还涉及到后端的很多操作。</p></blockquote><h2 id="两个关于客户端的误解"><a href="#两个关于客户端的误解" class="headerlink" title="两个关于客户端的误解"></a>两个关于客户端的误解</h2><h3 id="库里表多，不是连接慢，跟服务端没关系"><a href="#库里表多，不是连接慢，跟服务端没关系" class="headerlink" title="库里表多，不是连接慢，跟服务端没关系"></a>库里表多，不是连接慢，跟服务端没关系</h3><p>有些线上的库，会包含很多表（我见过最多的一个库里有6万个表）。这时候，你就会发现，每次用客户端连接都会卡在下面这个界面上。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7e4666bfd580505180c77447d1f44c83.png" alt="img"></p><p>​ 图4 连接等待</p><p>而如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。因此，有同学会认为是表的数目影响了连接性能。</p><p>从<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/68319">第一篇文章</a>你就知道，每个<strong>客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。</strong></p><p>但实际上，正如图中的文字提示所说的，当使用默认参数连接的时候，<strong>MySQL客户端</strong>会提供一个<strong>本地库名和表名补全</strong>的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p><ol><li>执行show databases；</li><li>切到db1库，执行show tables；</li><li>把这两个命令的结果用于构建一个本地的哈希表。</li></ol><p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p><p>也就是说，<strong>我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。</strong></p><p>图中的提示也说了，如果在连接命令中加上**-A，就可以关掉这个自动补全的功能**，然后客户端就可以快速返回了。</p><p>这里自动补全的效果就是，你在输入库名或者表名的时候，输入前缀，可以使用Tab键自动补全表名或者显示提示。</p><p>实际使用中，如果你自动补全功能用得并不多，我建议你每次使用的时候都默认加-A。</p><h3 id="quick参数会降低服务端性能，加速客户端"><a href="#quick参数会降低服务端性能，加速客户端" class="headerlink" title="-quick参数会降低服务端性能，加速客户端"></a>-quick参数会降低服务端性能，加速客户端</h3><p>其实提示里面没有说，除了加-A以外，加–quick(或者简写为-q)参数，也可以跳过这个阶段。但是，这个<strong>–quick是一个更容易引起误会的参数，也是关于客户端常见的一个误解。</strong></p><p>你看到这个参数，是不是觉得这应该是一个让服务端加速的参数？但实际上恰恰相反，设置了<strong>这个参数可能会降低服务端的性能</strong>。为什么这么说呢？</p><p>MySQL客户端发送请求后，接收服务端返回结果的方式有两种：</p><ol><li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用API开发，对应的就是<strong>mysql_store_result</strong> 方法。</li><li>另一种是不缓存，读一个处理一个。如果你用API开发，对应的就是<strong>mysql_use_result</strong>方法。</li></ol><p><strong>MySQL客户端默认采用第一种方式，而如果加上–quick参数，就会使用第二种不缓存的方式。</strong></p><p>采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。关于服务端的具体行为，我会在下一篇文章再和你展开说明。</p><p>那你会说，既然这样，为什么要给这个参数取名叫作quick呢？这是因为使用这个参数可以达到以下三点效果：</p><ul><li>第一点，就是前面提到的，<strong>跳过表名自动补全功能</strong>。</li><li>第二点，mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能，所以使用mysql_use_result；</li><li>第三点，是不会把执行命令记录到本地的命令历史文件。</li></ul><p>所以你看到了，<strong>–quick参数的意思，是让客户端变得更快</strong>。</p><h2 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h2><p>如果你碰到一个被killed的事务一直处于回滚状态，你认为是应该直接把MySQL进程强行重启，还是应该让它自己执行完成呢？为什么呢？</p><p>因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该<strong>让它自己结束。</strong></p><p>当然，如果这个语句可能会占用别的锁，或者由于占用IO资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。</p><p>切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。这个操作属于我们在文章中说到的，减少系统压力，加速终止逻辑。</p><p><strong>总结：</strong></p><p>kill不掉的两个原因：</p><ol><li><strong>线程没有执行到判断线程状态的逻辑</strong></li><li><strong>终止逻辑耗时较长</strong></li></ol><p>库里表多是客户端慢，可用-A或-quick参数跳过客户端的一些操作，例如自动补全</p><p>-quick不会开辟本地缓存，也会跳过自动补全，不会记录历史命令记录</p><h1 id="33-查询数据大于主机内存会不会OOM"><a href="#33-查询数据大于主机内存会不会OOM" class="headerlink" title="33 查询数据大于主机内存会不会OOM"></a>33 查询数据大于主机内存会不会OOM</h1><p>我经常会被问到这样一个问题：我的主机内存只有100G，现在要对一个200G的大表做全表扫描，会不会把数据库主机的内存用光了？</p><p>这个问题确实值得担心，被系统OOM（out of memory）可不是闹着玩的。但是，反过来想想，逻辑备份的时候，可不就是做整库扫描吗？如果这样就会把内存吃光，逻辑备份不是早就挂了？</p><p>所以说，对大表做全表扫描，看来应该是没问题的。但是，这个流程到底是怎么样的呢？</p><h2 id="Server层查询逻辑"><a href="#Server层查询逻辑" class="headerlink" title="Server层查询逻辑"></a>Server层查询逻辑</h2><p>假设，我们现在要对一个200G的InnoDB表db1.t，执行一个全表扫描。当然，你要把扫描结果保存在客户端，会使用类似这样的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$host -P$port -u$user -p$pwd -e &quot;select * from db1.t&quot; &gt; $target_file</span><br></pre></td></tr></table></figure><p>你已经知道了，InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p><p>那么，这个“结果集”存在哪里呢？</p><p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p><ol><li>获取一行，写到<strong>net_buffer</strong>中。这块内存的大小是由参数<strong>net_buffer_length</strong>定义的，<strong>默认是16k</strong>。</li><li>重复获取行，直到net_buffer写满，调用网络接口发出去。</li><li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。</li><li>如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（<strong>socket send buffer</strong>）写满了，进入等待。直到网络栈重新可写，再继续发送。</li></ol><p>这个过程对应的流程图如下所示。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20231012134011637.png" alt="image-20231012134011637" style="zoom:50%"><p>​ 图1 查询结果发送流程</p><p>从这个流程中，你可以看到：</p><ol><li>一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，并不会达到200G；</li><li>socket send buffer 也不可能达到200G（默认定义&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_default），如果socket send buffer被写满，就会暂停读数据的流程。</li></ol><p>也就是说，<strong>MySQL是“边读边发的”</strong>，这个概念很重要。这就意味着，如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p><h3 id="Sending-to-client"><a href="#Sending-to-client" class="headerlink" title="Sending to client"></a>Sending to client</h3><p>比如下面这个状态，就是我故意让客户端不去读socket receive buffer中的内容，然后在服务端show processlist看到的结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/183a704d4495bebbc13c524695b5b6c3.png" alt="img"></p><p>​ 图2 服务端发送阻塞</p><p>如果你看到State的值一直处于<strong>“Sending to client”</strong>，<strong>就表示服务器端的网络栈写满了。</strong></p><p>我在上一篇文章中曾提到，如果客户端使用–quick参数，会使用mysql_use_result方法。这个方法是读一行处理一行。你可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能就会出现如图2所示的这种情况。</p><p>因此，<strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p><p>当然前提是查询返回结果不多。在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/78427">第30篇文章</a>评论区，有同学说到自己因为执行了一个大查询导致客户端占用内存近20G，这种情况下就需要改用mysql_use_result接口了。</p><blockquote><p>另一方面，如果你在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着你要让业务开发同学<strong>优化查询结果</strong>，并<strong>评估</strong>这么多的返回结果<strong>是否合理</strong>。</p><p>而如果要快速减少处于这个状态的线程的话，将<strong>net_buffer_length参数设置为一个更大的值</strong>是一个可选方案。</p></blockquote><h3 id="Sending-data"><a href="#Sending-data" class="headerlink" title="Sending data"></a>Sending data</h3><p>与“Sending to client”长相很类似的一个状态是<strong>“Sending data”</strong>，这是一个经常被误会的问题。有同学问我说，在自己维护的实例上看到很多查询语句的状态是“Sending data”，但查看网络也没什么问题啊，为什么Sending data要这么久？</p><p>实际上，一个查询语句的状态变化是这样的（注意：这里，我略去了其他无关的状态）：</p><ul><li>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”；</li><li>然后，发送执行结果的列相关的信息（meta data) 给客户端；</li><li>再继续执行语句的流程；</li><li>执行完成后，把状态设置成空字符串。</li></ul><p>也就是说，“Sending data”并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。比如，你可以构造一个锁等待的场景，就能看到Sending data状态。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/7640b0d82965bf8b305514f30425424b.png" alt="img"></p><p>​ 图3 读全表被锁</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/84533515cf36be65582309fbb85e13c0.png" alt="img"></p><p>​ 图 4 Sending data状态</p><p>可以看到，session B明显是在等锁，状态显示为Sending data。</p><p>也就是说，<strong>仅当一个线程处于“等待客户端接收结果”的状态，才会显示”Sending to client”；而如果显示成“Sending data”，它的意思只是“正在执行”</strong>。</p><p>现在你知道了，查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，<strong>并不会把内存打爆</strong>。</p><p>在server层的处理逻辑我们都清楚了，在InnoDB引擎里面又是怎么处理的呢？ 扫描全表会不会对引擎系统造成影响呢？</p><h2 id="InnoDB层处理逻辑"><a href="#InnoDB层处理逻辑" class="headerlink" title="InnoDB层处理逻辑"></a>InnoDB层处理逻辑</h2><h3 id="内存命中率"><a href="#内存命中率" class="headerlink" title="内存命中率"></a>内存命中率</h3><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/68633">第2</a>和<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73161">第15篇</a>文章中，我介绍WAL机制的时候，和你分析了InnoDB内存的一个作用，是保存更新的结果，再配合redo log，就避免了随机写盘。</p><p>内存的数据页是在Buffer Pool (BP)中管理的，在WAL里Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。</p><p>在第2篇文章的评论区有同学问道，由于有WAL机制，当事务提交的时候，磁盘上的数据页是旧的，那如果这时候马上有一个查询要来读这个数据页，是不是要马上把redo log应用到数据页呢？</p><p>答案是不需要。因为这时候内存数据页的结果是最新的，直接读内存页就可以了。你看，这时候<strong>查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以说，Buffer Pool还有加速查询的作用</strong>。</p><p>而Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong>。</p><p>你可以在show engine innodb status结果中，查看一个系统当前的BP命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在<strong>99%以上</strong>。</p><p>执行show engine innodb status ，可以看到“Buffer pool hit rate”字样，显示的就是当前的命中率。比如图5这个命中率，就是99.0%。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/c70a95ee99826812c292c46de508982e.png" alt="img"></p><p>​ 图5 show engine innodb status显示内存命中率</p><p>如果所有查询需要的数据页都能够直接从内存得到，那是最好的，对应的命中率就是100%。但，这在实际生产上是很难做到的。</p><p>InnoDB Buffer Pool的大小是由参数 <strong>innodb_buffer_pool_size</strong>确定的，<strong>一般建议设置成可用物理内存的60%~80%。</strong></p><h3 id="淘汰旧页-最近最少使用算法LRU"><a href="#淘汰旧页-最近最少使用算法LRU" class="headerlink" title="淘汰旧页 最近最少使用算法LRU"></a>淘汰旧页 最近最少使用算法LRU</h3><p>在大约十年前，单机的数据量是上百个G，而物理内存是几个G；现在虽然很多服务器都能有128G甚至更高的内存，但是单机的数据量却达到了T级别。</p><p>所以，innodb_buffer_pool_size小于磁盘的数据量是很常见的。<strong>如果一个 Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。</strong></p><p>InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是淘汰最久未使用的数据。</p><p>下图是一个LRU算法的基本模型。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/e0ac92febac50a5d881f1188ea5bfd65.jpg" alt="img" style="zoom:50%"><p>​ 图6 基本LRU算法</p><p>InnoDB管理Buffer Pool的LRU算法，是用<strong>链表</strong>来实现的。</p><ol><li>在图6的状态1里，链表头部是P1，表示P1是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；</li><li>这时候有一个读请求访问P3，因此变成状态2，P3被移到最前面；</li><li>状态3表示，这次访问的数据页是不存在于链表中的，所以需要在Buffer Pool中新申请一个数据页Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾Pm这个数据页的内存，存入Px的内容，然后放到链表头部。</li><li>从效果上看，就是最久没有被访问的数据页Pm，被淘汰了。</li></ol><p>这个算法乍一看上去没什么问题，但是如果考虑到要做一个全表扫描，会不会有问题呢？</p><p>假设按照这个算法，我们要扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访问它。</p><p>那么，<strong>按照这个算法扫描的话，就会把当前的Buffer Pool里的数据全部淘汰掉</strong>，存入扫描过程中访问到的数据页的内容。也就是说<strong>Buffer Pool里面主要放的是这个历史数据表的数据。</strong></p><p>对于一个正在做业务服务的库，<strong>这可不妙</strong>。你会看到，<strong>Buffer Pool的内存命中率急剧下降</strong>，磁盘压力增加，SQL语句响应变慢。</p><p>所以，InnoDB不能直接使用这个LRU算法。实际上，<strong>InnoDB对LRU算法做了<code>改进</code>。</strong></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/25e18920dd204cf99eec2d62755fe99e.png" alt="img" style="zoom:50%"><p>​ 图 7 改进的LRU算法</p><p>在InnoDB实现上，按照<strong>5:3</strong>的比例把整个LRU链表分成了<strong>young区域和old区域</strong>。图中LRU_old指向的就是old区域的第一个位置，是整个链表的5&#x2F;8处。也就是说，<strong>靠近链表头部的5&#x2F;8是young区域，靠近链表尾部的3&#x2F;8是old区域。</strong></p><p>改进后的LRU算法执行流程变成了下面这样。</p><ol><li>图7中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。</li><li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是<strong>新插入的数据页Px，是放在LRU_old处。</strong></li><li>处于old区域的数据页，每次被访问的时候都要做下面这个判断：<ul><li>若这个数据页在LRU链表中存在的<strong>时间超过了1秒</strong>，就把它<strong>移动到链表头部；</strong></li><li>如果这个数据页在LRU链表中存在的<strong>时间短于1秒，位置保持不变</strong>。1秒这个时间，是由参数<strong>innodb_old_blocks_time</strong>控制的。其默认值是1000，单位毫秒。于是<strong>很快就会被淘汰</strong></li></ul></li></ol><p>这个策略，就是为了处理类似全表扫描的操作量身定制的。还是以刚刚的扫描200G的历史数据表为例，我们看看改进后的LRU算法的操作逻辑：</p><ol><li>扫描过程中，需要<strong>新插入的数据页，都被放到old区域;</strong></li><li>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；</li><li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是young区域），很快就会被淘汰出去。</li></ol><p>可以看到，这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。</p><h2 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h2><p>你可以设想出由于客户端的性能问题，对数据库影响更严重的例子吗？或者你是否经历过这样的场景？你又是怎么优化的？</p><p>这个问题的核心是，<strong>造成了“长事务”</strong>。</p><p>至于长事务的影响，就要结合我们前面文章中提到的锁、MVCC的知识点了。</p><ul><li>如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住；</li><li>当然读的事务也有问题，就是会导致undo log不能被回收，导致回滚段空间膨胀。</li></ul><p>如果要快速减少处于这个状态的线程的话，将 net_buffer_length 参数设置为一个更大的值是一个可选方案。<br>对于这个方案不是很懂，“Sending to client” 表示服务器端的网路栈写满了，那不是应该加大 socket send buffer 吗？跟加大 net_buffer_length 有什么关系？net_buffer_length 加再大，但 socket send buffer 很小的话，网络栈不还是处于写满状态？</p><p>是这样的，net_buffer_length 的最大值是 1G，这个值比 socket send buffer大（一般是几M）</p><p>比如假设一个业务，他的平均查询结果都是10M （当然这个业务有有问题，最终是要通过业务解决）</p><p>但是如果我把net_buffer_length 改成10M，就不会有“Sending to client” 的情况。虽然网络栈还是慢慢发的，但是那些没发完的都缓存在net_buffer中，对于执行器来说，都是“已经写出去了”。</p><h1 id="34-讲到底可不可以使用join连接查询"><a href="#34-讲到底可不可以使用join连接查询" class="headerlink" title="34 讲到底可不可以使用join连接查询"></a>34 讲到底可不可以使用join连接查询</h1><p>在实际生产中，关于join语句使用的问题，一般会集中在以下两类：</p><ol><li>我们DBA不让使用join，使用join有什么问题呢？</li><li>如果有两个大小不同的表做join，应该用哪个表做驱动表呢？</li></ol><p>今天这篇文章，我就先跟你说说join语句到底是怎么执行的，然后再来回答这两个问题。</p><p>为了便于量化分析，我还是创建两个表t1和t2来和你说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t2` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。t2数据为(1,1,1)…(1000,1000,1000)</p><h2 id="Index-Nested-Loop-Join（NLJ）"><a href="#Index-Nested-Loop-Join（NLJ）" class="headerlink" title="Index Nested-Loop Join（NLJ）"></a>Index Nested-Loop Join（NLJ）</h2><p>我们来看一下这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 straight_join t2 on (t1.a=t2.a);</span><br></pre></td></tr></table></figure><p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程。所以，为了便于分析执行过程中的性能问题，我改用straight_join让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join。在这个语句里，t1 是驱动表，t2是被驱动表。</p><p>现在，我们来看一下这条语句的explain结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/4b9cb0e0b83618e01c9bfde44a0ea990.png" alt="img"></p><p>​ 图1 使用索引字段join的 explain结果</p><p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p><ol><li>从表t1中读入一行数据 R；</li><li>从数据行R中，取出a字段到表t2里去查找；</li><li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li><li>重复执行步骤1到3，直到表t1的末尾循环结束。</li></ol><p>这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为<strong>“Index Nested-Loop Join”，简称NLJ</strong>。</p><p>它对应的流程图如下所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/d83ad1cbd6118603be795b26d38f8df6.jpg" alt="img" style="zoom:50%"><p>​ 图2 Index Nested-Loop Join算法的执行流程</p><p>在这个流程里：</p><ol><li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li><li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li><li>所以，整个执行流程，<strong>总扫描行数是200</strong>。</li></ol><h2 id="用不用join，谁做驱动表"><a href="#用不用join，谁做驱动表" class="headerlink" title="用不用join，谁做驱动表"></a>用不用join，谁做驱动表</h2><p>现在我们知道了这个过程，再试着回答一下文章开头的两个问题。</p><p>先看第一个问题：<strong>能不能使用join?</strong></p><p>假设不使用join，那我们就只能用单表查询。我们看看上面这条语句的需求，用单表查询怎么实现。</p><ol><li>执行<code>select * from t1</code>，查出表t1的所有数据，这里有100行；</li><li>循环遍历这100行数据：<ul><li>从每一行R取出字段a的值$R.a；</li><li>执行<code>select * from t2 where a=$R.a</code>；</li><li>把返回的结果和R构成结果集的一行。</li></ul></li></ol><p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。</p><p>显然，这么做<strong>还不如直接join好</strong>。</p><p>我们再来看看第二个问题：<strong>怎么选择驱动表？</strong></p><p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p><p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p><p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。</p><p>因此整个执行过程，近似复杂度是 N + N<em>2</em>log2M。</p><p>显然，N对扫描行数的影响更大，<strong>因此应该让小表来做驱动表</strong>。</p><blockquote><p>如果你没觉得这个影响有那么“显然”， 可以这么理解：N扩大1000倍的话，扫描行数就会扩大1000倍；而M扩大1000倍，扫描行数扩大不到10倍。</p></blockquote><p>到这里小结一下，通过上面的分析我们得到了两个结论：</p><ol><li><strong>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；</strong></li><li><strong>如果使用join语句的话，需要让小表做驱动表。</strong></li></ol><p>但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。</p><p>接下来，我们再看看被驱动表用不上索引的情况。</p><h2 id="Simple-Nested-Loop-Join（SNL）"><a href="#Simple-Nested-Loop-Join（SNL）" class="headerlink" title="Simple Nested-Loop Join（SNL）"></a>Simple Nested-Loop Join（SNL）</h2><p>现在，我们把SQL语句改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 straight_join t2 on (t1.a=t2.b);</span><br></pre></td></tr></table></figure><p>由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。</p><p>你可以先设想一下这个问题，继续使用图2的算法，是不是可以得到正确的结果呢？如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。</p><p>但是，这样算来，这个SQL请求就要扫描表t2多达100次，<strong>总共扫描100*1000&#x3D;10万行</strong>。</p><p>这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围），就要扫描100亿行，这个算法看上去太“笨重”了。</p><p>当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。</p><h2 id="Block-Nested-Loop-Join（BNL）"><a href="#Block-Nested-Loop-Join（BNL）" class="headerlink" title="Block Nested-Loop Join（BNL）"></a>Block Nested-Loop Join（BNL）</h2><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p><ol><li>把表t1的数据读入线程内存<strong>join_buffer</strong>中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li><li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li></ol><p>这个过程的流程图如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/15ae4f17c46bf71e8349a8f2ef70d573.jpg" alt="img" style="zoom:50%"><p>​ 图3 Block Nested-Loop Join 算法的执行流程</p><p>对应地，这条SQL语句的explain结果如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/676921fa0883e9463dd34fb2bc5e87e1.png" alt="img"></p><p>​ 图4 不使用索引字段join的 explain结果</p><p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此<strong>总的扫描行数是1100</strong>。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的<strong>判断次数</strong>是：100*1000&#x3D;<strong>10万次</strong>。</p><p>前面我们说过，如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。因此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join算法的<strong>这10万次判断是内存操作，速度上会快很多</strong>，性能也更好。</p><p>接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。</p><p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p><ol><li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li><li>内存中的判断次数是M*N。</li></ol><p>可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p><p>然后，你可能马上就会问了，这个例子里表t1才100行，要是表t1是一个大表，<strong>join_buffer放不下怎么办呢？</strong></p><p>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。<strong>如果放不下表t1的所有数据话，策略很简单，就是分段放。</strong>我把join_buffer_size改成1200，再执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 straight_join t2 on (t1.a=t2.b);</span><br></pre></td></tr></table></figure><p>执行过程就变成了：</p><ol><li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</li><li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</li><li>清空join_buffer；</li><li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</li></ol><p>执行流程图也就变成这样：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/695adf810fcdb07e393467bcfd2f6ac4.jpg" alt="img" style="zoom:50%"><p>​ 图5 Block Nested-Loop Join – 两段</p><p>图中的步骤4和5，表示清空join_buffer再复用。</p><p>这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去join”。</p><p>可以看到，这时候由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成两次放入join_buffer，但是<strong>判断等值条件的次数</strong>还是不变的，**依然是(88+12)*1000&#x3D;10万次**。</p><p>我们再来看下，在这种情况下驱动表的选择问题。</p><p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p><p>注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。</p><p>所以，在这个算法的执行过程中：</p><ol><li>扫描行数是 N+λ<em>N</em>M；</li><li>内存判断 N*M次。</li></ol><p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。</p><p>所以结论是，<strong>应该让小表当驱动表。</strong></p><p>当然，你会发现，在<strong>N+λ<em>N</em>M</strong>这个式子里，<strong>λ</strong>才是影响扫描行数的关键因素，这个值<strong>越小越好</strong>。</p><p>刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p><p>这就是为什么，你可能会看到一些建议告诉你，如果你的join语句很慢，就把join_buffer_size改大。</p><h2 id="再次回答两个问题"><a href="#再次回答两个问题" class="headerlink" title="再次回答两个问题"></a>再次回答两个问题</h2><p>理解了MySQL执行join的两种算法，现在我们再来试着<strong>回答文章开头的两个问题</strong>。</p><p>第一个问题：能不能使用join语句？</p><ol><li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li><li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li></ol><p>所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop”字样。</p><p>第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p><ol><li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li><li>如果是Block Nested-Loop Join算法：<ul><li>在join_buffer_size足够大的时候，是一样的；</li><li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ol><p>所以，这个问题的结论就是，总是应该使用<strong>小表做驱动表</strong>。</p><h2 id="有索引谁做驱动表"><a href="#有索引谁做驱动表" class="headerlink" title="有索引谁做驱动表"></a>有索引谁做驱动表</h2><p>只有一个表有索引时：</p><p>若是外连接，则会选择有索引的作为<strong>被驱动表</strong></p><p>若是内连接，则会选择有索引的作为<strong>驱动表</strong></p><h2 id="什么叫做小表"><a href="#什么叫做小表" class="headerlink" title="什么叫做小表"></a>什么叫做小表</h2><p>当然了，这里我需要说明下，<strong>什么叫作“小表”</strong>。</p><p>我们前面的例子是没有加条件的。如果我在语句的where条件加上 t2.id&lt;&#x3D;50这个限定条件，再来看下这两条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=50;</span><br><span class="line">select * from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=50;</span><br></pre></td></tr></table></figure><p>注意，为了让两条语句的被驱动表都用不上索引，所以join字段都使用了没有索引的字段b。</p><p>但如果是用第二个语句的话，join_buffer只需要放入t2的前50行，显然是更好的。所以这里，“t2的前50行”是那个相对小的表，也就是“小表”。</p><p>我们再来看另外一组例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select t1.b,t2.* from  t1  straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;</span><br><span class="line">select t1.b,t2.* from  t2  straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100;</span><br></pre></td></tr></table></figure><p>这个例子里，表t1 和 t2都是只有100行参加join。但是，这两条语句每次查询放入join_buffer中的数据是不一样的：</p><ul><li>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；</li><li>表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段id、a和b。</li></ul><p>这里，我们应该选择表t1作为驱动表。也就是说在这个例子里，“只需要一列参与join的表t1”是那个相对小的表。</p><p>所以，更准确地说，<strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h2 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h2><p>我的问题是，如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中可能会导致IO压力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？（这个问题需要结合上一篇文章的知识点）</p><blockquote><p>看下一节的 《BNL算法可能会对内存命中率造成影响》</p></blockquote><h1 id="35-讲join语句怎么优化"><a href="#35-讲join语句怎么优化" class="headerlink" title="35 讲join语句怎么优化"></a>35 讲join语句怎么优化</h1><p>在上一篇文章中，我和你介绍了join语句的两种算法，分别是Index Nested-Loop Join(<strong>NLJ</strong>)和Block Nested-Loop Join(<strong>BNL</strong>)。</p><p>我们发现在使用NLJ算法的时候，其实效果还是不错的，比通过应用层拆分成多个语句然后再拼接查询结果更方便，而且性能也不会差。</p><p>但是，BNL算法在大表join的时候性能就差多了，比较次数等于两个表参与join的行数的乘积，很消耗CPU资源。</p><p>当然了，这两个算法都还有继续优化的空间，我们今天就来聊聊这个话题。</p><p>为了便于分析，我还是创建两个表t1、t2来和你展开今天的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table t1(id int primary key, a int, b int, index(a));</span><br><span class="line">create table t2 like t1;</span><br></pre></td></tr></table></figure><p>我在表t1里，插入了1000行数据，每一行的a&#x3D;1001-id的值。也就是说，表t1中字段a是逆序的。同时，我在表t2中插入了100万行数据。</p><h2 id="Multi-Range-Read优化回表（MRR）"><a href="#Multi-Range-Read优化回表（MRR）" class="headerlink" title="Multi-Range Read优化回表（MRR）"></a>Multi-Range Read优化回表（MRR）</h2><p>在介绍join语句的优化方案之前，我需要先和你介绍一个知识点，即：Multi-Range Read优化(MRR)。<strong>这个优化的主要目的是尽量使用顺序读盘。</strong></p><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/69236">第4篇文章</a>中，我和你介绍InnoDB的索引结构时，提到了<strong>“回表”</strong>的概念。我们先来回顾一下这个概念。回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键索引上去查整行数据的过程。</p><p>然后，有同学在留言区问到，回表过程是一行行地查数据，还是批量地查数据？</p><p>我们先来看看这个问题。假设，我执行这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where a&gt;=1 and a&lt;=100;</span><br></pre></td></tr></table></figure><p>主键索引是一棵B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图1所示。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/1761edbd7734276ae0a213af3cdd3311.jpg" alt="img" style="zoom:50%"><p>​ 图1 基本回表流程</p><p>如果随着a的值递增顺序查询的话，<strong>id的值就变成随机的，那么就会出现随机访问，性能相对较差</strong>。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。</p><p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p><p>这，就是MRR优化的设计思路。此时，语句的执行流程变成了这样：</p><ol><li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;</li><li>将read_rnd_buffer中的id进行递增排序；</li><li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。</li></ol><p>这里，read_rnd_buffer的大小是由<strong>read_rnd_buffer_size</strong>参数控制的。如果步骤1中，read_rnd_buffer放满了，就会先执行完步骤2和3，然后清空read_rnd_buffer。之后继续找索引a的下个记录，并继续循环。</p><p>另外需要说明的是，如果你想要稳定地使用MRR优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用MRR，把mrr_cost_based设置为off，就是固定使用MRR了。）</p><p>下面两幅图就是使用了MRR优化后的执行流程和explain结果。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/d502fbaea7cac6f815c626b078da86c7.jpg" alt="img" style="zoom:50%"><p>​ 图2 MRR执行流程</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/a513d07ebaf1ae044d44391c89bc6432.png" alt="img"></p><p>​ 图3 MRR执行流程的explain结果</p><p>从图3的explain结果中，我们可以看到Extra字段多了<strong>Using MRR</strong>，表示的是用上了MRR优化。而且，由于我们在read_rnd_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递增顺序的，也就是与图1结果集中行的顺序相反。</p><p>到这里，我们小结一下。</p><p><strong>MRR能够提升性能的核心</strong>在于，这条查询语句在索引a上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p><h2 id="Batched-Key-Access优化NLJ和BNL（BKA）"><a href="#Batched-Key-Access优化NLJ和BNL（BKA）" class="headerlink" title="Batched Key Access优化NLJ和BNL（BKA）"></a>Batched Key Access优化NLJ和BNL（BKA）</h2><h3 id="BKA优化NLJ"><a href="#BKA优化NLJ" class="headerlink" title="BKA优化NLJ"></a>BKA优化NLJ</h3><p>理解了MRR性能提升的原理，我们就能理解MySQL在5.6版本后开始引入的Batched Key Acess(BKA)算法了。这个BKA算法，其实就是对NLJ算法的优化。</p><p>我们再来看看上一篇文章中用到的NLJ算法的流程图：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/10e14e8b9691ac6337d457172b641a3d.jpg" alt="img" style="zoom:50%"><p>​ 图4 Index Nested-Loop Join流程图</p><p>NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是说，对于表t2来说，每次都是匹配一个值。这时，MRR的优势就用不上了。</p><p>那怎么才能<strong>一次性地多传些值</strong>给表t2呢？方法就是，从表t1里一次性地多拿些行出来，一起传给表t2。</p><p>既然如此，我们就把表t1的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，就是<strong>join_buffer</strong>。</p><p>通过上一篇文章，我们知道join_buffer <strong>在BNL算法里的作用，是暂存驱动表的数据</strong>。但是<strong>在NLJ算法</strong>里并没有用。那么，我们刚好就可以<strong>复用join_buffer到BKA算法</strong>中。</p><p>如图5所示，是上面的NLJ算法优化后的BKA算法的流程。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/31d85666542b9cb0b47a447a8593a47e.jpg" alt="img" style="zoom:50%"><p>​ 图5 Batched Key Acess流程</p><p>图中，我在join_buffer中放入的数据是P1<del>P100，表示的是只会取查询需要的字段。当然，如果join buffer放不下P1</del>P100的所有数据，就会把这100行数据分成多段执行上图的流程。</p><p>那么，这个BKA算法到底要怎么启用呢？</p><p>如果要使用BKA优化算法的话，你需要在执行SQL语句之前，先设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;</span><br></pre></td></tr></table></figure><p>其中，前两个参数的作用是要启用MRR。这么做的原因是，<strong>BKA算法的优化要依赖于MRR</strong>。</p><h3 id="BKA优化BNL"><a href="#BKA优化BNL" class="headerlink" title="BKA优化BNL"></a>BKA优化BNL</h3><h4 id="BNL算法可能会对内存命中率造成影响"><a href="#BNL算法可能会对内存命中率造成影响" class="headerlink" title="BNL算法可能会对内存命中率造成影响"></a>BNL算法可能会对内存命中率造成影响</h4><p>说完了NLJ算法的优化，我们再来看BNL算法的优化。</p><p>我在上一篇文章末尾，给你留下的思考题是<strong>，使用Block Nested-Loop Join(BNL)算法时，可能会对被驱动表做多次扫描。如果这个被驱动表是一个大的冷数据表，除了会导致IO压力大以外，还会对系统有什么影响呢？</strong></p><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/79407">第33篇文章</a>中，我们说到InnoDB的LRU算法的时候提到，由于InnoDB对Bufffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。如果1秒之后这个数据页不再被访问了，就不会被移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。</p><p>但是，<strong>如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒</strong>，就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表头部。</p><p>这种情况对应的，是冷表的数据量小于整个Buffer Pool的3&#x2F;8，能够完全放入old区域的情况。</p><p>如果这个<strong>冷表很大</strong>，就会出现另外一种情况：<strong>业务正常访问的数据页，没有机会进入young区域</strong>。</p><p>由于优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒之内就被淘汰了。这样，就会导致这个MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理地淘汰。</p><p>也就是说，这两种情况都<strong>会影响Buffer Pool的正常运作</strong>。</p><p><strong>大表join操作虽然对IO有影响，但是在语句执行结束后，对IO的影响也就结束了。但是，对Buffer Pool的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong></p><p>为了减少这种影响，你可以考虑增大join_buffer_size的值，减少对被驱动表的扫描次数。</p><p>也就是说，BNL算法对系统的影响主要包括三个方面：</p><ol><li>可能会多次扫描被驱动表，占用磁盘IO资源；</li><li>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源；</li><li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。</li></ol><p>我们执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否要使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上索引，把BNL算法转成BKA算法。</p><p>接下来，我们就具体看看，这个优化怎么做？</p><h4 id="BNL转BKA"><a href="#BNL转BKA" class="headerlink" title="BNL转BKA"></a>BNL转BKA</h4><ul><li>适合建索引时：</li></ul><p>一些情况下，我们<strong>可以直接在被驱动表上建索引</strong>，这时就可以直接转成BKA算法了。</p><ul><li>不适合2建索引时：建立临时表，在临时表上建索引</li></ul><p>但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 join t2 on (t1.b=t2.b) where t2.b&gt;=1 and t2.b&lt;=2000;</span><br></pre></td></tr></table></figure><p>我们在文章开始的时候，在表t2中插入了100万行数据，但是经过where条件过滤后，需要参与join的只有2000行数据。如果这条语句同时是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。</p><p>但是，如果使用BNL算法来join的话，这个语句的执行流程是这样的：</p><ol><li>把表t1的所有字段取出来，存入join_buffer中。这个表只有1000行，join_buffer_size默认值是256k，可以完全存入。</li><li>扫描表t2，取出每一行数据跟join_buffer中的数据进行对比，<ul><li>如果不满足t1.b&#x3D;t2.b，则跳过；</li><li>如果满足t1.b&#x3D;t2.b, 再判断其他条件，也就是是否满足t2.b处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。</li></ul></li></ol><p>我在上一篇文章中说过，对于表t2的每一行，判断join是否满足的时候，都需要遍历join_buffer中的所有行。因此判断等值条件的次数是1000*100万&#x3D;10亿次，这个判断的工作量很大。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/92fbdbfc35da3040396401250cb33f60.png" alt="img"></p><p>​ 图6 explain结果</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d862bc3e88305688df2c354a4b26809c.png" alt="img"></p><p>​ 图7 语句执行时间</p><p>可以看到，explain结果里Extra字段显示使用了BNL算法。在我的测试环境里，这条语句需要执行1分11秒。</p><p>在表t2的字段b上创建索引会浪费资源，但是不创建索引的话这个语句的等值条件要判断10亿次，想想也是浪费。那么，有没有两全其美的办法呢？</p><p>这时候，我们可以考虑<strong>使用临时表</strong>。使用临时表的大致思路是：</p><ol><li>把表t2中<strong>满足条件的数据放在临时表tmp_t中</strong>；</li><li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；</li><li>让表t1和tmp_t做join操作。</li></ol><p>此时，对应的SQL语句的写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;</span><br><span class="line">insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;</span><br><span class="line">select * from t1 join temp_t on (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure><p>图8就是这个语句序列的执行效果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/a80cdffe8173fa0fd8969ed976ac6ac7.png" alt="img"></p><p>​ 图8 使用临时表的执行效果</p><p>可以看到，整个过程3个语句执行时间的总和还不到1秒，相比于前面的1分11秒，性能得到了大幅提升。接下来，我们一起看一下这个过程的消耗：</p><ol><li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描行数是100万。</li><li>之后的join语句，扫描表t1，这里的扫描行数是1000；join比较过程中，做了1000次带索引的查询。相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的。</li></ol><p>总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让join语句能够用上被驱动表上的索引，来触发BKA算法，提升查询性能。</p><h2 id="扩展：hash-join"><a href="#扩展：hash-join" class="headerlink" title="扩展：hash join"></a>扩展：hash join</h2><p>看到这里你可能发现了，其实上面计算10亿次那个操作，看上去有点儿傻。如果join_buffer里面维护的不是一个无序数组，而是一个哈希表的话，那么就不是10亿次判断，而是100万次hash查找。这样的话，整条语句的执行速度就快多了吧？</p><p>确实如此。</p><p>这，也正是MySQL的优化器和执行器一直被诟病的一个原因：不支持哈希join。并且，MySQL官方的roadmap，也是迟迟没有把这个优化排上议程。</p><p>实际上，这个优化思路，我们可以自己实现在业务端。实现流程大致如下：</p><ol><li><code>select * from t1;</code>取得表t1的全部1000行数据，在业务端存入一个hash结构，比如C++里的set、PHP的dict这样的数据结构。</li><li><code>select * from t2 where b&gt;=1 and b&lt;=2000;</code> 获取表t2中满足条件的2000行数据。</li><li>把这2000行数据，一行一行地取到业务端，到hash结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li></ol><p>理论上，这个过程会比临时表方案的执行速度还要快一些。如果你感兴趣的话，可以自己验证一下。</p><p>现在，<strong>MySQL8.0.20已经支持Hash Join，正在逐步淘汰BNL</strong></p><h2 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h2><p>我们在讲join语句的这两篇文章中，都只涉及到了两个表的join。那么，现在有一个三个表join的需求，假设这三个表的表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t1` (</span><br><span class="line"> `id` int(11) NOT NULL,</span><br><span class="line"> `a` int(11) DEFAULT NULL,</span><br><span class="line"> `b` int(11) DEFAULT NULL,</span><br><span class="line"> `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">create table t2 like t1;</span><br><span class="line">create table t3 like t2;</span><br><span class="line">insert into ... //初始化三张表的数据</span><br></pre></td></tr></table></figure><p>语句的需求实现如下的join逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 join t2 on(t1.a=t2.a) join t3 on (t2.b=t3.b) where t1.c&gt;=X and t2.c&gt;=Y and t3.c&gt;=Z;</span><br></pre></td></tr></table></figure><p>现在为了得到最快的执行速度，如果让你来设计表t1、t2、t3上的索引，来支持这个join语句，你会加哪些索引呢？</p><p>同时，如果我希望你用straight_join来重写这个语句，配合你创建的索引，你就需要安排连接顺序，你主要考虑的因素是什么呢？</p><p>第一原则是要<strong>尽量使用BKA算法</strong>。需要注意的是，使用BKA算法的时候，并不是“先计算两个表join的结果，再跟第三个表join”，而是直接嵌套查询的。</p><p>具体实现是：在t1.c&gt;&#x3D;X、t2.c&gt;&#x3D;Y、t3.c&gt;&#x3D;Z这三个条件里，选择一个经过过滤以后，数据最少的那个表，作为第一个驱动表。此时，可能会出现如下两种情况。</p><p>第一种情况，如果选出来是表t1或者t3，那剩下的部分就固定了。</p><ol><li>如果驱动表是t1，则连接顺序是t1-&gt;t2-&gt;t3，要在被驱动表字段创建上索引，也就是t2.a 和 t3.b上创建索引；</li><li>如果驱动表是t3，则连接顺序是t3-&gt;t2-&gt;t1，需要在t2.b 和 t1.a上创建索引。</li></ol><p>同时，我们还需要在第一个驱动表的字段c上创建索引。</p><p>第二种情况是，如果选出来的第一个驱动表是表t2的话，则需要评估另外两个条件的过滤效果。</p><p>总之，整体的思路就是，尽量让每一次参与join的驱动表的数据集，越小越好，因为这样我们的驱动表就会越小。</p><p><strong>总结：</strong></p><p>今天，我和你分享了Index Nested-Loop Join（NLJ）和Block Nested-Loop Join（BNL）的优化方法。</p><p>在这些优化方法中：</p><ol><li>BKA优化是MySQL已经内置支持的，建议你默认使用；</li><li>BNL算法效率低，建议你都尽量转成BKA算法。<strong>优化的方向就是给被驱动表的关联字段加上索引</strong>；</li><li>基于临时表的改进方案，对于能够提前过滤出小数据的join语句来说，效果还是很好的；</li><li>MySQL目前的版本还不支持hash join，但你可以配合应用端自己模拟出来，理论上效果要好于临时表的方案。</li></ol><h1 id="36-临时表"><a href="#36-临时表" class="headerlink" title="36 临时表"></a>36 临时表</h1><h2 id="临时表和内存表"><a href="#临时表和内存表" class="headerlink" title="临时表和内存表"></a>临时表和内存表</h2><p>在上一篇文章中，我们在优化join查询的时候使用到了临时表。当时，我们是这么用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create temporary table temp_t like t1;</span><br><span class="line">alter table temp_t add index(b);</span><br><span class="line">insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;</span><br><span class="line">select * from t1 join temp_t on (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure><p>你可能会有疑问，为什么要用临时表呢？直接用普通表是不是也可以呢？</p><p>今天我们就从这个问题说起：临时表有哪些特征，为什么它适合这个场景？</p><p>这里，我需要先帮你厘清一个容易误解的问题：有的人可能会认为，临时表就是内存表。但是，这两个概念可是完全不同的。</p><ul><li><strong>内存表</strong>，指的是使用<strong>Memory引擎的表</strong>，建表语法是create table … engine&#x3D;memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li><li>而<strong>临时表</strong>，可以使用各种引擎类型 。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。</li></ul><p>弄清楚了内存表和临时表的区别以后，我们再来看看临时表有哪些特征。</p><h2 id="临时表的特点"><a href="#临时表的特点" class="headerlink" title="临时表的特点"></a>临时表的特点</h2><p>为了便于理解，我们来看下下面这个操作序列：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/3cbb2843ef9a84ee582330fb1bd0d6e3.png" alt="img" style="zoom:50%"><p>​ 图1 临时表特性示例</p><p>可以看到，临时表在使用上有以下几个特点：</p><ol><li>建表语法是<strong>create temporary table</strong> …。</li><li>一个临时表<strong>只能被创建它的session访问</strong>，对其他线程不可见。所以，图中session A创建的临时表t，对于session B就是不可见的。</li><li>临时表<strong>可以与普通表同名</strong>。</li><li>session A内有同名的临时表和普通表的时候，show create语句，以及增删改查语句<strong>优先访问的是临时表</strong>。</li><li><strong>show tables命令不显示临时表</strong>。</li></ol><p>由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表。也正是由于这个特性，<strong>临时表就特别适合我们文章开头的join优化这种场景</strong>。为什么呢？</p><p>原因主要包括以下两个方面<strong>优点</strong>：</p><ol><li>不同session的临时表是可以重名的，如果有多个session同时执行join优化，不需要担心表名重复导致建表失败的问题。</li><li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li></ol><h2 id="临时表的应用"><a href="#临时表的应用" class="headerlink" title="临时表的应用"></a>临时表的应用</h2><p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p><p>一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上。如下图所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/ddb9c43526dfd9b9a3e6f8c153478181.jpg" alt="img" style="zoom:50%"><p>​ 图2 分库分表简图</p><p>一般情况下，这种分库分表系统都有一个中间层proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有proxy这一层。</p><p>在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将这条语句路由到哪个分表做查询。</p><p>比如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select v from ht where f=N;</span><br></pre></td></tr></table></figure><p>这时，我们就可以通过分表规则（比如，N%1024)来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。</p><p>但是，如果这个表上还有另外一个索引k，并且查询语句是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select v from ht where k &gt;= M order by t_modified desc limit 100;</span><br></pre></td></tr></table></figure><p>这时候，由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一做order by 的操作。这种情况下，有两种比较常用的思路。</p><p><strong>第一种思路是，</strong>在proxy层的进程代码中实现排序。</p><p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p><ol><li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高；</li><li>对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题。</li></ol><p><strong>另一种思路就是，</strong>把各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作。</p><p>比如上面这条语句，执行流程可以类似这样：</p><ul><li>在汇总库<strong>上创建一个临时表temp_ht</strong>，表里包含三个字段v、k、t_modified；</li><li>在各个分库上执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100;</span><br></pre></td></tr></table></figure><ul><li>把分库执行的结果插入到temp_ht表中；</li><li>执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select v from temp_ht order by t_modified desc limit 100; </span><br></pre></td></tr></table></figure><p>得到结果。</p><p>这个过程对应的流程图如下所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/f5ebe0f5af37deeb4d0b63d6fb11fc0d.jpg" alt="img" style="zoom:50%"><p>​ 图3 跨库查询流程示意图</p><p><strong>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表temp_ht放到32个分库中的某一个上。</strong>这时的查询逻辑与图3类似，你可以自己再思考一下具体的流程。</p><h2 id="为什么临时表可以重名？"><a href="#为什么临时表可以重名？" class="headerlink" title="为什么临时表可以重名？"></a>为什么临时表可以重名？</h2><h3 id="临时表文件命名区别"><a href="#临时表文件命名区别" class="headerlink" title="临时表文件命名区别"></a>临时表文件命名区别</h3><p>你可能会问，不同线程可以创建同名的临时表，这是怎么做到的呢？</p><p>接下来，我们就看一下这个问题。</p><p>我们在执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create temporary table temp_t(id int primary key)engine=innodb;</span><br></pre></td></tr></table></figure><p>这个语句的时候，MySQL要给这个InnoDB表创建一个<strong>frm</strong>文件保存表结构定义，还要有地方保存表数据。</p><p>**这个frm文件放在临时文件目录下，文件名的后缀是.frm，<code>前缀是“#sql&#123;进程id&#125;_&#123;线程id&#125;_序列号”</code>**。你可以使用select @@tmpdir命令，来显示实例的临时文件目录。</p><p>而关于表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：</p><ul><li>在<strong>5.6以及之前</strong>的版本里，MySQL会在临时文件目录下创建一个相同前缀、以**.ibd<strong>为后缀的文件，用来</strong>存放数据**文件；</li><li>而从 <strong>5.7版本开始</strong>，MySQL引入了一个<strong>临时文件表空间</strong>，专门用来存放临时文件的数据。因此，我们就不需要再创建ibd文件了。</li></ul><p>从文件名的前缀规则，我们可以看到，其实创建一个叫作t1的InnoDB临时表，MySQL在存储上认为我们创建的表名跟普通表t1是不同的，因此同一个库下面已经有普通表t1的情况下，还是可以再创建一个临时表t1的。</p><p>为了便于后面讨论，我先来举一个例子。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/22078eab5c7688c9fbfd6185555bd91b.png" alt="img"></p><p>​ 图4 临时表的表名</p><p>这个进程的进程号是1234，session A的线程id是4，session B的线程id是5。所以你看到了，session A和session B创建的临时表，在磁盘上的文件不会重名。</p><h3 id="内存table-def-key区别"><a href="#内存table-def-key区别" class="headerlink" title="内存table_def_key区别"></a>内存table_def_key区别</h3><p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个<strong>table_def_key</strong>。</p><ul><li>一个<strong>普通表</strong>的table_def_key的值是由<strong>“库名+表名”</strong>得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。</li><li>而对于<strong>临时表</strong>，table_def_key在<strong>“库名+表名”</strong>基础上，又加入了<strong>“server_id+thread_id”</strong>。</li></ul><p>也就是说，session A和sessionB创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。</p><p>在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。</p><p>这时候你会发现，binlog中也记录了DROP TEMPORARY TABLE这条命令。你一定会觉得奇怪，临时表只在线程内自己可以访问，为什么需要写到binlog里面？</p><p>这，就需要说到主备复制了。</p><h2 id="临时表的主备复制问题"><a href="#临时表的主备复制问题" class="headerlink" title="临时表的主备复制问题"></a>临时表的主备复制问题</h2><h3 id="什么情况binlog需要记录临时表sql语句"><a href="#什么情况binlog需要记录临时表sql语句" class="headerlink" title="什么情况binlog需要记录临时表sql语句"></a>什么情况binlog需要记录临时表sql语句</h3><p>既然写binlog，就意味着备库需要。</p><p>你可以设想一下，在主库上执行下面这个语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/</span><br><span class="line">create temporary table temp_t like t_normal;/*Q2*/</span><br><span class="line">insert into temp_t values(1,1);/*Q3*/</span><br><span class="line">insert into t_normal select * from temp_t;/*Q4*/</span><br></pre></td></tr></table></figure><p>如果关于临时表的操作都不记录，那么在备库就只有create table t_normal表和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。</p><p>你可能会说，如果把binlog设置为row格式就好了吧？因为binlog是row格式时，在记录insert into t_normal的binlog时，记录的是这个操作的数据，即：write_row event里面记录的逻辑是“插入一行数据（1,1)”。</p><p>确实是这样。<strong>如果当前的binlog_format&#x3D;row，那么跟临时表有关的语句，就不会记录到binlog里</strong>。也就是说，<strong>只在binlog_format&#x3D;statment&#x2F;mixed 的时候，binlog中才会记录临时表的操作</strong>。</p><h3 id="statment-mixed格式需要额外执行DROP-TEMPORARY-TABLE传给备库执行"><a href="#statment-mixed格式需要额外执行DROP-TEMPORARY-TABLE传给备库执行" class="headerlink" title="statment&#x2F;mixed格式需要额外执行DROP TEMPORARY TABLE传给备库执行"></a>statment&#x2F;mixed格式需要额外执行DROP TEMPORARY TABLE传给备库执行</h3><p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上<strong>再写一个DROP TEMPORARY TABLE传给备库执行</strong>。</p><p><strong>之前有人问过我一个有趣的问题：</strong>MySQL在记录binlog的时候，不论是create table还是alter table语句，都是原样记录，甚至于连空格都不变。但是如果执行drop table t_normal，系统记录binlog就会写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE `t_normal` /* generated by server */</span><br></pre></td></tr></table></figure><p>也就是改成了标准的格式。为什么要这么做呢 ？</p><p>现在你知道原因了，那就是：drop table命令是可以一次删除多个表的。比如，在上面的例子中，设置binlog_format&#x3D;row，如果主库上执行 “drop table t_normal, temp_t”这个命令，那么binlog中就只能记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE `t_normal` /* generated by server */</span><br></pre></td></tr></table></figure><p>因为备库上并没有表temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。</p><p>所以，drop table命令记录binlog的时候，就必须对语句做改写。“&#x2F;* generated by server *&#x2F;”说明了这是一个被服务端改写过的命令。</p><h3 id="备库执行临时表sql也能区分同名表"><a href="#备库执行临时表sql也能区分同名表" class="headerlink" title="备库执行临时表sql也能区分同名表"></a>备库执行临时表sql也能区分同名表</h3><p>说到主备复制，<strong>还有另外一个问题需要解决</strong>：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？</p><p>现在，我给你举个例子，下面的序列中实例S是M的备库。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/74e789024f10bcde515f21c0368847ba.png" alt="img"></p><p>​ 图5 主备关系中的临时表操作</p><p>主库M上的两个session创建了同名的临时表t1，这两个create temporary table t1 语句都会被传到备库S上。</p><p>但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个create 语句两次。（即使开了多线程复制，也可能被分配到从库的同一个worker中执行）。那么，这会不会导致同步线程报错 ？</p><p>显然是不会的，否则临时表就是一个bug了。也就是说，备库线程在执行的时候，要把这两个t1表当做两个不同的临时表来处理。这，又是怎么实现的呢？</p><p>MySQL在记录binlog的时候，<strong>会把主库执行这个语句的线程id写到binlog中</strong>。这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key：</p><ol><li>session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid”+“session A的thread_id”;</li><li>session B的临时表t1，在备库的table_def_key就是 ：库名+t1+“M的serverid”+“session B的thread_id”。</li></ol><p>由于table_def_key不同，所以这两个表在备库的应用线程里面是不会冲突的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天这篇文章，我和你介绍了临时表的用法和特性。</p><p>在实际应用中，<strong>临时表一般用于处理比较复杂的计算逻辑</strong>。由于临时表是每个线程自己可见的，所以不需要考虑多个线程执行同一个处理逻辑时，临时表的重名问题。在线程退出的时候，临时表也能自动删除，省去了收尾和异常处理的工作。</p><p>如何区分同名临时表：</p><ol><li>临时表文件格式	#sql{进程id}_{线程id}_序列号.frm<br>内存table_def_key&#x3D;库名+表名+server_id+thread_id</li><li>普通表和临时表以临时表优先</li><li>备库备份时也能构建table_def_key以区分同名临时表</li></ol><p>在binlog_format&#x3D;<strong>‘row’</strong>的时候，临时表的操作<strong>不记录到binlog</strong>中，也省去了不少麻烦，这也可以成为你选择binlog_format时的一个考虑因素。</p><p>需要注意的是，我们上面说到的这种临时表，是用户自己创建的 ，也可以称为用户临时表。与它相对应的，就是内部临时表，在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73795">第17篇文章</a>中我已经和你介绍过。</p><h2 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h2><p>下面的语句序列是创建一个临时表，并将其改名：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/333ad95b2ce16de1931fe347128caff9.png" alt="img"></p><p>​ 图6 关于临时表改名的思考题</p><p>可以看到，我们可以使用alter table语法修改临时表的表名，而不能使用rename语法。你知道这是什么原因吗？</p><p>在实现上，执行rename table语句的时候，要求按照“库名&#x2F;表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是“#sql{进程id}_{线程id}_序列号.frm”，因此会报“找不到文件名”的错误。</p><h1 id="37-内存临时表"><a href="#37-内存临时表" class="headerlink" title="37 内存临时表"></a>37 内存临时表</h1><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73479">第16</a>和<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/79700">第34</a>篇文章中，我分别和你介绍了sort buffer、内存临时表和join buffer。这三个数据结构都是用来存放语句执行过程中的中间数据，以辅助SQL语句的执行的。其中，我们在排序的时候用到了sort buffer，在使用join语句的时候用到了join buffer。</p><p>然后，你可能会有这样的疑问，MySQL什么时候会使用内部临时表呢？</p><p>今天这篇文章，我就先给你举两个需要用到内部临时表的例子，来看看内部临时表是怎么工作的。然后，我们再来分析，什么情况下会使用内部临时表。</p><h2 id="什么时候会使用内存临时表"><a href="#什么时候会使用内存临时表" class="headerlink" title="什么时候会使用内存临时表"></a>什么时候会使用内存临时表</h2><h3 id="union-执行流程"><a href="#union-执行流程" class="headerlink" title="union 执行流程"></a>union 执行流程</h3><p>为了便于量化分析，我用下面的表t1来举例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table t1(id int primary key, a int, b int, index(a));</span><br><span class="line">delimiter ;;</span><br><span class="line">create procedure idata()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line"></span><br><span class="line">  set i=1;</span><br><span class="line">  while(i&lt;=1000)do</span><br><span class="line">    insert into t1 values(i, i, i);</span><br><span class="line">    set i=i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call idata();</span><br></pre></td></tr></table></figure><p>然后，我们执行下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select 1000 as f) union (select id from t1 order by id desc limit 2);</span><br></pre></td></tr></table></figure><p>这条语句用到了union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p><p>下图是这个语句的explain结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/402cbdef84eef8f1b42201c6ec4bad4e.png" alt="img"></p><p>​ 图1 union语句explain 结果</p><p>可以看到：</p><ul><li>第二行的key&#x3D;PRIMARY，说明第二个子句用到了索引id。</li><li>第三行的Extra字段，表示在对子查询的结果集做union的时候，使用了临时表(Using temporary)。</li></ul><p>这个语句的执行流程是这样的：</p><ol><li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。</li><li>执行第一个子查询，得到1000这个值，并存入临时表中。</li><li>执行第二个子查询：<ul><li>拿到第一行id&#x3D;1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li><li>取到第二行id&#x3D;999，插入临时表成功。</li></ul></li><li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。</li></ol><p>这个过程的流程图如下所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/5d038c1366d375cc997005a5d65c600e.jpg" alt="img" style="zoom:50%"><p>​ 图 2 union 执行流程</p><p>可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。</p><p>顺便提一下，如果把上面这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/c1e90d1d7417b484d566b95720fe3f6d.png" alt="img"></p><p>​ 图3 union all的explain结果</p><p>可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表了。</p><h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><p>另外一个常见的使用临时表的例子是group by，我们来看一下这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id%10 as m, count(*) as c from t1 group by m;</span><br></pre></td></tr></table></figure><p>这个语句的逻辑是把表t1里的数据，按照 id%10 进行分组统计，并按照m的结果排序后输出。它的explain结果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3d1cb94589b6b3c4bb57b0bdfa385d98.png" alt="img"></p><p>​ 图4 group by 的explain结果</p><p>在Extra字段里面，我们可以看到三个信息：</p><ul><li>Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表；</li><li>Using temporary，表示使用了临时表；</li><li>Using filesort，表示需要排序。</li></ul><p>这个语句的执行流程是这样的：</p><ol><li>创建内存临时表，表里有两个字段m和c，主键是m；</li><li>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；<ul><li>如果临时表中没有主键为x的行，就插入一个记录(x,1);</li><li>如果表中有主键为x的行，就将x这一行的c值加1；</li></ul></li><li>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。</li></ol><p>这个流程的执行图如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/0399382169faf50fc1b354099af71954.jpg" alt="img" style="zoom:50%"><p>​ 图5 group by执行流程</p><p>图中最后一步，对内存临时表的排序，在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73795">第17篇文章</a>中已经有过介绍，我把图贴过来，方便你回顾。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/b5168d201f5a89de3b424ede2ebf3d68.jpg" alt="img" style="zoom:50%"><p>​ 图6 内存临时表排序流程</p><p>其中，临时表的排序过程就是图6中虚线框内的过程。</p><p>接下来，我们再看一下这条语句的执行结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/ae6a28d890efc35ee4d07f694068f455.png" alt="img"></p><p>​ 图 7 group by执行结果</p><p>如果你的需求并<strong>不需要对结果进行排序</strong>，那你可以在SQL语句末尾增加<strong>order by null</strong>，也就是改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id%10 as m, count(*) as c from t1 group by m order by null;</span><br></pre></td></tr></table></figure><p>这样就跳过了最后排序的阶段，直接从临时表中取数据返回。返回的结果如图8所示。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/036634e53276eaf8535c3442805dfaeb.png" alt="img"></p><p>​ 图8 group + order by null 的结果（内存临时表）</p><p>由于表t1中的id值是从1开始的，因此返回的结果集中第一行是id&#x3D;1；扫描到id&#x3D;10的时候才插入m&#x3D;0这一行，因此结果集里最后一行才是m&#x3D;0。</p><p>这个例子里由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数<strong>tmp_table_size</strong>就是控制这个内存大小的，<strong>默认是16M</strong>。</p><p>如果我执行下面这个语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set tmp_table_size=1024;</span><br><span class="line">select id%100 as m, count(*) as c from t1 group by m order by null limit 10;</span><br></pre></td></tr></table></figure><p>把内存临时表的大小限制为最大1024字节，并把语句改成id % 100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024字节）。</p><p>那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。 这时，返回的结果如图9所示。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/a76381d0f3c947292cc28198901f9e6e.png" alt="img"></p><p>​ 图9 group + order by null 的结果（磁盘临时表）</p><p>如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。</p><h2 id="group-by的优化"><a href="#group-by的优化" class="headerlink" title="group by的优化"></a>group by的优化</h2><h3 id="group-by-优化方法-–索引"><a href="#group-by-优化方法-–索引" class="headerlink" title="group by 优化方法 –索引"></a>group by 优化方法 –索引</h3><p>可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个group by语句执行起来就会很慢，我们有什么优化的方法呢？</p><p>要解决group by语句的优化问题，你可以先想一下这个问题：执行group by语句为什么需要临时表？</p><p>group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p><p>那么，如果扫描过程中可以<strong>保证出现的数据是有序的</strong>，是不是就简单了呢？</p><p>假设，现在有一个类似图10的这么一个数据结构，我们来看看group by可以怎么做。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/5c4a581c324c1f6702f9a2c70acddd19.jpg" alt="img" style="zoom:50%"><p>​ 图10 group by算法优化-有序输入</p><p>可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程：</p><ul><li>当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是(0,X);</li><li>当碰到第一个2的时候，已经知道累积了Y个1，结果集里的第二行就是(1,Y);</li></ul><p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外排序。</p><p>你一定想到了，InnoDB的索引，就可以满足这个输入有序的条件。</p><p>在MySQL 5.7版本支持了<strong>generated column</strong>机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t1 add column z int generated always as(id % 100), add index(z);</span><br></pre></td></tr></table></figure><p>这样，索引z上的数据就是类似图10这样有序的了。上面的group by语句就可以改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select z, count(*) as c from t1 group by z;</span><br></pre></td></tr></table></figure><p>优化后的group by语句的explain结果，如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/c9f88fa42d92cf7dde78fca26c4798b9.png" alt="img"></p><p>​ 图11 group by 优化的explain结果</p><p>从Extra字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。</p><h3 id="group-by优化方法-–直接排序"><a href="#group-by优化方法-–直接排序" class="headerlink" title="group by优化方法 –直接排序"></a>group by优化方法 –直接排序</h3><p>所以，如果可以通过加索引来完成group by逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的group by要怎么优化呢？</p><p>如果我们明明知道，一个group by语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。</p><p>那么，我们就会想了，MySQL有没有让我们直接走磁盘临时表的方法呢？</p><p>答案是，有的。</p><p>在group by语句中加入<strong>SQL_BIG_RESULT</strong>这个提示（hint），就可以<strong>告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表</strong>。</p><p>MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p><p>因此，下面这个语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</span><br></pre></td></tr></table></figure><p>的执行流程就是这样的：</p><ol><li>初始化sort_buffer，确定放入一个整型字段，记为m；</li><li>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</li><li>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序）；</li><li>排序完成后，就得到了一个有序数组。</li></ol><p>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。这一步的逻辑，你已经从前面的图10中了解过了。</p><p>下面两张图分别是执行流程图和执行explain命令得到的结果。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/8269dc6206a7ef20cb515c23df0b846a.jpg" alt="img" style="zoom:50%"><p>​ 图12 使用 SQL_BIG_RESULT的执行流程图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/83b6cd6b3e37dfbf9699cf0ccc0f1bec.png" alt="img"></p><p>​ 图13 使用 SQL_BIG_RESULT的explain 结果</p><p>从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>基于上面的union、union all和group by语句的执行过程的分析，我们来回答文章开头的问题：<strong>MySQL什么时候会使用内存临时表？</strong></p><ol><li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来<strong>保存中间结果</strong>；</li><li><strong>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</strong></li><li>如果执行逻辑需要用到<strong>二维表特性，就会优先考虑使用临时表</strong>。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。</li><li>当需要使用临时表时，比如filesort时，如果<strong>数据量小于tmp_table_size，使用内存临时表</strong>，否则会进行文件排序（filesort使用cache还是磁盘临时表看sort_buffer的大小够否），若确定数据量很大，SQL语句可以使用SQL_BIG_RESULT来避免出现内存临时表不够用而重新使用磁盘临时表的情况</li></ol><p>通过今天这篇文章，我重点和你讲了group by的几种实现算法，从中可以总结一些使用的指导原则：</p><ol><li>如果对group by语句的结果没有排序要求，要在语句后面加 <strong>order by null</strong>；</li><li><strong>尽量让group by过程用上表的索引</strong>，确认方法是explain结果里没有Using temporary 和 Using filesort；</li><li>如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当<strong>调大tmp_table_size参数，来避免用到磁盘临时表；</strong></li><li>如果数据量实在太大，使用<strong>SQL_BIG_RESULT</strong>这个提示，来告诉优化器<strong>直接使用磁盘临时表排序算法</strong>得到group by的结果。</li></ol><h2 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h2><p>文章中图8和图9都是order by null，为什么图8的返回结果里面，0是在结果集的最后一行，而图9的结果里面，0是在结果集的第一行？</p><ul><li>图8是tmp_table_size够的情况，使用的是内存临时表，存储引擎默认为Memory，默认索引是Hash索引，存储的数据是无序的</li><li>图9是tmp_table_size不够的情况，使用的是磁盘临时表，存储引擎默认为InnoDB，默认索引是B+树索引，存储的数据是有序的</li></ul><h1 id="38-内存表（Memory引擎）"><a href="#38-内存表（Memory引擎）" class="headerlink" title="38 内存表（Memory引擎）"></a>38 内存表（Memory引擎）</h1><p>我在上一篇文章末尾留给你的问题是：两个group by 语句都用了order by null，为什么使用内存临时表得到的语句结果里，0这个值在最后一行；而使用磁盘临时表得到的结果里，0这个值在第一行？</p><p>今天我们就来看看，出现这个问题的原因吧。</p><h2 id="InnoDB和Memory表数据组织结构的对比"><a href="#InnoDB和Memory表数据组织结构的对比" class="headerlink" title="InnoDB和Memory表数据组织结构的对比"></a>InnoDB和Memory表数据组织结构的对比</h2><p>为了便于分析，我来把这个问题简化一下，假设有以下的两张表t1 和 t2，其中表t1使用Memory 引擎， 表t2使用InnoDB引擎。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t1(id int primary key, c int) engine=Memory;</span><br><span class="line">create table t2(id int primary key, c int) engine=innodb;</span><br><span class="line">insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);</span><br><span class="line">insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);</span><br></pre></td></tr></table></figure><p>然后，我分别执行select * from t1和select * from t2。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3fb1100b6e3390357d4efff0ba4765e6.png" alt="img"></p><p>​ 图1 两个查询结果-0的位置</p><p>可以看到，内存表t1的返回结果里面0在最后一行，而InnoDB表t2的返回结果里0在第一行。</p><p>出现这个区别的原因，要从这两个引擎的主键索引的组织方式说起。</p><p>表t2用的是InnoDB引擎，它的主键索引id的组织方式，你已经很熟悉了：InnoDB表的数据就放在主键索引树上，主键索引是B+树。所以表t2的数据组织方式如下图所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/4e29e4f9db55ace6ab09161c68ad8c8d.jpg" alt="img" style="zoom:50%"><p>​ 图2 表t2的数据组织</p><p>主键索引上的值是有序存储的。在执行select *的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0就出现在第一行。</p><p>与InnoDB引擎不同，Memory引擎的数据和索引是分开的。我们来看一下表t1中的数据内容。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/dde03e92074cecba4154d30cd16a9684.jpg" alt="img" style="zoom:50%"><p>​ 图3 表t1 的数据组织</p><p>可以看到，内存表的数据部分以数组的方式单独存放，而主键id索引里，存的是每个数据的位置。主键id是hash索引，可以看到索引上的key并不是有序的。</p><p>在内存表t1中，当我执行select *的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0就是最后一个被读到，并放入结果集的数据。</p><p>可见，InnoDB和Memory引擎的数据组织方式是不同的：</p><ul><li>InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为<strong>索引组织表</strong>（Index Organizied Table）。</li><li>而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为<strong>堆组织表</strong>（Heap Organizied Table）。</li></ul><p>从中我们可以看出，<strong>这两个引擎的一些典型不同</strong>：</p><ol><li><strong>InnoDB</strong>表的数据总是<strong>有序</strong>存放的，而<strong>内存表</strong>的数据就是按照<strong>写入顺序</strong>存放的；</li><li>当数据文件有空洞的时候，<strong>InnoDB表</strong>在插入新数据的时候，为了保证数据有序性，只能在<strong>固定的位置写入新值</strong>，而<strong>内存表</strong>找到<strong>空位就可以</strong>插入新值；</li><li>数据位置发生变化的时候，<strong>InnoDB表只需要修改主键索引，而内存表需要修改所有索引；</strong></li><li>InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而<strong>内存表</strong>没有这个区别，<strong>所有索引的“地位”都是相同的</strong>。</li><li><strong>InnoDB支持变长数据类型</strong>，不同记录的长度可能不同；内存表不支持Blob 和 Text字段，并且即使定义了varchar(N)，实际也当作char(N)，也就是固定长度字符串来存储，因此<strong>内存表的每行数据长度相同</strong>。</li></ol><p>由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。比如，如果要在表t1中执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from t1 where id=5;</span><br><span class="line">insert into t1 values(10,10);</span><br><span class="line">select * from t1;</span><br></pre></td></tr></table></figure><p>就会看到返回结果里，id&#x3D;10这一行出现在id&#x3D;4之后，也就是原来id&#x3D;5这行数据的位置。</p><p>需要指出的是，表t1的这个主键索引是哈希索引，因此如果执行范围查询，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where id&lt;5;</span><br></pre></td></tr></table></figure><p>是用不上主键索引的，需要走全表扫描。你可以借此再回顾下<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/69236">第4篇文章</a>的内容。那如果要让内存表支持范围扫描，应该怎么办呢 ？</p><h2 id="hash索引和B-Tree索引的对比"><a href="#hash索引和B-Tree索引的对比" class="headerlink" title="hash索引和B-Tree索引的对比"></a>hash索引和B-Tree索引的对比</h2><p>实际上，内存表也是支B-Tree索引的。在id列上创建一个B-Tree索引，SQL语句可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t1 add index a_btree_index using btree (id);</span><br></pre></td></tr></table></figure><p>这时，表t1的数据组织形式就变成了这样：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/1788deca56cb83c114d8353c92e3bde3.jpg" alt="img" style="zoom:50%"><p>​ 图4 表t1的数据组织–增加B-Tree索引</p><p>新增的这个B-Tree索引你看着就眼熟了，这跟InnoDB的b+树索引组织形式类似。</p><p>作为对比，你可以看一下这下面这两个语句的输出：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/a85808fcccab24911d257d720550328a.png" alt="img"></p><p>​ 图5 使用B-Tree和hash索引查询返回结果对比</p><p>可以看到，执行select * from t1 where id&lt;5的时候，优化器会选择B-Tree索引，所以返回结果是0到4。 使用force index强行使用主键id这个索引，id&#x3D;0这一行就在结果集的最末尾了。</p><p>其实，一般在我们的印象中，内存表的优势是速度快，其中的一个原因就是Memory引擎支持hash索引。当然，更重要的原因是，内存表的所有数据都保存在内存，而内存的读写速度总是比磁盘快。</p><h2 id="内存表的缺点"><a href="#内存表的缺点" class="headerlink" title="内存表的缺点"></a>内存表的缺点</h2><p>但是，接下来我要跟你说明，为什么我不建议你在生产环境上使用内存表。这里的原因主要包括两个方面：</p><ol><li>锁粒度问题；</li><li>数据持久化问题。</li></ol><h3 id="内存表只支持表锁"><a href="#内存表只支持表锁" class="headerlink" title="内存表只支持表锁"></a>内存表只支持表锁</h3><p>我们先来说说内存表的锁粒度问题。</p><p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p><p>需要注意的是，这里的表锁跟之前我们介绍过的MDL锁不同，但都是表级的锁。接下来，我通过下面这个场景，跟你模拟一下内存表的表级锁。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/f216e2d707559ed2ca98fbe21e509f29.png" alt="img"></p><p>​ 图6 内存表的表锁–复现步骤</p><p>在这个执行序列里，session A的update语句要执行50秒，在这个语句执行期间session B的查询会进入锁等待状态。session C的show processlist 结果输出如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/14d88076dad6db573f0b66f2c17df916.png" alt="img"></p><p>​ 图7 内存表的表锁–结果</p><p>跟行锁比起来，表锁对并发访问的支持不够好。所以，内存表的锁粒度问题，决定了它在处理并发事务的时候，性能也不会太好。</p><h3 id="不支持数据持久性"><a href="#不支持数据持久性" class="headerlink" title="不支持数据持久性"></a>不支持数据持久性</h3><p>接下来，我们再看看数据持久性的问题。</p><p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p><p>你可能会说，如果数据库异常重启，内存表被清空也就清空了，不会有什么问题啊。但是，在高可用架构下，内存表的这个特点简直可以当做bug来看待了。为什么这么说呢？</p><p><strong>我们先看看M-S架构下，使用内存表存在的问题。</strong></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/5b910e4c0f1afa219aeecd1f291c95e9.jpg" alt="img" style="zoom:50%"><p>​ 图8 M-S基本架构</p><p>我们来看一下下面这个时序：</p><ol><li>业务正常访问主库；</li><li>备库硬件升级，备库重启，内存表t1内容被清空；</li><li>备库重启后，客户端发送一条update语句，修改表t1的数据行，这时备库应用线程就会报错“找不到要更新的行”。</li></ol><p>这样就会导致主备同步停止。当然，如果这时候发生主备切换的话，客户端会看到，表t1的数据“丢失”了。</p><p>在图8中这种有proxy的架构里，大家默认主备切换的逻辑是由数据库系统自己维护的。这样对客户端来说，就是“网络断开，重连之后，发现内存表数据丢失了”。</p><p>你可能说这还好啊，毕竟主备发生切换，连接会断开，业务端能够感知到异常。</p><p>但是，接下来内存表的这个特性就会让使用现象显得更“诡异”了。<strong>由于MySQL知道重启之后，内存表的数据会丢失。所以，担心主库重启之后，出现主备不一致，MySQL在实现上做了这样一件事儿：在数据库重启之后，往binlog里面写入一行DELETE FROM t1。</strong></p><p><strong>如果你使用是如图9所示的双M结构的话：</strong></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/4089c9c1f92ce61d2ed779fd0932ba57.jpg" alt="img" style="zoom:50%"><p>​ 图9 双M结构</p><p>在备库重启的时候，备库binlog里的delete语句就会传到主库，然后把主库内存表的内容删除。这样你在使用的时候就会发现，主库的内存表数据突然被清空了。</p><p>基于上面的分析，你可以看到，内存表并不适合在生产环境上作为普通数据表使用。</p><p>有同学会说，但是内存表执行速度快呀。这个问题，其实你可以这么分析：</p><ol><li>如果你的表更新量大，那么并发度是一个很重要的参考指标，InnoDB支持行锁，并发度比内存表好；</li><li>能放到内存表的数据量都不大。如果你考虑的是读的性能，一个读QPS很高并且数据量不大的表，即使是使用InnoDB，数据也是都会缓存在InnoDB Buffer Pool里的。因此，使用InnoDB表的读性能也不会差。</li></ol><p>所以，<strong>我建议你把普通内存表都用InnoDB表来代替。</strong>但是，有一个场景却是例外的。</p><h2 id="内存表的适用场景"><a href="#内存表的适用场景" class="headerlink" title="内存表的适用场景"></a>内存表的适用场景</h2><p>这个场景就是，我们在第35和36篇说到的<strong>用户临时表</strong>。在<strong>数据量可控，不会耗费过多内存的情况下，你可以考虑使用内存表。</strong></p><p>内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p><ol><li>临时表不会被其他线程访问，没有并发性的问题；</li><li>临时表重启后也是需要删除的，清空数据这个问题不存在；</li><li>备库的临时表也不会影响主库的用户线程。</li></ol><p>现在，我们回过头再看一下第35篇join语句优化的例子，当时我建议的是创建一个InnoDB临时表，使用的语句序列是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;</span><br><span class="line">insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;</span><br><span class="line">select * from t1 join temp_t on (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure><p>了解了内存表的特性，你就知道了， 其实这里使用内存临时表的效果更好，原因有三个：</p><ol><li>相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t的写数据的速度更快；</li><li>索引b使用hash索引，查找的速度比B-Tree索引快；</li><li>临时表数据只有2000行，占用的内存有限。</li></ol><p>因此，你可以对<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80147">第35篇文章</a>的语句序列做一个改写，将临时表t1改成内存临时表，并且在字段b上创建一个hash索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create temporary table temp_t(id int primary key, a int, b int, index (b))engine=memory;</span><br><span class="line">insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;</span><br><span class="line">select * from t1 join temp_t on (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/a468ba6d14ea225623074b6255b99f92.png" alt="img"></p><p>​ 图10 使用内存临时表的执行效果</p><p>可以看到，不论是导入数据的时间，还是执行join的时间，使用内存临时表的速度都比使用InnoDB临时表要更快一些。</p><h2 id="小结和问题"><a href="#小结和问题" class="headerlink" title="小结和问题"></a>小结和问题</h2><p>今天这篇文章，我从“要不要使用内存表”这个问题展开，和你介绍了Memory引擎的几个特性。</p><p>可以看到，由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是<strong>双M架构，还可能导致主库的内存表数据被删掉。</strong></p><p>因此，在生产上，我不建议你使用普通内存表。</p><p>如果你是DBA，可以在建表的审核系统中增加这类规则，要求业务改用InnoDB表。我们在文中也分析了，其实InnoDB表性能还不错，而且数据安全也有保障。而内存表由于不支持行锁，更新语句会阻塞查询，性能也未必就如想象中那么好。</p><p>基于内存表的特性，我们还分析了它的<strong>一个适用场景，就是内存临时表</strong>。内存表支持hash索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。</p><p>最后，我给你留一个问题吧。</p><p>假设你刚刚接手的一个数据库上，真的发现了一个内存表。备库重启之后肯定是会导致备库的内存表数据被清空，进而导致主备同步停止。这时，最好的做法是将它修改成InnoDB引擎表。</p><p>假设当时的业务场景主库暂时不允许你修改引擎，你可以加上什么自动化逻辑，来避免主备同步停止呢？</p><p>我们假设的是主库暂时不能修改引擎，那么就把<strong>备库</strong>的内存表引擎先<strong>都改成InnoDB</strong>。对于每个内存表，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set sql_log_bin=off;</span><br><span class="line">alter table tbl_name engine=innodb;</span><br></pre></td></tr></table></figure><p>这样就能避免备库重启的时候，数据丢失的问题。</p><p>由于主库重启后，会往binlog里面写“delete from tbl_name”，这个命令传到备库，备库的同名的表数据也会被清空。</p><p>因此，就不会出现主备同步停止的问题。</p><p>如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB表。</p><p>所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。</p><p>同时，跟业务开发同学约定好建表规则，避免创建新的内存表。</p><h1 id="39-MySQL自增主键"><a href="#39-MySQL自增主键" class="headerlink" title="39 MySQL自增主键"></a>39 MySQL自增主键</h1><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/69236">第4篇文章</a>中，我们提到过自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</p><p>之前我见过有的业务设计依赖于自增主键的连续性，也就是说，这个设计假设自增主键是连续的。但实际上，这样的假设是错的，因为自增主键不能保证连续递增。</p><p>今天这篇文章，我们就来说说这个问题，看看什么情况下自增主键会出现 “空洞”？</p><p>为了便于说明，我们创建一个表t，其中id是自增主键字段、c是唯一索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="自增值保存在哪儿？"><a href="#自增值保存在哪儿？" class="headerlink" title="自增值保存在哪儿？"></a>自增值保存在哪儿？</h2><p>在这个空表t里面执行insert into t values(null, 1, 1);插入一行数据，再执行show create table命令，就可以看到如下图所示的结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/cb2637cada0201b18650f56875e94fff.png" alt="img"></p><p>​ 图1 自动生成的AUTO_INCREMENT值</p><p>可以看到，表定义里面出现了一个AUTO_INCREMENT&#x3D;2，表示下一次插入数据时，如果需要自动生成自增值，会生成id&#x3D;2。</p><p>其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。实际上，<strong>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。</strong></p><p>不同的引擎对于自增值的保存策略不同。</p><ul><li><strong>MyISAM</strong>引擎的自增值<strong>保存在数据文件</strong>中。</li><li><strong>InnoDB</strong>引擎的自增值，其实是<strong>保存在了内存</strong>里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：<ul><li>在<strong>MySQL 5.7及之前</strong>的版本，自增值<strong>保存在内存里，并没有持久化</strong>。每次<strong>重启后</strong>，第一次打开表的时候，都会<strong>去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值</strong>。﻿<br>举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT&#x3D;11。这时候，我们删除id&#x3D;10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10。﻿<br>也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。</li><li>在<strong>MySQL 8.0</strong>版本，将自增值的<strong>变更记录在了redo log</strong>中，重启的时候依靠redo log恢复重启之前的值。</li></ul></li></ul><p>理解了MySQL对自增值的保存策略以后，我们再看看自增值修改机制。</p><h2 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h2><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p><ol><li>如果X&lt;Y，那么这个表的自增值不变；</li><li>如果X≥Y，就需要把当前自增值修改为新的自增值。</li></ol><p><strong>新的自增值生成算法是</strong>：从<strong>auto_increment_offset</strong>开始，以<strong>auto_increment_increment</strong>为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。</p><p>其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p><blockquote><p>备注：在一些场景下，使用的就不全是默认值。比如，<strong>双M的主备结构里要求双写</strong>的时候，我们就<strong>可能会设置成auto_increment_increment&#x3D;2</strong>，让一个库的自增id都是<strong>奇数</strong>，另一个库的自增id都是<strong>偶数</strong>，避免两个库生成的主键发生冲突。</p></blockquote><p>当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑很简单，就是：</p><ol><li>如果准备插入的值&gt;&#x3D;当前自增值，新的自增值就是“准备插入的值+1”；</li><li>否则，自增值不变。</li></ol><p>这就引入了我们文章开头提到的问题，在这两个参数都设置为1的时候，自增主键id却不能保证是连续的，这是什么原因呢？</p><h2 id="为什么自增主键id不能保证是连续的？"><a href="#为什么自增主键id不能保证是连续的？" class="headerlink" title="为什么自增主键id不能保证是连续的？"></a>为什么自增主键id不能保证是连续的？</h2><ol><li>唯一键冲突后，自增值不会回滚</li><li>事务回滚后，自增值不会回滚</li><li>批量插入自增锁的优化机制会连续申请id</li></ol><h3 id="自增值的修改时机（原因1和2）"><a href="#自增值的修改时机（原因1和2）" class="headerlink" title="自增值的修改时机（原因1和2）"></a>自增值的修改时机（原因1和2）</h3><p>要回答这个问题，我们就要看一下自增值的修改时机。</p><p>假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(null, 1, 1); </span><br></pre></td></tr></table></figure><p>这个语句的执行流程就是：</p><ol><li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li><li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li><li>将传入的行的值改成(2,1,1);</li><li>将表的自增值改成3；</li><li>继续执行插入数据操作，由于已经存在c&#x3D;1的记录，所以报Duplicate key error，语句返回。</li></ol><p>对应的执行流程图如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/f16d89a6e7ad6e2cde13b32bb2292dd3.jpg" alt="img" style="zoom:50%"><p>​ 图2 insert(null, 1,1)唯一键冲突</p><p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id&#x3D;2这一行并没有插入成功，但也没有将自增值再改回去。</p><p>所以，在这之后，再插入新的数据行时，拿到的自增id就是3。也就是说，出现了自增主键不连续的情况。</p><p>如图3所示就是完整的演示结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/77b87820b649692a555f19b562d5d926.png" alt="img"></p><p>​ 图3 一个自增主键id不连续的复现步骤</p><p>可以看到，这个操作序列复现了一个自增主键id不连续的现场(没有id&#x3D;2的行）。可见，<strong>唯一键冲突是导致自增主键id不连续的第一种原因。</strong></p><p>同样地，事务<strong>回滚也会产生类似的现象，这就是第二种原因。</strong></p><p>下面这个语句序列就可以构造不连续的自增id，你可以自己验证一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(null,1,1);</span><br><span class="line">begin;</span><br><span class="line">insert into t values(null,2,2);</span><br><span class="line">rollback;</span><br><span class="line">insert into t values(null,2,2);</span><br><span class="line">//插入的行是(3,2,2)</span><br></pre></td></tr></table></figure><p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去呢？如果把表t的当前自增值从3改回2，再插入新数据的时候，不就可以生成id&#x3D;2的一行数据了吗？</p><p>其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看<strong>自增值为什么不能回退。</strong></p><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p><ol><li>假设事务A申请到了id&#x3D;2， 事务B申请到id&#x3D;3，那么这时候表t的自增值是4，之后继续执行。</li><li>事务B正确提交了，但事务A出现了唯一键冲突。</li><li>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id&#x3D;3的行，而当前的自增id值是2。</li><li>接下来，继续执行的其他事务就会申请到id&#x3D;2，然后再申请到id&#x3D;3。这时，就会出现插入语句报错“主键冲突”。</li></ol><p>而为了解决这个主键冲突，有两种方法：</p><ol><li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li><li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增id回退”的前提导致的。</p><p>因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保证了自增id是递增的，但不保证是连续的。</p><h3 id="自增锁策略"><a href="#自增锁策略" class="headerlink" title="自增锁策略"></a>自增锁策略</h3><p>可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL 5.1版本之前，并不是这样的。</p><p>接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。</p><p>在MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p><p>MySQL 5.1.22版本引入了一个新策略，新增参数<strong>innodb_autoinc_lock_mode</strong></p><ol><li>这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</li><li>这个参数的值被设置为1时：（MySQL8.0前默认）<ul><li>普通insert语句，自增锁在申请之后就马上释放；</li><li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li><li>这个参数的值被设置为2时，（MySQL8.0后默认）所有的申请自增主键的动作都是申请后就释放锁。（为了主备数据一致性需要设置binlog格式为row）</li></ol><p>你一定有两个疑问：<strong>为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是2？</strong></p><p>答案是，这么设计还是<strong>为了数据的一致性</strong>。</p><p>我们一起来看一下这个场景：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/e0a69e151277de54a8262657e4ec89df.png" alt="img"></p><p>​ 图4 批量插入数据的自增锁</p><p>在这个例子里，我往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session同时执行向表t2中插入数据的操作。</p><p>你可以设想一下，如果session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p><ul><li>session B先插入了两个记录，(1,1,1)、(2,2,2)；</li><li>然后，session A来申请自增id得到id&#x3D;3，插入了（3,5,5)；</li><li>之后，session B继续执行，插入两条记录(4,3,3)、 (5,4,4)。</li></ul><p>你可能会说，这也没关系吧，毕竟session B的语义本身就没有要求表t2的所有行的数据都跟session A相同。</p><p>是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format&#x3D;statement，你可以设想下，binlog会怎么记录呢？</p><p>由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，要么先记session B的。</p><p>但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了<strong>数据不一致</strong>。</p><p>你可以分析一下，出现这个问题的原因是什么？</p><p>其实，这是因为原库session B的insert语句，生成的id不连续。这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的。</p><p>而要解决这个问题，有两种思路：</p><ol><li>一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。（innodb_autoinc_lock_mode&#x3D;1）</li><li>另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是<strong>innodb_autoinc_lock_mode设置为2，同时binlog_format设置为row</strong>。</li></ol><h4 id="自增锁的优化（原因3）"><a href="#自增锁的优化（原因3）" class="headerlink" title="自增锁的优化（原因3）"></a>自增锁的优化（原因3）</h4><p>因此，<strong>在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode&#x3D;2 ，并且 binlog_format&#x3D;row</strong>.这样做，既能提升并发性，又不会出现数据一致性问题。</p><p>需要注意的是，我这里说的<strong>批量插入数据，包含的语句类型是insert … select、replace … select和load data语句。</strong></p><p>但是，在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。</p><p>也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”。</p><p>既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一个select … insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次。显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p><p>因此，对于批量插入数据的语句，<strong>MySQL有一个批量申请自增id的策略</strong>：</p><ol><li>语句执行过程中，第一次申请自增id，会分配1个；</li><li>1个用完以后，这个语句第二次申请自增id，会分配2个；</li><li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</li><li>依此类推，<strong>同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</strong></li></ol><p>举个例子，我们一起看看下面的这个语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(null, 1,1);</span><br><span class="line">insert into t values(null, 2,2);</span><br><span class="line">insert into t values(null, 3,3);</span><br><span class="line">insert into t values(null, 4,4);</span><br><span class="line">create table t2 like t;</span><br><span class="line">insert into t2(c,d) select c,d from t;</span><br><span class="line">insert into t2 values(null, 5,5);</span><br></pre></td></tr></table></figure><p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id&#x3D;1，第二次被分配了id&#x3D;2和id&#x3D;3， 第三次被分配到id&#x3D;4到id&#x3D;7。</p><p>由于这条语句实际只用上了4个id，所以id&#x3D;5到id&#x3D;7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p><p><strong>这是主键id出现自增id不连续的第三种原因。</strong></p><h2 id="小结和问题-1"><a href="#小结和问题-1" class="headerlink" title="小结和问题"></a>小结和问题</h2><p>今天，我们从“自增主键为什么会出现不连续的值”这个问题开始，首先讨论了自增值的存储。</p><p>在MyISAM引擎里面，自增值是被写在数据文件上的。而在InnoDB中，自增值是被记录在内存的。MySQL直到8.0版本，才给InnoDB表的自增值加上了持久化的能力（记录在redo log中），确保重启前后一个表的自增值不变。</p><p>然后，我和你分享了在一个语句执行过程中，自增值改变的时机，分析了为什么MySQL在事务回滚的时候不能回收自增id。</p><p>MySQL 5.1.22版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范围。从并发性能的角度考虑，我<strong>建议你将其设置为2，同时将binlog_format设置为row</strong>。我在前面的文章中其实多次提到，binlog_format设置为row，是很有必要的。今天的例子给这个结论多了一个理由。</p><blockquote><p>回顾以下binlog_format&#x3D;row的优点：</p><ol><li>无索引update操作时更少的行锁</li><li>解决了使用statement&#x2F;mixed格式时产生的主从不一致问题</li><li>便于使用binlog恢复数据</li><li>可以将innodb_autoinc_lock_mode设置为2，提高并发性能</li></ol></blockquote><p>最后，我给你留一个思考题吧。</p><p>在最后一个例子中，执行insert into t2(c,d) select c,d from t;这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format&#x3D;statement。这个语句会对表t的所有记录和间隙加锁。</p><p>你觉得为什么需要这么做呢？</p><p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format&#x3D;statement的情况下，binlog里面就记录了这样的语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(-1,-1,-1);</span><br><span class="line">insert into t2(c,d) select c,d from t;</span><br></pre></td></tr></table></figure><p>这个语句到了备库执行，就会把id&#x3D;-1这一行也写到表t2中，出现主备不一致。</p><blockquote><p>和数据发生改变没有关系，RR隔离级别下是一致性读，是无法访问到后来被修改的数据的</p><p>该问题详情请看 下一讲 insert … select语句</p></blockquote><h1 id="40-讲insert语句的锁为什么这么多"><a href="#40-讲insert语句的锁为什么这么多" class="headerlink" title="40 讲insert语句的锁为什么这么多"></a>40 讲insert语句的锁为什么这么多</h1><p>在上一篇文章中，我提到MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。</p><p>因此，insert语句是一个很轻量的操作。不过，这个结论对于“普通的insert语句”才有效。也就是说，还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。</p><p>那么，今天这篇文章，我们就一起来聊聊这个话题。</p><h2 id="insert-…-select-语句"><a href="#insert-…-select-语句" class="headerlink" title="insert … select 语句"></a>insert … select 语句</h2><p>我们先从昨天的问题说起吧。表t和t2的表结构、初始化数据语句如下，今天的例子我们还是针对这两个表展开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(null, 1,1);</span><br><span class="line">insert into t values(null, 2,2);</span><br><span class="line">insert into t values(null, 3,3);</span><br><span class="line">insert into t values(null, 4,4);</span><br><span class="line"></span><br><span class="line">create table t2 like t</span><br></pre></td></tr></table></figure><p>现在，我们一起来看看为什么在可重复读隔离级别下，<strong>binlog_format&#x3D;statement</strong>时执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t2(c,d) select c,d from t;</span><br></pre></td></tr></table></figure><p>这个语句时，需要对表t的所有行和间隙加锁呢？</p><p>其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/33e513ee55d5700dc67f32bcdafb9386.png" alt="img"></p><p>​ 图1 并发insert场景</p><p>实际的执行效果是，如果session B先执行，由于这个语句对表t主键索引加了(-∞,1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p><p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format&#x3D;statement的情况下，binlog里面就记录了这样的语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(-1,-1,-1);</span><br><span class="line">insert into t2(c,d) select c,d from t;</span><br></pre></td></tr></table></figure><p>这个语句到了备库执行，就会把id&#x3D;-1这一行也写到表t2中，出现主备不一致。</p><h2 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h2><h3 id="插入其他表"><a href="#插入其他表" class="headerlink" title="插入其他表"></a>插入其他表</h3><p>当然了，执行insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p><p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p><p>此时，我们可以这么写这条SQL语句 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t2(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);</span><br></pre></td></tr></table></figure><p>这个语句的加锁范围，就是表t索引c上的(4,supremum]这个next-key lock和主键索引上id&#x3D;4这一行。</p><p>它的执行流程也比较简单，从表t中按照索引c倒序，扫描第一行，拿到结果写入到表t2中。</p><p>因此整条语句的扫描行数是1。</p><p>这个语句执行的慢查询日志（slow log），如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/3efdf8256309a44e23d93089459eda74.png" alt="img"></p><p>​ 图2 慢查询日志–将数据插入表t2</p><p>通过这个慢查询日志，我们看到Rows_examined&#x3D;1，正好验证了执行这条语句的扫描行数为1。</p><h3 id="插入自己表造成循环写入"><a href="#插入自己表造成循环写入" class="headerlink" title="插入自己表造成循环写入"></a>插入自己表造成循环写入</h3><blockquote><p>对自己一边做查询一边插入需要使用临时表</p></blockquote><p>那么，如果我们是要把这样的一行数据插入到<strong>表t本身</strong>中的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);</span><br></pre></td></tr></table></figure><p>语句的执行流程是怎样的？扫描行数又是多少呢？</p><p>这时候，我们再看慢查询日志就会发现不对了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/6f90b04c09188bff11dae6e788abb918.png" alt="img"></p><p>​ 图3 慢查询日志–将数据插入表t</p><p>可以看到，这时候的Rows_examined的值是5。</p><p>我在前面的文章中提到过，希望你都能够学会用explain的结果来“脑补”整条语句的执行过程。今天，我们就来一起试试。</p><p>如图4所示就是这条语句的explain结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d7270781ee3f216325b73bd53999b82a.png" alt="img"></p><p>​ 图4 explain结果</p><p>从Extra字段可以看到“Using temporary”字样，表示这个语句用到了临时表。也就是说，执行过程中，需要把表t的内容读出来，写入临时表。</p><p>图中rows显示的是1，我们不妨先对这个语句的执行流程做一个猜测：如果说是把子查询的结果读出来（扫描1行），写入临时表，然后再从临时表读出来（扫描1行），写回表t中。那么，这个语句的扫描行数就应该是2，而不是5。</p><p>所以，这个猜测不对。实际上，Explain结果里的rows&#x3D;1是因为受到了limit 1 的影响。</p><p>从另一个角度考虑的话，我们可以看看InnoDB扫描了多少行。如图5所示，是在执行这个语句前后查看Innodb_rows_read的结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/489281d8029e8f60979cb7c4494010d7.png" alt="img"></p><p>​ 图5 查看 Innodb_rows_read变化</p><p>可以看到，这个语句执行前后，Innodb_rows_read的值增加了4。因为默认临时表是使用Memory引擎的，所以这4行查的都是表t，也就是说对表t做了全表扫描。</p><p>这样，我们就把整个执行过程理清楚了：</p><ol><li>创建临时表，表里有两个字段c和d。</li><li>按照索引c扫描表t，依次取c&#x3D;4、3、2、1，然后回表，读到c和d的值写入临时表。这时，Rows_examined&#x3D;4。</li><li>由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中。这时，Rows_examined的值加1，变成了5。</li></ol><p>也就是说，这个语句会导致在表t上做<strong>全表扫描</strong>，并且会给索引c上的所有间隙都加上共享的next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p><p>至于<strong>这个语句的执行为什么需要临时表</strong>，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p><p>由于<strong>实现上这个语句没有在子查询中就直接使用limit 1，从而导致了这个语句的执行需要遍历整个表t</strong>。</p><p>它的<strong>优化方法</strong>也比较简单，就是用前面介绍的方法，先insert into到<strong>临时表</strong>temp_t，这样就只需要扫描一行；然后再从表temp_t里面取出这行数据插入表t1。</p><p>当然，由于这个语句涉及的数据量很小，你可以考虑使用内存临时表来做这个优化。使用内存临时表优化时，语句序列的写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create temporary table temp_t(c int,d int) engine=memory;</span><br><span class="line">insert into temp_t  (select c+1, d from t force index(c) order by c desc limit 1);</span><br><span class="line">insert into t select * from temp_t;</span><br><span class="line">drop table temp_t;</span><br></pre></td></tr></table></figure><h2 id="insert-唯一键冲突会获取锁"><a href="#insert-唯一键冲突会获取锁" class="headerlink" title="insert 唯一键冲突会获取锁"></a>insert 唯一键冲突会获取锁</h2><h3 id="造成冲突会获取一个邻间锁"><a href="#造成冲突会获取一个邻间锁" class="headerlink" title="造成冲突会获取一个邻间锁"></a>造成冲突会获取一个邻间锁</h3><p>前面的两个例子是使用insert … select的情况，接下来我要介绍的这个例子就是最常见的insert语句出现唯一键冲突的情况。</p><p>对于有唯一键的表，插入数据时出现唯一键冲突也是常见的情况了。我先给你举一个简单的唯一键冲突的例子。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/83fb2d877932941b230d6b5be8cca6ca.png" alt="img"></p><p>​ 图6 唯一键冲突加锁</p><p>这个例子也是在可重复读（repeatable read）隔离级别下执行的。可以看到，session B要执行的insert语句进入了锁等待状态。</p><p>也就是说，session A执行的insert语句，<strong>发生主键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁</strong>。我们前面说过，<strong>一个next-key lock就是由它右边界的值定义的</strong>。这时候，session A持有索引c上的**(5,10]**共享next-key lock（读锁）。</p><p>至于为什么要加这个读锁，其实我也没有找到合理的解释。从作用上来看，这样做可以避免这一行被别的事务删掉。</p><p>这里<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">官方文档</a>有一个描述错误，认为如果冲突的是主键索引，就加记录锁，唯一索引才加next-key lock。但实际上，这两类索引冲突加的都是next-key lock。</p><blockquote><p>备注：这个bug，是我在写这篇文章查阅文档时发现的，已经<a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=93806">发给官方</a>并被verified了。</p></blockquote><h3 id="可能会造成死锁"><a href="#可能会造成死锁" class="headerlink" title="可能会造成死锁"></a>可能会造成死锁</h3><p>有同学在前面文章的评论区问到，在有多个唯一索引的表中并发插入数据时，会出现死锁。但是，由于他没有提供复现方法或者现场，我也无法做分析。所以，我建议你在评论区发问题的时候，尽量同时附上复现方法，或者现场信息，这样我才好和你一起分析问题。</p><p>这里，我就先和你分享一个经典的死锁场景，如果你还遇到过其他<strong>唯一键冲突导致的死锁场景</strong>，也欢迎给我留言。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/63658eb26e7a03b49f123fceed94cd2d.png" alt="img"></p><p>​ 图7 唯一键冲突–死锁</p><p>在session A执行rollback语句回滚的时候，session C几乎同时发现死锁并返回。</p><p>这个死锁产生的逻辑是这样的：</p><ol><li>在T1时刻，启动session A，并执行insert语句，此时在索引c的c&#x3D;5上加了<strong>记录锁</strong>。注意，这个索引是唯一索引，因此退化为记录锁（如果你的印象模糊了，可以回顾下<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/75659">第21篇文章</a>介绍的加锁规则）。</li><li>在T2时刻，session B要执行相同的insert语句，发现了唯一键冲突，加上读锁；同样地，session C也在索引c上，c&#x3D;5这一个记录上，加了<strong>读锁</strong>。</li><li>T3时刻，session A回滚。这时候，session B和session C都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁。</li></ol><p>这个流程的状态变化图如下所示。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/3e0bf1a1241931c14360e73fd10032b8.jpg" alt="img" style="zoom:50%"><p>​ 图8 状态变化图–死锁</p><h2 id="insert-into-…-on-duplicate-key-update"><a href="#insert-into-…-on-duplicate-key-update" class="headerlink" title="insert into … on duplicate key update"></a>insert into … on duplicate key update</h2><p>上面这个例子是主键冲突后直接报错，如果是改写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(11,10,10) on duplicate key update d=100; </span><br></pre></td></tr></table></figure><p>的话，就会给索引c上**(5,10]** 加一个排他的next-key lock（写锁）。</p><p><strong>insert into … on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</strong></p><p>注意，<strong>如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行</strong>。</p><p>现在表t里面已经有了(1,1,1)和(2,2,2)这两行，我们再来看看下面这个语句执行的效果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/5f384d6671c87a60e1ec7e490447d702.png" alt="img"></p><p>​ 图9 两个唯一键同时冲突</p><p>可以看到，主键<strong>id是先</strong>判断的，MySQL认为这个语句跟id&#x3D;2这一行冲突，所以修改的是id&#x3D;2的行。</p><p>需要注意的是，执行这条语句的affected rows返回的是2，很容易造成误解。实际上，真正更新的只有一行，只是在代码实现上，insert和update都认为自己成功了，update计数加了1， insert计数也加了1。</p><h2 id="小结和问题-2"><a href="#小结和问题-2" class="headerlink" title="小结和问题"></a>小结和问题</h2><p>今天这篇文章，我和你介绍了几种特殊情况下的insert语句。</p><p>insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给select的表里扫描到的<strong>记录和间隙加读锁。</strong></p><p>而如果<strong>insert和select的对象是同一个表，则有可能会造成循环写入</strong>。这种情况下，我们需要引入用户临时表来做优化。</p><p>insert 语句如果出现<strong>唯一键冲突</strong>，会在冲突的**唯一值上加共享的next-key lock(S锁)**。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p><p>最后，我给你留一个问题吧。</p><p>你平时在两个表之间拷贝数据用的是什么方法，有什么注意事项吗？在你的应用场景里，这个方法，相较于其他方法的优势是什么呢？</p><p>三种方法，看下一讲</p><h1 id="41-讲怎么最快地复制一张表"><a href="#41-讲怎么最快地复制一张表" class="headerlink" title="41 讲怎么最快地复制一张表"></a>41 讲怎么最快地复制一张表</h1><p>我在上一篇文章最后，给你留下的问题是怎么在两张表中拷贝数据。如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用insert … select 语句即可实现。</p><p>当然，为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。这时，有两种常用的方法。接下来的内容，我会和你详细展开一下这两种方法。</p><p>为了便于说明，我还是先创建一个表db1.t，并插入1000行数据，同时创建一个相同结构的表db2.t。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create database db1;</span><br><span class="line">use db1;</span><br><span class="line"></span><br><span class="line">create table t(id int primary key, a int, b int, index(a))engine=innodb;</span><br><span class="line">delimiter ;;</span><br><span class="line">  create procedure idata()</span><br><span class="line">  begin</span><br><span class="line">    declare i int;</span><br><span class="line">    set i=1;</span><br><span class="line">    while(i&lt;=1000)do</span><br><span class="line">      insert into t values(i,i,i);</span><br><span class="line">      set i=i+1;</span><br><span class="line">    end while;</span><br><span class="line">  end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call idata();</span><br><span class="line"></span><br><span class="line">create database db2;</span><br><span class="line">create table db2.t like db1.t</span><br></pre></td></tr></table></figure><p>假设，我们要把db1.t里面a&gt;900的数据行导出来，插入到db2.t中。</p><h2 id="mysqldump方法"><a href="#mysqldump方法" class="headerlink" title="mysqldump方法"></a>mysqldump方法</h2><p>一种方法是，使用mysqldump命令将数据导出成一组INSERT语句。你可以使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user --add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql</span><br></pre></td></tr></table></figure><p>把结果输出到临时文件。</p><p>这条命令中，主要参数含义如下：</p><ol><li>–single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li><li>–add-locks设置为0，表示在输出的文件结果里，不增加” LOCK TABLES <code>t</code> WRITE;” ；</li><li>–no-create-info的意思是，不需要导出表结构；</li><li>–set-gtid-purged&#x3D;off表示的是，不输出跟GTID相关的信息；</li><li>–result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。</li></ol><p>通过这条mysqldump命令生成的t.sql文件中就包含了如图1所示的INSERT语句。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/8acdcefcaf5c9940570bf7e8f73dbdde.png" alt="img"></p><p>​ 图1 mysqldump输出文件的部分结果</p><p>可以看到，一条INSERT语句里面会包含多个value对，这是为了后续用这个文件来写入数据的时候，执行速度可以更快。</p><p>如果你希望生成的文件中一条INSERT语句只插入一行数据的话，可以在执行mysqldump命令时，加上参数–skip-extended-insert。</p><p>然后，你可以通过下面这条命令，将这些INSERT语句放到db2库里去执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e &quot;source /client_tmp/t.sql&quot;</span><br></pre></td></tr></table></figure><p>需要说明的是，source并不是一条SQL语句，而是一个客户端命令。mysql客户端执行这个命令的流程是这样的：</p><ol><li>打开文件，默认以分号为结尾读取一条条的SQL语句；</li><li>将SQL语句发送到服务端执行。</li></ol><p>也就是说，服务端执行的并不是这个“source t.sql”语句，而是INSERT语句。所以，不论是在慢查询日志（slow log），还是在binlog，记录的都是这些要被真正执行的INSERT语句。</p><h2 id="导出CSV文件"><a href="#导出CSV文件" class="headerlink" title="导出CSV文件"></a>导出CSV文件</h2><p>另一种方法是直接将结果导出成.csv文件。MySQL提供了下面的语法，用来将查询结果导出到服务端本地目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from db1.t where a&gt;900 into outfile &#x27;/server_tmp/t.csv&#x27;;</span><br></pre></td></tr></table></figure><p>我们在使用这条语句时，需要注意如下几点。</p><ol><li>这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生成t.csv文件的。</li><li>into outfile指定了文件的生成位置（&#x2F;server_tmp&#x2F;），这个位置必须受参数<strong>secure_file_priv</strong>的限制。参数secure_file_priv的可选值和作用分别是：<ul><li>如果设置为<strong>empty</strong>，表示不限制文件生成的位置，这是不安全的设置；</li><li>如果设置为一个表示路径的<strong>字符串</strong>，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li><li>如果设置为<strong>NULL</strong>，就表示禁止在这个MySQL实例上执行select … into outfile 操作。</li></ul></li><li>这条命令不会帮你覆盖文件，因此你需要确保&#x2F;server_tmp&#x2F;t.csv这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li><li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li></ol><p>得到.csv导出文件后，你就可以用下面的load data命令将数据导入到目标表db2.t中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#x27;/server_tmp/t.csv&#x27; into table db2.t;</span><br></pre></td></tr></table></figure><p>这条语句的执行流程如下所示。</p><ol><li>打开文件&#x2F;server_tmp&#x2F;t.csv，以制表符(\t)作为字段间的分隔符，以换行符（\n）作为记录之间的分隔符，进行数据读取；</li><li>启动事务。</li><li>判断每一行的字段数与表db2.t是否相同：<ul><li>若不相同，则直接报错，事务回滚；</li><li>若相同，则构造成一行，调用InnoDB引擎接口，写入到表中。</li></ul></li><li>重复步骤3，直到&#x2F;server_tmp&#x2F;t.csv整个文件读入完成，提交事务。</li></ol><p>你可能有一个疑问，<strong>如果binlog_format&#x3D;statement，这个load语句记录到binlog里以后，怎么在备库重放呢？</strong></p><p>由于&#x2F;server_tmp&#x2F;t.csv文件只保存在主库所在的主机上，如果只是把这条语句原文写到binlog中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。</p><p>所以，这条语句执行的完整流程，其实是下面这样的。</p><ol><li>主库执行完成后，将&#x2F;server_tmp&#x2F;t.<strong>csv文件的内容直接写到binlog文件</strong>中。</li><li>往binlog文件中写入语句load data local infile ‘&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li><li>把这个binlog日志传到备库。</li><li>备库的apply线程在执行这个事务日志时：<br>a. 先将binlog中t.csv文件的内容读出来，写入到本地临时目录&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0 中；<br>b. 再执行load data语句，往备库的db2.t表中插入跟主库相同的数据。</li></ol><p>执行流程如图2所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/3a6790bc933af5ac45a75deba0f52cfd.jpg" alt="img" style="zoom:50%"><p>​ 图2 load data的同步流程</p><p>注意，这里备库执行的load data语句里面，<strong>多了一个“local”</strong>。它的意思是“将执行这条命令的客户端所在机器的本地文件&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0的内容，加载到目标表db2.t中”。</p><p>也就是说，<strong>load data命令有两种用法</strong>：</p><ol><li>不加“local”，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录下；</li><li>加上“local”，读取的是客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时候，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。</li></ol><p>另外需要注意的是，<strong>select …into outfile方法不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump提供了一个–tab参数，可以同时导出表结构定义文件和csv数据文件。这条命令的使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user ---single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --tab=$secure_file_priv</span><br></pre></td></tr></table></figure><p>这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个t.txt文件保存CSV数据。</p><h2 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h2><p>前面我们提到的mysqldump方法和导出CSV文件的方法，都是逻辑导数据的方法，也就是将数据从表db1.t中读出来，生成文本，然后再写入目标表db2.t中。</p><p>你可能会问，有物理导数据的方法吗？比如，直接把db1.t表的.frm文件和.ibd文件拷贝到db2目录下，是否可行呢？</p><p>答案是不行的。</p><p>因为，一个InnoDB表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有db2.t这个表，系统是不会识别和接受它们的。</p><p>不过，在MySQL 5.6版本引入了<strong>可传输表空间</strong>(transportable tablespace)的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。</p><p>假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p><ol><li>执行 create table r like t，创建一个相同表结构的空表；</li><li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</li><li>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</li><li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li><li>执行unlock tables，这时候t.cfg文件会被删除；</li><li>执行alter table r import tablespace，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。</li></ol><p>至此，拷贝表数据的操作就完成了。这个流程的执行过程图如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/2407737651cdc1f5d6ade4d8907e7c05.jpg" alt="img" style="zoom:50%"><p>​ 图3 物理拷贝表</p><p>关于拷贝表的这个流程，有以下几个注意点：</p><ol><li>在第3步执行完flsuh table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令后才释放读锁；</li><li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改t.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件（比如TB级别），每个数据页都需要修改，所以你会看到这个import语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import语句的耗时是非常短的。</li></ol><h2 id="小结和问题-3"><a href="#小结和问题-3" class="headerlink" title="小结和问题"></a>小结和问题</h2><p>今天这篇文章，我和你介绍了三种将一个表的数据导入到另外一个表中的方法。</p><p>我们来对比一下这三种方法的优缺点。</p><ol><li><strong>物理拷贝</strong>的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：<ul><li>必须是全表拷贝，不能只拷贝部分数据；</li><li>需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用；</li><li>由于是通过拷贝物理文件实现的，源表和目标表都是使用InnoDB引擎时才能使用。（物理拷贝也适用于MyISAM）</li></ul></li><li>用<strong>mysqldump</strong>生成包含INSERT语句文件的方法，可以在where参数增加过滤条件，来实现只导出部分数据。这个方式的不足之一是，不能使用join这种比较复杂的where条件写法。</li><li>用<strong>select … into outfile</strong>的方法是最灵活的，支持所有的SQL写法。但，这个方法的缺点之一就是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。</li></ol><p>后两种方式都是逻辑备份方式，是可以跨引擎使用的。</p><p>最后，我给你留下一个思考题吧。</p><p>我们前面介绍binlog_format&#x3D;statement的时候，binlog记录的load data命令是带local的。既然这条命令是发送到备库去执行的，那么备库执行的时候也是本地执行，为什么需要这个local呢？如果写到binlog中的命令不带local，又会出现什么问题呢？</p><p>这样做的一个原因是，<strong>为了确保备库应用binlog正常</strong>。因为备库可能配置了secure_file_priv&#x3D;null（不允许执行select … into outfile ），所以如果不用local的话，可能会导入失败，造成主备同步延迟。</p><p>另一种应用场景是使用mysqlbinlog工具解析binlog文件，并应用到目标库的情况。你可以使用下面这条命令 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog $binlog_file | mysql -h$host -P$port -u$user -p$pwd</span><br></pre></td></tr></table></figure><p>把日志直接解析出来发给目标库执行。增加local，就能让这个方法支持非本地的$host。</p><h1 id="42-讲grant之后要跟着flushprivileges吗"><a href="#42-讲grant之后要跟着flushprivileges吗" class="headerlink" title="42 讲grant之后要跟着flushprivileges吗"></a>42 讲grant之后要跟着flushprivileges吗</h1><p>在MySQL里面，grant语句是用来给用户赋权的。不知道你有没有见过一些操作文档里面提到，grant之后要马上跟着执行一个flush privileges命令，才能使赋权语句生效。我最开始使用MySQL的时候，就是照着一个操作文档的说明按照这个顺序操作的。</p><p>那么，grant之后真的需要执行flush privileges吗？如果没有执行这个flush命令的话，赋权语句真的不能生效吗？</p><p>接下来，我就先和你介绍一下grant语句和flush privileges语句分别做了什么事情，然后再一起来分析这个问题。</p><p>为了便于说明，我先创建一个用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;ua&#x27;@&#x27;%&#x27; identified by &#x27;pa&#x27;;</span><br></pre></td></tr></table></figure><p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是pa。注意，在MySQL里面，用户名(user)+地址(host)才表示一个用户，因此 ua@ip1 和 ua@ip2代表的是两个不同的用户。</p><p>这条命令做了两个动作：</p><ol><li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是N；</li><li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。</li></ol><p>图1就是这个时刻用户ua在user表中的状态。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/7e75bbfbca0cb932e1256941c99d5f35.png" alt="img" style="zoom:50%"><p>​ 图1 mysql.user 数据行</p><p>在MySQL中，用户权限是有不同的范围的。接下来，我就按照用户权限范围从大到小的顺序依次和你说明。</p><h2 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h2><p>全局权限，作用于整个MySQL实例，这些权限信息保存在mysql库的user表里。如果我要给用户ua赋一个最高权限的话，语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>这个grant命令做了两个动作：</p><ol><li>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为‘Y’；</li><li>内存里，从数组acl_users中找到这个用户对应的对象，将access值（权限位）修改为二进制的“全1”。</li></ol><p>在这个grant命令执行完成后，如果有新的客户端使用用户名ua登录成功，MySQL会为新连接维护一个线程对象，然后从acl_users数组里查到这个用户的权限，并将权限值拷贝到这个线程对象中。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存的权限位。</p><p>基于上面的分析我们可以知道：</p><ol><li>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。</li><li>对于一个已经存在的连接，它的全局权限不受grant命令的影响。</li></ol><p>需要说明的是，<strong>一般在生产环境上要合理控制用户权限的范围</strong>。我们上面用到的这个grant语句就是一个典型的错误示范。如果一个用户有所有权限，一般就不应该设置为所有IP地址都可以访问。</p><p>如果要回收上面的grant语句赋予的权限，你可以使用下面这条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke all privileges on *.* from &#x27;ua&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这条revoke命令的用法与grant类似，做了如下两个动作：</p><ol><li>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为“N”；</li><li>内存里，从数组acl_users中找到这个用户对应的对象，将access的值修改为0。</li></ol><h2 id="db权限"><a href="#db权限" class="headerlink" title="db权限"></a>db权限</h2><p>除了全局权限，MySQL也支持库级别的权限定义。如果要让用户ua拥有库db1的所有权限，可以执行下面这条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on db1.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。这条grant命令做了如下两个动作：</p><ol><li>磁盘上，往mysql.db表中插入了一行记录，所有权限位字段设置为“Y”；</li><li>内存里，增加一个对象到数组acl_dbs中，这个对象的权限位为“全1”。</li></ol><p>图2就是这个时刻用户ua在db表中的状态。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/32cd61ee14ad2f370e1de0fb4e39bb2e.png" alt="img" style="zoom:50%"><p>​ 图2 mysql.db 数据行</p><p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次acl_dbs数组，根据user、host和db找到匹配的对象，然后根据对象的权限位来判断。</p><p>也就是说，grant修改db权限的时候，是同时对磁盘和内存生效的。</p><p>grant操作对于已经存在的连接的影响，在全局权限和基于db的权限效果是不同的。接下来，我们做一个对照试验来分别看一下。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/aea26807c8895961b666a5d96b081ac7.png" alt="img" style="zoom:50%"><p>​ 图3 权限操作效果</p><p>需要说明的是，图中set global sync_binlog这个操作是需要super权限的。</p><p>可以看到，虽然用户ua的super权限在T3时刻已经通过revoke语句回收了，但是在T4时刻执行set global的时候，权限验证还是通过了。这是因为super是全局权限，这个权限信息在线程对象中，而revoke操作影响不到这个线程对象。</p><p>而在T5时刻去掉ua对db1库的所有权限后，在T6时刻session B再操作db1库的表，就会报错“权限不足”。这是因为acl_dbs是一个全局数组，所有线程判断db权限都用这个数组，这样revoke操作马上就会影响到session B。</p><p>这里在代码实现上有一个特别的逻辑，如果当前会话已经处于某一个db里面，之前use这个库的时候拿到的库权限会保存在会话变量中。</p><p>你可以看到在T6时刻，session C和session B对表t的操作逻辑是一样的。但是session B报错，而session C可以执行成功。这是因为session C在T2 时刻执行的use db1，拿到了这个库的权限，在切换出db1库之前，session C对这个库就一直有权限。</p><h2 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h2><p>除了db级别的权限外，MySQL支持更细粒度的表权限和列权限。其中，表权限定义存放在表mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在内存的hash结构column_priv_hash中。</p><p>这两类权限的赋权命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table db1.t1(id int, a int);</span><br><span class="line"></span><br><span class="line">grant all privileges on db1.t1 to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br><span class="line">GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>跟db权限类似，这两个权限每次grant的时候都会修改数据表，也会同步修改内存中的hash结构。因此，对这两类权限的操作，也会马上影响到已经存在的连接。</p><p>看到这里，你一定会问，看来grant语句都是即时生效的，那这么看应该就不需要执行flush privileges语句了呀。</p><p>答案也确实是这样的。</p><p>flush privileges命令会清空acl_users数组，然后从mysql.user表中读取数据重新加载，重新构造一个acl_users数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p><p>同样地，对于db权限、表权限和列权限，MySQL也做了这样的处理。</p><p>也就是说，如果内存的权限数据和磁盘数据表相同的话，不需要执行flush privileges。而如果我们都是用grant&#x2F;revoke语句来执行的话，内存和数据表本来就是保持同步更新的。</p><p><strong>因此，正常情况下，grant命令之后，没有必要跟着执行flush privileges命令。</strong></p><h2 id="flush-privileges使用场景"><a href="#flush-privileges使用场景" class="headerlink" title="flush privileges使用场景"></a>flush privileges使用场景</h2><p>那么，flush privileges是在什么时候使用呢？显然，当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges语句可以用来重建内存数据，达到一致状态。</p><p>这种不一致往往是由不规范的操作导致的，比如直接用DML语句操作系统权限表。我们来看一下下面这个场景：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/9031814361be42b7bc084ad2ab2aa3ec.png" alt="img"></p><p>​ 图4 使用flush privileges</p><p>可以看到，T3时刻虽然已经用delete语句删除了用户ua，但是在T4时刻，仍然可以用ua连接成功。原因就是，这时候内存中acl_users数组中还有这个用户，因此系统判断时认为用户还正常存在。</p><p>在T5时刻执行过flush命令后，内存更新，T6时刻再要用ua来登录的话，就会报错“无法访问”了。</p><p>直接操作系统表是不规范的操作，这个不一致状态也会导致一些更“诡异”的现象发生。比如，前面这个通过delete语句删除用户的例子，就会出现下面的情况：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/dd625b6b4eb2dcbdaac73648a1af50f1.png" alt="img"></p><p>​ 图5 不规范权限操作导致的异常</p><p>可以看到，由于在T3时刻直接删除了数据表的记录，而内存的数据还存在。这就导致了：</p><ol><li>T4时刻给用户ua赋权限失败，因为mysql.user表中找不到这行记录；</li><li>而T5时刻要重新创建这个用户也不行，因为在做内存判断的时候，会认为这个用户还存在。</li></ol><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>今天这篇文章，我和你介绍了MySQL用户权限在数据表和内存中的存在形式，以及grant和revoke命令的执行逻辑。</p><p><strong>使用grant和revoke语句时，无论是操作全局权限、db权限、表权限、列权限，都是会立即更新磁盘和内存的，因此完全不需要加上flush privileges</strong></p><p>grant语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，<strong>规范地使用grant和revoke语句，是不需要随后加上flush privileges语句的。</strong></p><p>flush privileges语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用DML语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p><p>另外，在使用grant语句赋权时，你可能还会看到这样的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant super on *.* to &#x27;ua&#x27;@&#x27;%&#x27; identified by &#x27;pa&#x27;;</span><br></pre></td></tr></table></figure><p>这条命令加了identified by ‘密码’， 语句的逻辑里面除了赋权外，还包含了：</p><ol><li>如果用户’ua’@’%’<strong>不存在</strong>，就创建这个用户，密码是pa；</li><li>如果用户ua已经<strong>存在</strong>，就将密码修改成pa。</li></ol><p>这也是一种<strong>不建议</strong>的写法，因为这种写法很容易就会不慎把密码给改了。</p><p>“grant之后随手加flush privileges”，我自己是这么使用了两三年之后，在看代码的时候才发现其实并不需要这样做，那已经是2011年的事情了。</p><p>去年我看到一位小伙伴这么操作的时候，指出这个问题时，他也觉得很神奇。因为，他和我一样看的第一份文档就是这么写的，自己也一直是这么用的。</p><h1 id="43-讲要不要使用分区表"><a href="#43-讲要不要使用分区表" class="headerlink" title="43 讲要不要使用分区表"></a>43 讲要不要使用分区表</h1><p>我经常被问到这样一个问题：分区表有什么问题，为什么公司规范不让使用分区表呢？今天，我们就来聊聊分区表的使用行为，然后再一起回答这个问题。</p><h2 id="分区表是什么？"><a href="#分区表是什么？" class="headerlink" title="分区表是什么？"></a>分区表是什么？</h2><p>为了说明分区表的组织形式，我先创建一个表t：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `ftime` datetime NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line">PARTITION BY RANGE (YEAR(ftime))</span><br><span class="line">(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,</span><br><span class="line">PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);</span><br><span class="line">insert into t values(&#x27;2017-4-1&#x27;,1),(&#x27;2018-4-1&#x27;,1);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/06f041129783533de9c75580f9decdf5.png" alt="img"></p><p>​ 图1 表t的磁盘文件</p><p>我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。</p><p>可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p><ul><li>对于引擎层来说，这是4个表；</li><li>对于Server层来说，这是1个表。</li></ul><p>你可能会觉得这两句都是废话。其实不然，这两句话非常重要，可以帮我们理解分区表的执行逻辑。</p><h2 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h2><p>我先给你举个在分区表加间隙锁的例子，目的是说明对于InnoDB来说，这是4个表。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d28d6ab873bd8337d88812d45b9266c7.png" alt="img"></p><p>​ 图2 分区表间隙锁示例</p><p>这里顺便复习一下，我在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/75659">第21篇文章</a>和你介绍的间隙锁加锁规则。</p><p>我们初始化表t的时候，只插入了两行数据， ftime的值分别是，‘2017-4-1’ 和’2018-4-1’ 。session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引上，间隙和加锁状态应该是图3这样的。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20231017154007915.png" alt="image-20231017154007915" style="zoom:50%"><p>​ 图3 普通表的加锁范围</p><p>也就是说，‘2017-4-1’ 和’2018-4-1’ 这两个记录之间的间隙是会被锁住的。那么，sesion B的两条插入语句应该都要进入锁等待状态。</p><p>但是，从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功的。这是因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。所以T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是图4这样的：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/92f63aba0b24adefac7316c75463b95c.jpg" alt="img" style="zoom:50%"><p>​ 图4 分区表t的加锁范围</p><p>由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图4中深绿色的部分。</p><p>所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p><p>图5就是这时候的show engine innodb status的部分结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/e3d83d9ba89de9a6f541c9a2f24a3b0f.png" alt="img"></p><p>​ 图5 session B被锁住信息</p><p>看完InnoDB引擎的例子，我们再来一个MyISAM分区表的例子。</p><p>我首先用alter table t engine&#x3D;myisam，把表t改成MyISAM表；然后，我再用下面这个例子说明，对于MyISAM引擎来说，这是4个表。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/941306d4a7193455dcf1cfebf7678876.png" alt="img"></p><p>​ 图6 用MyISAM表锁验证</p><p>在session A里面，我用sleep(100)将这条语句的执行时间设置为100秒。由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读。</p><p>但我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态。</p><p>这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。</p><p>看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。</p><p>接下来，我们一起看看手动分表和分区表有什么区别。</p><p>比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。</p><p>分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。</p><p>其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。</p><h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p><p>下图就是我创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/abfa0054ec43d97fb18ba3c1c8829ae7.png" alt="img"></p><p>​ 图 7 insert 语句报错</p><p>可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。</p><p>这时，你一定从表名猜到了，这个表我用的是MyISAM引擎。是的，因为使用InnoDB引擎的话，并不会出现这个问题。</p><p>MyISAM分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p><p>从MySQL 5.7.9开始，InnoDB引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在InnoDB内部自己管理打开分区的行为。</p><p>MySQL从5.7.17开始，将MyISAM分区表标记为即将弃用(deprecated)，意思是“从这个版本开始不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。</p><p>从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p><p>接下来，我们再看一下分区表在server层的行为。</p><h2 id="分区表的server层行为"><a href="#分区表的server层行为" class="headerlink" title="分区表的server层行为"></a>分区表的server层行为</h2><p>如果从server层看的话，一个分区表就只是一个表。</p><p>这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图8和图9所示，分别是这个例子的操作序列和执行结果图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/0eca5a3190161e59ea58493915bd5e81.png" alt="img"></p><p>​ 图8 分区表的MDL锁</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/afe662f5e051a2ceb96a87624a589aa8.png" alt="img"></p><p>​ 图9 show processlist结果</p><p>可以看到，虽然session B只需要操作p_2107这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住。</p><p>这也是DBA同学经常说的，分区表，在做DDL的时候，影响会更大。如果你使用的是普通分表，那么当你在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现MDL锁冲突。</p><p>到这里我们小结一下：</p><ol><li>MySQL在第一次打开分区表的时候，需要访问所有的分区；</li><li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</li><li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li></ol><p>而关于“必要的分区”的判断，就是根据SQL语句中的where条件，结合分区规则来实现的。比如我们上面的例子中，where ftime&#x3D;‘2018-4-1’，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区。</p><p>但是，如果这个where 条件改成 where ftime&gt;&#x3D;‘2018-4-1’，虽然查询结果相同，但是这时候根据where条件，就要访问p_2019和p_others这两个分区。</p><p>如果查询语句的where条件中没有分区key，那就只能访问所有分区了。当然，这并不是分区表的问题。即使是使用业务分表的方式，where条件中没有使用分表的key，也必须访问所有的分表。</p><p>我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？</p><h2 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h2><p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。</p><p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p><p>这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p><h2 id="小结和问题-4"><a href="#小结和问题-4" class="headerlink" title="小结和问题"></a>小结和问题</h2><p>这篇文章，我主要和你介绍的是server层和引擎层对分区表的处理方式。我希望通过这些介绍，你能够对是否选择使用分区表，有更清晰的想法。</p><p>需要注意的是，我是以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、list分区等分区方法。你可以在需要用到的时候，再翻翻<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html">手册</a>。</p><p>一个含有4个分区的分区表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p><ul><li>对于引擎层来说，这是4个表；</li><li>对于Server层来说，这是1个表。</li></ul><p>具体来看：</p><ol><li>MySQL在<strong>第一次</strong>打开分区表的时候，需要<strong>访问所有</strong>的分区；</li><li>在server层，认为这是同一张表，因此所有分区<strong>共用同一个MDL锁</strong>；</li><li>在<strong>引擎层</strong>，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，<strong>只访问必要的分区</strong>。</li></ol><p>实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：<strong>一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁。</strong></p><p>因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：</p><ol><li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li><li>分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。</li></ol><p>至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。</p><p>当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外的复杂性，对DBA也更直观，自然是更好的。</p><p>最后，我给你留下一个思考题吧。</p><p>我们举例的表中没有用到自增主键，假设现在要创建一个自增字段id。MySQL要求分区表中的主键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这么定义呢？</p><p>这时候就有两种可选：一种是(ftime, id)，另一种是(id, ftime)。</p><p>如果从利用率上来看，应该使用(ftime, id)这种模式。因为用ftime做分区key，说明大多数语句都是包含ftime的，使用这种模式，可以利用前缀索引的规则，减少一个索引。</p><p>这时的建表语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `ftime` datetime NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`ftime`,`id`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=latin1</span><br><span class="line">PARTITION BY RANGE (YEAR(ftime))</span><br><span class="line">(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = MyISAM,</span><br><span class="line"> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = MyISAM,</span><br><span class="line"> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = MyISAM,</span><br><span class="line"> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = MyISAM);</span><br></pre></td></tr></table></figure><p>当然，我的建议是你要尽量使用InnoDB引擎。InnoDB表要求至少有一个索引，以自增字段作为第一个字段，所以需要加一个id的单独索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `ftime` datetime NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`ftime`,`id`),</span><br><span class="line">  KEY `id` (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line">PARTITION BY RANGE (YEAR(ftime))</span><br><span class="line">(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);</span><br></pre></td></tr></table></figure><p>当然把字段反过来，创建成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY (`id`,`ftime`),</span><br><span class="line">KEY `id` (`ftime`)</span><br></pre></td></tr></table></figure><p>也是可以的。</p><h1 id="44-讲答疑文章（三）："><a href="#44-讲答疑文章（三）：" class="headerlink" title="44 讲答疑文章（三）："></a>44 讲答疑文章（三）：</h1><h2 id="join的写法"><a href="#join的写法" class="headerlink" title="join的写法"></a>join的写法</h2><p>在第35篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80147">《join语句怎么优化？》</a>中，我在介绍join执行顺序的时候，用的都是straight_join。@郭健 同学在文后提出了两个问题：</p><ol><li>如果用left join的话，左边的表一定是驱动表吗？</li><li>如果两个表的join包含多个条件的等值匹配，是都要写到on里面呢，还是只把一个条件写到on里面，其他条件写到where部分？</li></ol><p>为了同时回答这两个问题，我来构造两个表a和b：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table a(f1 int, f2 int, index(f1))engine=innodb;</span><br><span class="line">create table b(f1 int, f2 int)engine=innodb;</span><br><span class="line">insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);</span><br><span class="line">insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);</span><br></pre></td></tr></table></figure><p>表a和b都有两个字段f1和f2，不同的是表a的字段f1上有索引。然后，我往两个表中都插入了6条记录，其中在表a和b中同时存在的数据有4行。</p><p>@郭健 同学提到的第二个问题，其实就是下面这两种写法的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/</span><br><span class="line">select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/</span><br></pre></td></tr></table></figure><p>我把这两条语句分别记为Q1和Q2。</p><p>首先，需要说明的是，这两个left join语句的语义逻辑并不相同。我们先来看一下它们的执行结果。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/871f890532349781fdc4a4287e9f91bd.png" alt="img" style="zoom:50%"><p>​ 图1 两个join的查询结果</p><p>可以看到：</p><ul><li>语句Q1返回的数据集是6行，表a中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表b的各个字段值填成NULL。</li><li>语句Q2返回的是4行。从逻辑上可以这么理解，最后的两行，由于表b中没有匹配的字段，结果集里面b.f2的值是空，不满足where 部分的条件判断，因此不能作为结果集的一部分。</li></ul><p>接下来，我们看看实际执行这两条语句时，MySQL是怎么做的。</p><p>我们先一起看看语句Q1的explain结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/b7f27917ceb0be90ef7b201f2794c817.png" alt="img"></p><p>​ 图2 Q1的explain结果</p><p>可以看到，这个结果符合我们的预期：</p><ul><li>驱动表是表a，被驱动表是表b；</li><li>由于表b的f1字段上没有索引，所以使用的是Block Nexted Loop Join（简称BNL） 算法。</li></ul><p>看到BNL算法，你就应该知道这条语句的执行流程其实是这样的：</p><ol><li>把表a的内容读入join_buffer 中。因为是select * ，所以字段f1和f2都被放入join_buffer了。</li><li>顺序扫描表b，对于每一行数据，判断join条件（也就是a.f1&#x3D;b.f1 and a.f2&#x3D;b.f2)是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有where子句，需要先判断where部分满足条件后，再返回。</li><li>表b扫描完成后，对于没有被匹配的表a的行（在这个例子中就是(1,1)、(2,2)这两行），把剩余字段补上NULL，再放入结果集中。</li></ol><p>对应的流程图如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/8fd4b4b179fb84caaecece84b6406ad7.jpg" alt="img" style="zoom:50%"><p>​ 图3 left join -BNL算法</p><p>可以看到，这条语句确实是以表a为驱动表，而且从执行效果看，也和使用straight_join是一样的。</p><p>你可能会想，语句Q2的查询结果里面少了最后两行数据，是不是就是把上面流程中的步骤3去掉呢？我们还是先看一下语句Q2的expain结果吧。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/f5712c56dc84d331990409a5c313ea9c.png" alt="img"></p><p>​ 图4 Q2的explain结果</p><p>这里先和你说一句题外话，专栏马上就结束了，我也和你一起根据explain结果“脑补”了很多次一条语句的执行流程了，所以我希望你已经具备了这个能力。今天，我们再一起分析一次SQL语句的explain结果。</p><p>可以看到，这条语句是以表b为驱动表的。而如果一条join语句的Extra字段什么都没写的话，就表示使用的是Index Nested-Loop Join（简称NLJ）算法。</p><p>因此，语句Q2的执行流程是这样的：顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后判断a.f2&#x3D;b.f2是否满足，满足条件的话就作为结果集的一部分返回。</p><p>那么，<strong>为什么语句Q1和Q2这两个查询的执行流程会差距这么大呢？</strong>其实，这是因为优化器基于Q2这个查询的语义做了优化。</p><p>为了理解这个问题，我需要再和你交代一个背景知识点：在MySQL里，NULL跟任何值执行等值判断和不等值判断的结果，都是NULL。这里包括， select NULL &#x3D; NULL 的结果，也是返回NULL。</p><p>因此，语句Q2里面where a.f2&#x3D;b.f2就表示，查询结果里面不会包含b.f2是NULL的行，这样这个left join的语义就是“找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃”。</p><p>这样，这条语句虽然用的是left join，但是语义跟join是一致的。</p><p>因此，优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱动表，这样就可以用上NLJ 算法。在执行explain之后，你再执行show warnings，就能看到这个改写的结果，如图5所示。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d74878e7469edb8b713a18c6158530ab.png" alt="img"></p><p>​ 图5 Q2的改写结果</p><p>这个例子说明，即使我们在SQL语句中写成left join，执行过程还是有可能不是从左到右连接的。也就是说，<strong>使用left join时，左边的表不一定是驱动表。</strong></p><p>这样看来，<strong>如果需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。</strong>那如果是join语句呢？</p><p>这时候，我们再看看这两条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from a join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q3*/</span><br><span class="line">select * from a join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q4*/</span><br></pre></td></tr></table></figure><p>我们再使用一次看explain 和 show warnings的方法，看看优化器是怎么做的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/d9952e4c2150bc649c7f2977e6ea80f5.png" alt="img"></p><p>​ 图6 join语句改写</p><p>可以看到，这两条语句都被改写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a join b where (a.f1=b.f1) and (a.f2=b.f2);</span><br></pre></td></tr></table></figure><p>执行计划自然也是一模一样的。</p><p>也就是说，在这种情况下，join将判断条件是否全部放在on部分就没有区别了。</p><h2 id="Simple-Nested-Loop-Join-的性能问题"><a href="#Simple-Nested-Loop-Join-的性能问题" class="headerlink" title="Simple Nested Loop Join 的性能问题"></a>Simple Nested Loop Join 的性能问题</h2><p>我们知道，join语句使用不同的算法，对语句的性能影响会很大。在第34篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/79700">《到底可不可以使用join？》</a>的评论区中，@书策稠浊 和 @朝夕心 两位同学提了一个很不错的问题。</p><p>我们在文中说到，虽然BNL算法和Simple Nested Loop Join 算法都是要判断M*N次（M和N分别是join的两个表的行数），但是Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上BNL算法执行起来会快很多。</p><p>为了便于说明，我还是先为你简单描述一下这两个算法。</p><p>BNL算法的执行逻辑是：</p><ol><li>首先，将驱动表的数据全部读入内存join_buffer中，这里join_buffer是无序数组；</li><li>然后，顺序遍历被驱动表的所有行，每一行数据都跟join_buffer中的数据进行匹配，匹配成功则作为结果集的一部分返回。</li></ol><p>Simple Nested Loop Join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p><p>这两位同学的疑问是，Simple Nested Loop Join算法，其实也是把数据读到内存里，然后按照匹配条件进行判断，为什么性能差距会这么大呢？</p><p>解释这个问题，需要用到MySQL中索引结构和Buffer Pool的相关知识点：</p><ol><li>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；<br>从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部（请参考<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80147">第35篇文章</a>中的相关内容)；</li><li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而join_buffer中是数组，遍历的成本更低。</li></ol><p>所以说，BNL算法的性能会更好。</p><h2 id="distinct-和-group-by的性能"><a href="#distinct-和-group-by的性能" class="headerlink" title="distinct 和 group by的性能"></a>distinct 和 group by的性能</h2><p>在第37篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80477">《什么时候会使用内部临时表？》</a>中，@老杨同志 提了一个好问题：如果只需要去重，不需要执行聚合函数，distinct 和group by哪种效率高一些呢？</p><p>我来展开一下他的问题：如果表t的字段a上没有索引，那么下面这两条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select a from t group by a order by null;</span><br><span class="line">select distinct a from t;</span><br></pre></td></tr></table></figure><p>的性能是不是相同的?</p><p>首先需要说明的是，这种group by的写法，并不是SQL标准的写法。标准的group by语句，是需要在select部分加一个聚合函数，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a,count(*) from t group by a order by null;</span><br></pre></td></tr></table></figure><p>这条语句的逻辑是：按照字段a分组，计算每组的a出现的次数。在这个结果里，由于做的是聚合计算，相同的a只出现一次。</p><blockquote><p>备注：这里你可以顺便复习一下<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80477">第37篇文章</a>中关于group by的相关内容。</p></blockquote><p>没有了count(<em>)以后，也就是不再需要执行“计算总数”的逻辑时，第一条语句的逻辑就变成是：按照字段a做分组，相同的a的值只返回一行。而这就是distinct的语义，所以不需要执行聚合函数时，distinct 和group by这两条语句的语义和执行流程是相同的，因此*<em>执行性能也相同。</em></em></p><p>这两条语句的执行流程是下面这样的。</p><ol><li>创建一个临时表，临时表有一个字段a，并且在这个字段a上创建一个唯一索引；</li><li>遍历表t，依次取数据插入临时表中：<ul><li>如果发现唯一键冲突，就跳过；</li><li>否则插入成功；</li></ul></li><li>遍历完成后，将临时表作为结果集返回给客户端。</li></ol><h2 id="备库自增主键问题"><a href="#备库自增主键问题" class="headerlink" title="备库自增主键问题"></a>备库自增主键问题</h2><p>除了性能问题，大家对细节的追问也很到位。在第39篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80531">《自增主键为什么不是连续的？》</a>评论区，@帽子掉了 同学问到：在binlog_format&#x3D;statement时，语句A先获取id&#x3D;1，然后语句B获取id&#x3D;2；接着语句B提交，写binlog，然后语句A再写binlog。这时候，如果binlog重放，是不是会发生语句B的id为1，而语句A的id为2的不一致情况呢？</p><p>首先，这个问题默认了“自增id的生成顺序，和binlog的写入顺序可能是不同的”，这个理解是正确的。</p><p>其次，这个问题限定在statement格式下，也是对的。因为row格式的binlog就没有这个问题了，Write row event里面直接写了每一行的所有字段的值。</p><p>而至于为什么不会发生不一致的情况，我们来看一下下面的这个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table t(id int auto_increment primary key);</span><br><span class="line">insert into t values(null);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/b55b2167aa301d899ccc86a00b496b25.png" alt="img"></p><p>​ 图7 insert 语句的binlog</p><p>可以看到，在insert语句之前，还有一句SET INSERT_ID&#x3D;1。这条命令的意思是，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用1这个值。</p><p>这个SET INSERT_ID语句是固定跟在insert语句之前的，比如@帽子掉了同学提到的场景，主库上语句A的id是1，语句B的id是2，但是写入binlog的顺序先B后A，那么binlog就变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET INSERT_ID=2;</span><br><span class="line">语句B；</span><br><span class="line">SET INSERT_ID=1;</span><br><span class="line">语句A；</span><br></pre></td></tr></table></figure><p>你看，在备库上语句B用到的INSERT_ID依然是2，跟主库相同。</p><p>因此，即使两个INSERT语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>今天这篇答疑文章，我选了4个好问题和你分享，并做了分析。在我看来，能够提出好问题，首先表示这些同学理解了我们文章的内容，进而又做了深入思考。有你们在认真的阅读和思考，对我来说是鼓励，也是动力。</p><p>说实话，短短的三篇答疑文章无法全部展开同学们在评论区留下的高质量问题，之后有的同学还会二刷，也会有新的同学加入，大家想到新的问题就请给我留言吧，我会继续关注评论区，和你在评论区交流。</p><p>老规矩，答疑文章也是要有课后思考题的。</p><p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/70562">第8篇文章</a>的评论区， @XD同学提到一个问题：他查看了一下innodb_trx，发现这个事务的trx_id是一个很大的数（281479535353408），而且似乎在同一个session中启动的会话得到的trx_id是保持不变的。当执行任何加写锁的语句后，trx_id都会变成一个很小的数字（118378）。</p><p>你可以通过实验验证一下，然后分析看看，事务id的分配规则是什么，以及MySQL为什么要这么设计呢？</p><h1 id="45-自增id用完的情况"><a href="#45-自增id用完的情况" class="headerlink" title="45 自增id用完的情况"></a>45 自增id用完的情况</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0.assets/image-20231020153102372.png" alt="image-20231020153102372"></p><p>MySQL 里有很多自增的 id，每个自增 id 都是定义了初始值，然后不停地往上加步长。虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型 (unsigned int) 是 4 个字节，上限就是 232-1。</p><p>既然自增 id 有上限，就有可能被用完。但是，自增 id 用完了会怎么样呢？</p><p>今天这篇文章，我们就来看看 MySQL 里面的几种自增 id，一起分析一下它们的值达到上限以后，会出现什么情况。</p><h2 id="表定义自增值-id"><a href="#表定义自增值-id" class="headerlink" title="表定义自增值 id"></a>表定义自增值 id</h2><p>说到自增 id，你第一个想到的应该就是表结构定义里的自增字段，也就是我在第 39 篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80531">《自增主键为什么不是连续的？》</a>中和你介绍过的自增主键 id。</p><p>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。</p><p>我们可以通过下面这个语句序列验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table t(id int unsigned auto_increment primary key) auto_increment=4294967295;</span><br><span class="line">insert into t values(null);</span><br><span class="line">// 成功插入一行 4294967295</span><br><span class="line">show create table t;</span><br><span class="line">/* CREATE TABLE `t` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">insert into t values(null);</span><br><span class="line">//Duplicate entry &#x27;4294967295&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>第一个 insert 语句插入数据成功后，这个表的 AUTO_INCREMENT 没有改变（还是 4294967295），就导致了第二个 insert 语句又拿到相同的自增 id 值，再试图执行插入语句，报主键冲突错误。</strong></p><p>232-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的。因此在建表的时候你需要考察你的表是否有可能达到这个上限，如果有可能，就应该创建成 8 个字节的 bigint unsigned。</p><h2 id="InnoDB-系统自增-row-id"><a href="#InnoDB-系统自增-row-id" class="headerlink" title="InnoDB 系统自增 row_id"></a>InnoDB 系统自增 row_id</h2><p>如果你创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。InnoDB 维护了一个全局的 dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。</p><p>实际上，在代码实现时 row_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度，这样写到数据表中时只放了最后 6 个字节，所以 row_id 能写到数据表中的值，就有两个特征：</p><ol><li>row_id 写入表中的值范围，是从 0 到 248-1；</li><li>当 dict_sys.row_id&#x3D;248时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。</li></ol><p>也就是说，写入表的 row_id 是从 0 开始到 248-1。达到上限后，下一个值就是 0，然后继续循环。</p><p>当然，248-1 这个值本身已经很大了，但是如果一个 MySQL 实例跑得足够久的话，还是可能达到这个上限的。在 InnoDB 逻辑里，<strong>申请到 row_id&#x3D;N 后，就将这行数据写入表中；如果表中已经存在 row_id&#x3D;N 的行，新写入的行就会覆盖原有的行。</strong></p><p>要验证这个结论的话，你可以通过 gdb 修改系统的自增 row_id 来实现。注意，用 gdb 改变量这个操作是为了便于我们复现问题，只能在测试环境使用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,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4hKQgAQkIAEJSEACEpCABCQgAQlIQAJTlYDC21Qtea9bAhKQgAQkIAEJSEACEpCABCQgAQlIYKAEFN4GitfEJSABCUhAAhKQgAQkIAEJSEACEpCABKYqAYW3qVryXrcEJCABCUhAAhKQgAQkIAEJSEACEpDAQAkovA0Ur4lLQAISkIAEJCABCUhAAhKQgAQkIAEJTFUCc07VC/e6JSABCUx1Av/5z3/SD3/4wzTbbLOlFVZYIS+nEpO//e1v6a677krzzTdfWnbZZafSpXutEpCABCQgAQlIQAISkMA4EdDjbZxAexoJSEACw0bg0ksvTdOnT0+XX375lBPdKIu55porHXjggWmnnXZKv/nNb4ateMyPBCQgAQlIQAISkIAEJDAJCCi8TYJC9BIkIAEJdEvg0UcfTaeffnqac845084779zt4ZNi/3nmmSdtvvnm6b///W8666yzJsU1eRESkIAEJCABCUhAAhKQwHARMNR0AstjxowZ6dZbb03zzz//lO34TiD+SX/qOurXv//973TyySdnVmuuuWZafvnlJyW3qcjqtNNOS4RabrrppumFL3zhuJfrDTfckC6++OK06qqrpq222mrczx8n5PrPO++8dO2116btt98+LbroorFp0i6Hhf2gAf/1r39Np5xySnrkkUfSLrvskhZffPFBn3Ko07/99tvTN77xjZxHPF0R3cPqaAMjLZcSkIAEJCABCUhAAmMJ6PE2lse4fuMhmI7nlVdeOa7n9WRTg0Ad9QvhjTrK37333jtpwU01Vni7XX311bk8N9tss3EvV+rVkUcemW677bYsjPziF78Y9zzECZ/1rGeljTbaaMp4vQ0T+yiDQS2/9KUv5d/XG2+8MZ1xxhmDOs3IpPvzn/+80Z4/8cQTY/JdRxs4JkG/SEACEpCABCQgAQk0CCi8NVD4YSoQuPnmm9NFF12Uvva1r03o5Q5LPiYUQocnl1WHoGbu1ikrxH4EmFe84hVpscUW6/wENe3J2GoLLLBATq34uabkczJ/+ctf8r3O/f773/++ZdLvfOc70+yzz5693ib7WG9F3sXPLQGN6MaFFlqokfPi58ZKP0hAAhKQgAQkIAEJSGAcCDwVZzAOJ/MUEphoAnj5XHfddWnppZdO66yzzoRlZ1jyMWEAujixrDqH1QkrxjNjMgVsww037Dzxmvc87rjjsgC+8sorN0S4Ok/x8MMPp+OPPz4n+YIXvCDx18zYRij117/+9XTOOeekAw44oNmuk2L9oNkPCyTKlHBK6sKb3/zmYcmW+ZCABCQgAQlIQAISmGIE9HibYgXu5UpAAlObwD333JP+8Ic/ZAirrbbahMF4/vOfn7bZZpu0zDLLTFgeiid+4xvfmL8y/hni5GS2YWM/KNZ4MU6bNi2PYzjffPMN6jSmKwEJSEACEpCABCQggZYEFN5a4nGjBCQggclFgAldsBe/+MXJ8LunynaFFVbIX/7+97+nu+6666kNfpKABCQgAQlIQAISkIAEJNAHgYGGmjKgMWPr0MFj5jrGFLrjjjvS9773vRz68drXvjbx98xnPrNxCXga3HnnnXm2TwYCft7znpeWXXbZ9KY3vSnNNttsjf1+9rOfJQYDxtZdd92WoUoPPPBA+uY3v5n3XWWVVdJLXvKS/Dn+/fKXv0zf+ta30m9/+9s8yx/eAEsttVRaa621EmPgtLJ//OMfOa/kmbGByOtKK62UllhiiZzfX//613ncJdJgEPM55pijVXKNbeTpGc94Rnruc5/bWDceH37yk5/kTifs6YAyw99LX/rS7DVQlXcGaf/qV7+as/aWt7wl5xkO3//+99MPfvCDPGPrhz/84VmyTj2gc3v33XfnbS972cty+Odyyy03y77lFU8++WT6zne+k370ox+l+++/P3unMCsjzKkneDkUjZntCMHDKA+MWe6+8IUv5M/8o6yrWBOiRD0jn1zXi170olw3VlxxxZZ1rpFw4UM/+XjooYdyWN7vfve7xOcFF1wwz0S5xhprdDULI9dDuTCo/X/+85/08pe/PMG8jtn++inTAqb8sVdW3daN8nmL3ycrqxDeqMOdWl31r3i+7373u+m+++5LTG6w/vrrFzel8m8HdZU2/4c//GFeIhhSZwkXn3feecccyzh33OfkOYz2nXsH4zdl2kwvqLJxTzHeHXmCEfdGK+u2vle1leSRa+KefOyxx/L5Cb1td27yxf7kEy60TbShiId4ENJW89sLR6z829OMfd155NzdcuKYuoxZe7/85S/n5FZfffXcfkfa/dSxOtOItFjG7y9eqZTvkksumX/XKNdyPS8eF5//+c9/5rad55Ff/epX+bcq6kRxBtPYv91ykG1gu3O7XQISkIAEJCABCUwmAgMV3phRjIfbtdde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EpCABCQgAQlIQAISkIAEJCABCUhAAkNKQOFtSAvGbElAAhKQgAQkIAEJSEACEpCABCQgAQmMNgGFt9EuP3MvAQlIQAISkIAEJCABCUhAAhKQgAQkMKQEFN6GtGDMlgQkIAEJSEACEpCABCQgAQlIQAISkMBoE1B4G+3yM/cSkIAEJCABCUhAAhKQgAQkIAEJSEACQ0pA4W1IC8ZsSUACEpCABCQgAQlIQAISkIAEJCABCYw2AYW30S4/cy8BCUhAAhKQgAQkIAEJSEACEpCABCQwpATmHNJ89ZStU089Nf3jH/9IK620Unr9618/Jo0ZM2akW2+9Nc0///xp5513HrPNL8NH4IYbbkgXX3xxWnXVVdNWW23VcwZb1YmeE+3hwH/961/pS1/6UrrnnnvSgw8+mJ71rGel/fffv4eUPKRM4N///nc6+eST8+o111wzLb/88uVdOvp+++23p2984xt53+nTp6c555xUzWNHDKb6Ts3ai7/+9a/plFNOSY888kjaZZdd0uKLLz7VUXn940Cgrnpn29ZfYU2l58e6fk/7I+7REpCABCQggclHYFL1LK+44or05z//Oc0999yzCG88eCLkLLDAAgpvQ16PefA78sgj01/+8pd02223ZfHtpS99aU+5blUnekqwh4P++Mc/pt133z39/ve/bxw9xxxzKLw1aPT3gfrCvY295CUv6Vl4+/nPf95IZ9ddd1V4669YGkcfeuih6fHHH09bbLFFetWrXtVYP4wfmrUXiOZXXnllzjKC7OGHHz6M2TdPk4xAXfVuItq2//73v+mCCy5Id955Zy6VrbfeOr385S+fpYRGoX2YSs+Pdf2ezlLQrpCABCQgAQlMcQKTSnib4mU5aS5/rrnmygIpwlt8HuWLO+GEExqi29JLL53e9KY3pQUXXHCUL8m8S6BjAniv4olMvR924a3ZRS200EKNTcXPjZU1fLj55pvTb37zm9z2rbPOOjWkaBKjTqBY14qfh/26eNl08MEHJwSrsPXXXz8+jllOhvZhzAUN8AvPRF/5ylfyGdZYY430ghe8YIBnM2kJSEACEpCABOokoPBWJ03Tqo3Acccdl772ta+llVdeOXdEa0t4nBN68skn00033ZTP+prXvCaddNJJ45wDTycBCfRLgBBmPN0efvjh9OY3v7nf5CqPv/rqq9N1112XEOcV3ioR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IAEJSEACEpCABCQgAQlIYLQJKLyNdvmZewlIQAISkIAEJCABCUhAAhKQgAQkIIEhJaDwNqQFY7YkIAEJSEACEpCABCQgAQlIQAISkIAERpuAwttol5+5l4AEJCABCUhAAhKQgAQkIAEJSEACEhhSAgpvQ1owZksCEpCABCQgAQlIQAISkIAEJCABCUhgtAkovI12+Zl7CUhAAhKQgAQkIAEJSEACEpCABCQggSEloPA2pAVjtiQgAQlIQAISkIAEJCABCUhAAhKQgARGm4DC22iXn7mXgAQkIAEJSEACEpCABCQgAQlIQAISGFICCm9DWjBmSwISkIAEJCABCUhAAhKQgAQkIAEJSGC0Ccw52tk39xKQgASmJoHf/OY36YEHHkgveMEL0iKLLNIXhL/97W/prrvuSvPNN19adtll+0rLgyUgAQlIQAISkIAEJCABCUjgKQIKb0+x8JMEJCCBkSDwj3/8I02fPj09+OCD6bzzzus7z3PNNVc68MAD01/+8pd04YUXpkUXXbTvNE1AAhKQgAQkIAEJSEACEpCABFIy1NRaIAEJSGDECJx77rnZ2+3Nb35zWnzxxfvO/TzzzJM233zz9N///jedddZZfadnAhKQgAQkIAEJSEACEpCABCTw/wQU3iawJsyYMSMdd9xx6bTTTpuwXPz1r39NRx11VNp3333TL3/5ywnLxzCfWEbDXDpj8/bvf/8731PcV7fffvvYjZPk2+9///t0wQUXJLzU3vve99Z2VZtuummad95507XXXpsIY9UkIAEJSEACEpCABCQgAQlIoH8CCm/9M+w5BYSBiy++OF155ZU9p9HvgV/60pfy+W+88cZ0xhln9JvcpDxeRqNTrAhv3FP83XvvvaOT8S5yeskllySu8w1veENaeOGFOzoSUf3ggw9O+++/fzrllFMqj3nWs56VNtpoI73eKum4UgISkIAEJCABCUhAAhKQQG8EFN564zZpjlpooYUa11L83Fg54h9uvvnmdNFFF6Wvfe1rPV9JkUvxc88JVhxYRz4rku16FWN8wYs/PKu04SLwz3/+M335y1/Omdpggw06ytyll16adthhh+zJ9s1vfjPdcsstTY975zvfmWaffXa93poScoMEJCABCUhAAhKQgAQkIIHuCDi5Qne8Jt3ea665ZppzzjnTww8/nBgvarLZ1Vdfna677rq09NJLp3XWWaenyxsPRnXks6eLKx1EPTj++OPzWmbL5E8bHgJf//rXE6HPCMCvfe1rW2bsz3/+czriiCMS3qydGuVNfec855xzTjrggAM6PdT9JCABCUhAAhKQgAQkIAEJSKCCgB5vFVCm0iq8W6ZNm5YY32m++eabSpfe8bXKqGNU7jhgAiGirbrqqtkzrdnpvv/976dtttkmi26zzTZbwpNtySWXbLb7mPVvfOMb8/cbbrghh52O2egXCUhAAhKQgAQkIAEJSEACEuiKgMJbV7jcWQISkMDEEGDG0R/84Af55K95zWuaZuJnP/tZ2mOPPdKDDz6Ynv3sZ6djjjkmf59//vmbHlPcsMIKK+Svf//739Ndd91V3ORnCUhAAhKQgAQkIAEJSEACEuiSwEBDTfHOYJyoF7/4xQkPDQYEv+OOO9L3vve9HNpIqBR/z3zmMxvZpnN55513pltvvTX9/Oc/T8973vPSsssum970pjclPDfC6FzGrIXrrrtuWmCBBWLTLMsHHnggMbYRtsoqq6SXvOQlY/Zh4PFvfetb6be//W3629/+lp7//OenpZZaKq211lp55sAxO5e+/OMf/8h5Jc/MBEheV1pppbTEEkvk/P76179OjN+FbbbZZmmOOeYopVD9lTw94xnPSM997nOrd6hpLdcbY0atvvrq6UUvelEj5XL5/ec//0lw/+EPf5iXhLstvvjiOYST2RBbGWX/jW98I91zzz25Tjz96U9PiyyySMK7hjTaGSGQlPfdd9+dOZNPymjFFVecpewJxSN0E4M/9sgjj6QvfOEL+TP/KNtO2Q6KUT/5fPTRR3M5MIHAfffdl68Fj6ZXvOIVabHFFmtcZ6cfqKOweuihhxqHcE/87ne/y9+5D/GM7MS++MUvpieeeCItuuiiabXVVmt5CDNoUjYM7L/++uuP2Ze8MDYfeeDzggsumF74whemNdZYI6c9ZucOvhTvxQ033DA97WlPqzyKce6uueaavO31r39903Dbbupk1Ym6bXeo+9RFjHrfzB577LH05JNPppVXXjl99KMfTc95znOa7Vq5Hs7UIeoV7fDLX/7yyv1cKQEJSEACEpCABCQgAQlIQALtCQxUeGM2SMSbtddeOy2//PLpve99b6KzGcZ2xhdjTCk6kggRu+++exZnYp9YvvrVr05HHnlk7qCzjvC/E044ITbnUKrGl9IHzsOMnRyD4BLGQOWf+MQn0le/+tXKkCpm/9t3331zRz+OKS7pyH/4wx/OHdRYz9hI2Ctf+cp8XYiHkc+NN964Y+GNDu+JJ56YRa0tt9yy4zCxyEenS8aBivwhrhSFt2L5UT7ve9/70k9+8pNZkj733HNzB/9Vr3rVLNtYgaiD1839998/y/bTTz89CzoIBPPMM88s21lx/fXX57GqQnQo7oRgwzhUiIZhCDlxTbEO8bW4bplllulYeBsUo17zCY+jjjoqIRCVDXH6Xe96V9ppp53aisbFYxGaou7G+uJsu3hYTetQeGPwfu57BJ8rrriiaUgk5Xn44YdnQZ5QyBDeEN8pq8svvzxvi/zE8tOf/nR629velt7//vd3fD9xbPFeZEbQZsIbIl/UFcTDqnHuuq2TkXeWvbY7CN4YeWolptGm7rbbbmmrrbYa87IiH9zhP9pbhDfE7q233nqWoxDSf/WrXw2sXZrlhK6QgAQkIAEJSEACEpCABCQwogQGKrwFEzrSBx10UPZ0wsOJjiyduu985zvZM2b//fdPJ510Ujr66KPTL37xi+yVhhcUHiXsg/BBp5MON0IX9rKXvSx7leHxgycVHfdmxnYMT7TwciJPBx98cJoxY0behlfe6173ujxoOZ1NzkcHnLzRCacjWjQ8v6ZPn54Ix8LwEMHbiE4v3m8//vGP01577ZU6nXmwmHZ8xmsIQYQ/PAMRVNoNqB7H1rmE1SGHHJJ++tOfZoEUbz48/bhGyhGPpI985CPZo6wczsY+++23X/rXv/6Vx5AjjA0R7w9/+EMOm6P88EZEjPjkJz85S7YRTM8888y8Hq9Grh9PObwTo27ss88+ac8998weheyIoBLcb7vttiz4IdDhKRXWykMy9ulm2QujXvJ56qmnJoROjDH5EHhf+tKXpj/+8Y+5fBAYP/e5z2VPpdNOO61j8Y1yQfhE/I57gvsFMRajfndqTNKB8Mb986Mf/SiL7lXHsg8CDvaWt7ylscuhhx6aZ9VkBd5X3FdcI0LlTTfdlEMoL7744uwR+p73vKdx3Hh96KVORt76aXcoWwyP3Fa23HLLJf76sTgH9apsCKbveMc7El6X3I8xGUd5P79LQAISkIAEJCABCUhAAhKQQErjIrwhfNGBR0AphhUiijAWEcLau9/97oRog5cZ3nFhdO523XXX7F1x1VVXZa8rwhQxOusIdog7dEoXXnjhOKyxRBhCzMOKs3YirIXA8MEPfjBtvvnmjWPw8MCbY4cddsgC03nnnTeL8HbyySdn0Q0vOrz08EorGiF0eOj1OkYSXoJwueyyy7IAiRcRf4henIsZOueaa67iKQf2mfJjrChYF0PcEBEorwsvvDCLLJ///Oczs2JGEEsR3RA2EYIQwIoGI8oVrzgEy2JYG96RZ599dt4d0QzPtmJYMqIA6/DCI22YkU+8gRBMsQMPPDALbwgJsS5vqPlfL4y6zSci5fnnn59zziytzFiJCBmGiHXsscdmLzOEYUJrq7yVYv/iEg8y/rhf4r5AXCmKlcX9W33G+5BywiMPLsX7uXgc2zDqNGHDGPcq9w6GqMP1cI+FPf7441l8/+53v5vrxtvf/vZZQo1j30Ese62TkZd+2h2ER4w6PmgLYTrOWTwfEzfQLmO0SYi1hMVrEpCABCQgAQlIQAISkIAEJDArgad6tLNuq3XNhz70oTGiG4kj4qy33nqN8xAeV+6k08ncbrvt8j6MW8Q4amGM7UannPUxhltsi2V07hH1YrY+tiHWYYy5tskmm+TPxX+MA4cHFqIc4zwVjY4noiGGp11ZdGM9eeNYPLl6Ma57xx13zMIbglHMSIj4cthhhyUEBwRBOr3jYYSZFkU3zgn7XXbZJXsJ8r0choowh5ccRohvWXRjPZ5q/MGqPP4doh5pIJrhcVcU3TgWMZf1c889dxZBzznnHFZPmPXCqJvMEnoMDzzdjjvuuDGiG+kgxBIazdheGKJllXCSNw7wH/lABMW4L7k/y4bXFKINVvR2I1SWa+CPel4U3dgXrzzqHAYLwkfH0/qtk/20OyF2jafwhvhfLj/agXj5wWdFt/GsgZ5LAhKQgAQkIAEJSEACEhg1AuMivCGYMLlCleHtElYcpyvWsSzuUwx9wmOI8FAsBLb8pfAv1jM5Q3ECAMQLjAkDwsOncFj+SHgpnnBlYS7SRPBhHKVmhqBQ9Ehqtl+r9YgYhE0SXoiXHSIgYgQzFuJNRt4QYZjEYlDGdcb4W+VzkD9CATHCP4tGPjkWu37muGTlDjzrEVKYdALOhA+HIcwQVoghbEZ5xfZYErbMeF0YoacTZb0y6jS/CKxMSoJR5q3ElxCqGWR/opiEmEY9ZUKVsjFxAx561BFE6jA8YhkLkb8Qd2JbLPGeDCsK8bFuUMs66mTU417aHc6PNeNS53XHOQh3L788oD1n/Mezzjore8HWeV7TkoAEJCABCUhAAhKQgAQkMNkIjIvwVhywvwyQMdHCYvy1+B7L4rhhZfEmwkcj3DSOYUm4aFWYKdsIY4tzf+xjH8uDvOOdVU6ffcsWIhciAWNQNTPSZ5ysugzvEsbBI6QToYpOPGOtMd4VYYGEXZbFrzrOTfmVPY+K6cY4YFWD/YeYSojeNttskz34OvHSKwoqjGPWyhj/C6Nc8IKaCOuHUSf5LfIoex6Wj8drNLwHi8eV9xvkd2b3jdmDQ6guni/WIZy3miigeAxiFR5YRfGddeNlRZa91sl+2p3w+Ozk/umXSdzLCOshFhbTRGgm3Lk403Rxu58lIAEJSEACEpCABCQgAQlI4P8JPKV6DZBIiAB1nKIsjOHthHcG3iCEtRUnWYjOPaGKDB5fNESBvffeO4eTMgbZl7/85fxH2BTCxWqrrZamTZtW6VnEZAJYJ95snexTzFcnnxF5CM1klljGR2OMNTyLuF5EmVZCZyfpl/dpNvtj7BcCZnwvLpl5ktlfETURQZlFlhBexDJmysQTkdlQyx34osjRbgD9qBN4UP3pT39qTAhQzMegP/fDqJO8FXnEwPfNjkMkXWihhfIEFoMQYpudt7werze8MvF2/MAHPtAoY+5VxmjDQjgvH8sYdcw2jGCLgI4QhMg8kVYsg17rZD/tTng5jkf4cJwjzjmR3D23BCQgAQlIQAISkIAEJCCBUSYwLh5vgwSE58Waa66ZTxFCW5wvvhMmWRZ22Oetb31rDuHEeyy8bvAmIQzu4x//eNpoo42ycBAzL0a64XHSTmxh/0GOf8TMoIgSEYLG+aquk/UTZXTcP/OZz+RZTxHaEIXwSrvnnnvy4P+M14UnXIwFF/nEsykMYa3VX+zHMsbBKq6bDJ+jznEtEQbY6rpin/BcarXvoLYxfiPljRjK7KZh3/72t3OYKXmMMOHYRt346Ec/mifpYHIIxoHDww3RDQGf+vTCF74wdh/XZV11std2J0SwEMUGefFxjphkYZDnMm0JSEACEpCABCQgAQlIQAKTmcC4eLwNGiBeM1deeeWY2U3xsmIiAqzZ+GRswwMF7zE8cvCuYdZBhAHGxiKMjQkM6HB/+MMfZvdseBwhaDCTajsrhsW127eT7TE21CWXXJJ+8IMfNA5hNtB3vetd2YOssXJIPiC+bLjhhvkPkZAxv8j7V77ylTwbKp5wTEzA5AiLLrpoznVRXPnc5z43y8QcQ3Jp45aNIg/qVIT3NstA1E3GwJsoY5ZhxFbGpkMEX2655XJWQhBHMI8xACOPp59+evr617+ev8YYi4zxSBh6hJwjhBcnSolj61qGB2U5vWIZ9Fsne2l3wns2PG7L+avze5wjzlln2qYlAQlIQAISkIAEJCABCUhgKhEYeY83CovQUDrFdJhjdtPo3DPwf3Ew9maFi6cY4Y+bbrppDoWkYx3HIeo99NBDjUOjAx6d08aGig8IgHUYnlxnz5ylktlMmeUU4Yo8M4bapz71qfTZz342zxyKyDXMhpcTYby77757uvTSS9POO++cs8sA7oxdF1YMl8U7bqpbkUe7eod3XHi6hZA5UfxikgXCTbk///73vzcmfKgKM73mmmtyVgk/ZjIRQpG5D0N0Y2PRw7Ob6yqGvLdKo5lYXiyDuupkN+1OjO1H/mKcyW6uv5t9Q9Qvh+h3k4b7SkACEpCABCQgAQlIQAISkEBKw63SdFFC0Ym/7rrr8lGxjPVdJJV3XWyxxcbMWFoc36k4mP/3v//9pknff//9jZk5m+7UZsOdd96ZDj300DzLIyGbeDIx4DnhahdccEEeMw3PoFE0roMw0xizrChS4mkTg7oj2vRrCD6jYM3yWeSBENzKrrjiisbm4ozAjZUdfmiWlw4Pz7vhmYZoRr1lApSYzRTxGsG8aIhh4anHpAvNROSf/OQnxcM6/lz0EuTebGaML1dlxTKoo05WnaNVu8NkLhH6GcJYVRr9risKeyH29Zumx0tAAhKQgAQkIAEJSEACEpiqBCaN8BbjuNEpJ7SNMFOEnbXXXruybHfddde07rrrZuGnmfdLcT0d4jC84kIUOvXUUysHfX/iiSfSSSedlFj2YnT+GcB9xx13zCGZhNc961nPStttt12eGZTQV8LVhtluuummzBjOeLdVGaGzeLthRcaU3dZbb53X48XIWF9V9vDDD6ctttgie9FRpmWLmSCZZKCZJ1P5mIn43i6fTGDx7ne/O2ft9ttvTyEsl/PKuH9MtoEx8yazaHZjkQ+OufXWW7s5tHLfeeedtxH+jBdqeKJWCeKMmRjjJhL2XWWPPfZY9oSr2tZuXdFjjclUqgzP1uBX3l5Hneyn3cE7LoSwOsqmfH3x/bbbbssfGVOumXBL+Xzxi18cuOdd5MmlBCQgAQlIQAISkIAEJCCBUSUwaYQ3xrLCg4ZwtoMOOiiXB2GYRSGhWEh41CCsIdAdeOCBCcEOEQjD8+qiiy7KkwLwnXRjYHO+43XChAwYkwIwuyjCEOkxCDzjxE2fPj3hFdPrGEl4B8WEA3gH7bXXXllw22mnndKCCy6Yzz3s/xAJKA+4HH/88XnW2AjZRWxjZst99tknT4iAqFAet2vLLbfMs3NynexH+C+zt2J4RsE3Zk1l3bbbbstijBXFlmOPPTYhKpCfXgXRMYnX+KWTfMIjvAOZgAAPSMbHY0ICREVmAd1+++0TA+PDc4899ug6h9StEJVnzJiR7wNY9+P9FiIbYhdjJ5K3WFfMIOvDCw5hkVBTBGjqEPcV3nI77LBDDqNFBOvWmOhk1VVXzYfdeOON2VuUe526AL9rr70282NsumbWb53sp90hT9OmTctZu/nmm/MEFflLzf9ijL111lmncrIWwmy32mqrHJJPfUMM1SQgAQlIQAISkIAEJCABCUigmsCkmFwhLo3xpBC9YmbLqs597Is3FWIbEykgAPGH4IDHTYg77IsgcuSRR8ZhjSWeZ3hR4cGD+MHkDAgH/CGEYIhk88wzT/Z8axzYxQfGp6ODy8yPzcLuukhu3HfF2+noo49Oe+65Z/rXv/6VDj/88JwHxCMEuOJssQiVK6200pg8xvEIo4xrdsopp+Q/ygkhJgzmCJOrrLJKrGosmVnzrLPOymIbYgt/2Kc//emGyNPYeQI/dJJPJiKAJ6Ibs9mePXPMP/6oG1HnuAT4wJz604shKp977rlZ4EIw5Y9JEvDg7MUYJwwBOsI743tVWgisiDncw4RS80eoKuWNALfQQgslvEzxHIuZN6vSabaOSTwQXx9//PEsZF922WVjdiWM/JOf/GR629veNmZ9fOm3Tvbb7iBOMwMz9w9CJGPg1Wm0ZYh6CJuEgVcZHpdhjCeIh3FZNI/tLiUgAQlIQAISkIAEJCABCUx1ApPG442CpBOK0IXhoRbeLXlF6R+he0cccUT2pApvIzr3Ibrh1bbLLrtkYaPo7RbJ0AE/7LDDsmdbzByJMIAtvfTSae+9985hobF/t8sNNtggMcMjHi6jKLrF9eL1duaZZyaEJZhjhEMiunFdiGWnnXZaDheNY4rLZZZZJs92yph2CA5YiG4cjyiJEEP4b5XhwXXiiSemlVdeOVFmw2qd5nOppZbKQiLiWIxZFqIbE1dQ55kdlvrTqxHejGiMyIWoicWylzQ5tjizcEy4UJUW13TGGWfkEPE4Jx5VCOJrrLFGFkxj0pOq49utY5w0+OBZF+lzDHWL9uO4445LeMa1sn7qZL/tDsdvsskmOXtXXXVVq2z2tA2vUoxzMJNsla211lpjZhluNiZe1bGuk4AEJCABCUhAAhKQgAQkMNUIzDZTLPp/tajiymOsnxhXqGKXoVqFmIOXGx11hIkPfvCDHefvz3/+cxaECDsjtLNKbGuVGLNIMgEDHjMRqsf+jBcVnkJ4xw2z+NPq+urYRvkQtoi4ibCJF1S3IYN4OcGZ8unleMoZwa6duFLH9faTRqf5JGwW7zdEkhDi+jlv+VjKjLrN+IIhnJb3GdR3vNIoawQy7quiUFbHORFwYUddiJmKe0m3nzrZS7uDN+A73vGO3M6dd955Y0SwXvIfx3BvbrbZZpkz47c1E95if9qzAw44IDHeJMK4JgEJSEACEpCABCQgAQlIYKoSaKWfTapQU8aFQnSjg94sVKxZJUBY4K9XYyy5XkP7ej3nqB2HyIbA0Y/IgWDHX6/WTxn3es5ejus0n3i5DbLeUWbhadjLdfRzDN6rSy65ZD9JtDwWgRzvtX6tnzrZS7uD6MxYd3hy4u1J+HEdxriWvHjgpUU70Y3z8cMyxxxz5DDkOs5vGhKQgAQkIAEJSEACEpCABCYjgUkTaornCCFqGOF2ixVmIZ2MBec1SUACU5cAnmnMasyYhUzE0q/hOXnFFVe0HNstzkFo89kzxxa88sor08Ybb9yXkB5pupSABCQgAQlIQAISkIAEJDBZCYy8xxthnL///e/zgOAM4M8A9IzNpklAAhKYrAQI+2VsRCY3qCNsGs9GxDSW7bzd8LTDO45x+5hURpOABCQgAQlIQAISkIAEJCCB5gRGXni7+OKLc3gUl0joGOMNDTI8rTlKt0hAAhIYPwKEt/NXhxHW22kIOJPHMMMws9NqEpCABCQgAQlIQAISkIAEJNCawMgLb+985zvzmG50Gpnhsp/xv1qj6m0rs0uuvvrq+eCYcbW3lDxKAhKQwMQTYAIbTQISkIAEJCABCUhAAhKQgAQ6IzDywtvuu+/e2ZVO0F51eqVM0CV4WglIQAISkIAEJCABCUhAAhKQgAQkIIEeCEyayRV6uHYPkYAEJCABCUhAAhKQgAQkIAEJSEACEpDAwAgovA0MrQlLQAISkIAEJCABCUhAAhKQgAQkIAEJTGUCCm9TufS9dglIQAISkIAEJCABCUhAAhKQgAQkIIGBEVB4GxhaE5aABCQgAQlIQAISkIAEJCABCUhAAhKYygQU3qZy6XvtEpCABCQgAQlIQAISkIAEJCABCUhAAgMjoPA2MLQmLAEJSEACEpCABCQgAQlIQAISkIAEJDCVCSi8TeXS99olIAEJSEACEpCABCQgAQlIQAISkIAEBkZA4W1gaE1YAhKQgAQkIAEJSEACEpCABCQgAQlIYCoTUHibyqXvtUtAAhKQgAQkIAEJSEACEpCABCQgAQkMjIDC28DQmrAEJCABCUhAAhKQgAQkIAEJSEACEpDAVCag8DaVS99rl4AEJCABCUhAAhKQgAQkIAEJSEACEhgYgTk7Sfm2227rZDf3kYAEJCABCUhAAhKQgAQkIAEJSEACEpCABP5HQI83q4IEJCABCUhAAhKQgAQkIAEJSEACEpCABAZAoCOPtxVXXHEApzZJCUhAAhKQgAQkIAEJSEACEpCABCQgAQmMNoFWkaJ6vI122Zp7CUhAAhKQgAQkIAEJSEACEpCABCQggSEloPA2pAVjtiQgAQlIQAISkIAEJCABCUhAAhKQgARGm4DC22iXn7mXgAQkIAEJSEACEpCABCQgAQlIQAISGFICCm9DWjBmSwISkIAEJCABCUhAAhKQgAQkIAEJSGC0CSi8jXb5mXsJSEACEpCABCQgAQlIQAISkIAEJCCBISWg8DakBWO2JCABCUhAAhKQgAQkIAEJSEACEpCABEabgMLbaJefuZeABCQgAQlIQAISkIAEJCABCUhAAhIYUgIKb0NaMGZLAhKQgAQkIAEJSEACEpCABCQgAQlIYLQJKLyNdvmZewlIQAISkIAEJCABCUhAAhKQgAQkIIEhJaDwNqQFY7YkIAEJSEACEpCABCQgAQlIQAISkIAERpuAwttol5+5l4AEJCABCUhAAhKQgAQkIAEJSEACEhhSAgpvQ1owZksCEpCABCQgAQlIQAISkIAEJCABCUhgtAkovI12+Zl7CUhAAhKQgAQkIAEJSEACEpCABCQggSEloPA2pAVjtiQgAQlIQAISkIAEJCABCUhAAhKQgARGm4DC22iXn7mXgAQkIAEJSEACEpCABCQgAQlIQAISGFICCm9DWjBmSwISkIAEJCABCUhAAhKQgAQkIAEJSGC0CSi8jXb5mXsJSEACEpCABCQgAQlIQAISkIAEJCCBISUwx8EzrVne7r///rxpkUUWabbLUK0/9dRT04033pieeOKJ9JKXvGRM3mbMmJEuvfTSdMcdd6SVVlppzDa/DB+BG264IR1zzDHpkUceScstt1zPGWxVJ3pO1AMzgbruKctoaleo22+/PV144YXpO9/5Tlp55ZXT7LM/9T6ornZgahP26rslUFe9m8i27dFHH83PQnPPPXe3lz9m/4ceeij997//Tf2mMybRKfgFhg8++GCab7750myzzTahBHiuevLJJ9Ncc801ofno5eQ83//lL39J8/4fe+cBb0dVve1N0dCbhGogCKEJojTphECw0DHU0FvIFwKSgIRepAQVAgktgCQkFCEghhZaBAImKoSi0kGQKi2KNAGVL8/mvw77zp2ZMzNn5t5z7n3X73fvOWfqnmdm9uz9zlprzzNPkdXbrNNsHJqtPG1gFfxRVjux4O47dLXPPvvMjR492rdl5ptvPrfUUkt16P61MxEQgeYgkKafzd0cRSynFJMnT3bvvfeebyBuuummbTZK527SpElu0UUXdYMGDWozTz+aiwAPr7POOss3rh555BG34YYbum984xuFCpl2TRTaoFaqESjrntI5qiEt7cuDDz7opkyZ4pZYYgl3xBFHlLbdKjb03HPP+bqZbQ8ePNjNPfcXj6Uy64Eqyq1tdk0CZV53HV238bwcP368e/755x3CG/a1r33NrbXWWv7eWnbZZeueNASiO+64w91www3ub3/7m/v444/9OosssohbddVV3YEHHui++c1v1t2OLfDiiy+6K6+80sF1mWWWcUOGDLFZmT8nTJjgnnnmmdryBx10kFthhRVqv/nC8f785z9vMy3Lj0022cT94Ac/qLtoljJEN/LJJ5/4Y+elAhz4TYccjmuvvbbbe++9Y8WvKo7lrrvucr/73e/cX/7yF2edAtrDa665poPnSiutFC1+ZUzzXhNcgxMnTnS0OZ588knPkWuZl7LbbLONZ9mu8AkTinAIN3XRRRe51157LZyU+H2VVVZx++yzT+J8ZjRSntNOO82z2H333f15TN1RJ80sq53YScXPtVvqOPqZGM4f1LsyERABEQgJdCnhLTwwfW9dAryFpUHIW0373rpHo5KLQMcTeOWVV9y9997rG3/NLrwl0bF7v8p6YMaMGQ5W1Df9+/dPKoqmdyMCHXHdlY2TDt+ZZ57p7rzzznabxmPtt7/9rY8GGDp0qBswYEC7ZWwCHjc//vGPHWJ41BCDEJD422677dyIESPqem4RZTBmzBgvDrC9Pn365BbeHn74YYfnYGg/+tGP2glviDPUeXkti1dK1jKE+37sscfcGWec0U6k+eijjxwCKX+8IOG8RctQ5rEgpJ5//vk1QSAsI+cbjyQiRfbdd193yCGHhLO96Fo207zXBC/Thw0b5p566qk2ZUP84u/uu+92J510kttqq63azI/+aIRDuC329+abb4aTEr//+9//TpxXRnnwzOVa2WKLLZpWeEsE0MEzaEfwQgFDbOclgEwEREAEOpqAhLeOJq79ZSIwatQo36Ai9IxOsUwERKD7Eai6Hrj99tvd1KlTHZ4JEt663/WVdMRVX3dJ+y06HWHKRLfvfOc7Dg8YPC4++OADL/CMGzfOd9DPO+887z2Ot1XU/vvf/7oTTjihJroRNbDrrru65ZZbziEg4HF2xRVXuJdeesndcsstvuOKWBNniCUISgg6jRiiAt7v2EILLeRfxiVtjxDO733ve0mz20z/9NNPayLdXHPN1WZe9EeeMti6r7/+uhs+fHjNW3Drrbd2/fr18+fk73//u/vjH//orrvuOvf000+7/fff3wuLYXqUso6FsMzjjz++dh7WWGONmkhD2CsecPwhquIpueSSS7oddtjBDsOHxZbFtMg1Qbn+3//7f/6ao1AIvhtvvLEvJ2Lob37zGy++kTEHb0K83+KsUQ62TcJzZ82a5X+uv/76ddumCM1xVlZ54ratafEEOG/Ufxiim4S3eE6aKgIiUC0BCW/V8tXWCxLgDTBhGDIREIHuS0D1QPc995155K103ZG39le/+pXHte2227pjjz22jSfa6quv7jbYYAN3wAEH+JxvCGKEkUYNAfrRRx/1k/fYYw+Hd1xovXr1cptttpkPSySU9bLLLnM777yzW3DBBcPFHIIIIXAIO+QyQ7ybOXOmD39ts2CGHxdffLEPiyQ88/DDD3enn3564lqEwp588smJ88MZN910kxfeyCdZL8w0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y1qP0XXJFcK9sNlmmyUm4y9rf3m3Q45G80glaTBllbU2ARITMxIbyb27WqL71j4zX5S+2euErsBYxyACIiACIiACIiACIiACZRNIG1yhQ4S3sg9I2xMBERABERABERABERABERABERABERABERCBZiCQJrzN2QwFVBlEQAREQAREQAREQAREQAREQAREQAREQAREoKsRkPDW1c6ojkcEREAEREAEREAEREAEREAEREAEREAERKApCEh4a4rToEKIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAh0NQIS3rraGdXxiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAINAUBCW9NcRpUCBEQAREQAREQAREQAREQAREQAREQAREQga5GQMJbVzujOh4REAEREAEREAEREAEREAEREAEREAEREIGmICDhrSlOgwohAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiLQ1QhIeOtqZ1THIwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0BQEJLw1xWlQIURABERABERABERABERABERABERABERABLoaAQlvXe2M6nhEQAREQAREQAREQAREQAREQAREQAREQASagoCEt6Y4DSqECIiACIiACIiACIiACIiACIiACIiACIhAVyMwd5YDeuSRR7IspmVEQAREQAREQAREQAREQAREQAREQAREQAREQAT+j4A83nQpiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEAFBDJ5vK299toV7FqbFAEREAEREAEREAEREAEREAEREAEREAEREIHWJpAWKSqPt9Y+tyq9CIiACIiACIiACIiACIiACIiACIiACIhAkxKQ8NakJ0bFEgEREAEREAEREAEREAEREAEREAEREAERaG0CEt5a+/yp9CIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAk1KQMJbk54YFUsEREAEREAEREAEREAEREAEREAEREAERKC1CUh4a+3zp9KLgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAg0KQEJb016YlQsERABERABERABERABERABERABERABERCB1iYg4a21z59KLwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0KQEJLw16YlRsURABERABERABERABERABERABERABERABFqbgIS31j5/Kr0IiIAIiIAIiIAIiIAIiIAIiIAIiIAIiECTEpDw1qQnRsUSAREQAREQAREQAREQAREQAREQAREQARFobQIS3lr7/Kn0IiACIiACIiACIiACIiACIiACIiACIiACTUpAwluTnhgVSwREQAREQAREQAREQAREQAREQAREQAREoLUJSHhr7fOn0ouACIiACIiACIiACIiACIiACIiACIiACDQpAQlvTXpiVCwREAEREAEREAEREAEREAEREAEREAEREIHWJjB3axdfpRcBERCB7knglVdecW+99ZZbZpll3NJLL10qhA8++MA988wzbt5553Wrr756qdvWxkRABERABERABERABERABESgOxGQ8NadzraOVQREoEsQ+Pjjj93QoUPdO++84yZOnFj6MX3lK19xJ554ovvXv/7lrr32WterV6/S96ENioAIiIAIiIAIiIAIiIAIiEB3IKBQ0+5wlnWMIiACXYrAhAkTvLfbD37wA7fCCiuUfmw9evRwu+yyi/vf//7nxo0bV/r2tUEREAEREAEREAEREAEREAER6C4EJLx14pmeNm2aGzVqlBs7dmynleL99993I0eOdMccc4x78cUXO60czbxjMWrms9O2bJ999pm/p7ivHn/88bYzu8iv119/3V1zzTUOr7SDDz4411H985//dISRZrGdd97ZzTPPPO6uu+5yhLXKREAEREAEREAEREAEREAEREAE8hNQqGl+ZqWtgTAwadIkt+iii7pBgwaVtt08G7r11lvdzTff7FeZe+653RlnnJFn9W6xrBi1zmlGeOOewpZffnm31lprtU7hM5b0hhtucBznlltu6ZZYYom6az3yyCNu/Pjx7vnnn3cIb9jXvvY1z2bw4MFu2WWXjd3Gwgsv7LbbbjvPE6+3k046KXY5TRQBERABERABERABERABERABEUgmII+3ZDbdYk7Pnj1rxxl+r01s8S8zZsxw119/vbv77rsLH0nIJfxeeIMxK5ZRzpjN5p5ETi948Ydnlay5CPz73/92t912my/UNttsk1o4xLlTTz3VHXbYYe7hhx+uiW6s9O6777rf/va3bs8993QIeUm22267uTnnnFNeb0mANF0EREAEREAEREAEREAEREAE6hCQx1sdQF19dr9+/RyebrNmzXLki+pqdvvtt7upU6e6VVZZxfXv37/Q4XUEozLKWejgIitxHZx33nl+KqNl8idrHgL33HOP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+WYNCWcwGUYcZrRamQiIgAiIgAiIgAiIgAiIgAiIQFsCLS+87bbbbj6nG51ERrhsJP9XWzTl/GJ0yY033thvzEZcLWfL2ooIiIAIdD4BBrSRiYAIiIAIiIAIiIAIiIAIiIAIxBNoeeFtyJAh8UfWJFOr9EppkkNUMURABERABERABERABERABERABERABERABGIIdJnBFWKOTZNEQAREQAREQAREQAREQAREQAREQAREQAREoNMISHjrNPTasQiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQFcmIOGtK59dHZsIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiECnEZDw1mnotWMREAEREAEREAEREAEREAEREAEREAEREIGuTEDCW1c+uzo2ERABERABERABERABERABERABERABERCBTiMg4a3T0GvHIiACIiACIiACIiACIiACIiACIiACIiACXZmAhLeufHZ1bCIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAp1GQMJbp6HXjkVABERABERABERABERABERABERABERABLoyAQlvXfns6thEQAREQAREQAREQAREQAREQAREQAREQAQ6jYCEt05Drx2LgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAh0ZQJzd+WD07GJgAiIQFcl8Morr7i33nrLLbPMMm7ppZcu/TA/+OAD98wzz7h5553Xrb766qVvXxsUAREQAREQAREQAREQAREQge5AQMJbdzjLOkYREIEuReDjjz92Q4cOde+8846bOHFiJcf2la98xZ144onuX//6l7v22mtdr169KtmPNioCIiACIiACIiACIiACIiACXZmAQk278tnVsYmACHRJAhMmTPDebj/4wQ/cCiusUMkx9ujRw+2yyy7uf//7nxs3blwl+9BGRUAEREAEREAEREAEREAERKCrE5Dw1olneNq0aW7UqFFu7NixnVaK999/340cOdIdc8wx7sUXX+y0cjTzjsWomc9O27J99tln/p7ivnr88cfbzuwiv15//XV3zTXXODzSDj744FxH9cknn7g333zTi2lZVtx5553dPPPM4+666y5HaKtMBERABERABERABERABERABEQgHwGFmubjVerSCAOTJk1yiy66qBs0aFCp2866sVtvvdXdfPPNfvG5557bnXHGGVlX7TbLiVHrnGqEN+4pbPnll3drrbVW6xQ+Y0lvuOEGx3FuueWWbokllqi71t/+9jd36aWXuieffNJ7yX3++edetPv617/u+vfv7wYOHOh/x21o4YUXdtttt51nitfbSSedFLeYpomACIiACIiACIiACIiACIiACCQQkMdbApjuMrlnz561Qw2/1ya2+JcZM2a466+/3t19992FjyTkEn4vvMGYFcsoZ8xmc08inxe8+MOzStZcBP7973+72267zRdqm222qVu4yy+/3O29997u3nvv9Z5uiG4Ywh0erghyzE/zZtttt93cnHPOKa+3urS1gAiIgAiIgAiIgAiIgAiIgAi0JyCPt/ZMutWUfv36OTzdZs2a5cgX1dXs9ttvd1OnTnWrrLKK9+4pcnwdwaiMchY5tug6XAfnnXeen8xomfzJmofAPffc4wh9RgBef/31UwvGNXXFFVf4ZcgDh2dbnz59fOgoXnAMmPDoo4+6l19+2Z188slehKMuiBrXAPcA+77yyivdCSecEF1Ev0VABERABERABERABERABERABBIIyOMtAUx3mYwnS9++fR25nOadd97ucti5jlOMcuHSwhUSeOCBB/zWN9xwQ++FlrSr9957z/3iF7/wswm3RTD74Q9/6IU3RifdZJNN3IUXXui+973v+WWefvppN2XKlKTNuc0339zPu//++zPnh0vcmGaIgAiIgAiIgAiIgAiIgAiIQDciIOGtG51sHaoIiEDrEmB0UTzUsHXWWSf1QB5++GFHWCp29NFHe6/WuBUOP/zw2uQnnnii9j365Tvf+Y6f9OGHH7pnnnkmOlu/RUAEREAEREAEREAEREAEREAEEgi0jytKWLDIZLwzyBO13HLLOTw0yCv0pz/9yT300EM+tJFQKf4WWmih2ubpXD711FNu5syZ7rnnnnNLLrmkW3311d0WW2zh5phjjtpyeGjYqIVbb721H6CgNjPy5a233vI5jpi8wQYb+KTr4SLkOnrwwQfdq6++6j744AO31FJLec8QkpczcmCaffzxx76slJk8SZR13XXXdSuuuKIvL2Fc5O/CBgwY4Oaaa660zdXmUaYFF1zQLb744rVpVXzheC1n1MYbb+xIuG4WPX///e9/Hdwfe+wx/0m4GyFsJGhn5MM049z/9re/dc8//7y/JhZYYAG39NJLe08atlHPCIHkfD/77LOeM+UkbG7ttddud+4JxSPMDoM/9o9//MNdd911/jv/OLdZ2VbFqJFy/vOf//Tn4YUXXnAvvfSSP5aVVlrJffOb33S9e/euHWfWL1yjsHr33Xdrq3BPvPbaa/439yGekVnsxhtvdP/5z38cnlUbbbRR6iqMlsm5IYn/97///TbLUhZy81EGvi+22GJu2WWX9d5abDuvhffitttu6+aff/7YTZDnzry/Nt1008Rw2zzXZNyO8tY7XPtcixjXfZpRL1F27stvfOMbiYsysMvXvvY1z/fvf/974nKw57riWqNuXm211RKX1QwREAEREAEREAEREAEREAEREIEvCVQqvDEaJOLNVltt5UcXPPjgg31Cb9s988kpRE4pOpIIEUOGDPHijC1jn9/+9rfdWWed5TvoTCP87/zzz7fZjgTgScZ+SDLOOgguZniE/PznP3d33nlnbPgUoVjHHHOM7+jbOuEnHfkRI0b4zqhNJw8StsYaa/jjQjy0cu6www6ZhTc6t6NHj/ai1h577OEQVaowQtKsfIgrofAWnj/Oz2GHHebivGImTJjgRztcc801Y4uIqEPY2xtvvNFu/mWXXeYFHUZL7NGjR7v5TLjvvvvcmWeeWRMdwoUQbMg5hWhohpBjx2TTEF/Daauuumpm4a0qRkXLCY+RI0c6BKKoIU7vueee7pBDDqkrGofrIjTZtWvTbbRbfuNh1Tej8PbHP/7R3/cIOpMnT04MiUREYhRdRFnuXxPeEN85V7/5zW/8PCuPfV588cVup512cnhrZRWyWTe8FzfbbLNE4Q2Rz64VBL64PHd5r0krO59F6x0Eb4wywTbNEBb5q2eUhesQqydmUgcjvCGA77XXXu02jUDKy4LwRUq7hTRBBERABERABERABERABERABLoZgUqFN2NJR5rk3Xi/kSuIjiwduN///vfeM+b44493Y8aMcWeffbb761//6r3S8ILCo4RlED7odNLhRujCVl55Ze9VhscPnlRpwhvzMTzRzMuJMp1yyilu2rRpfh5eed/97nd90nI6luyPDjhloxNOpzM0PL+GDh3qCL3C8AbB2wghEe+3v/zlL2748OEuy8iD4XbD73gNIYjwh2cggkq9hOrh+mV9h9Wpp57qnnzySS+Q4s2HRw3HyHmkw33cccd5j7L55puvzW5Z5thjj3WffvqpzyFHyBoiHt41hM1x/hhxEQHgnHPOabMuPxBMLUE83jkcP55yeCfatUEo3bBhw7xHIevgyWTcH3nkES/4IdCR18qMbZVpRRgVKecll1ziEDoxcvIh8OLR9Oabb/rzg8B49dVXe6+ksWPHZhbfOC8In4jfdk9wvyDGYlzfWY1BOhDcuX/+/Oc/e9E9bl2WQXTDyD9mdtppp/kRNPmNpxX3FceIQDR9+nT3zjvvuEmTJnmR56CDDrLVOuyzyDVphWuk3uHcYnjklmW//vWvay8d8BxOM9sv11rUxo8f7wdnwEN41KhRdT3youvrtwiIgAiIgAiIgAiIgAiIgAh0VQIdIrwhfNGBR0AJwwoRRY444ggvrO2zzz4O0QYvM5KBmxFSN3jwYMcofLfccov3uiJMEaOzjmCHuEOndIkllrDVap8IQ4h5WDhqJ8KaCQxHHnmk22WXXWrr4M3B/g444AAvME2cOLGd8HbBBRd40Q0vOrz08EoLjRA6PPSK5kPCSxDB8aabbvICJF5E/CF6sS/CO+uFwYblaeQ752+RRRbxrMMQN0QEzhejIyKy/OpXv/LMwn0hliK6IWwiBCGAhQYjzitecQiWYQgboXh06DFEMzzbQm8aBACm4YXHtmFGOfEGQjDFTjzxRC+8IRrYND+j5H9FGOUtJyLlVVdd5UvOKK14ASJCmiFinXvuud7LDGGY0No4zyRbPvzEg4w/7he7L3bdddc2YmW4fNp3vA85T3jkwSW8n8P1mIdxTRM2jHGvcu9giKwcD/eY2SeffOLF9z/84Q/+2vjRj37ULtTYlq3is+g1aWVppN4xzzSu8UYNUZ/rg/sGr0HquiSPVduXidVWDpvOJyMHY1yDXD9hPeFn6J8IiIAIiIAIiIAIiIAIiIAIdFMCX/ZoKwbwk5/8pI3oxu7onNmoevwmPC7aSaeTud9++zHbff755z6/l/8x+x8eGnTKmY7XVJxZ5x5Rz0bmYznEOoxO54477ui/h/+WX35574GFKEeupNBIXI5oiOFpFxXdmE7ZWBdPriLGcR944IFeeEMwslBTxJfTTz/dITggCOKh1BFGmGm0Mw37Qw891HsJUoZoGCrCHF5yGCG+UdGN6Xiq8QeraNggoh7bQDTD4y4U3VgXMZfpX/3qV70IysiNnWlFGOUpL6HH8MDTDa+iUHRjOwixhEavt956frOIlnEiSZ59FlmWciCCYtyX3J9RI8wUIRkLvd0IleUY+OM6D0U3lsUrj2sOgwXhox1pjV6TjdQ7vITAighvsOYlB3+IbNS7HAv1Ci9E9t9//7oYTXjjhUD0nFrdyj0chn3X3agWEAEREAEREAEREAEREAEREIEuTqBDhDcEEwZXiDO8XcySOmzhMmGYEx5DhIdiJrDZtuzTpjM4QzgAAOIFxoAB5uFj69gn4aV4wkWFOdsmgs/AgQNt8XafCApRcaTdQnUmIGIQNkl4IV52iICIEYTb4U1G2RBhCOOtyjhOy78V3QflIxQQI/wzNMrJuth9s/OSRTvrTEdIYdAJOBM+bIYwQ1ghhrBp58vm2ydhy+Trwgg97SwryihreRFYGZQE45yniS8mVH/00UedxsTENK5TBlSJGgM34B3FNRKGOOIRSy5E/syzNbou3pNmDGjSUVbGNWnXcZF6h/1jSVzSOOCRyvXDH96QhIpjeE5mFe9tv3jLRV8oEPKLxyveqyb8ppVH80RABERABERABERABERABESguxDoEOEtTNgfBUtONDPLv2a/7TPMGxYVbyx81MJNbR0+CReNCzNlHmFstu+f/vSnPsk73lnR7bNs1EzkQiQgB1WSsX3yZJVleJyRB48OLkIVnXg60OS7IiyQsMuo+FXGvjl/Uc+jcLuWBywu2b+JqYTo7b333t6DL0tHPxRUyGOWZjZqI+cFL6jOsEYYZSlvyCPqeRhdH69R8x4M14suV+VvRvfFaxQzoTrcn01DOK83UICth1iFt1UovjOtoyxkWfSabKTeMY/PLPdPlAkCG56C/CHMEqpOfcvgF3hqkqPR8lVG17Xfdn8jtpuAaPP4RBBNE4TDZfVdBERABERABERABERABERABLoLgS9VrwqP2ESAMnYRFcbwdsITA28QwtrCQRasc0+oIsnjQ0MUOOqoo3w4KTnIbrvtNv/HqHwIFxtttJHr27dvbEeSwQSwLN5sWZYJy5XlOyIPoZmMEouHCTnW8CzieBFl0oTOLNuPLsMgAGlmAmbcMow8yeiviJqIoIwiyyAKiGWMlIknIrmlCDEMLRQ56iXQt2sCD6q33367NiBAuL2qvzfCKEvZQh6W5D5pPUTSnj17+gEsqhBik/YbnY7XG16ZeDv++Mc/rp1j7lVytGEmnEfXxSuL0YYRbBHQEX3MSyu6bEf9Ds9B0WuykXrHRK0i4cPcbyZQGy/qPcLVf/nLX/pzxH3MwBZJZvu1ciQtp+kiIAIiIAIiIAIiIAIiIAIiIAJfEugQj7cvd1f+N0L8+vXr5zdsQpvtxX4TJhkVdlhm++239yGceI+Z1w3eJITB/exnP3PbbbedFw4QdEIzj5N6YgvrIORVZYwMiihhIWjsJ+44q9p/lu3SSb/00ku9Rw1CG6IQXmnPP/+8T+6OBw6ecJYLzraJZ5MZwlrany3Hp+XBCqd1he92zXEsFvKXdly2jHkppS1b1TzyiHG+EUMZ3dTsd7/7nQ8zpYwWJmzzuDZOOukkn4eM5P/kJsPDDdENAZ/radlll7XFO/SzrGuyaL1jgpcJYI0ePHUneSQtjPyee+5xzz77bOJmbb+W6y1xQc0QAREQAREQAREQAREQAREQARGoEegQj7fa3ir6gtfMzTff3GZ0U7ysGIgAs45l3O7xQMF7DI8cvGsYdRBhgHxhhLHhEUKHe8SIEbXV8ThC0GAk1XoWhsXVWzbLfMsNdcMNN7hHH320tgqjge65557eg6w2sUm+IL5su+22/g+RkJxflP2OO+7wo6HiCUe4G4Mj9OrVy5c6FFeuvvrqdgNzNMmhdVgxQh5cUxbem1QAuzbJgddZxijDiK3kFUME/9a3vuWLYoI4grnlALQyXnbZZQ4BCLMci+R4JCzSQs4Rwi2Zv61X5qd5UEa3GZ6DRq/JIvWOec+ax220fEV/Uz9yL2J4Goa5FsNt2n6tHOE8fRcBERABERABERABERABERABEYgn0PIebxwWoaF0iukw2+im1rkn8X+YjD0ewxeeYoRi7bzzzj4Uko61rYeoR3JyM+uAW0fUpsd9IgCWYXhyjZ89SiWjmTLKKcIV3m3kULvooot8uBgjhyJyNbPh5UQY75AhQ9yvf/1rN2jQIF9ckrWTu84sDJfFO667W8ij3nWHd5x5upmQ2Vn8bJAFwk25P8kjZoNgxIWZTpkyxReV8GMGEyEUmfvQRDdmhh6eeY4rDHlP20aSWB6eg7KuSe7hrPWO5fajfJZnMun477//fl8XWo7LpOWYjkBqRsh6kpnQHw3bT1pe00VABERABERABERABERABERABJxrbpUmxxmyTvzUqVP9WvZp03Nsyi/au3fvNiOWhvmdLFcSnd+HH344cdNvvPFGbWTOxIXqzHjqqad83iVGeSRkE08mkpsTrnbNNdf4nGl4BrWicRyEmVrOslCkxKvGErgj2jRq9RLHN7r9stZPKmfIAyE4zUiYbxaOCGzTsn4mlSXr+iyHZxqiGdctA6DYaKaI1wjmoSGGmacegy4kichPPPFEuFrm76GXIPdmkuH1FWfhOSjjmozbR1q9w2AuFuZpIljcNpiG9ygCPSMe17NQROzTp0/s4qHYZwJg7IKaKAIiIAIiIAIiIAIiIAIiIAIi0IZAlxHeLI8bnXJC2wgzRdjZaqut2hyw/Rg8eLDbeuutvfCT5P0STqdDbIZXnIlCl1xySWzS9//85z9uzJgxjs8iRuefBO7kYCIMjPC6hRde2I9IeNNNN/nQV8LVmtmmT5/uGcMZ77Y4I3QWbzcsZMy522uvvfx0vBjJ9RVns2bNcrvvvrv3ouOcRs1GgmSQgSRPpug6nfG7XjlJfL/PPvv4oj3++OPOhOVoWcn7x2AbGCNvMopmHrNysM7MmTPzrBq77DzzzFMLf8YL1TxR4wRxciZa3kTCvuPso48+8p5wcfPqTQs91hhMJc7wbDV+0fllXJON1Dt4x5noVe/c2HIIdDaQRfR4+E3uvCuuuMLPQuhMGq31kUce8cuQZy5OzP3kk0/c3Xff7b3skkJ1/Qb0TwREQAREQAREQAREQAREQAS6GYEuI7yRywoPGjp9J598sj+NhGGGQkJ4bvGoQVhDoDvxxBMdgh0iEIbn1fXXX+89zPjNdi2xOb/xOmFABoxBARhdFGGI7dGRJU/c0KFDHV4xRfMh4R1kAw7gHTR8+HCH4HbIIYe4xRZbzO+72f/R+ed8wOW8887zo8ZayC5iG4LA0Ucf7QdEQFSI5u3aY489/OicHCfLEf5roXB4RsHXRk1lmX333ZePNhaKLeeee65DQKA8RQXRNhsv8UeWcsLDvAMZgAAPSEIJGZAAUZFRQPfff39HEnx4HnHEEblLyLVlovK0adP8fQDrRrzfTGRD7CLMlLLZtLCATDcvOIRFQk0RoLmGuK/wljvggAN8GC0iWF5joJMNN9zQr/bAAw94b1Huda4F+N11112eXxh6Gd1Ho9dkI/UOZenbt68v0owZM7wY73/E/KN+op7i2jjuuOP8vQPD0BDlCPl+6aWX/GREQfOoC5fju+Xd69+/f+wALtS5/OFlh7edTAREQAREQAREQAREQAREQARE4AsCXWJwBTuZ5JNC9LKRLeM697Ys3lSIbQykgADEH4IDHjcm7rAsgshZZ51lq9U+99tvP4cXFR48iB8MzoBwwB+dXQyRrEePHt7zrbZiji/kpxs4cKAf+TEp7C7H5jp8Ubydzj77bDds2DD36aefujPOOMOXAfEIAS4cLRahct11121TRlsfYZS8ZhdeeKH/4zyFIgLMESY32GCDNuvzg5E1x40b58U2xBb+sIsvvrgm8vgJnfwvSzkZiACeiG6MZjt+ds4//rg27JrjMOADc66fIoZoM2HCBC9wIZjyxyAJeHAWMXKCIUBbeKf9jtsWAiviIfcwodT8EarK+UaA69mzp8PLFJHIRtmM207SNAbxQHzFQwshm7/QCCM/55xz3E477RROrn1v9JpstN5BnGYEZu4fhEhy4MUZYbUjR470LwBgx70zduxYPygHdRz3UyimbrPNNm1C68NtUr8h9CF2EhoeZwyYYkadSP0oEwEREAEREAEREAEREAEREAER6EI53jiZdEIRujA81My7xU+I/CN078wzz/SeVOZtRAfVRDc8Pw499FAvbITebrYZOuCnn36679jayJEIA9gqq6zijjrqqIY6n3SEGeERD5dWFN2ME15vhLIhLMEcIxwS0Y3jQixDECBcNM5WXXVV70FDTjsEB8xEN9bfbLPNvBBD+G+c4cE1evRot9566znOWbNa1nKSgwshEXHMcpaZ6MbAFVzzeBxx/RQ1wpsRjRG5EDUx+yyyTdYNRxa2ARfitsUxXX755T5E3PZJeCli0SabbOIFUxv0JG79etPIkwYfPOts+6zDtUX9QU40POPSrJFrstF6h/V33HFHX7xbbrklrZiOASquu+46P5ow9wqefQhuzz77bE10I2yUY8ZTLcnwNMXYL6PLxhmCnI1QixdxKKrHLa9pIiACIiACIiACIiACIiACItBdCMwxWyz6Qi2KOWLL62P5gmIWaapJdPbwcqOjjjBx5JFHZi7fe++95wUhOqeEdsaJbWkbYxRJBmDAY8ZC9ViefFHmKYQnSDOLP2nHV8Y8zg9hi4ibCJt4QeUNGcTLCc6cnyLrc54RIeqJK2UcbyPbyFpOwmbxfkMQMSGukf1G1+WccW2TX9CE0+gyVf3GK41zjUDGfRUKZWXsEwEXdlwLNlJxke02ck0WqXfwBtx11119PTdx4kSHmFjPWIdjxUuXa4aXDQiYHDf3Q5Jxvw4YMMCzv/HGGxOFN9bHgw7PX8J26w0AkrQ/TRcBERABERABERABERABERCBViSQpp91qVBT8kIhutFBTwoVSzqBCAv8FTVyyRUN7Su6z1ZbD5GNjn4jIgeCXVIeqiw8GjnHWbZf1jJZy4mXW5XXHefMPA3LOras28F7daWVVsq6eO7lEMjxXmvUGrkmi9Q7iM7kusOTk7Bbwo/rGevwZzn06i1v88l1ycsIXmQkebvZsgiljMKcFuJvy+pTBERABERABERABERABERABLoLgWRXhxYjgOcIIWoY4Xa9e/f23/VPBERABLoaAbzQGNWYnIUMxFKF4Rk3efLk1Nxutl/ywJFXEKGWUGWZCIiACIiACIiACIiACIiACIjAFwRa3uONMM7XX3/dJ/8mgT95hsjNJhMBERCBrkqAsF9yI77//vuVhU0joo2fPXgHn2nebrNmzfIDYjAIBl54NvJuV2Wv4xIBERABERABERABERABERCBPARaXnibNGmSD4XioAkdGzFiRKXhaXngalkREAERqIoA4e38VWWE+mYJCydHHINxbLfddpWWp6rj1HZFQAREQAREQAREQAREQAREoEoCLS+87bbbbj6nGx1ERrhsJP9XFaAZXXLjjTf2m7YRV6vYj7YpAiIgAp1BgNxxAwcO7Ixda58iIAIiIAIiIAIiIAIiIAIi0PQEWl54GzJkSFNDrtorpakPXoUTAREQAREQAREQAREQAREQAREQAREQgW5MoMsMrtCNz6EOXQREQAREQAREQAREQAREQAREQAREQAREoAkJSHhrwpOiIomACIiACIiACIiACIiACIiACIiACIiACLQ+AQlvrX8OdQQiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAJNSEDCWxOeFBVJBERABERABERABERABERABERABERABESg9QlIeGv9c6gjEAEREAEREAEREAEREAEREAEREAEREAERaEICEt6a8KSoSCIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAq1PQMJb659DHYEIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEATEpDw1oQnRUUSAREQAREQAREQAREQAREQAREQAREQARFofQIS3lr/HOoIREAEREAEREAEREAEREAEREAEREAEREAEmpCAhLcmPCkqkgiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQOsTkPDW+udQRyACIiACIiACIiACIiACIiACIiACIiACItCEBCS8NeFJUZFEQAREQAREQAREQAREQAREQAREQAREQARan4CEt9Y/hzoCERABERABERABERABERABERABERABERCBJiQwdxOWqdsUadq0aW7mzJluvvnmc4MGDeo2x20H+tlnn7kLLrjA/+zXr59ba621bJY+cxD49NNP3a233uqef/55984777iFF17YHX/88Tm2oEVFQAREQAREQAREQAREQAREQAREQASqICDhrQqqGbf5+OOPu0mTJrlFF1202wpvHD+2/PLLdxvh7YorrnAvvPCCO/zww92SSy6Z8WqJX+zNN990Q4YMca+//nptgbnmmkvCW42GvoiACIiACIiACIiACIiACIiACIhA5xGQ8NZ57LXnFiDwr3/9y91xxx2+pJtssolbZpllGi71M8884x544AF32GGHNbyt888/vya6rbLKKm6LLbZwiy22WMPbbfUNzJgxw73yyite1O7fv3+rH47KLwIiIAIiIAIiIAIiIAIiIAIi0KIEJLy16IlTsTuGwKxZs9x5553nd4boVkR4QwC67LLL3PDhw30Y6Pzzz++3t8ACC/jPKVOmuNdee80ddNBBuQ7q888/d9OnT/frrLPOOm7MmDG51u/KC99+++1u6tSpDjFSwltXPtM6NhEQAREQAREQAREQAREQARFobgIS3pr7/Kh0XYDAhAkT3D333OMeffRRHwJqwhs57sjFdu+997qvfOUrbsCAAW6RRRbJfMRvv/22I78bttlmm2VeTwuKgAiIgAiIgAiIgAiIgAiIgAiIgAh0DAEJbx3DWXvpxgSOOuoon8PuqquucsOGDXM9e/Z0c845p9t3333du+++6whhPfTQQ3OJbuD86KOPalSXXnrp2nd9EQEREAEREAEREAEREAEREAEREAERaA4ClQpv5LEi6ftyyy3nNtxwQ4eHz5/+9Cf30EMPOUL41l9/ff+30EIL1Wj873//c0899ZQf7fO5557zyedXX311n7tqjjnmqC339NNPOwYnwLbeemufy6k2M/Llrbfe8l5FTN5ggw28CBIu8uKLL7oHH3zQvfrqq+6DDz5wSy21lOvTp4/bcsstvSdSuGz0+8cff+zLSpkJKaSs6667rltxxRUd5X355Zcd+aYwPJpIfJ/FKNOCCy7o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" alt="img"></p><p>​ 图 1 row_id 用完的验证序列</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,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" alt="img"></p><p>​ 图 2 row_id 用完的效果验证</p><p>可以看到，在我用 gdb 将 dict_sys.row_id 设置为 248之后，再插入的 a&#x3D;2 的行会出现在表 t 的第一行，因为这个值的 row_id&#x3D;0。之后再插入的 a&#x3D;3 的行，由于 row_id&#x3D;1，就覆盖了之前 a&#x3D;1 的行，因为 a&#x3D;1 这一行的 row_id 也是 1。</p><p>从这个角度看，我们还是应该在 InnoDB 表中主动创建自增主键。因为，表自增 id 到达上限后，再插入数据时报主键冲突错误，是更能被接受的。</p><p>毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性；报主键冲突，是插入失败，影响的是可用性。而一般情况下，可靠性优先于可用性。</p><h2 id="Xid"><a href="#Xid" class="headerlink" title="Xid"></a>Xid</h2><p>在第 15 篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73161">《答疑文章（一）：日志和索引相关问题》</a>中，我和你介绍 redo log 和 binlog 相配合的时候，提到了它们有一个共同的字段叫作 Xid。它在 MySQL 中是用来对应事务的。</p><p>那么，Xid 在 MySQL 内部是怎么生成的呢？</p><p>MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。</p><p><strong>而 global_query_id 是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。</strong></p><p><strong>但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是唯一的。</strong></p><p>虽然 MySQL 重启不会导致同一个 binlog 里面出现两个相同的 Xid，但是如果 global_query_id 达到上限后，就会继续从 0 开始计数。从理论上讲，还是就会出现同一个 binlog 里面出现相同 Xid 的场景。</p><p>因为 global_query_id 定义的长度是 8 个字节，这个自增值的上限是 264-1。要出现这种情况，必须是下面这样的过程：</p><ol><li>执行一个事务，假设 Xid 是 A；</li><li>接下来执行 264次查询语句，让 global_query_id 回到 A；</li><li>再启动一个事务，这个事务的 Xid 也是 A。</li></ol><p>不过，264这个值太大了，大到你可以认为这个可能性只会存在于理论上。</p><h2 id="Innodb-trx-id"><a href="#Innodb-trx-id" class="headerlink" title="Innodb trx_id"></a>Innodb trx_id</h2><p>Xid 和 InnoDB 的 trx_id 是两个容易混淆的概念。</p><p>Xid 是由 server 层维护的。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。</p><p>其实，你应该非常熟悉这个 trx_id。它就是在我们在第 8 篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>中讲事务可见性时，用到的事务 id（transaction id）。</p><p>InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。</p><p>InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。</p><p>对于正在执行的事务，你可以从 information_schema.innodb_trx 表中看到事务的 trx_id。</p><p>我在上一篇文章的末尾留给你的思考题，就是关于从 innodb_trx 表里面查到的 trx_id 的。现在，我们一起来看一个事务现场：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20231020160346907.png" alt="image-20231020160346907" style="zoom:50%"><p>​ 图 3 事务的 trx_id</p><p>session B 里，我从 innodb_trx 表里查出的这两个字段，第二个字段 trx_mysql_thread_id 就是线程 id。显示线程 id，是为了说明这两次查询看到的事务对应的线程 id 都是 5，也就是 session A 所在的线程。</p><p>可以看到，T2 时刻显示的 trx_id 是一个很大的数；T4 时刻显示的 trx_id 是 1289，看上去是一个比较正常的数字。这是什么原因呢？</p><p>实际上，在 T1 时刻，session A 还没有涉及到更新，是一个只读事务。而对于只读事务，InnoDB 并不会分配 trx_id。也就是说：</p><ol><li>在 T1 时刻，trx_id 的值其实就是 0。而这个很大的数，只是显示用的。一会儿我会再和你说说这个数据的生成逻辑。</li><li>直到 session A 在 T3 时刻执行 insert 语句的时候，InnoDB 才真正分配了 trx_id。所以，T4 时刻，session B 查到的这个 trx_id 的值就是 1289。</li></ol><p>需要注意的是，除了显而易见的修改类语句外，如果在 select 语句后面加上 for update，这个事务也不是只读事务。</p><p>在上一篇文章的评论区，有同学提出，实验的时候发现不止加 1。这是因为：</p><ol><li>update 和 delete 语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到 purge 队列里等待后续物理删除，这个操作也会把 max_trx_id+1， 因此在一个事务中至少加 2；</li><li>InnoDB 的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可能看到，trx_id 值并不是按照加 1 递增的。</li></ol><p>那么，<strong>T2 时刻查到的这个很大的数字是怎么来的呢？</strong></p><p>其实，这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的 trx 变量的指针地址转成整数，再加上 2^48^。使用这个算法，就可以保证以下两点：</p><ol><li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在 innodb_trx 还是在 innodb_locks 表里，同一个只读事务查出来的 trx_id 就会是一样的。</li><li>如果有并行的多个只读事务，每个事务的 trx 变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的 trx_id 就是不同的。</li></ol><p>那么，<strong>为什么还要再加上 2^48^呢？</strong></p><p>在显示值里面加上 2^48^，目的是要保证只读事务显示的 trx_id 值比较大，正常情况下就会区别于读写事务的 id。但是，trx_id 跟 row_id 的逻辑类似，定义长度也是 8 个字节。因此，在理论上还是可能出现一个读写事务与一个只读事务显示的 trx_id 相同的情况。不过这个概率很低，并且也没有什么实质危害，可以不管它。</p><p>另一个问题是，<strong>只读事务不分配 trx_id，有什么好处呢？</strong></p><ul><li>一个好处是，这样做可以减小事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB 就只需要拷贝读写事务的 trx_id。</li><li>另一个好处是，可以减少 trx_id 的申请次数。在 InnoDB 里，即使你只是执行一个普通的 select 语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请 trx_id，就大大减少了并发事务申请 trx_id 的锁冲突。</li></ul><p>由于只读事务不分配 trx_id，一个自然而然的结果就是 trx_id 的增加速度变慢了。</p><p>但是，max_trx_id 会持久化存储，重启也不会重置为 0，那么从理论上讲，只要一个 MySQL 服务跑得足够久，就可能出现 max_trx_id 达到 2^48^-1 的上限，然后从 0 开始的情况。</p><p>当达到这个状态后，MySQL 就会持续出现一个脏读的 bug，我们来复现一下这个 bug。</p><p>首先我们需要把当前的 max_trx_id 先修改成 2^48^-1。注意：这个 case 里使用的是可重复读隔离级别。具体的操作流程如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image/MySQL(6)实战45讲笔记.assets/image-20231020160411108.png" alt="image-20231020160411108" style="zoom:50%"><p>​ 图 4 复现脏读</p><p>由于我们已经把系统的 max_trx_id 设置成了 2^48^-1，所以在 session A 启动的事务 TA 的低水位就是 248-1。</p><p>在 T2 时刻，session B 执行第一条 update 语句的事务 id 就是 2^48^-1，而第二条 update 语句的事务 id 就是 0 了，这条 update 语句执行后生成的数据版本上的 trx_id 就是 0。</p><p>在 T3 时刻，session A 执行 select 语句的时候，判断可见性发现，c&#x3D;3 这个数据版本的 trx_id，小于事务 TA 的低水位，因此认为这个数据可见。</p><p>但，这个是脏读。</p><p>由于低水位值会持续增加，而事务 id 从 0 开始计数，就导致了系统在这个时刻之后，所有的查询都会出现脏读的。</p><p>并且，MySQL 重启时 max_trx_id 也不会清 0，也就是说重启 MySQL，这个 bug 仍然存在。</p><p>那么，<strong>这个 bug 也是只存在于理论上吗？</strong></p><p>假设一个 MySQL 实例的 TPS 是每秒 50 万，持续这个压力的话，在 17.8 年后，就会出现这个情况。如果 TPS 更高，这个年限自然也就更短了。但是，从 MySQL 的真正开始流行到现在，恐怕都还没有实例跑到过这个上限。不过，这个 bug 是只要 MySQL 实例服务时间够长，就会必然出现的。</p><p>当然，这个例子更现实的意义是，可以加深我们对低水位和数据可见性的理解。你也可以借此机会再回顾下第 8 篇文章<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>中的相关内容。</p><h2 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h2><p>接下来，我们再看看线程 id（thread_id）。其实，线程 id 才是 MySQL 中最常见的一种自增 id。平时我们在查各种现场的时候，show processlist 里面的第一列，就是 thread_id。</p><p>thread_id 的逻辑很好理解：系统保存了一个全局变量 thread_id_counter，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量。</p><p>thread_id_counter 定义的大小是 4 个字节，因此达到 2^32^-1 后，它就会重置为 0，然后继续增加。但是，你不会在 show processlist 里看到两个相同的 thread_id。</p><p>这，是因为 MySQL 设计了一个唯一数组的逻辑，给新线程分配 thread_id 的时候，逻辑代码是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  new_id= thread_id_counter++;</span><br><span class="line">&#125; while (!thread_ids.insert_unique(new_id).second);</span><br></pre></td></tr></table></figure><p>这个代码逻辑简单而且实现优雅，相信你一看就能明白。</p><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>今天这篇文章，我给你介绍了 MySQL 不同的自增 id 达到上限以后的行为。数据库系统作为一个可能需要 7*24 小时全年无休的服务，考虑这些边界是非常有必要的。</p><p>每种自增 id 有各自的应用场景，在达到上限后的表现也不同：</p><ol><li>表的<strong>自增 id</strong> 达到上限后，<strong>再申请时它的值就不会改变</strong>，进而导致继续插入数据时报主键冲突的错误。</li><li><strong>row_id</strong> 达到上限后，<strong>则会归 0 再重新递增</strong>，如果出现相同的 row_id，后写的数据会覆盖之前的数据。</li><li>Xid 只需要不在同一个 binlog 文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。</li><li>InnoDB 的 <strong>max_trx_id</strong> 递增值每次 MySQL 重启都<strong>会被保存</strong>起来，所以我们文章中提到的脏读的例子就是一个必现的 bug，好在留给我们的时间还很充裕。</li><li>thread_id 是我们使用中最常见的，而且也是处理得最好的一个自增 id 逻辑了。</li></ol><p>当然，在 MySQL 里还有别的自增 id，比如 table_id、binlog 文件序号等，就留给你去验证和探索了。</p><p>不同的自增 id 有不同的上限值，上限值的大小取决于声明的类型长度。</p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/img/cover_default_img/07.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.webp" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.webp" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/Redis/" title="Redis安装和常见数据类型命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/05.webp" onerror='onerror=null,src="/img/404.webp"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis安装和常见数据类型命令</div></div></a></div><div class="next-post pull-right"><a href="/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/" title="MySQL(5)日志与备份篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/01.webp" onerror='onerror=null,src="/img/404.webp"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL(5)日志与备份篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/MySQL(5)%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/" title="MySQL(5)日志与备份篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/01.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">MySQL(5)日志与备份篇</div></div></a></div><div><a href="/blog/MySQL(4)%E4%BA%8B%E5%8A%A1%E7%AF%87/" title="MySQL(4)事务篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/01.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">MySQL(4)事务篇</div></div></a></div><div><a href="/blog/MySQL(3)%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E7%AF%87/" title="MySQL(3)索引和调优篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/05.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">MySQL(3)索引和调优篇</div></div></a></div><div><a href="/blog/MySQL(2)%E6%9E%B6%E6%9E%84%E7%AF%87/" title="MySQL(2)架构篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/04.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">MySQL(2)架构篇</div></div></a></div><div><a href="/blog/MySQL(1)%E5%9F%BA%E7%A1%80%E7%AF%87/" title="MySQL(1)基础篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/03.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">MySQL(1)基础篇</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">spongehah</div><div class="author-info__description">Java后端学习中，我的原创日常笔记将会分享在这里，还会转载一些觉得写的好的笔记，快来和我一起学习吧！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="http://47.115.207.49/"><i class="fas fa-home"></i><span>The another blog</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/spongehah" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="/spongehah@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到HahHome！<br>本站运行时间为本站搭建完成时间，站主第一个博客网站搭建时间为2022年11月25日<br>站主方向为Java后端，平时记录一些自己的学习笔记，也会转载一些觉得写的好的博客，站主会抽空定期更新的~~<br>更多笔记和资料没有md文档无法上传，另外想获得实时笔记和md源文档还有更多资料可以关注一下我的github仓库。<font color="red">💘</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2"><span class="toc-number">1.</span> <span class="toc-text">MySQL实战45讲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#01-%E8%AE%B2%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">01 讲基础架构：一条SQL查询语句是如何执行的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">第一步：连接器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5sleep"><span class="toc-number">2.1.1.</span> <span class="toc-text">连接sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.2.</span> <span class="toc-text">长连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">第二步：查询缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">第三步：分析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">第四步：优化器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">第五步：执行器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-%E8%AE%B2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">02 讲日志系统：一条SQL更新语句是如何执行的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log"><span class="toc-number">3.1.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog"><span class="toc-number">3.2.</span> <span class="toc-text">binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">更新语句执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">3.4.</span> <span class="toc-text">redo log的两阶段提交</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-%E8%AE%B2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81"><span class="toc-number">4.</span> <span class="toc-text">03 讲事务隔离：为什么你改了我还看不见</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9D%8F%E5%A4%84"><span class="toc-number">4.1.</span> <span class="toc-text">长事务的坏处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-%E8%AE%B2%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8A"><span class="toc-number">5.</span> <span class="toc-text">04 讲深入浅出索引(上)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-number">5.1.</span> <span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.</span> <span class="toc-text">有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-%E8%AE%B2%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8B"><span class="toc-number">6.</span> <span class="toc-text">05 讲深入浅出索引(下)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">回表过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">6.2.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-number">6.3.</span> <span class="toc-text">最左前缀原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">6.4.</span> <span class="toc-text">索引下推</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-%E8%AE%B2%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%EF%BC%9A%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D"><span class="toc-number">7.</span> <span class="toc-text">06 讲全局锁和表锁：给表加个字段怎么有这么多阻碍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">7.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">7.2.</span> <span class="toc-text">表级锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-%E8%AE%B2%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%EF%BC%9A%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">8.</span> <span class="toc-text">07 讲行锁功过：怎么减少行锁对性能的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="toc-number">8.1.</span> <span class="toc-text">两阶段锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">8.2.</span> <span class="toc-text">死锁和死锁检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%94%B1%E7%83%AD%E7%82%B9%E8%A1%8C%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">怎么解决由热点行更新导致的性能问题？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-%E8%AE%B2%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84"><span class="toc-number">9.</span> <span class="toc-text">08 讲事务到底是隔离的还是不隔离的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#read-view%E7%9A%84%E7%94%9F%E6%88%90%E4%BB%A5%E5%8F%8A%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">9.1.</span> <span class="toc-text">read view的生成以及当前读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#read-view%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.1.</span> <span class="toc-text">read view原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">9.1.2.</span> <span class="toc-text">当前读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-%E8%AE%B2%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9"><span class="toc-number">10.</span> <span class="toc-text">09 讲普通索引和唯一索引，应该怎么选择</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.1.</span> <span class="toc-text">查询过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.</span> <span class="toc-text">更新过程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#change-buffer"><span class="toc-number">10.2.1.</span> <span class="toc-text">change buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.2.</span> <span class="toc-text">更新区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#change-buffer%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.3.</span> <span class="toc-text">change buffer的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#change-buffer-%E5%92%8C-redo-log"><span class="toc-number">10.4.</span> <span class="toc-text">change buffer 和 redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E9%97%AE%E9%A2%98"><span class="toc-number">10.5.</span> <span class="toc-text">总结与问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E8%AE%B2MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="toc-number">11.</span> <span class="toc-text">10 讲MySQL为什么有时候会选错索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">11.1.</span> <span class="toc-text">MySQL选错索引举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">11.2.</span> <span class="toc-text">优化器的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.1.</span> <span class="toc-text">基数统计方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E4%BC%B0%E6%89%AB%E6%8F%8F%E8%A1%8C%E6%95%B0"><span class="toc-number">11.2.2.</span> <span class="toc-text">预估扫描行数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">11.2.3.</span> <span class="toc-text">修正统计信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">11.2.4.</span> <span class="toc-text">第二个例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">索引选择异常和处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E8%AE%B2%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">12.</span> <span class="toc-text">11 讲怎么给字符串字段加索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">12.1.</span> <span class="toc-text">字符串前缀索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E5%A5%BD%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">12.2.</span> <span class="toc-text">怎么定义好前缀索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">12.3.</span> <span class="toc-text">前缀索引对覆盖索引的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F"><span class="toc-number">12.4.</span> <span class="toc-text">定义字符串索引的其他方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">12.4.1.</span> <span class="toc-text">倒序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%AD%97%E6%AE%B5"><span class="toc-number">12.4.2.</span> <span class="toc-text">hash字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E5%BA%8F%E5%92%8Chash%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">12.4.3.</span> <span class="toc-text">倒序和hash的异同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E8%AE%B2%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84MySQL%E4%BC%9A%E2%80%9C%E6%8A%96%E2%80%9D%E4%B8%80%E4%B8%8B"><span class="toc-number">13.</span> <span class="toc-text">12 讲为什么我的MySQL会“抖”一下</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E7%AA%81%E7%84%B6%E5%8F%98%E6%85%A2%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">为什么会突然变慢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9Aflush"><span class="toc-number">13.2.</span> <span class="toc-text">什么时候会flush</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush%E6%93%8D%E4%BD%9C%E5%AF%B9%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">13.3.</span> <span class="toc-text">flush操作对系统性能的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%88%B7%E8%84%8F%E9%A1%B5%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">13.4.</span> <span class="toc-text">InnoDB刷脏页速度的控制策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BAIO%E8%83%BD%E5%8A%9B"><span class="toc-number">13.4.1.</span> <span class="toc-text">主机IO能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%8F%E9%A1%B5%E6%AF%94%E4%BE%8B"><span class="toc-number">13.4.2.</span> <span class="toc-text">脏页比例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E8%84%8F%E9%A1%B5%E7%9A%84%E9%80%9F%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">13.4.3.</span> <span class="toc-text">刷脏页的速度计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E8%AE%B2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%EF%BC%8C%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98"><span class="toc-number">14.</span> <span class="toc-text">13 讲为什么表数据删掉一半，表文件大小不变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0innodb-file-per-table"><span class="toc-number">14.1.</span> <span class="toc-text">参数innodb_file_per_table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">14.2.</span> <span class="toc-text">delete删除数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A%E9%87%8D%E5%BB%BA%E8%A1%A8"><span class="toc-number">14.3.</span> <span class="toc-text">解决方法：重建表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Online-%E5%92%8C-inplace"><span class="toc-number">14.4.</span> <span class="toc-text">Online 和 inplace</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E8%AE%B2count-%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">15.</span> <span class="toc-text">14 讲count(*)这么慢，我该怎么办</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#count-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">count(*)的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E4%BF%9D%E5%AD%98%E8%AE%A1%E6%95%B0"><span class="toc-number">15.2.</span> <span class="toc-text">用缓存系统保存计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E5%AD%98%E8%AE%A1%E6%95%B0"><span class="toc-number">15.3.</span> <span class="toc-text">在数据库保存计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84count%E7%94%A8%E6%B3%95"><span class="toc-number">15.4.</span> <span class="toc-text">不同的count用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E8%AE%B2%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">15 讲答疑文章（一）：日志和索引相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%90%8C%E5%BC%82%E5%B8%B8%E9%87%8D%E5%90%AF%E7%9A%84%E7%8E%B0%E8%B1%A1"><span class="toc-number">16.1.</span> <span class="toc-text">两阶段提交不同异常重启的现象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE1%EF%BC%9AMySQL%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93binlog%E6%98%AF%E5%AE%8C%E6%95%B4%E7%9A%84"><span class="toc-number">16.1.0.1.</span> <span class="toc-text">追问1：MySQL怎么知道binlog是完整的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE2%EF%BC%9Aredo-log-%E5%92%8C-binlog%E6%98%AF%E6%80%8E%E4%B9%88%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%E7%9A%84"><span class="toc-number">16.1.0.2.</span> <span class="toc-text">追问2：redo log 和 binlog是怎么关联起来的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE3%EF%BC%9A%E5%A4%84%E4%BA%8Eprepare%E9%98%B6%E6%AE%B5%E7%9A%84redo-log%E5%8A%A0%E4%B8%8A%E5%AE%8C%E6%95%B4binlog%EF%BC%8C%E9%87%8D%E5%90%AF%E5%B0%B1%E8%83%BD%E6%81%A2%E5%A4%8D%EF%BC%8CMySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">16.1.0.3.</span> <span class="toc-text">追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE4%EF%BC%9A%E5%A6%82%E6%9E%9C%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%91%A2%EF%BC%9F%E5%B9%B2%E8%84%86%E5%85%88redo-log%E5%86%99%E5%AE%8C%EF%BC%8C%E5%86%8D%E5%86%99binlog%E3%80%82%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%BE%97%E4%B8%A4%E4%B8%AA%E6%97%A5%E5%BF%97%E9%83%BD%E5%AE%8C%E6%95%B4%E6%89%8D%E5%8F%AF%E4%BB%A5%E3%80%82%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9F"><span class="toc-number">16.1.0.4.</span> <span class="toc-text">追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE5%EF%BC%9A%E4%B8%8D%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E6%97%A5%E5%BF%97%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%B2%A1%E6%9C%89%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E5%BF%85%E8%A6%81%E4%BA%86%E3%80%82%E5%8F%AA%E7%94%A8binlog%E6%9D%A5%E6%94%AF%E6%8C%81%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%EF%BC%8C%E5%8F%88%E8%83%BD%E6%94%AF%E6%8C%81%E5%BD%92%E6%A1%A3%EF%BC%8C%E4%B8%8D%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%EF%BC%9F"><span class="toc-number">16.1.0.5.</span> <span class="toc-text">追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE6%EF%BC%9A%E9%82%A3%E8%83%BD%E4%B8%8D%E8%83%BD%E5%8F%8D%E8%BF%87%E6%9D%A5%EF%BC%8C%E5%8F%AA%E7%94%A8redo-log%EF%BC%8C%E4%B8%8D%E8%A6%81binlog%EF%BC%9F"><span class="toc-number">16.1.0.6.</span> <span class="toc-text">追问6：那能不能反过来，只用redo log，不要binlog？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE7%EF%BC%9Aredo-log%E4%B8%80%E8%88%AC%E8%AE%BE%E7%BD%AE%E5%A4%9A%E5%A4%A7%EF%BC%9F"><span class="toc-number">16.1.0.7.</span> <span class="toc-text">追问7：redo log一般设置多大？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE8%EF%BC%9A%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E8%90%BD%E7%9B%98%EF%BC%8C%E6%98%AF%E4%BB%8Eredo-log%E6%9B%B4%E6%96%B0%E8%BF%87%E6%9D%A5%E7%9A%84%E8%BF%98%E6%98%AF%E4%BB%8Ebuffer-pool%E6%9B%B4%E6%96%B0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">16.1.0.8.</span> <span class="toc-text">追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE9%EF%BC%9Aredo-log-buffer%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E5%85%88%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E5%86%99redo-log%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">16.1.0.9.</span> <span class="toc-text">追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%80%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AEMySQL%E4%BC%9A%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C"><span class="toc-number">16.2.</span> <span class="toc-text">修改一样的数据MySQL会怎样运行</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E8%AE%B2%E2%80%9Corderby%E2%80%9D%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">17.</span> <span class="toc-text">16 讲“orderby”是怎么工作的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filesort%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">17.1.</span> <span class="toc-text">filesort归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F"><span class="toc-number">17.1.1.</span> <span class="toc-text">全字段排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rowid%E6%8E%92%E5%BA%8F"><span class="toc-number">17.1.2.</span> <span class="toc-text">rowid排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F-VS-rowid%E6%8E%92%E5%BA%8F"><span class="toc-number">17.1.3.</span> <span class="toc-text">全字段排序 VS rowid排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.</span> <span class="toc-text">索引排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">17.3.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-orderby-2-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF"><span class="toc-number">18.</span> <span class="toc-text">17 orderby 2 如何正确地显示随机消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-number">18.1.</span> <span class="toc-text">内存临时表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%B4%E6%97%B6%E8%A1%A8InnoDB"><span class="toc-number">18.2.</span> <span class="toc-text">磁盘临时表InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%8E%92%E5%BA%8F"><span class="toc-number">18.2.1.</span> <span class="toc-text">优先队列排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%87%E7%AB%A0%E5%BC%80%E5%A4%B4%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">18.3.</span> <span class="toc-text">解决文章开头随机排序的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-number">18.4.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E8%AE%B2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9BSQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%EF%BC%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7"><span class="toc-number">19.</span> <span class="toc-text">18 讲为什么这些SQL语句逻辑相同，性能却差异巨大</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EF%BC%88%E5%8D%B3%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">（即索引失效）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">20.1.</span> <span class="toc-text">索引字段使用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">20.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">20.3.</span> <span class="toc-text">隐式字符编码转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E8%AE%B2%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2"><span class="toc-number">21.</span> <span class="toc-text">19 讲为什么我只查一行的语句，也执行这么慢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">21.1.</span> <span class="toc-text">影响查询速度的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%EF%BC%9A%E6%9F%A5%E8%AF%A2%E9%95%BF%E6%97%B6%E9%97%B4%E4%B8%8D%E8%BF%94%E5%9B%9E"><span class="toc-number">21.1.1.</span> <span class="toc-text">第一类：查询长时间不返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89MDL%E9%94%81"><span class="toc-number">21.1.1.1.</span> <span class="toc-text">等MDL锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89flush"><span class="toc-number">21.1.1.2.</span> <span class="toc-text">等flush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E8%A1%8C%E9%94%81"><span class="toc-number">21.1.1.3.</span> <span class="toc-text">等行锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%85%A2"><span class="toc-number">21.1.2.</span> <span class="toc-text">第二类：查询慢</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">21.1.2.1.</span> <span class="toc-text">全表扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo%E9%93%BE%E5%A4%AA%E9%95%BF"><span class="toc-number">21.1.2.2.</span> <span class="toc-text">undo链太长</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E8%AE%B2%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">22.</span> <span class="toc-text">20 讲幻读是什么，幻读有什么问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5"><span class="toc-number">22.1.</span> <span class="toc-text">非索引字段更新语句的加锁情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-number">22.2.</span> <span class="toc-text">幻读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">22.3.</span> <span class="toc-text">如何解决幻读？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E9%82%BB%E9%97%B4%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C%E8%A7%84%E5%88%99"><span class="toc-number">23.</span> <span class="toc-text">21 邻间锁的范围和规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%8E%9F%E5%88%99%E4%B8%A4%E4%BC%98%E5%8C%96%E4%B8%80bug"><span class="toc-number">23.1.</span> <span class="toc-text">两原则两优化一bug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">23.2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">23.2.1.</span> <span class="toc-text">案例一：等值查询间隙锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E9%94%81"><span class="toc-number">23.2.2.</span> <span class="toc-text">案例二：非唯一索引等值锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%E4%B8%BB%E9%94%AE-%E5%94%AF%E4%B8%80-%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="toc-number">23.2.3.</span> <span class="toc-text">案例三：主键(唯一)索引范围锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%9B%9B%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="toc-number">23.2.4.</span> <span class="toc-text">案例四：非唯一索引范围锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%94%EF%BC%9A%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81bug"><span class="toc-number">23.2.5.</span> <span class="toc-text">案例五：唯一索引范围锁bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%85%AD%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E5%AD%98%E5%9C%A8%E2%80%9D%E7%AD%89%E5%80%BC%E2%80%9D%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">23.2.6.</span> <span class="toc-text">案例六：非唯一索引上存在”等值”的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%83%EF%BC%9Alimit-%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81"><span class="toc-number">23.2.7.</span> <span class="toc-text">案例七：limit 语句加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%85%AB%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">23.2.8.</span> <span class="toc-text">案例八：一个死锁的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">23.3.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E8%AE%B2MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E2%80%9C%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E2%80%9D%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">24.</span> <span class="toc-text">22 讲MySQL有哪些“饮鸩止渴”提高性能的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5%E9%A3%8E%E6%9A%B4"><span class="toc-number">24.1.</span> <span class="toc-text">短连接风暴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A%E5%85%88%E5%A4%84%E7%90%86%E6%8E%89%E9%82%A3%E4%BA%9B%E5%8D%A0%E7%9D%80%E8%BF%9E%E6%8E%A5%E4%BD%86%E6%98%AF%E4%B8%8D%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%BA%BF%E7%A8%8B%E3%80%82"><span class="toc-number">24.1.1.</span> <span class="toc-text">第一种方法：先处理掉那些占着连接但是不工作的线程。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A%E5%87%8F%E5%B0%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E7%9A%84%E6%B6%88%E8%80%97%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">24.1.2.</span> <span class="toc-text">第二种方法：减少连接过程的消耗（不推荐）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">24.2.</span> <span class="toc-text">慢查询性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%B2%A1%E6%9C%89%E8%AE%BE%E8%AE%A1%E5%A5%BD"><span class="toc-number">24.2.1.</span> <span class="toc-text">索引没有设计好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%B2%A1%E5%86%99%E5%A5%BD"><span class="toc-number">24.2.2.</span> <span class="toc-text">SQL语句没写好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="toc-number">24.2.3.</span> <span class="toc-text">MySQL选错索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QPS%E7%AA%81%E5%A2%9E%E9%97%AE%E9%A2%98"><span class="toc-number">24.3.</span> <span class="toc-text">QPS突增问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-redo-log%E5%92%8Cbin-log%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">25.</span> <span class="toc-text">23 redo log和bin log持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog%E7%9A%84%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">25.1.</span> <span class="toc-text">binlog的写入机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log%E7%9A%84%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">25.2.</span> <span class="toc-text">redo log的写入机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%8F%90%E4%BA%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">25.2.1.</span> <span class="toc-text">组提交机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E5%8C%96%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">25.2.2.</span> <span class="toc-text">细化两阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8D%87binlog%E7%BB%84%E6%8F%90%E4%BA%A4%E6%95%88%E6%9E%9C"><span class="toc-number">25.2.3.</span> <span class="toc-text">提升binlog组提交效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-MySQL%E4%B8%BB%E5%A4%87%E6%B5%81%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">24 MySQL主备流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%BB%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">26.1.</span> <span class="toc-text">MySQL主备的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BA%93%E8%AE%BE%E7%BD%AE%E4%B8%BAreadonly%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">26.1.1.</span> <span class="toc-text">备库设置为readonly的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-number">26.1.2.</span> <span class="toc-text">主从复制的详细流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">26.2.</span> <span class="toc-text">binlog的三种格式对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89mixed%E6%A0%BC%E5%BC%8F%E7%9A%84binlog%EF%BC%9F"><span class="toc-number">26.2.1.</span> <span class="toc-text">为什么会有mixed格式的binlog？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8binlog%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">26.2.2.</span> <span class="toc-text">使用binlog恢复数据的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98"><span class="toc-number">26.2.3.</span> <span class="toc-text">循环复制问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-MySQL%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">27.</span> <span class="toc-text">25 MySQL主备切换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F"><span class="toc-number">27.1.</span> <span class="toc-text">主备延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-number">27.1.1.</span> <span class="toc-text">主备延迟的来源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="toc-number">27.2.</span> <span class="toc-text">可靠性优先策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="toc-number">27.3.</span> <span class="toc-text">可用性优先策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E7%A7%8D%E6%83%85%E5%86%B5%E9%80%89%E6%8B%A9%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="toc-number">27.4.</span> <span class="toc-text">哪种情况选择可用性优先策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2"><span class="toc-number">27.5.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-MySQL%E5%A4%87%E5%BA%93%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E8%83%BD%E5%8A%9B"><span class="toc-number">28.</span> <span class="toc-text">26 MySQL备库的并行复制能力</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BA%93%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E8%83%BD%E5%8A%9B"><span class="toc-number">28.1.</span> <span class="toc-text">备库的并行复制能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">28.2.</span> <span class="toc-text">从库实现并行复制的思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-5-5%E7%89%88%E6%9C%AC%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5%EF%BC%88%E4%BD%9C%E8%80%85%E8%87%AA%E5%86%99%EF%BC%89"><span class="toc-number">28.3.</span> <span class="toc-text">MySQL 5.5版本的并行复制策略（作者自写）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%A1%A8%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5"><span class="toc-number">28.3.1.</span> <span class="toc-text">按表分发策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%A1%8C%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5"><span class="toc-number">28.3.2.</span> <span class="toc-text">按行分发策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">28.3.3.</span> <span class="toc-text">这两种方式的缺点和解决方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-5-6%E7%89%88%E6%9C%AC%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">28.4.</span> <span class="toc-text">MySQL 5.6版本的并行复制策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MariaDB%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">28.5.</span> <span class="toc-text">MariaDB的并行复制策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-5-7%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">28.6.</span> <span class="toc-text">MySQL 5.7的并行复制策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-5-7-22%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">28.7.</span> <span class="toc-text">MySQL 5.7.22的并行复制策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-3"><span class="toc-number">28.8.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-MySQL%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E6%89%BE%E5%90%8C%E6%AD%A5%E7%82%B9"><span class="toc-number">29.</span> <span class="toc-text">27 MySQL主备切换找同步点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E"><span class="toc-number">29.1.</span> <span class="toc-text">一主多从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%82%B9pos%E7%9A%84%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2"><span class="toc-number">29.2.</span> <span class="toc-text">基于位点pos的主备切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GTID%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1ID"><span class="toc-number">29.3.</span> <span class="toc-text">GTID全局事务ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GTID%E7%9A%84%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5"><span class="toc-number">29.3.1.</span> <span class="toc-text">GTID的生成策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GTID%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">29.3.2.</span> <span class="toc-text">GTID处理冲突的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EGTID%E7%9A%84%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2"><span class="toc-number">29.3.3.</span> <span class="toc-text">基于GTID的主备切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GTID%E5%92%8C%E5%9C%A8%E7%BA%BFDDL%E6%94%B9%E5%96%84%E4%B8%BB%E5%A4%87%E4%B8%B4%E6%97%B6%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">29.3.4.</span> <span class="toc-text">GTID和在线DDL改善主备临时添加索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-4"><span class="toc-number">29.4.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="toc-number">30.</span> <span class="toc-text">28 MySQL读写分离的延迟问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84"><span class="toc-number">30.1.</span> <span class="toc-text">两种读写分离架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB"><span class="toc-number">30.2.</span> <span class="toc-text">怎么处理过期读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%B5%B0%E4%B8%BB%E5%BA%93%E6%96%B9%E6%A1%88"><span class="toc-number">30.2.1.</span> <span class="toc-text">强制走主库方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sleep-%E6%96%B9%E6%A1%88"><span class="toc-number">30.2.2.</span> <span class="toc-text">Sleep 方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%BB%E5%A4%87%E6%97%A0%E5%BB%B6%E8%BF%9F%E6%96%B9%E6%A1%88"><span class="toc-number">30.2.3.</span> <span class="toc-text">判断主备无延迟方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E5%90%88semi-sync%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">30.2.4.</span> <span class="toc-text">配合semi-sync半同步复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%B8%BB%E5%BA%93%E4%BD%8D%E7%82%B9%E6%96%B9%E6%A1%88"><span class="toc-number">30.2.5.</span> <span class="toc-text">等主库位点方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85GTID%E6%96%B9%E6%A1%88"><span class="toc-number">30.2.6.</span> <span class="toc-text">等待GTID方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-5"><span class="toc-number">30.3.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-%E5%88%A4%E6%96%ADMySQL%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8"><span class="toc-number">31.</span> <span class="toc-text">29 判断MySQL服务是否可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select-1%E5%88%A4%E6%96%AD"><span class="toc-number">31.1.</span> <span class="toc-text">select 1判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%A1%A8%E5%88%A4%E6%96%AD"><span class="toc-number">31.2.</span> <span class="toc-text">查表判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%88%A4%E6%96%AD"><span class="toc-number">31.3.</span> <span class="toc-text">更新判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%9F%E8%AE%A1IO"><span class="toc-number">31.4.</span> <span class="toc-text">内部统计IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">31.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E8%AE%B2%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%82%BB%E9%97%B4%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">32.</span> <span class="toc-text">30 讲答疑文章（二）：邻间锁的相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%AD%89%E5%8F%B7%E4%B9%9F%E6%9C%89%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-number">32.1.</span> <span class="toc-text">非等号也有等值查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%BA%9B%E2%80%9C%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%93%AA%E9%87%8C%E6%9D%A5%E7%9A%84%E2%80%9D"><span class="toc-number">32.1.1.</span> <span class="toc-text">这些“等值查询哪里来的”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">32.1.2.</span> <span class="toc-text">等值查询的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">32.1.3.</span> <span class="toc-text">死锁的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%9C%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">32.1.4.</span> <span class="toc-text">怎么看死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%9C%8B%E9%94%81%E7%AD%89%E5%BE%85%EF%BC%9F"><span class="toc-number">32.1.5.</span> <span class="toc-text">怎么看锁等待？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#delete%E5%92%8Cinsert%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">32.1.5.1.</span> <span class="toc-text">delete和insert的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">32.1.5.2.</span> <span class="toc-text">update的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-6"><span class="toc-number">32.2.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E8%AE%B2%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">33.</span> <span class="toc-text">31 讲误删数据怎么办</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AF%E5%88%A0%E8%A1%8C"><span class="toc-number">33.1.</span> <span class="toc-text">误删行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AF%E5%88%A0%E5%BA%93-%E8%A1%A8"><span class="toc-number">33.2.</span> <span class="toc-text">误删库&#x2F;表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E6%81%A2%E5%A4%8D%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">33.2.1.</span> <span class="toc-text">加速恢复的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rm%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">33.3.</span> <span class="toc-text">rm删除数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E9%A2%84%E9%98%B2%E8%AF%AF%E5%88%A0"><span class="toc-number">33.4.</span> <span class="toc-text">提前预防误删</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%BB%9F%E8%AE%A1"><span class="toc-number">33.4.1.</span> <span class="toc-text">方法统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%A4%8D%E5%88%B6%E5%A4%87%E5%BA%93"><span class="toc-number">33.4.2.</span> <span class="toc-text">延迟复制备库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E8%AF%AF%E5%88%A0%E5%BA%93-%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">33.4.3.</span> <span class="toc-text">预防误删库&#x2F;表的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-%E8%AE%B2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-number">34.</span> <span class="toc-text">32 讲为什么还有kill不掉的语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E5%88%B0kill%E4%BB%A5%E5%90%8E%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">34.1.</span> <span class="toc-text">收到kill以后，线程做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill%E4%B8%8D%E6%8E%89%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">34.2.</span> <span class="toc-text">kill不掉的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill%E4%B8%8D%E6%8E%89%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93"><span class="toc-number">34.3.</span> <span class="toc-text">kill不掉情况总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%85%B3%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="toc-number">34.4.</span> <span class="toc-text">两个关于客户端的误解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E9%87%8C%E8%A1%A8%E5%A4%9A%EF%BC%8C%E4%B8%8D%E6%98%AF%E8%BF%9E%E6%8E%A5%E6%85%A2%EF%BC%8C%E8%B7%9F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E5%85%B3%E7%B3%BB"><span class="toc-number">34.4.1.</span> <span class="toc-text">库里表多，不是连接慢，跟服务端没关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quick%E5%8F%82%E6%95%B0%E4%BC%9A%E9%99%8D%E4%BD%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">34.4.2.</span> <span class="toc-text">-quick参数会降低服务端性能，加速客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-7"><span class="toc-number">34.5.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%A4%A7%E4%BA%8E%E4%B8%BB%E6%9C%BA%E5%86%85%E5%AD%98%E4%BC%9A%E4%B8%8D%E4%BC%9AOOM"><span class="toc-number">35.</span> <span class="toc-text">33 查询数据大于主机内存会不会OOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Server%E5%B1%82%E6%9F%A5%E8%AF%A2%E9%80%BB%E8%BE%91"><span class="toc-number">35.1.</span> <span class="toc-text">Server层查询逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sending-to-client"><span class="toc-number">35.1.1.</span> <span class="toc-text">Sending to client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sending-data"><span class="toc-number">35.1.2.</span> <span class="toc-text">Sending data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%B1%82%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">35.2.</span> <span class="toc-text">InnoDB层处理逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-number">35.2.1.</span> <span class="toc-text">内存命中率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E6%97%A7%E9%A1%B5-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95LRU"><span class="toc-number">35.2.2.</span> <span class="toc-text">淘汰旧页 最近最少使用算法LRU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-8"><span class="toc-number">35.3.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-%E8%AE%B2%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">36.</span> <span class="toc-text">34 讲到底可不可以使用join连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Index-Nested-Loop-Join%EF%BC%88NLJ%EF%BC%89"><span class="toc-number">36.1.</span> <span class="toc-text">Index Nested-Loop Join（NLJ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%B8%8D%E7%94%A8join%EF%BC%8C%E8%B0%81%E5%81%9A%E9%A9%B1%E5%8A%A8%E8%A1%A8"><span class="toc-number">36.2.</span> <span class="toc-text">用不用join，谁做驱动表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simple-Nested-Loop-Join%EF%BC%88SNL%EF%BC%89"><span class="toc-number">36.3.</span> <span class="toc-text">Simple Nested-Loop Join（SNL）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block-Nested-Loop-Join%EF%BC%88BNL%EF%BC%89"><span class="toc-number">36.4.</span> <span class="toc-text">Block Nested-Loop Join（BNL）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%AC%A1%E5%9B%9E%E7%AD%94%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">36.5.</span> <span class="toc-text">再次回答两个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%B4%A2%E5%BC%95%E8%B0%81%E5%81%9A%E9%A9%B1%E5%8A%A8%E8%A1%A8"><span class="toc-number">36.6.</span> <span class="toc-text">有索引谁做驱动表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9A%E5%B0%8F%E8%A1%A8"><span class="toc-number">36.7.</span> <span class="toc-text">什么叫做小表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-9"><span class="toc-number">36.8.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-%E8%AE%B2join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">37.</span> <span class="toc-text">35 讲join语句怎么优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Multi-Range-Read%E4%BC%98%E5%8C%96%E5%9B%9E%E8%A1%A8%EF%BC%88MRR%EF%BC%89"><span class="toc-number">37.1.</span> <span class="toc-text">Multi-Range Read优化回表（MRR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Batched-Key-Access%E4%BC%98%E5%8C%96NLJ%E5%92%8CBNL%EF%BC%88BKA%EF%BC%89"><span class="toc-number">37.2.</span> <span class="toc-text">Batched Key Access优化NLJ和BNL（BKA）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BKA%E4%BC%98%E5%8C%96NLJ"><span class="toc-number">37.2.1.</span> <span class="toc-text">BKA优化NLJ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BKA%E4%BC%98%E5%8C%96BNL"><span class="toc-number">37.2.2.</span> <span class="toc-text">BKA优化BNL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BNL%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%B9%E5%86%85%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%E9%80%A0%E6%88%90%E5%BD%B1%E5%93%8D"><span class="toc-number">37.2.2.1.</span> <span class="toc-text">BNL算法可能会对内存命中率造成影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BNL%E8%BD%ACBKA"><span class="toc-number">37.2.2.2.</span> <span class="toc-text">BNL转BKA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9Ahash-join"><span class="toc-number">37.3.</span> <span class="toc-text">扩展：hash join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-10"><span class="toc-number">37.4.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-number">38.</span> <span class="toc-text">36 临时表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%92%8C%E5%86%85%E5%AD%98%E8%A1%A8"><span class="toc-number">38.1.</span> <span class="toc-text">临时表和内存表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">38.2.</span> <span class="toc-text">临时表的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">38.3.</span> <span class="toc-text">临时表的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D%EF%BC%9F"><span class="toc-number">38.4.</span> <span class="toc-text">为什么临时表可以重名？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E5%8C%BA%E5%88%AB"><span class="toc-number">38.4.1.</span> <span class="toc-text">临时表文件命名区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98table-def-key%E5%8C%BA%E5%88%AB"><span class="toc-number">38.4.2.</span> <span class="toc-text">内存table_def_key区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98"><span class="toc-number">38.5.</span> <span class="toc-text">临时表的主备复制问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5binlog%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BD%95%E4%B8%B4%E6%97%B6%E8%A1%A8sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">38.5.1.</span> <span class="toc-text">什么情况binlog需要记录临时表sql语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#statment-mixed%E6%A0%BC%E5%BC%8F%E9%9C%80%E8%A6%81%E9%A2%9D%E5%A4%96%E6%89%A7%E8%A1%8CDROP-TEMPORARY-TABLE%E4%BC%A0%E7%BB%99%E5%A4%87%E5%BA%93%E6%89%A7%E8%A1%8C"><span class="toc-number">38.5.2.</span> <span class="toc-text">statment&#x2F;mixed格式需要额外执行DROP TEMPORARY TABLE传给备库执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BA%93%E6%89%A7%E8%A1%8C%E4%B8%B4%E6%97%B6%E8%A1%A8sql%E4%B9%9F%E8%83%BD%E5%8C%BA%E5%88%86%E5%90%8C%E5%90%8D%E8%A1%A8"><span class="toc-number">38.5.3.</span> <span class="toc-text">备库执行临时表sql也能区分同名表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">38.6.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-11"><span class="toc-number">38.7.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37-%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-number">39.</span> <span class="toc-text">37 内存临时表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-number">39.1.</span> <span class="toc-text">什么时候会使用内存临时表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#union-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">39.1.1.</span> <span class="toc-text">union 执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#group-by-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">39.1.2.</span> <span class="toc-text">group by 执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-by%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">39.2.</span> <span class="toc-text">group by的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#group-by-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95-%E2%80%93%E7%B4%A2%E5%BC%95"><span class="toc-number">39.2.1.</span> <span class="toc-text">group by 优化方法 –索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#group-by%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95-%E2%80%93%E7%9B%B4%E6%8E%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">39.2.2.</span> <span class="toc-text">group by优化方法 –直接排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">39.3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-12"><span class="toc-number">39.4.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-%E5%86%85%E5%AD%98%E8%A1%A8%EF%BC%88Memory%E5%BC%95%E6%93%8E%EF%BC%89"><span class="toc-number">40.</span> <span class="toc-text">38 内存表（Memory引擎）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%92%8CMemory%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">40.1.</span> <span class="toc-text">InnoDB和Memory表数据组织结构的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E7%B4%A2%E5%BC%95%E5%92%8CB-Tree%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">40.2.</span> <span class="toc-text">hash索引和B-Tree索引的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%A1%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">40.3.</span> <span class="toc-text">内存表的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%A1%A8%E5%8F%AA%E6%94%AF%E6%8C%81%E8%A1%A8%E9%94%81"><span class="toc-number">40.3.1.</span> <span class="toc-text">内存表只支持表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">40.3.2.</span> <span class="toc-text">不支持数据持久性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%A1%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">40.4.</span> <span class="toc-text">内存表的适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">40.5.</span> <span class="toc-text">小结和问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE"><span class="toc-number">41.</span> <span class="toc-text">39 MySQL自增主键</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E5%80%BC%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F"><span class="toc-number">41.1.</span> <span class="toc-text">自增值保存在哪儿？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E5%80%BC%E4%BF%AE%E6%94%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">41.2.</span> <span class="toc-text">自增值修改机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AEid%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F"><span class="toc-number">41.3.</span> <span class="toc-text">为什么自增主键id不能保证是连续的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E6%97%B6%E6%9C%BA%EF%BC%88%E5%8E%9F%E5%9B%A01%E5%92%8C2%EF%BC%89"><span class="toc-number">41.3.1.</span> <span class="toc-text">自增值的修改时机（原因1和2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%E7%AD%96%E7%95%A5"><span class="toc-number">41.3.2.</span> <span class="toc-text">自增锁策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E5%8E%9F%E5%9B%A03%EF%BC%89"><span class="toc-number">41.3.2.1.</span> <span class="toc-text">自增锁的优化（原因3）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%92%8C%E9%97%AE%E9%A2%98-1"><span class="toc-number">41.4.</span> <span class="toc-text">小结和问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E8%AE%B2insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A"><span class="toc-number">42.</span> <span class="toc-text">40 讲insert语句的锁为什么这么多</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-%E2%80%A6-select-%E8%AF%AD%E5%8F%A5"><span class="toc-number">42.1.</span> <span class="toc-text">insert … select 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-%E5%BE%AA%E7%8E%AF%E5%86%99%E5%85%A5"><span class="toc-number">42.2.</span> <span class="toc-text">insert 循环写入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%B6%E4%BB%96%E8%A1%A8"><span class="toc-number">42.2.1.</span> <span class="toc-text">插入其他表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%87%AA%E5%B7%B1%E8%A1%A8%E9%80%A0%E6%88%90%E5%BE%AA%E7%8E%AF%E5%86%99%E5%85%A5"><span class="toc-number">42.2.2.</span> <span class="toc-text">插入自己表造成循环写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E4%BC%9A%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">42.3.</span> <span class="toc-text">insert 唯一键冲突会获取锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%A0%E6%88%90%E5%86%B2%E7%AA%81%E4%BC%9A%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E9%82%BB%E9%97%B4%E9%94%81"><span class="toc-number">42.3.1.</span> <span class="toc-text">造成冲突会获取一个邻间锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81"><span class="toc-number">42.3.2.</span> <span class="toc-text">可能会造成死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-into-%E2%80%A6-on-duplicate-key-update"><span class="toc-number">42.4.</span> <span class="toc-text">insert into … on duplicate key update</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%92%8C%E9%97%AE%E9%A2%98-2"><span class="toc-number">42.5.</span> <span class="toc-text">小结和问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-%E8%AE%B2%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8"><span class="toc-number">43.</span> <span class="toc-text">41 讲怎么最快地复制一张表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysqldump%E6%96%B9%E6%B3%95"><span class="toc-number">43.1.</span> <span class="toc-text">mysqldump方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BACSV%E6%96%87%E4%BB%B6"><span class="toc-number">43.2.</span> <span class="toc-text">导出CSV文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">43.3.</span> <span class="toc-text">物理拷贝方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%92%8C%E9%97%AE%E9%A2%98-3"><span class="toc-number">43.4.</span> <span class="toc-text">小结和问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-%E8%AE%B2grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flushprivileges%E5%90%97"><span class="toc-number">44.</span> <span class="toc-text">42 讲grant之后要跟着flushprivileges吗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%9D%83%E9%99%90"><span class="toc-number">44.1.</span> <span class="toc-text">全局权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#db%E6%9D%83%E9%99%90"><span class="toc-number">44.2.</span> <span class="toc-text">db权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E6%9D%83%E9%99%90%E5%92%8C%E5%88%97%E6%9D%83%E9%99%90"><span class="toc-number">44.3.</span> <span class="toc-text">表权限和列权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush-privileges%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">44.4.</span> <span class="toc-text">flush privileges使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">44.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-%E8%AE%B2%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">45.</span> <span class="toc-text">43 讲要不要使用分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">45.1.</span> <span class="toc-text">分区表是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E5%BC%95%E6%93%8E%E5%B1%82%E8%A1%8C%E4%B8%BA"><span class="toc-number">45.2.</span> <span class="toc-text">分区表的引擎层行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5"><span class="toc-number">45.3.</span> <span class="toc-text">分区策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84server%E5%B1%82%E8%A1%8C%E4%B8%BA"><span class="toc-number">45.4.</span> <span class="toc-text">分区表的server层行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">45.5.</span> <span class="toc-text">分区表的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%92%8C%E9%97%AE%E9%A2%98-4"><span class="toc-number">45.6.</span> <span class="toc-text">小结和问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-%E8%AE%B2%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A"><span class="toc-number">46.</span> <span class="toc-text">44 讲答疑文章（三）：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#join%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">46.1.</span> <span class="toc-text">join的写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simple-Nested-Loop-Join-%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">46.2.</span> <span class="toc-text">Simple Nested Loop Join 的性能问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#distinct-%E5%92%8C-group-by%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">46.3.</span> <span class="toc-text">distinct 和 group by的性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BA%93%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-number">46.4.</span> <span class="toc-text">备库自增主键问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">46.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">47.</span> <span class="toc-text">45 自增id用完的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%AE%9A%E4%B9%89%E8%87%AA%E5%A2%9E%E5%80%BC-id"><span class="toc-number">47.1.</span> <span class="toc-text">表定义自增值 id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%A2%9E-row-id"><span class="toc-number">47.2.</span> <span class="toc-text">InnoDB 系统自增 row_id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Xid"><span class="toc-number">47.3.</span> <span class="toc-text">Xid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Innodb-trx-id"><span class="toc-number">47.4.</span> <span class="toc-text">Innodb trx_id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-id"><span class="toc-number">47.5.</span> <span class="toc-text">thread_id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">47.6.</span> <span class="toc-text">小结</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/%E9%98%85%E8%AF%BB%E5%A3%B0%E6%98%8E/" title="阅读声明"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/05.webp" onerror='this.onerror=null,this.src="/img/404.webp"' alt="阅读声明"></a><div class="content"><a class="title" href="/blog/%E9%98%85%E8%AF%BB%E5%A3%B0%E6%98%8E/" title="阅读声明">阅读声明</a><time datetime="2023-10-12T14:45:55.000Z" title="发表于 2023-10-12 22:45:55">2023-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="JVM垃圾回收、垃圾回收算法、垃圾回收器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/02.webp" onerror='this.onerror=null,this.src="/img/404.webp"' alt="JVM垃圾回收、垃圾回收算法、垃圾回收器"></a><div class="content"><a class="title" href="/blog/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="JVM垃圾回收、垃圾回收算法、垃圾回收器">JVM垃圾回收、垃圾回收算法、垃圾回收器</a><time datetime="2023-10-12T14:41:08.000Z" title="发表于 2023-10-12 22:41:08">2023-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/Kafka%E7%AC%94%E8%AE%B0/" title="Kafka笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/04.webp" onerror='this.onerror=null,this.src="/img/404.webp"' alt="Kafka笔记"></a><div class="content"><a class="title" href="/blog/Kafka%E7%AC%94%E8%AE%B0/" title="Kafka笔记">Kafka笔记</a><time datetime="2023-10-11T15:56:32.000Z" title="发表于 2023-10-11 23:56:32">2023-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/Redis/" title="Redis安装和常见数据类型命令"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/05.webp" onerror='this.onerror=null,this.src="/img/404.webp"' alt="Redis安装和常见数据类型命令"></a><div class="content"><a class="title" href="/blog/Redis/" title="Redis安装和常见数据类型命令">Redis安装和常见数据类型命令</a><time datetime="2023-10-01T06:51:00.000Z" title="发表于 2023-10-01 14:51:00">2023-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/" title="MySQL(6)实战45讲笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/07.webp" onerror='this.onerror=null,this.src="/img/404.webp"' alt="MySQL(6)实战45讲笔记"></a><div class="content"><a class="title" href="/blog/MySQL(6)%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/" title="MySQL(6)实战45讲笔记">MySQL(6)实战45讲笔记</a><time datetime="2023-10-01T06:50:06.000Z" title="发表于 2023-10-01 14:50:06">2023-10-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/cover_default_img/07.webp)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By spongehah</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp; <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('/pluginsSrc/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.hahhome.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.hahhome.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('/pluginsSrc/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '7ecf16f704fd5834a3a5',
      clientSecret: 'ed4a99d0eb3e4480a27445dd2b6a03b96fa99ddf',
      repo: 'hahhome.github.io',
      owner: 'spongehah',
      admin: ['spongehah'],
      id: '8cea0b2fcd695eb1cf6fe84d189aa039',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('/pluginsSrc/gitalk/dist/gitalk.css')
    getScript('/pluginsSrc/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Twikoo' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/cursor.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/pluginsSrc/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var e=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),e&&e.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="b16a1fa0e63c46a4b8f28abfb06ae3fe",gaud_map_key="e2b04289e870b005374ee030148d64fd&s=rsv3",baidu_ak_key="undefined",flag=0,clock_rectangle="112.982279,28.19409",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:300,hOffset:20,vOffset:-20},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/"})</script></body></html>