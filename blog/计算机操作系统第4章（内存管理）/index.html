<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>计算机操作系统第4章-内存管理 | HahHome</title><meta name="author" content="spongehah"><meta name="copyright" content="spongehah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机操作系统第4章-内存管理"><meta property="og:type" content="article"><meta property="og:title" content="计算机操作系统第4章-内存管理"><meta property="og:url" content="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/index.html"><meta property="og:site_name" content="HahHome"><meta property="og:description" content="计算机操作系统第4章-内存管理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.hahhome.top/img/cover_default_img/05.webp"><meta property="article:published_time" content="2024-01-01T08:43:10.000Z"><meta property="article:modified_time" content="2024-01-01T08:42:59.489Z"><meta property="article:author" content="spongehah"><meta property="article:tag" content="计算机操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.hahhome.top/img/cover_default_img/05.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"计算机操作系统第4章-内存管理",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-01 16:42:59"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><div id="myscoll"></div><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})</script><link rel="stylesheet" href="/css/loading-bar.css"><script src="/pluginsSrc/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover_default_img/05.webp)"><nav id="nav"><span id="blog-info"><a href="/" title="HahHome"><span class="site-name">HahHome</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机操作系统第4章-内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-01T08:43:10.000Z" title="发表于 2024-01-01 16:43:10">2024-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-01T08:42:59.489Z" title="更新于 2024-01-01 16:42:59">2024-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="四-内存管理"><a href="#四-内存管理" class="headerlink" title="四 内存管理"></a>四 内存管理</h1><blockquote><p>author: spongehah from:hut</p><p>作者个人博客：<a href="https://blog.hahhome.top/">https://blog.hahhome.top/</a></p><p>参考视频: B站王道考研计算机操作系统</p></blockquote><p>[TOC]</p><h1 id="1-内存的基础知识"><a href="#1-内存的基础知识" class="headerlink" title="1 内存的基础知识"></a>1 内存的基础知识</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010104752881.webp" alt="image-20231010104752881"></p><h2 id="1-1-什么是内存，有何作用？"><a href="#1-1-什么是内存，有何作用？" class="headerlink" title="1.1 什么是内存，有何作用？"></a>1.1 什么是内存，有何作用？</h2><p><strong>内存可存放数据</strong>。程序执行前需要先放到内存中才能被CPU处理</p><p>作用：缓和CPU与硬盘之间的速度矛盾</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010104928179.webp" alt="image-20231010104928179"></p><blockquote><p>思考：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？</p><p>方案：给内存的存储单元编地址</p><p><strong>存储单元</strong>：内存地址从0开始，<strong>每个地址对应一个存储单元</strong></p><ul><li>如果计算机<strong>“按字节编址”</strong>则每个存储单元大小为<strong>1字节</strong>，即1B，即8个二进制位</li><li>如果字长为<strong>16位</strong>的计算机<strong>“按字编址”</strong>，则每个存储单元大小为<strong>1个字</strong>；每个字的大小为<strong>16个二进制位</strong></li></ul></blockquote><h2 id="1-2-指令的工作原理和代码到程序运行的三步"><a href="#1-2-指令的工作原理和代码到程序运行的三步" class="headerlink" title="1.2 指令的工作原理和代码到程序运行的三步"></a>1.2 指令的工作原理和代码到程序运行的三步</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010105436370.webp" alt="image-20231010105436370"></p><blockquote><p><strong>指令的工作基于“地址”</strong>，每个地址对应一个数据的存储单元</p><p>上图中每条指令的<strong>加红部分代表的是指令类型</strong>，第二个8位代表的是某个某个寄存器的地址，第三个8位代表的是从这个地址取数据，下面的指令根据指令类型进行操作</p><ul><li>指令1代表从地址01001111取数据到寄存器00000011</li><li>指令2代表将寄存器00000011的数据加上00000001</li><li>指令3代表将寄存器00000011的数据写回地址01001111</li></ul></blockquote><p>思考：不可能每个进程分配到的地址都是从地址0开始的，如果这个进程不是从地址0开始存放的，会影响指令的正常执行吗？</p><p><strong>地址从0开始存放：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010110102989.webp" alt="image-20231010110102989"></p><blockquote><p>正常工作</p></blockquote><p><strong>地址不从0开始存放：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010110132295.webp" alt="image-20231010110132295"></p><blockquote><p>现在要解决的就是，<strong>如何将逻辑地址转换为物理地址？</strong></p><p>答案是马上要讲的<strong>装入</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010110419990.webp" alt="image-20231010110419990"></p><blockquote><p>而程序代码到程序运行要经历：<strong>编译 -&gt; 链接 -&gt; 装入</strong> 三个步骤才能真正装入内存运行</p><ul><li><strong>编译</strong>就是把高级语言翻译为机器语言</li><li><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，<strong>形成一个完整的装入模块</strong></li><li><strong>装入</strong>（装载）：由装入程序<strong>将装入模块装入内存运行</strong>，并将<strong>逻辑地址转换为物理地址</strong></li></ul><p>接下来要讲的就是如何链接以及如何装入</p></blockquote><h2 id="1-3-链接的三种方式"><a href="#1-3-链接的三种方式" class="headerlink" title="1.3 链接的三种方式"></a>1.3 链接的三种方式</h2><p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，<strong>形成一个完整的装入模块</strong></p><h3 id="1）静态链接"><a href="#1）静态链接" class="headerlink" title="1）静态链接"></a>1）静态链接</h3><p>静态链接：在程序<strong>运行之前</strong>，先将各目标模块及它们所需的<br>库函数<strong>连接成一个完整的可执行文件（装入模块）</strong>，之后<strong>不再拆开</strong>。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231010110905770.webp" alt="image-20231010110905770" style="zoom:50%"></p><h3 id="2）装入时动态链接"><a href="#2）装入时动态链接" class="headerlink" title="2）装入时动态链接"></a>2）装入时动态链接</h3><p>装入时动态链挠：将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式。（结合后面的装入一起）</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231010111054170.webp" alt="image-20231010111054170" style="zoom:50%"><h3 id="3）运行时动态链接"><a href="#3）运行时动态链接" class="headerlink" title="3）运行时动态链接"></a>3）运行时动态链接</h3><p>运行时动态链接：在程序执行中<strong>需要该目标模块时，才对它进行链接</strong>。其优点是便于修改和更新，便于实现对目标模块的共享。<strong>用不到的模块就不需要装入内存</strong></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231010111148667.webp" alt="image-20231010111148667" style="zoom:50%"><h2 id="1-4-装入的三种方式"><a href="#1-4-装入的三种方式" class="headerlink" title="1.4 装入的三种方式"></a>1.4 装入的三种方式</h2><p><strong>装入</strong>（装载）：由装入程序<strong>将装入模块装入内存运行</strong>，并将<strong>逻辑地址转换为物理地址</strong></p><h3 id="1）绝对装入"><a href="#1）绝对装入" class="headerlink" title="1）绝对装入"></a>1）绝对装入</h3><p><strong>绝对装入</strong>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>Eg:如果知道装入模块要从地址为100的地方开始存放</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010111459979.webp" alt="image-20231010111459979"></p><blockquote><p>链接后得到的<strong>装入模块直接就使用的是绝对地址</strong>，</p><p>不足：<strong>只适用于单道程序阶段，此时还无操作系统</strong></p></blockquote><h3 id="2）静态重定位（可重定位装入）"><a href="#2）静态重定位（可重定位装入）" class="headerlink" title="2）静态重定位（可重定位装入）"></a>2）静态重定位（可重定位装入）</h3><p><strong>静态重定位</strong>：又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行“重定位”，将逻辑地址变换为物理地址</strong>（地址变换是在装入时<strong>一次性完成</strong>的)</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010111831907.webp" alt="image-20231010111831907"></p><blockquote><p>将装入模块装入内存时<strong>一次性</strong>分配要求的<strong>全部内存空间</strong>，并将<strong>逻辑地址变换为物理地址</strong>，适用于<strong>早期多道批处理</strong></p><p>不足：如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p></blockquote><h3 id="3）动态重定位（动态运行时装入）"><a href="#3）动态重定位（动态运行时装入）" class="headerlink" title="3）动态重定位（动态运行时装入）"></a>3）动态重定位（动态运行时装入）</h3><p><strong>动态重定位</strong>：又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，<strong>装入时依然保持使用逻辑地址</strong>，而是把<strong>地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010112538351.webp" alt="image-20231010112538351"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010112852009.webp" alt="image-20231010112852009"></p><blockquote><p>重定位寄存器：存放装入模块存放的<strong>起始位置</strong>，适用于<strong>现代操作系统</strong></p><p>优点：</p><ol><li>可将程序分配到<strong>不连续的存储区</strong>中；</li><li>在程序运行前<strong>只需装入它的部分代码即可投入运行</strong>，然后在程序运行期间，根据需要动态申请分配内存</li><li>便于程序段的<strong>共享</strong>，可以向用户提供一个比存储空间大得多的地址空间。</li></ol></blockquote><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010113116291.webp" alt="image-20231010113116291"></p><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><h2 id="2-1-内存管理要实现的四个目标"><a href="#2-1-内存管理要实现的四个目标" class="headerlink" title="2.1 内存管理要实现的四个目标"></a>2.1 内存管理要实现的四个目标</h2><p>1.操作系统负责<strong>内存空间的分配与回收</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010113403691.webp" alt="image-20231010113403691"></p><p>2.操作系统需要提供某种技术从<strong>逻辑上对内存空间进行扩充</strong>（覆盖技术、交换技术、虚拟技术）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010115847697.webp" alt="image-20231010115847697"></p><p>3.操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址</strong>与<strong>物理地址</strong>的<strong>转换</strong>（这个过程称为<strong>地址重定位</strong>），采用<strong>装入</strong>或<strong>具体存储管理方式的地址变换机构</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010113549970.webp" alt="image-20231010113549970"></p><p>4.操作系统需要提供<strong>内存保护功能</strong>。保证各进程在各自存储空间内运行，<strong>互不干扰</strong></p><ul><li>方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界<br>假设进程1的逻辑地址空间为0 ~ 179：实际物理地址空间为100 ~ 279<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231010114151331.webp" alt="image-20231010114151331" style="zoom:50%"></li><li>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>（注意一个是物理，一个是逻辑）<br>假设进程1的逻辑地址空间为0 ~ 179：实际物理地址空间为100 ~ 279<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231010114111711.webp" alt="image-20231010114111711" style="zoom:50%"></li></ul><p><strong>小总结：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010114411624.webp" alt="image-20231010114411624"></p><h2 id="2-2-实现内存空间的扩充"><a href="#2-2-实现内存空间的扩充" class="headerlink" title="2.2 实现内存空间的扩充"></a>2.2 实现内存空间的扩充</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010115124792.webp" alt="image-20231010115124792"></p><p>虚拟存储技术后面才会讲</p><h3 id="1）覆盖技术"><a href="#1）覆盖技术" class="headerlink" title="1）覆盖技术"></a>1）覆盖技术</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010115243417.webp" alt="image-20231010115243417"></p><blockquote><p><strong>覆盖技术</strong>，用来<strong>解决“程序大小超过物理内存总和”的问题</strong></p><p>覆盖技术的思想：将<strong>程序分为多个段</strong>（多个模块）常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为<strong>一个“固定区”</strong>和<strong>若干个“覆盖区”</strong>。</p><p>需要<strong>常驻内存的段放在“固定区”</strong>中，<strong>调入后就不再调出</strong>（除非运行结束）<strong>不常用的段放在“覆盖区”</strong>，<strong>需要用到时调入内存，用不到时调出内存</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010115422566.webp" alt="image-20231010115422566"></p><blockquote><p>例如A端需放入固定区</p><p>B段和C段最多只能同时运行一个，所以只需要划分一个大者（10K）的覆盖区即可</p><p>D段和E、F段也是如此，只需要划分一个12K的覆盖区即可</p><p><strong>优点：</strong>这样总内存大小8+8+10+12+4+10&#x3D;52K的进程，只需要划分30K就可以运行</p><p><strong>缺点：</strong>必须由<strong>程序员声明覆盖结构</strong>，操作系统完成自动覆盖。<strong>对用户不透明，增加了用户编程负担</strong>。覆盖技术只用于<strong>早期的操作系统</strong>中，现在己成为历史。</p></blockquote><h3 id="2）交换技术"><a href="#2）交换技术" class="headerlink" title="2）交换技术"></a>2）交换技术</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010115947667.webp" alt="image-20231010115947667"></p><blockquote><p><strong>交换（对换）技术</strong>的设计思想：内存空间紧张时，系统<strong>将内存中某些进程暂时换出外存</strong>，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</p><p>即<strong>中级调度</strong>的应用：暂时换出外存等待的进程状态为<strong>挂起状态（挂起态，suspend)<strong>，挂起态又可以进一步细分为</strong>就绪挂起、阻塞挂起</strong>两种状态<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010120131057.webp" alt="image-20231010120131057"></p></blockquote><ol><li>应该在外存（磁盘）的什么位置保存被换出的进程？<ul><li>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区主要用于存放文件，主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>：对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>（学过文件管理章节后即可理解)。总之，<strong>对换区的I&#x2F;O速度比文件区的更快</strong>。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231010120426618.webp" alt="image-20231010120426618" style="zoom:50%"></li></ul></li><li>什么时候应该交换？<ul><li>交换通常在许多进程运行且<strong>内存吃紧时进行</strong>，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</li></ul></li><li>应该换出哪些进程？<ul><li>可<strong>优先换出阻塞进程</strong>；可换出<strong>优先级低</strong>的进程；为了防止优先级低的进程在被调入内存后很快又被换出导致饥饿，有的系统还会<strong>考虑进程在内存的驻留时间</strong></li></ul></li></ol><p>(注意：<strong>PCB会常驻内存</strong>，不会被换出外存)</p><h3 id="覆盖和交换的区别"><a href="#覆盖和交换的区别" class="headerlink" title="覆盖和交换的区别"></a>覆盖和交换的区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231010120643030.webp" alt="image-20231010120643030"></p><blockquote><p>覆盖是在<strong>同一个</strong>程序或进程中的，交换是在<strong>不同</strong>进程（或作业）之间的</p></blockquote><h2 id="2-3-实现内存空间的分配与回收（连续分配管理方式）"><a href="#2-3-实现内存空间的分配与回收（连续分配管理方式）" class="headerlink" title="2.3 实现内存空间的分配与回收（连续分配管理方式）"></a>2.3 实现内存空间的分配与回收（连续分配管理方式）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012144211986.webp" alt="image-20231012144211986"></p><h3 id="2-3-1-三种连续分配管理方式"><a href="#2-3-1-三种连续分配管理方式" class="headerlink" title="2.3.1 三种连续分配管理方式"></a>2.3.1 三种连续分配管理方式</h3><h4 id="1）单一连续分配"><a href="#1）单一连续分配" class="headerlink" title="1）单一连续分配"></a>1）单一连续分配</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012144510835.webp" alt="image-20231012144510835"></p><blockquote><p>优点：实现简单，无外部碎片</p><p>缺点：有内部碎片，<strong>同一时间只能运行一个程序</strong>，内存利用率极低</p></blockquote><h4 id="2）固定分区分配"><a href="#2）固定分区分配" class="headerlink" title="2）固定分区分配"></a>2）固定分区分配</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012144653905.webp" alt="image-20231012144653905"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012144816213.webp" alt="image-20231012144816213"></p><blockquote><p>分为两类：</p><ol><li>分区大小相等：缺乏灵活性，但适用于某些特定场景</li><li>分区大小不等：增加了灵活性</li></ol><p>优点：实现简单，无外部碎片</p><p>缺点：用户程序太大时没有一个分区满足，不得不使用覆盖技术，会降低性能<br>会产生内部碎片，内存利用率低</p></blockquote><h4 id="3）动态分区分配"><a href="#3）动态分区分配" class="headerlink" title="3）动态分区分配"></a>3）动态分区分配</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012144929411.webp" alt="image-20231012144929411"></p><blockquote><p>1.系统要用什么样的<strong>数据结构</strong>记录内存的使用情况？</p><ul><li>空闲分区表：每个空闲分区对应一个表项。表项中包含分区号分区大小、分区起始地址等信息</li><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231012161053542.webp" alt="image-20231012161053542" style="zoom:50%"></li></ul><p>2.当很多个空闲分区都能满足需求时，应该<strong>选择哪个分区</strong>进行分配？</p><ul><li>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。下个小节会介绍四种<strong>动态分区分配算法</strong></li></ul><p>3.如何进行分区的<strong>分配与回收</strong>操作？</p><ul><li>回收时<strong>相邻的空闲区合并成一个</strong>，若无相邻空闲区则自己成为一个空闲区</li></ul></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012145835251.webp" alt="image-20231012145835251"></p><blockquote><p>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。（前面两种方法都是有内部碎片没有外部碎片）</p><p><strong>内部碎片</strong>：分配给某进程的内存区域中，如果有些部分没有用上。<br><strong>外部碎片</strong>：是指内存中的某些空闲分区由于太小而难以利用。</p><p>如何处理外部碎片？<br>可以通过<strong>紧凑（拼凑，Compaction)技术</strong>来解决外部碎片。例如把使用到的内存块向小地址方向整理到一起</p></blockquote><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012145933335.webp" alt="image-20231012145933335"></p><h3 id="2-3-2-四种动态分区分配算法"><a href="#2-3-2-四种动态分区分配算法" class="headerlink" title="2.3.2 四种动态分区分配算法"></a>2.3.2 四种动态分区分配算法</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012150022466.webp" alt="image-20231012150022466"></p><h4 id="1）首次适应算法"><a href="#1）首次适应算法" class="headerlink" title="1）首次适应算法"></a>1）首次适应算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012151606649.webp" alt="image-20231012151606649"></p><blockquote><p>首次适应算法：空闲区的大小排序是<strong>无序</strong>的，从<strong>低地址依次向高地址</strong>查找，直到找到<strong>第一个满足要求</strong>的空闲分区</p></blockquote><h4 id="2）最佳适应算法"><a href="#2）最佳适应算法" class="headerlink" title="2）最佳适应算法"></a>2）最佳适应算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012151912854.webp" alt="image-20231012151912854"></p><blockquote><p>最佳适应算法：空闲分区<strong>按容量递增次序链接</strong>，每次分配内存时顺时针查找到满足要求的第一个空闲分区，即<strong>刚好满足要求的第一个分区</strong></p><p>会对空闲分区进行重新排序</p><p><strong>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</strong></p></blockquote><h4 id="3）最坏适应算法"><a href="#3）最坏适应算法" class="headerlink" title="3）最坏适应算法"></a>3）最坏适应算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012152338647.webp" alt="image-20231012152338647"></p><blockquote><p>最坏适应算法：空闲分区<strong>按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表)，找到大小能满足要求的第一个空闲分区，即<strong>优先使用此时最大的空闲分区</strong></p><p>会对空闲分区进行重新排序</p><p><strong>缺点</strong>：每次都选最大的分区进行分配，虽然<strong>可以让分配后留下的空闲区更大</strong>，更可用，但是这种方式会<strong>导致较大的连续空闲区被迅速用完</strong>。如果之后有“<strong>大进程”到达，就没有内存分区可用了</strong>。</p></blockquote><h4 id="4）邻近适应算法"><a href="#4）邻近适应算法" class="headerlink" title="4）邻近适应算法"></a>4）邻近适应算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012153310634.webp" alt="image-20231012153310634"></p><blockquote><p>邻近适应算法：和首次适应算法一致，<strong>不对空闲分区的容量进行排序</strong>，但是将其首尾相连构成<strong>循环链表</strong>，每次分配内存时<strong>从上次查找结束的位置开始</strong>查找空闲分区链（或空闲分区表），找到大小能<strong>满足要求的第一个</strong>空闲分区。</p><p>和首次适应算法的<strong>区别</strong>：</p><ul><li>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。</li><li>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用<strong>（最佳适应算法的缺点）</strong></li></ul></blockquote><h4 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231012153319093.webp" alt="image-20231012153319093"></p><h2 id="2-4-实现内存空间的分配与回收（非连续分配管理方式）"><a href="#2-4-实现内存空间的分配与回收（非连续分配管理方式）" class="headerlink" title="2.4 实现内存空间的分配与回收（非连续分配管理方式）"></a>2.4 实现内存空间的分配与回收（非连续分配管理方式）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017095934058.webp" alt="image-20231017095934058"></p><h3 id="2-4-1-基本分页存储管理"><a href="#2-4-1-基本分页存储管理" class="headerlink" title="2.4.1 基本分页存储管理"></a>2.4.1 基本分页存储管理</h3><h4 id="1-1）页框和页面的概念"><a href="#1-1）页框和页面的概念" class="headerlink" title="1.1）页框和页面的概念"></a>1.1）页框和页面的概念</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017082840352.webp" alt="image-20231017082840352"></p><blockquote><p><strong>页框</strong>（页框&#x3D;页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面）：将因存空间份为一个个大小相等的分区（一般为4KB）</p><p><strong>页&#x2F;页面</strong>：将讲程的罗辑地址空间也分为与而掘大小相的一个个部分</p><p>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系<br>各个页面不必连续存放，可以放到不相邻的各个页框中。</p></blockquote><h4 id="1-2）页表和页表的大小计算"><a href="#1-2）页表和页表的大小计算" class="headerlink" title="1.2）页表和页表的大小计算"></a>1.2）页表和页表的大小计算</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017083132372.webp" alt="image-20231017083132372"></p><blockquote><p><strong>页表：</strong>维护进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系</p></blockquote><p>1.每个页表项多大？占几个字节？</p><p>2.如何通过页表实现逻辑地址到物理地址的转换？</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017083616105.webp" alt="image-20231017083616105"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017084238866.webp" alt="image-20231017084238866"></p><blockquote><p>页表项是连续存放，因此<strong>页号可以是隐含</strong>的，<strong>不占存储空间</strong>（类比数组）</p><p><em><em>-&gt;本例中(内存大小4GB)：由于页号是隐含的，因此每个页表项占3B,存储整个页表至少需要3</em>(n+1)B</em>*</p><p><strong>注意</strong>：页表记录的只是<strong>内存块号</strong>，而不是内存块的起始地址！<strong>」号内存块的起始地址&#x3D;」*内存块大小(4KB)</strong></p></blockquote><h4 id="1-3）逻辑地址到物理地址的转换"><a href="#1-3）逻辑地址到物理地址的转换" class="headerlink" title="1.3）逻辑地址到物理地址的转换"></a>1.3）逻辑地址到物理地址的转换</h4><p><strong>逻辑地址的结构：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017094012531.webp" alt="image-20231017094012531"></p><blockquote><p>0-11位为页内偏移量：因为一个页框的大小一般为4KB&#x3D;2^12^B</p><p>12-31位为页号：为上例中的页号位数(内存空间大小为4GB)，若<strong>内存空间大小不一样，页框大小不一样，页号的位数就不一样</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017085451465.webp" alt="image-20231017085451465"></p><blockquote><p>这是连续分配时逻辑地址到物理地址的转换方式：动态重定位，不清楚的可以去前面回顾一下</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017085650756.webp" alt="image-20231017085650756"></p><blockquote><p>逻辑地址A对应的<strong>物理地址</strong>&#x3D;P号页面在内存中的<strong>起始地址</strong>+<strong>页内偏移量W</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017090238089.webp" alt="image-20231017090238089"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017092051442.webp" alt="image-20231017092051442"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017092244116.webp" alt="image-20231017092244116"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017092305141.webp" alt="image-20231017092305141"></p><blockquote><p>总结：</p><p>计算物理地址的两种方式：</p><ol><li>实际的<strong>物理地址</strong>&#x3D;页面在内存中的<strong>起始地址</strong>+<strong>页内偏移量</strong><ul><li>起始地址&#x3D;内存块号(页帧号) * 内存块的大小(一般为4KB)</li></ul></li><li>如果页面大小刚好是2的整数幂，则只需把<strong>页表中记录的物理块号拼接上页内偏移量</strong>就能得到对应的物理地址</li></ol></blockquote><h4 id="小总结-3"><a href="#小总结-3" class="headerlink" title="小总结"></a>小总结</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231017094024655.webp" alt="image-20231017094024655"></p><h4 id="2）基本地址变换机构"><a href="#2）基本地址变换机构" class="headerlink" title="2）基本地址变换机构"></a>2）基本地址变换机构</h4><p>重点理解、记忆基本地址变换机构（<strong>用于实现逻辑地址到物理地址转换的一组硬件机构</strong>）的原理和流程</p><p>基本地址变换机构可以<strong>借助进程的页表将逻辑地址转换为物理地址</strong>。<br>通常会在系统中设置一个<strong>页表寄存器</strong>(PTR),存放<strong>页表在内存中的起始地址F和页表长度M</strong>。<br>进程未执行时，页表的始址和页表长度<strong>放在进程控制块(PCB)中</strong>，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>注意：<strong>页面大小是2的整数幂</strong><br>设页面大小为L,逻辑地址A到物理地址E的变换过程如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026170649057.webp" alt="image-20231026170649057"></p><blockquote><ul><li>①计算页号P和页内偏移量W(如果用十进制数手算，则P&#x3D;A&#x2F;L,W&#x3D;A%L:但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)</li><li>②比较页号P和页表长度M,若P<strong>≥</strong>M,则产生越界中断，否则继续执行。（注意：页号是从0始的，而页表长度至少是1，因此<strong>P&#x3D;M时也会越界</strong>)</li><li>③页表中页号P对应的<strong>页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度</strong>，取出该页表项内容b,即为内存块号。（注意区分<strong>页表项长度、页表长度、页面大小的区别</strong>。<strong>页表长度</strong>指的是这个页表中总共有几个页表项，即总共有几个页：<strong>页表项长度</strong>指的是每个页表项占多大的存储空间：<strong>页面大小</strong>指的是一个页面占多大的存储空间)</li><li>④计算E&#x3D;b*L+W,用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)</li></ul><p>动手验证：假设页面大小L&#x3D;1KB,最终要访问的内存块号b&#x3D;2,页内偏移量W&#x3D;1023。①尝试用E&#x3D;b*L+W计算目标物理地址。②尝试把内存块号、页内偏移量用二进制表示，并把它们拼接起来得到物理地址对比①②的结果是否一致</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026171021929.webp" alt="image-20231026171021929"></p></blockquote><p><strong>注意：虽然前面经过计算，一个页表项只需要3B就够了，可是为了方便页表的查询，往往会让每个页表项站内据4B，</strong><br><strong>如下：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026171320973.webp" alt="image-20231026171320973"></p><p><strong>另外：进程的页表通常是装在连续的内存块中的</strong></p><p>小总结：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026171411763.webp" alt="image-20231026171411763"></p><h4 id="3）具有快表的地址变换机构"><a href="#3）具有快表的地址变换机构" class="headerlink" title="3）具有快表的地址变换机构"></a>3）具有快表的地址变换机构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026171430792.webp" alt="image-20231026171430792"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026171456108.webp" alt="image-20231026171456108"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026171526495.webp" alt="image-20231026171526495"></p><p><strong>引入快表后，地址的变换过程：</strong></p><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p><p>②如果找到匹配的页号，说明要访问的页表顽在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此，若<strong>快表命中</strong>，则访问某个逻辑地址仅需<strong>一次访存</strong>即可。</p><p>③如果没有找到匹配的页号，则需要<strong>访问内存中的页表</strong>，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此，若<strong>快表未命中</strong>，则访问某个逻辑地址需要<strong>两次访存</strong>（注意：<strong>在找到页表项后，应同时将其存入快表</strong>，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026171833711.webp" alt="image-20231026171833711"></p><blockquote><p>有的系统支持<strong>快表和慢表同时查找</strong></p></blockquote><p><strong>局部性原理：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172006641.webp" alt="image-20231026172006641"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172019016.webp" alt="image-20231026172019016"></p><h4 id="4）两级页表"><a href="#4）两级页表" class="headerlink" title="4）两级页表"></a>4）两级页表</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172107918.webp" alt="image-20231026172107918"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172156732.webp" alt="image-20231026172156732"></p><blockquote><p><strong>一级页表需要的连续内存块太多了</strong></p><p>根据局部性原理可知，很多时候，<strong>进程在一段时间内只需要访问某几个页面就可以正常运行了</strong>。因此<strong>没有必要让整个页表都常驻内存。</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172428966.webp" alt="image-20231026172428966"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172818723.webp" alt="image-20231026172818723"></p><blockquote><p>页面大小4KB,每个页表项4B,<strong>每个页面可存放1K个页表项</strong>，因此每1K个连续的页表项为一组，<strong>每组刚好占一个内存块</strong>，再讲各组离散地放到各个内存块中</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172524242.webp" alt="image-20231026172524242"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172713329.webp" alt="image-20231026172713329"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172744036.webp" alt="image-20231026172744036"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026172933562.webp" alt="image-20231026172933562"></p><blockquote><p>1 各级页表的大小不能超过一个页面<br>2 n级页表需要n+1次访存（没有快表的情况下）</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026173111152.webp" alt="image-20231026173111152"></p><h3 id="2-4-2-基本分段存储管理"><a href="#2-4-2-基本分段存储管理" class="headerlink" title="2.4.2 基本分段存储管理"></a>2.4.2 基本分段存储管理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026173213677.webp" alt="image-20231026173213677"></p><h4 id="1）什么是分段"><a href="#1）什么是分段" class="headerlink" title="1）什么是分段"></a>1）什么是分段</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192340436.webp" alt="image-20231026192340436"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192349253.webp" alt="image-20231026192349253"></p><h4 id="2）段表和地址变换"><a href="#2）段表和地址变换" class="headerlink" title="2）段表和地址变换"></a>2）段表和地址变换</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192405340.webp" alt="image-20231026192405340"></p><blockquote><p>段表的每个段表项占6B：段长16位+基址32位&#x3D;48bit&#x3D;6B</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192424211.webp" alt="image-20231026192424211"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192638876.webp" alt="image-20231026192638876"></p><h4 id="3）分段、分页管理的对比"><a href="#3）分段、分页管理的对比" class="headerlink" title="3）分段、分页管理的对比"></a>3）分段、分页管理的对比</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192645373.webp" alt="image-20231026192645373"></p><blockquote><p><strong>页</strong>是信息的<strong>物理单位</strong>，<strong>对用户是不可见</strong>的<br><strong>段</strong>是信息的<strong>逻辑单位</strong>，<strong>对用户是可见</strong>的</p><p><strong>分页</strong>的用户进程地址空间是<strong>一维</strong>的<br><strong>分段</strong>的用户进程地址空间是<strong>二维</strong>的</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192829590.webp" alt="image-20231026192829590"></p><blockquote><p><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong>，只需指向同一个内存段即可</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026192959000.webp" alt="image-20231026192959000"></p><blockquote><p>若是采用分页管理，那么如果需要共享的信息在一个页中，将很难实现共享</p></blockquote><p><strong>对比小总结：</strong></p><p><strong>页</strong>是信息的<strong>物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的。</strong><br><strong>段</strong>是信息的<strong>逻辑单位</strong>。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。<br>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。<br><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><p><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong>。不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的</p><p>访问一个逻辑地址需要几次访存？<br><strong>分页（单级页表）</strong>：第一次访存一一查内存中的页表，第二次访存一一访问目标内存单元。总共<strong>两次访存</strong><br><strong>分段</strong>：第一次访存一一查内存中的段表，第二次访存一一访问目标内存单元。总共<strong>两次访存</strong><br>与分页系统类似，<strong>分段系统中也可以引入快表机构</strong>，将近期访问过的段表项放到快表中，这样<strong>可以少一次访问</strong>，加快地址变换速度。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026193549588.webp" alt="image-20231026193549588"></p><h4 id="4）分页分段的优缺点"><a href="#4）分页分段的优缺点" class="headerlink" title="4）分页分段的优缺点"></a>4）分页分段的优缺点</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026193630785.webp" alt="image-20231026193630785"></p><blockquote><p>不过：分段管理中产生的外部碎片也可以用<strong>“紧凑”</strong>来解决，只是需要付出较大的<strong>时间代价</strong></p></blockquote><h3 id="2-4-3-段页式管理"><a href="#2-4-3-段页式管理" class="headerlink" title="2.4.3 段页式管理"></a>2.4.3 段页式管理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026193832906.webp" alt="image-20231026193832906"></p><blockquote><p>先分段再分页</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026193844085.webp" alt="image-20231026193844085"></p><blockquote><p>若是32位逻辑地址，每个段最多有2^4^&#x3D;16个页</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026193852006.webp" alt="image-20231026193852006"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026193858195.webp" alt="image-20231026193858195"></p><blockquote><p>需要<strong>三次访存</strong>，比纯分页或纯分段<strong>多一次</strong>访存</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026193903986.webp" alt="image-20231026193903986"></p><h2 id="2-5-虚拟内存技术"><a href="#2-5-虚拟内存技术" class="headerlink" title="2.5 虚拟内存技术"></a>2.5 虚拟内存技术</h2><p>前面说了，扩展内存的技术有三项：</p><ol><li>覆盖技术</li><li>交换技术</li><li>虚拟存储技术</li></ol><p>现在就来讲讲虚拟存储技术：</p><h3 id="2-5-1-虚拟内存的基本概念"><a href="#2-5-1-虚拟内存的基本概念" class="headerlink" title="2.5.1 虚拟内存的基本概念"></a>2.5.1 虚拟内存的基本概念</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026195753311.webp" alt="image-20231026195753311"></p><h4 id="1）传统存储管理方式的特征、缺点"><a href="#1）传统存储管理方式的特征、缺点" class="headerlink" title="1）传统存储管理方式的特征、缺点"></a>1）传统存储管理方式的特征、缺点</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026194418031.webp" alt="image-20231026194418031"></p><blockquote><p><strong>传统存储管理</strong>方式包括上面讲的所有连续分配和非连续分配的内存管理方式，它们的特征如下：</p><ol><li><strong>一次性</strong>：<strong>作业必须一次性全部装入内存后才能开始运行</strong>。<ul><li>作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong></li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong></li></ul></li><li><strong>驻留性</strong>：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>，直至作业运行结束<ul><li>事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul></li></ol></blockquote><h4 id="2）局部性原理"><a href="#2）局部性原理" class="headerlink" title="2）局部性原理"></a>2）局部性原理</h4><p>局部性原理在前面具有快表的地址变换机构也讲过</p><ol><li><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行：如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</li><li><strong>空间局部性</strong>：一见程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</li></ol><p>比如这个程序：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/计算机操作系统第4章（内存管理）.assets/image-20231026194854319.webp" alt="image-20231026194854319" style="zoom:50%">这个程序，while循环内的代码拥有时间局部性，a数组具有空间局部性</p><h4 id="3）虚拟内存的定义和特征"><a href="#3）虚拟内存的定义和特征" class="headerlink" title="3）虚拟内存的定义和特征"></a>3）虚拟内存的定义和特征</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026195017771.webp" alt="image-20231026195017771"></p><blockquote><p>虚拟内存简而言之，就是解决了上面传统方式的两个问题：</p><ol><li>解决了一次性问题：作业不用一次性全部装入内存，<strong>只装入用到的部分</strong></li><li>解决了驻留性问题：<strong>操作系统会将暂时用不到的信息换出到外存</strong></li></ol><p>看起来像是同时具备覆盖技术和交换技术的优点</p><p>虚拟内存的<strong>三个特征</strong>：</p><ol><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ol></blockquote><h4 id="4）实现虚拟内存的方式"><a href="#4）实现虚拟内存的方式" class="headerlink" title="4）实现虚拟内存的方式"></a>4）实现虚拟内存的方式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026195606971.webp" alt="image-20231026195606971"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026195642633.webp" alt="image-20231026195642633"></p><h3 id="2-5-2-请求分页管理方式"><a href="#2-5-2-请求分页管理方式" class="headerlink" title="2.5.2 请求分页管理方式"></a>2.5.2 请求分页管理方式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026200623599.webp" alt="image-20231026200623599"></p><h4 id="1）页表机制"><a href="#1）页表机制" class="headerlink" title="1）页表机制"></a>1）页表机制</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026200648139.webp" alt="image-20231026200648139"></p><blockquote><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要<strong>知道每个页面是否已经调入内存</strong>：如果还没调入，那么也需要知道该<strong>页面在外存中存放的位置</strong>。</p><p>当<strong>内存空间不够时，要实现“页面置换”</strong>，操作系统需要通过某些指标来决定到底换出哪个页面：有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面<strong>是否被修改</strong>的信息。</p><p>所以：<strong>请求页表</strong>项比<strong>页表</strong>增加了4个字段</p></blockquote><h4 id="2）缺页中断机构"><a href="#2）缺页中断机构" class="headerlink" title="2）缺页中断机构"></a>2）缺页中断机构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026200908264.webp" alt="image-20231026200908264"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026200915383.webp" alt="image-20231026200915383"></p><blockquote><p><strong>缺页中断</strong>是因为当前执行的指令<strong>想要访问的目标页面未调入内存而产生的</strong>，因此属于<strong>内中断</strong><br><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong>。</p></blockquote><h4 id="3）地址变换机构"><a href="#3）地址变换机构" class="headerlink" title="3）地址变换机构"></a>3）地址变换机构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026201102049.webp" alt="image-20231026201102049"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026201241798.webp" alt="image-20231026201241798"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026201307873.webp" alt="image-20231026201307873"></p><blockquote><p>注意补充细节的第⑤点，若发生缺页中断，将页面调入内存后，<strong>会同时放入慢表和快表</strong></p><p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：</p><p>查快表（未命中）-&gt; 查慢表（发现未调入内存）-&gt; 调页（调入的页面对应的表项会直接加入快表) -&gt; <strong>查快表（</strong>命中) -&gt; 访问目标内存单元</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231026201514768.webp" alt="image-20231026201514768"></p><h3 id="2-5-3-页面置换算法"><a href="#2-5-3-页面置换算法" class="headerlink" title="2.5.3 页面置换算法"></a>2.5.3 页面置换算法</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107084948915.webp" alt="image-20231107084948915"></p><h4 id="1）最佳置换算法OPT"><a href="#1）最佳置换算法OPT" class="headerlink" title="1）最佳置换算法OPT"></a>1）最佳置换算法OPT</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107085254670.webp" alt="image-20231107085254670"></p><blockquote><p>淘汰的页面是<strong>内存中之后最长时间不再被访问的页面</strong></p><p>打勾的地方发生了缺页中断：<strong>缺页时未必发生页面置换</strong></p><p>缺页率 &#x3D; 缺页中断次数 &#x2F; 访问页面次数</p><p>前提条件：知道之后依次要访问的页面是哪些<br>最佳置换算法可以<strong>保证最低的缺页率</strong>，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。<strong>操作系统无法提前预判页面访问序列</strong>。因此，最佳置换算法是<strong>无法实现</strong>的。</p></blockquote><h4 id="2）先进先出算法FIFO"><a href="#2）先进先出算法FIFO" class="headerlink" title="2）先进先出算法FIFO"></a>2）先进先出算法FIFO</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107090012863.webp" alt="image-20231107090012863"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107090156477.webp" alt="image-20231107090156477"></p><blockquote><p>维护了一个队列，每次发生缺页中断时，将队首的页面换出内存，换入的新页面放到队尾</p><p>Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p><strong>只有FIFO算法会产生Belady异常，算法性能差</strong></p></blockquote><h4 id="3）最近最久未使用算法LRU"><a href="#3）最近最久未使用算法LRU" class="headerlink" title="3）最近最久未使用算法LRU"></a>3）最近最久未使用算法LRU</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107090534070.webp" alt="image-20231107090534070"></p><blockquote><p>该算法性能好，是最接近最佳置换算法的</p><p>但是实现困难，开销大</p><p>在MySQL置换脏页和Redis对象内存淘汰中都有使用到LRU算法：</p><ol><li>在MySQL中：大致过程就是维护了一个链表，每次访问一个页就将其放到头的位置，那么尾部的页就是最近最久未使用</li><li>在Redis中：在RedisObject中维护了一个3字节的变量lru:LRU_BITS，记录该key的最近一次访问时间戳，并对所有key的(now-LRU_BITS)进行排序，值越大，越应该被淘汰</li></ol></blockquote><h4 id="4）时钟置换算法CLOCK"><a href="#4）时钟置换算法CLOCK" class="headerlink" title="4）时钟置换算法CLOCK"></a>4）时钟置换算法CLOCK</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107091446250.webp" alt="image-20231107091446250"></p><blockquote><p><strong>CLOCK算法</strong>也叫<strong>最近未用算法NRU</strong></p><p>CLOCK算法扫描过程(精准空降)：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?t=950.8&p=55">https://www.bilibili.com/video/BV1YE411D7nH?t=950.8&amp;p=55</a></p><p>先将1，3，4，2，5放入内存，<br>然后访问6号页时，先从1循环队列一号页开始扫描，第一轮扫描会将所有页面置0，这里会在第二轮扫描时扫描到1发现是0，然后把页面6放入1，<br>访问3时将3号页置1，访问4时将4号页置1，<br>访问7时缺页，之前扫描到1号页(现在应该是6号页)处，接着往后扫描3号页发现是1，置为0，4号页发现是1，置为0，扫描到2号页时是0，在此处替换为7号页</p><p><strong>最多会进行两轮扫描</strong></p></blockquote><h4 id="5）改进型的时钟置换算法"><a href="#5）改进型的时钟置换算法" class="headerlink" title="5）改进型的时钟置换算法"></a>5）改进型的时钟置换算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107092709865.webp" alt="image-20231107092709865"></p><blockquote><p>在CLOCK算法的基础上，再考虑修改位</p><ul><li>第一优先级：最近没访问，且没修改的页面(0,0)</li><li>第二优先级：最近没访问，但修改过的页面(0,1)，本轮将扫描过的访问位设为0</li><li>第三优先级：最近访问过但没修改的页面(0,0)</li><li>第四优先级：最近访问过，且修改过的页面(0,1)</li></ul><p><strong>最多会进行四轮扫描</strong></p></blockquote><h4 id="小总结-4"><a href="#小总结-4" class="headerlink" title="小总结"></a>小总结</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107093051666.webp" alt="image-20231107093051666"></p><h3 id="2-5-4-页面分配策略、抖动、工作集"><a href="#2-5-4-页面分配策略、抖动、工作集" class="headerlink" title="2.5.4 页面分配策略、抖动、工作集"></a>2.5.4 页面分配策略、抖动、工作集</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231107093526933.webp" alt="image-20231107093526933"></p><h4 id="1）驻留集"><a href="#1）驻留集" class="headerlink" title="1）驻留集"></a>1）驻留集</h4><p><strong>驻留集</strong>：指请求分页存储管理中<strong>给进程分配的物理块的集合</strong>。<br>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</p><p>eg：考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页</p><p>所以：<strong>若驻留集太小，会导致缺页频繁</strong>，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；<strong>驻留集太大，又会导致多道程序并发度下降，资源利用率降低</strong>。所以应该选择一个合适的驻留集大小。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129192556477.webp" alt="image-20231129192556477"></p><h4 id="2）页面分配策略"><a href="#2）页面分配策略" class="headerlink" title="2）页面分配策略"></a>2）页面分配策略</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129193004693.webp" alt="image-20231129193004693"></p><h4 id="3）何时、何处调入页面"><a href="#3）何时、何处调入页面" class="headerlink" title="3）何时、何处调入页面"></a>3）何时、何处调入页面</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129193354292.webp" alt="image-20231129193354292"></p><blockquote><p>采用 预调页策略 与 请求调页策略 相结合，<strong>运行前预调页，运行时请求调页</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129193359920.webp" alt="image-20231129193359920"></p><blockquote><p>分为 <strong>对换区空间 足够 与 不够</strong> 两种情况</p></blockquote><h4 id="4）抖动现象-与-工作集"><a href="#4）抖动现象-与-工作集" class="headerlink" title="4）抖动现象 与 工作集"></a>4）抖动现象 与 工作集</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129193700984.webp" alt="image-20231129193700984"></p><blockquote><p>分配给进程的物理块太少，所以会发生抖动现象<br>所以提出了<strong>工作集</strong>的概念：</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129193706696.webp" alt="image-20231129193706696"></p><blockquote><p><strong>驻留集大小不能小于工作集大小</strong>，否则进程运行过程中将频繁缺页。</p></blockquote><h4 id="小总结-5"><a href="#小总结-5" class="headerlink" title="小总结"></a>小总结</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129194016009.webp" alt="image-20231129194016009"></p><h1 id="3-内存映射文件"><a href="#3-内存映射文件" class="headerlink" title="3 内存映射文件"></a>3 内存映射文件</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129194134859.webp" alt="image-20231129194134859"></p><p>内存映射文件一一操作系统向上层程序员提供的功能（系统调用）</p><ol><li>方便程序员访问文件数据</li><li>方便多个进程共享同一个文件</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129194220294.webp" alt="image-20231129194220294"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129194226927.webp" alt="image-20231129194226927"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129194237102.webp" alt="image-20231129194237102"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.hahhome.top/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/../../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89.assets/image-20231129194244069.webp" alt="image-20231129194244069"></p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a></div><div class="post_share"><div class="social-share" data-image="/img/cover_default_img/05.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.webp" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.webp" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC5%E7%AB%A0%EF%BC%88%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/" title="计算机操作系统第5章-文件管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/07.webp" onerror='onerror=null,src="/img/404.webp"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机操作系统第5章-文件管理</div></div></a></div><div class="next-post pull-right"><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%EF%BC%88%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%EF%BC%89/" title="计算机操作系统第3章-进程与处理机管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/03.webp" onerror='onerror=null,src="/img/404.webp"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机操作系统第3章-进程与处理机管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="计算机操作系统面试题总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/01.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">计算机操作系统面试题总结</div></div></a></div><div><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%AB%A0%EF%BC%88%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%89/" title="计算机操作系统第6章-设备管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/03.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">计算机操作系统第6章-设备管理</div></div></a></div><div><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC5%E7%AB%A0%EF%BC%88%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/" title="计算机操作系统第5章-文件管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/07.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">计算机操作系统第5章-文件管理</div></div></a></div><div><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%EF%BC%88%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%EF%BC%89/" title="计算机操作系统第3章-进程与处理机管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/03.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">计算机操作系统第3章-进程与处理机管理</div></div></a></div><div><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0%EF%BC%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%89/" title="计算机操作系统第2章-操作系统的运行机制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/04.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">计算机操作系统第2章-操作系统的运行机制</div></div></a></div><div><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC1%E7%AB%A0%EF%BC%88%E7%BB%AA%E8%AE%BA%EF%BC%89/" title="计算机操作系统第1章-绪论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover_default_img/03.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">计算机操作系统第1章-绪论</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">四 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1 内存的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%EF%BC%8C%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">1.1 什么是内存，有何作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%89%E6%AD%A5"><span class="toc-text">1.2 指令的工作原理和代码到程序运行的三步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3 链接的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">1）静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">2）装入时动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">3）运行时动态链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1.4 装入的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="toc-text">1）绝对装入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%88%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%EF%BC%89"><span class="toc-text">2）静态重定位（可重定位装入）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%88%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A3%85%E5%85%A5%EF%BC%89"><span class="toc-text">3）动态重定位（动态运行时装入）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">2 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%9B%AE%E6%A0%87"><span class="toc-text">2.1 内存管理要实现的四个目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"><span class="toc-text">2.2 实现内存空间的扩充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-text">1）覆盖技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-text">2）交换技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%92%8C%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">覆盖和交换的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%88%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">2.3 实现内存空间的分配与回收（连续分配管理方式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E4%B8%89%E7%A7%8D%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">2.3.1 三种连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-text">1）单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-text">2）固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-text">3）动态分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-1"><span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%9B%9B%E7%A7%8D%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.2 四种动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">1）首次适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">2）最佳适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">3）最坏适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">4）邻近适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-2"><span class="toc-text">小总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%88%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">2.4 实现内存空间的分配与回收（非连续分配管理方式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">2.4.1 基本分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%EF%BC%89%E9%A1%B5%E6%A1%86%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1）页框和页面的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%EF%BC%89%E9%A1%B5%E8%A1%A8%E5%92%8C%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">1.2）页表和页表的大小计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%EF%BC%89%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.3）逻辑地址到物理地址的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-3"><span class="toc-text">小总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">2）基本地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3）具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">4）两级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">2.4.2 基本分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%AE%B5"><span class="toc-text">1）什么是分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%AE%B5%E8%A1%A8%E5%92%8C%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-text">2）段表和地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%88%86%E6%AE%B5%E3%80%81%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">3）分段、分页管理的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%88%86%E9%A1%B5%E5%88%86%E6%AE%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4）分页分段的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-text">2.4.3 段页式管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-text">2.5 虚拟内存技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.5.1 虚拟内存的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">1）传统存储管理方式的特征、缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">2）局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-text">3）虚拟内存的定义和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">4）实现虚拟内存的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">2.5.2 请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">1）页表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-text">2）缺页中断机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3）地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">2.5.3 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95OPT"><span class="toc-text">1）最佳置换算法OPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95FIFO"><span class="toc-text">2）先进先出算法FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95LRU"><span class="toc-text">3）最近最久未使用算法LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95CLOCK"><span class="toc-text">4）时钟置换算法CLOCK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">5）改进型的时钟置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-4"><span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E3%80%81%E6%8A%96%E5%8A%A8%E3%80%81%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-text">2.5.4 页面分配策略、抖动、工作集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%A9%BB%E7%95%99%E9%9B%86"><span class="toc-text">1）驻留集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">2）页面分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%BD%95%E6%97%B6%E3%80%81%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-text">3）何时、何处调入页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E6%8A%96%E5%8A%A8%E7%8E%B0%E8%B1%A1-%E4%B8%8E-%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-text">4）抖动现象 与 工作集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-5"><span class="toc-text">小总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-text">3 内存映射文件</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image:url(/img/cover_default_img/05.webp)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By spongehah</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp; <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('/pluginsSrc/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.hahhome.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.hahhome.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('/pluginsSrc/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '7ecf16f704fd5834a3a5',
      clientSecret: 'ed4a99d0eb3e4480a27445dd2b6a03b96fa99ddf',
      repo: 'hahhome.github.io',
      owner: 'spongehah',
      admin: ['spongehah'],
      id: 'a987f757242469c0f37f96f3927d4c97',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('/pluginsSrc/gitalk/dist/gitalk.css')
    getScript('/pluginsSrc/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Twikoo' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/pluginsSrc/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>